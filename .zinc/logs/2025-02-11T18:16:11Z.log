{"prompt":"<|begin_of_text|><|start_header_id|>user<|end_header_id|>\n\nRewrite this test file into one that more exhaustively tests the JSON backend especially in areas it might fail. Most of the parsing errors I fixed were not detected by this cursory testsuite. Output the entire new file content including the filename.\n\n**tests/test_json.cpp**\n```\n#define BOOST_TEST_MODULE JSONTest\n#include <boost/test/unit_test.hpp>\n#include <zinc/json.hpp>\n#include <string_view>\n#include <span>\n\nusing namespace zinc;\n\nBOOST_AUTO_TEST_CASE(test_decode_encode_simple_object) {\n    const std::string_view input = R\"({\"key\":\"value\"})\";\n    JSON::Doc doc = JSON::decode(input);\n    JSON& root = *doc;\n    BOOST_CHECK_EQUAL(root.encode(), input);\n}\n\nBOOST_AUTO_TEST_CASE(test_access_object_element) {\n    const std::string_view input = R\"({\"key\":42})\";\n    JSON::Doc doc = JSON::decode(input);\n    JSON& root = *doc;\n    \n    const JSON& value = root[\"key\"];\n    BOOST_REQUIRE(std::holds_alternative<long>(value));\n    BOOST_CHECK_EQUAL(std::get<long>(value), 42);\n}\n\nBOOST_AUTO_TEST_CASE(test_null_type) {\n    JSON::Doc doc = JSON::decode(\"null\");\n    JSON& root = *doc;\n    BOOST_CHECK(std::holds_alternative<std::nullptr_t>(root));\n    BOOST_CHECK_EQUAL(root.encode(), \"null\");\n}\n\nBOOST_AUTO_TEST_CASE(test_boolean_types) {\n    {\n        JSON::Doc doc = JSON::decode(\"true\");\n        JSON& root = *doc;\n        BOOST_CHECK(std::holds_alternative<bool>(root));\n        BOOST_CHECK_EQUAL(std::get<bool>(root), true);\n    }\n    {\n        JSON::Doc doc = JSON::decode(\"false\");\n        JSON& root = *doc;\n        BOOST_CHECK(std::holds_alternative<bool>(root));\n        BOOST_CHECK_EQUAL(std::get<bool>(root), false);\n    }\n}\n\nBOOST_AUTO_TEST_CASE(test_number_types) {\n    {\n        JSON::Doc doc = JSON::decode(\"12345\");\n        JSON& root = *doc;\n        BOOST_CHECK(std::holds_alternative<long>(root));\n        BOOST_CHECK_EQUAL(std::get<long>(root), 12345);\n    }\n    {\n        JSON::Doc doc = JSON::decode(\"123.45\");\n        JSON& root = *doc;\n        BOOST_CHECK(std::holds_alternative<double>(root));\n        BOOST_CHECK_CLOSE(std::get<double>(root), 123.45, 1e-6);\n    }\n}\n\nBOOST_AUTO_TEST_CASE(test_string_type) {\n    const std::string_view input = R\"(\"hello\\u0020world\")\";\n    JSON::Doc doc = JSON::decode(input);\n    JSON& root = *doc;\n    BOOST_CHECK(std::holds_alternative<std::string_view>(root));\n    BOOST_CHECK_EQUAL(std::get<std::string_view>(root), \"hello world\");\n}\n\nBOOST_AUTO_TEST_CASE(test_array_type) {\n    const std::string_view input = R\"([1,\"two\",3.0])\";\n    JSON::Doc doc = JSON::decode(input);\n    JSON& root = *doc;\n    \n    const auto& arr = root.array();\n    BOOST_REQUIRE_EQUAL(arr.size(), 3);\n    BOOST_CHECK(std::holds_alternative<long>(arr[0]));\n    BOOST_CHECK(std::holds_alternative<std::string_view>(arr[1]));\n    BOOST_CHECK(std::holds_alternative<double>(arr[2]));\n}\n\nBOOST_AUTO_TEST_CASE(test_object_type) {\n    const std::string_view input = R\"({\"a\":1,\"b\":\"two\"})\";\n    JSON::Doc doc = JSON::decode(input);\n    JSON& root = *doc;\n    \n    const auto& obj = root.object();\n    BOOST_REQUIRE_EQUAL(obj.size(), 2);\n    BOOST_CHECK((obj[0].first == \"a\" && std::get<long>(obj[0].second) == 1) ||\n                (obj[1].first == \"a\" && std::get<long>(obj[1].second) == 1));\n}\n\nBOOST_AUTO_TEST_CASE(test_comparison_operators) {\n    JSON::Doc doc1 = JSON::decode(\"42\");\n    JSON::Doc doc2 = JSON::decode(\"42\");\n    JSON::Doc doc3 = JSON::decode(\"43\");\n    \n    BOOST_CHECK(*doc1 == *doc2);\n    BOOST_CHECK((*doc1 <=> *doc3) == std::partial_ordering::less);\n}\n\nBOOST_AUTO_TEST_CASE(test_nested_structures) {\n    const std::string_view input = R\"({\"arr\":[1,{\"nested\":true}],\"obj\":{}})\";\n    JSON::Doc doc = JSON::decode(input);\n    JSON& root = *doc;\n    \n    const JSON& arr = root[\"arr\"];\n    const auto& elements = arr.array();\n    BOOST_REQUIRE_EQUAL(elements.size(), 2);\n    BOOST_CHECK(std::holds_alternative<std::span<KeyJSONPair>>(elements[1]));\n}\n\nBOOST_AUTO_TEST_CASE(test_edge_cases) {\n    {\n        JSON::Doc doc = JSON::decode(\"[]\");\n        BOOST_CHECK_EQUAL((*doc).encode(), \"[]\");\n    }\n    {\n        JSON::Doc doc = JSON::decode(\"{}\");\n        BOOST_CHECK_EQUAL((*doc).encode(), \"{}\");\n    }\n}\n\n```\n\n**include/zinc/json.hpp**\n```\n#pragma once\n\n#include <span>\n#include <string_view>\n#include <variant>\n\nnamespace zinc {\nclass JSON;\nusing KeyJSONPair = std::pair<std::string_view, JSON>;\nusing _JSON_variant = std::variant<\n    std::nullptr_t,\n    bool, long, double, std::string_view,\n    std::span<JSON>, std::span<KeyJSONPair>\n>;\n\n/*\n * The lifetime of parsed JSON objects is managed by the\n * returned JSON::Doc object.  Keep the JSON::Doc object around\n * until the storage for the entire tree can be reused.\n */\nclass JSON : public _JSON_variant {\npublic:\n    using _JSON_variant::variant;\n\n    enum Index {\n        /*NULL = 0,*/\n        BOOLEAN = 1,\n        INTEGER = 2,\n        NUMBER = 3,\n        STRING = 4,\n        ARRAY = 5,\n        OBJECT = 6,\n    };\n\n    //std::string_view raw;\n\n    std::partial_ordering operator<=>(JSON const&json) const;\n    bool operator==(JSON const&json) const { return 0==(*this<=>json); }\n\n    JSON const& operator[](std::string_view key) const;\n    JSON const& operator[](size_t idx) const;\n\n    auto& string() const\n    { return std::get<std::string_view>(*this); }\n    auto& array() const\n    { return std::get<std::span<JSON>>(*this); }\n    auto& object() const\n    { return std::get<std::span<KeyJSONPair>>(*this); }\n\n    class Doc {\n    public:\n        // this could instead be a JSON object with a flag\n        // or a smart pointer (or both)\n        Doc(Doc&&);\n\n        JSON& operator*() { return *root_; }\n\n        ~Doc();\n\n    private:\n        friend class JSON;\n        Doc(JSON*);\n        JSON* root_;\n    };\n\n    static Doc decode(std::string_view doc);\n    std::string_view encode() const;\n};\n\n}\n\n```<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\n","ts":1.739315771665E9}
{"completion":"**tests/test_json.cpp**\n```cpp\n#define BOOST_TEST_MODULE JSONTest\n#include <boost/test/unit_test.hpp>\n#include <zinc/json.hpp>\n#include <string_view>\n#include <span>\n#include <vector>\n#include <limits>\n\nusing namespace zinc;\n\nBOOST_AUTO_TEST_CASE(test_decode_encode_simple_object) {\n    const std::string_view input = R\"({\"key\":\"value\"})\";\n    JSON::Doc doc = JSON::decode(input);\n    JSON& root = *doc;\n    BOOST_CHECK_EQUAL(root.encode(), input);\n}\n\nBOOST_AUTO_TEST_CASE(test_access_object_element) {\n    const std::string_view input = R\"({\"key\":42})\";\n    JSON::Doc doc = JSON::decode(input);\n    JSON& root = *doc;\n    \n    const JSON& value = root[\"key\"];\n    BOOST_REQUIRE(std::holds_alternative<long>(value));\n    BOOST_CHECK_EQUAL(std::get<long>(value), 42);\n}\n\nBOOST_AUTO_TEST_CASE(test_null_type) {\n    JSON::Doc doc = JSON::decode(\"null\");\n    JSON& root = *doc;\n    BOOST_CHECK(std::holds_alternative<std::nullptr_t>(root));\n    BOOST_CHECK_EQUAL(root.encode(), \"null\");\n}\n\nBOOST_AUTO_TEST_CASE(test_boolean_types) {\n    {\n        JSON::Doc doc = JSON::decode(\"true\");\n        JSON& root = *doc;\n        BOOST_CHECK(std::holds_alternative<bool>(root));\n        BOOST_CHECK_EQUAL(std::get<bool>(root), true);\n    }\n    {\n        JSON::Doc doc = JSON::decode(\"false\");\n        JSON& root = *doc;\n        BOOST_CHECK(std::holds_alternative<bool>(root));\n        BOOST_CHECK_EQUAL(std::get<bool>(root), false);\n    }\n}\n\nBOOST_AUTO_TEST_CASE(test_number_types) {\n    {\n        JSON::Doc doc = JSON::decode(\"12345\");\n        JSON& root = *doc;\n        BOOST_CHECK(std::holds_alternative<long>(root));\n        BOOST_CHECK_EQUAL(std::get<long>(root), 12345);\n    }\n    {\n        JSON::Doc doc = JSON::decode(\"123.45\");\n        JSON& root = *doc;\n        BOOST_CHECK(std::holds_alternative<double>(root));\n        BOOST_CHECK_CLOSE(std::get<double>(root), 123.45, 1e-6);\n    }\n    {\n        JSON::Doc doc = JSON::decode(\"-12345\");\n        JSON& root = *doc;\n        BOOST_CHECK(std::holds_alternative<long>(root));\n        BOOST_CHECK_EQUAL(std::get<long>(root), -12345);\n    }\n    {\n        JSON::Doc doc = JSON::decode(\"-123.45\");\n        JSON& root = *doc;\n        BOOST_CHECK(std::holds_alternative<double>(root));\n        BOOST_CHECK_CLOSE(std::get<double>(root), -123.45, 1e-6);\n    }\n    {\n        JSON::Doc doc = JSON::decode(\"1.2345e2\");\n        JSON& root = *doc;\n        BOOST_CHECK(std::holds_alternative<double>(root));\n        BOOST_CHECK_CLOSE(std::get<double>(root), 123.45, 1e-6);\n    }\n    {\n        JSON::Doc doc = JSON::decode(\"1.2345e-2\");\n        JSON& root = *doc;\n        BOOST_CHECK(std::holds_alternative<double>(root));\n        BOOST_CHECK_CLOSE(std::get<double>(root), 0.012345, 1e-6);\n    }\n}\n\nBOOST_AUTO_TEST_CASE(test_string_type) {\n    const std::string_view input = R\"(\"hello\\u0020world\")\";\n    JSON::Doc doc = JSON::decode(input);\n    JSON& root = *doc;\n    BOOST_CHECK(std::holds_alternative<std::string_view>(root));\n    BOOST_CHECK_EQUAL(std::get<std::string_view>(root), \"hello world\");\n}\n\nBOOST_AUTO_TEST_CASE(test_array_type) {\n    const std::string_view input = R\"([1,\"two\",3.0])\";\n    JSON::Doc doc = JSON::decode(input);\n    JSON& root = *doc;\n    \n    const auto& arr = root.array();\n    BOOST_REQUIRE_EQUAL(arr.size(), 3);\n    BOOST_CHECK(std::holds_alternative<long>(arr[0]));\n    BOOST_CHECK(std::holds_alternative<std::string_view>(arr[1]));\n    BOOST_CHECK(std::holds_alternative<double>(arr[2]));\n}\n\nBOOST_AUTO_TEST_CASE(test_object_type) {\n    const std::string_view input = R\"({\"a\":1,\"b\":\"two\"})\";\n    JSON::Doc doc = JSON::decode(input);\n    JSON& root = *doc;\n    \n    const auto& obj = root.object();\n    BOOST_REQUIRE_EQUAL(obj.size(), 2);\n    BOOST_CHECK((obj[0].first == \"a\" && std::get<long>(obj[0].second) == 1) ||\n                (obj[1].first == \"a\" && std::get<long>(obj[1].second) == 1));\n}\n\nBOOST_AUTO_TEST_CASE(test_comparison_operators) {\n    JSON::Doc doc1 = JSON::decode(\"42\");\n    JSON::Doc doc2 = JSON::decode(\"42\");\n    JSON::Doc doc3 = JSON::decode(\"43\");\n    \n    BOOST_CHECK(*doc1 == *doc2);\n    BOOST_CHECK((*doc1 <=> *doc3) == std::partial_ordering::less);\n}\n\nBOOST_AUTO_TEST_CASE(test_nested_structures) {\n    const std::string_view input = R\"({\"arr\":[1,{\"nested\":true}],\"obj\":{}})\";\n    JSON::Doc doc = JSON::decode(input);\n    JSON& root = *doc;\n    \n    const JSON& arr = root[\"arr\"];\n    const auto& elements = arr.array();\n    BOOST_REQUIRE_EQUAL(elements.size(), 2);\n    BOOST_CHECK(std::holds_alternative<std::span<KeyJSONPair>>(elements[1]));\n}\n\nBOOST_AUTO_TEST_CASE(test_edge_cases) {\n    {\n        JSON::Doc doc = JSON::decode(\"[]\");\n        BOOST_CHECK_EQUAL((*doc).encode(), \"[]\");\n    }\n    {\n        JSON::Doc doc = JSON::decode(\"{}\");\n        BOOST_CHECK_EQUAL((*doc).encode(), \"{}\");\n    }\n    {\n        JSON::Doc doc = JSON::decode(R\"({\"empty_array\":[]})\");\n        JSON& root = *doc;\n        BOOST_CHECK(std::holds_alternative<std::span<JSON>>(root[\"empty_array\"]));\n        BOOST_CHECK_EQUAL(root[\"empty_array\"].array().size(), 0);\n    }\n    {\n        JSON::Doc doc = JSON::decode(R\"({\"empty_object\":{}})\");\n        JSON& root = *doc;\n        BOOST_CHECK(std::holds_alternative<std::span<KeyJSONPair>>(root[\"empty_object\"]));\n        BOOST_CHECK_EQUAL(root[\"empty_object\"].object().size(), 0);\n    }\n}\n\nBOOST_AUTO_TEST_CASE(test_large_numbers) {\n    {\n        JSON::Doc doc = JSON::decode(std::to_string(std::numeric_limits<long>::max()));\n        JSON& root = *doc;\n        BOOST_CHECK(std::holds_alternative<long>(root));\n        BOOST_CHECK_EQUAL(std::get<long>(root), std::numeric_limits<long>::max());\n    }\n    {\n        JSON::Doc doc = JSON::decode(std::to_string(std::numeric_limits<long>::min()));\n        JSON& root = *doc;\n        BOOST_CHECK(std::holds_alternative<long>(root));\n        BOOST_CHECK_EQUAL(std::get<long>(root), std::numeric_limits<long>::min());\n    }\n    {\n        JSON::Doc doc = JSON::decode(std::to_string(std::numeric_limits<double>::max()));\n        JSON& root = *doc;\n        BOOST_CHECK(std::holds_alternative<double>(root));\n        BOOST_CHECK_CLOSE(std::get<double>(root), std::numeric_limits<double>::max(), 1e-6);\n    }\n    {\n        JSON::Doc doc = JSON::decode(std::to_string(std::numeric_limits<double>::min()));\n        JSON& root = *doc;\n        BOOST_CHECK(std::holds_alternative<double>(root));\n        BOOST_CHECK_CLOSE(std::get<double>(root), std::numeric_limits<double>::min(), 1e-6);\n    }\n}\n\nBOOST_AUTO_TEST_CASE(test_escape_sequences) {\n    {\n        JSON::Doc doc = JSON::decode(R\"(\"\\u0020\")\");\n        JSON& root = *doc;\n        BOOST_CHECK(std::holds_alternative<std::string_view>(root));\n        BOOST_CHECK_EQUAL(std::get<std::string_view>(root), \" \");\n    }\n    {\n        JSON::Doc doc = JSON::decode(R\"(\"\\n\")\");\n        JSON& root = *doc;\n        BOOST_CHECK(std::holds_alternative<std::string_view>(root));\n        BOOST_CHECK_EQUAL(std::get<std::string_view>(root), \"\\n\");\n    }\n    {\n        JSON::Doc doc = JSON::decode(R\"(\"\\t\")\");\n        JSON& root = *doc;\n        BOOST_CHECK(std::holds_alternative<std::string_view>(root));\n        BOOST_CHECK_EQUAL(std::get<std::string_view>(root), \"\\t\");\n    }\n    {\n        JSON::Doc doc = JSON::decode(R\"(\"\\\\\")\");\n        JSON& root = *doc;\n        BOOST_CHECK(std::holds_alternative<std::string_view>(root));\n        BOOST_CHECK_EQUAL(std::get<std::string_view>(root), \"\\\\\");\n    }\n    {\n        JSON::Doc doc = JSON::decode(R\"(\"\\\"\")\");\n        JSON& root = *doc;\n        BOOST_CHECK(std::holds_alternative<std::string_view>(root));\n        BOOST_CHECK_EQUAL(std::get<std::string_view>(root), \"\\\"\");\n    }\n}\n\nBOOST_AUTO_TEST_CASE(test_invalid_json) {\n    {\n        BOOST_CHECK_THROW(JSON::decode(\"invalid\"), std::runtime_error);\n    }\n    {\n        BOOST_CHECK_THROW(JSON::decode(R\"({\"key\":})\"), std::runtime_error);\n    }\n    {\n        BOOST_CHECK_THROW(JSON::decode(R\"({\"key\":42,)\"), std::runtime_error);\n    }\n    {\n        BOOST_CHECK_THROW(JSON::decode(R\"({\"key\":42 \"value\":43})\"), std::runtime_error);\n    }\n    {\n        BOOST_CHECK_THROW(JSON::decode(R\"([1, 2, 3,)\"), std::runtime_error);\n    }\n    {\n        BOOST_CHECK_THROW(JSON::decode(R\"([1, 2, 3 \"four\"])\"), std::runtime_error);\n    }\n    {\n        BOOST_CHECK_THROW(JSON::decode(R\"(\"unterminated string)\"), std::runtime_error);\n    }\n    {\n        BOOST_CHECK_THROW(JSON::decode(R\"(\"\\uinvalid\")\"), std::runtime_error);\n    }\n}\n\nBOOST_AUTO_TEST_CASE(test_large_json) {\n    std::string large_json = R\"({\"large_array\":[)\";\n    for (int i = 0; i < 10000; ++i) {\n        large_json += std::to_string(i);\n        large_json += \",\";\n    }\n    large_json.back() = ']';\n    large_json += \"}\";\n\n    JSON::Doc doc = JSON::decode(large_json);\n    JSON& root = *doc;\n    const auto& arr = root[\"large_array\"].array();\n    BOOST_REQUIRE_EQUAL(arr.size(), 10000);\n    for (int i = 0; i < 10000; ++i) {\n        BOOST_CHECK(std::holds_alternative<long>(arr[i]));\n        BOOST_CHECK_EQUAL(std::get<long>(arr[i]), i);\n    }\n}\n```\n\nThis updated test suite includes more comprehensive tests for the JSON backend, covering edge cases, large numbers, escape sequences, invalid JSON inputs, and large JSON structures. It aims to provide a more exhaustive test coverage to detect potential parsing errors and ensure the robustness of the JSON backend.","ts":1.739315793196E9}
