{"prompt":"<|begin_of_text|><|start_header_id|>user<|end_header_id|>\n\nDraft a header file for xdiffpp with notes for next steps.\n\n**xdiffpp.txt**\n```\n**Project Document: xdiffpp**\n\n**Overview**\n\nxdiffpp is a C++ wrapper for the xdiff library, which is a file differential library used in the Git project. The goal of xdiffpp is to provide a modern and easy-to-use C++ interface to the xdiff library, making it easier for developers to integrate xdiff functionality into their applications.\n\n**Goals**\n\n* Provide a C++ wrapper for the xdiff library that is easy to use and understand.\n* Support all the features of the xdiff library, including text and binary diff, patch, and merge.\n* Use modern C++ features and best practices to ensure the wrapper is efficient, reliable, and maintainable.\n* Provide documentation and examples to help developers get started with using xdiffpp.\n\n**Task List**\n\n1. **Initial Setup**\n        * Create a new C++ project for xdiffpp.\n        * Set up the build system (e.g., CMake) to compile and link against the xdiff library.\n        * Done!\n2. **xdiff Library Analysis**\n        * Study the xdiff library documentation and source code to understand its API and functionality.\n        * Identify the key functions and data structures that need to be wrapped.\n3. **C++ Wrapper Implementation**\n        * Implement the C++ wrapper for the xdiff library, starting with the basic functions (e.g., `xdl_diff`, `xdl_patch`, `xdl_merge`).\n        * Use modern C++ features (e.g., smart pointers, containers) to ensure the wrapper is efficient and easy to use.\n4. **Text Diff Implementation**\n        * Implement the text diff functionality, including support for different diff algorithms (e.g., Myers, patience, histogram).\n        * Provide options for customizing the diff output (e.g., context size, ignore whitespace).\n5. **Binary Diff Implementation**\n        * Implement the binary diff functionality, including support for different diff algorithms (e.g., Rabin's polynomial fingerprinting).\n        * Provide options for customizing the diff output (e.g., block size).\n6. **Patch Implementation**\n        * Implement the patch functionality, including support for applying patches to files.\n        * Provide options for customizing the patch output (e.g., ignore whitespace).\n7. **Merge Implementation**\n        * Implement the merge functionality, including support for merging three files.\n        * Provide options for customizing the merge output (e.g., conflict marker size).\n8. **Testing and Debugging**\n        * Write unit tests and integration tests to ensure the wrapper is working correctly.\n        * Debug any issues that arise during testing.\n9. **Documentation and Examples**\n        * Write documentation for the xdiffpp wrapper, including API documentation and user guides.\n        * Provide examples of how to use the wrapper in different scenarios.\n\n**Deliverables**\n\n* A fully functional C++ wrapper for the xdiff library (xdiffpp).\n* Documentation for the xdiffpp wrapper, including API documentation and user guides.\n* Examples of how to use the wrapper in different scenarios.\n\n```\n\n**ref/git/xdiff/xdiff.h**\n```\n/*\n *  LibXDiff by Davide Libenzi ( File Differential Library )\n *  Copyright (C) 2003  Davide Libenzi\n *\n *  This library is free software; you can redistribute it and/or\n *  modify it under the terms of the GNU Lesser General Public\n *  License as published by the Free Software Foundation; either\n *  version 2.1 of the License, or (at your option) any later version.\n *\n *  This library is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n *  Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; if not, see\n *  <http://www.gnu.org/licenses/>.\n *\n *  Davide Libenzi <davidel@xmailserver.org>\n *\n */\n\n#if !defined(XDIFF_H)\n#define XDIFF_H\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif /* #ifdef __cplusplus */\n\n/* xpparm_t.flags */\n#define XDF_NEED_MINIMAL (1 << 0)\n\n#define XDF_IGNORE_WHITESPACE (1 << 1)\n#define XDF_IGNORE_WHITESPACE_CHANGE (1 << 2)\n#define XDF_IGNORE_WHITESPACE_AT_EOL (1 << 3)\n#define XDF_IGNORE_CR_AT_EOL (1 << 4)\n#define XDF_WHITESPACE_FLAGS (XDF_IGNORE_WHITESPACE | \\\n\t\t\t      XDF_IGNORE_WHITESPACE_CHANGE | \\\n\t\t\t      XDF_IGNORE_WHITESPACE_AT_EOL | \\\n\t\t\t      XDF_IGNORE_CR_AT_EOL)\n\n#define XDF_IGNORE_BLANK_LINES (1 << 7)\n\n#define XDF_PATIENCE_DIFF (1 << 14)\n#define XDF_HISTOGRAM_DIFF (1 << 15)\n#define XDF_DIFF_ALGORITHM_MASK (XDF_PATIENCE_DIFF | XDF_HISTOGRAM_DIFF)\n#define XDF_DIFF_ALG(x) ((x) & XDF_DIFF_ALGORITHM_MASK)\n\n#define XDF_INDENT_HEURISTIC (1 << 23)\n\n/* xdemitconf_t.flags */\n#define XDL_EMIT_FUNCNAMES (1 << 0)\n#define XDL_EMIT_NO_HUNK_HDR (1 << 1)\n#define XDL_EMIT_FUNCCONTEXT (1 << 2)\n\n/* merge simplification levels */\n#define XDL_MERGE_MINIMAL 0\n#define XDL_MERGE_EAGER 1\n#define XDL_MERGE_ZEALOUS 2\n#define XDL_MERGE_ZEALOUS_ALNUM 3\n\n/* merge favor modes */\n#define XDL_MERGE_FAVOR_OURS 1\n#define XDL_MERGE_FAVOR_THEIRS 2\n#define XDL_MERGE_FAVOR_UNION 3\n\n/* merge output styles */\n#define XDL_MERGE_DIFF3 1\n#define XDL_MERGE_ZEALOUS_DIFF3 2\n\ntypedef struct s_mmfile {\n\tchar *ptr;\n\tlong size;\n} mmfile_t;\n\ntypedef struct s_mmbuffer {\n\tchar *ptr;\n\tlong size;\n} mmbuffer_t;\n\ntypedef struct s_xpparam {\n\tunsigned long flags;\n\n\t/* -I<regex> */\n\tregex_t **ignore_regex;\n\tsize_t ignore_regex_nr;\n\n\t/* See Documentation/diff-options.txt. */\n\tchar **anchors;\n\tsize_t anchors_nr;\n} xpparam_t;\n\ntypedef struct s_xdemitcb {\n\tvoid *priv;\n\tint (*out_hunk)(void *,\n\t\t\tlong old_begin, long old_nr,\n\t\t\tlong new_begin, long new_nr,\n\t\t\tconst char *func, long funclen);\n\tint (*out_line)(void *, mmbuffer_t *, int);\n} xdemitcb_t;\n\ntypedef long (*find_func_t)(const char *line, long line_len, char *buffer, long buffer_size, void *priv);\n\ntypedef int (*xdl_emit_hunk_consume_func_t)(long start_a, long count_a,\n\t\t\t\t\t    long start_b, long count_b,\n\t\t\t\t\t    void *cb_data);\n\ntypedef struct s_xdemitconf {\n\tlong ctxlen;\n\tlong interhunkctxlen;\n\tunsigned long flags;\n\tfind_func_t find_func;\n\tvoid *find_func_priv;\n\txdl_emit_hunk_consume_func_t hunk_func;\n} xdemitconf_t;\n\ntypedef struct s_bdiffparam {\n\tlong bsize;\n} bdiffparam_t;\n\n\n#define xdl_malloc(x) xmalloc(x)\n#define xdl_calloc(n, sz) xcalloc(n, sz)\n#define xdl_free(ptr) free(ptr)\n#define xdl_realloc(ptr,x) xrealloc(ptr,x)\n\nvoid *xdl_mmfile_first(mmfile_t *mmf, long *size);\nlong xdl_mmfile_size(mmfile_t *mmf);\n\nint xdl_diff(mmfile_t *mf1, mmfile_t *mf2, xpparam_t const *xpp,\n\t     xdemitconf_t const *xecfg, xdemitcb_t *ecb);\n\ntypedef struct s_xmparam {\n\txpparam_t xpp;\n\tint marker_size;\n\tint level;\n\tint favor;\n\tint style;\n\tconst char *ancestor;\t/* label for orig */\n\tconst char *file1;\t/* label for mf1 */\n\tconst char *file2;\t/* label for mf2 */\n} xmparam_t;\n\n#define DEFAULT_CONFLICT_MARKER_SIZE 7\n\nint xdl_merge(mmfile_t *orig, mmfile_t *mf1, mmfile_t *mf2,\n\t\txmparam_t const *xmp, mmbuffer_t *result);\n\n#ifdef __cplusplus\n}\n#endif /* #ifdef __cplusplus */\n\n#endif /* #if !defined(XDIFF_H) */\n\n```\n\n**ref/libxdiff/man/xdiff.3**\n```\n.\\\"\n.\\\"  LibXDiff by Davide Libenzi ( File Differential Library )\n.\\\"  Copyright (C) 2003  Davide Libenzi\n.\\\"\n.\\\"  This library is free software; you can redistribute it and/or\n.\\\"  modify it under the terms of the GNU Lesser General Public\n.\\\"  License as published by the Free Software Foundation; either\n.\\\"  version 2.1 of the License, or (at your option) any later version.\n.\\\"\n.\\\"  This library is distributed in the hope that it will be useful,\n.\\\"  but WITHOUT ANY WARRANTY; without even the implied warranty of\n.\\\"  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n.\\\"  Lesser General Public License for more details.\n.\\\"\n.\\\"  You should have received a copy of the GNU General Public License\n.\\\"  along with this program; if not, write to the Free Software\n.\\\"  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n.\\\"\n.\\\"  Davide Libenzi <davidel@xmailserver.org>\n.\\\"\n.na\n.TH LibXDiff 3 \"0.23\" \"GNU\" \"File Differential Library\"\n.SH NAME\n\nxdl_set_allocator, xdl_malloc, xdl_free, xdl_realloc, xdl_init_mmfile, xdl_free_mmfile,\nxdl_mmfile_iscompact, xdl_seek_mmfile, xdl_read_mmfile, xdl_write_mmfile, xdl_writem_mmfile,\nxdl_mmfile_writeallocate, xdl_mmfile_ptradd, xdl_mmfile_first, xdl_mmfile_next, xdl_mmfile_size, xdl_mmfile_cmp,\nxdl_mmfile_compact, xdl_diff, xdl_patch, xdl_merge3, xdl_bdiff_mb, xdl_bdiff, xdl_rabdiff_mb, xdl_rabdiff,\nxdl_bdiff_tgsize, xdl_bpatch \\- File Differential Library support functions\n\n.SH SYNOPSIS\n.nf\n.B #include <xdiff.h>\n.sp\n.BI \"int xdl_set_allocator(memallocator_t const *\" malt \");\"\n.nl\n.BI \"void *xdl_malloc(unsigned int \" size \");\"\n.nl\n.BI \"void xdl_free(void *\" ptr \");\"\n.nl\n.BI \"void *xdl_realloc(void *\" ptr \", unsigned int \" nsize \");\"\n.nl\n.BI \"int xdl_init_mmfile(mmfile_t *\" mmf \", long \" bsize \", unsigned long \" flags \");\"\n.nl\n.BI \"void xdl_free_mmfile(mmfile_t *\" mmf \");\"\n.nl\n.BI \"int xdl_mmfile_iscompact(mmfile_t *\" mmf \");\"\n.nl\n.BI \"int xdl_seek_mmfile(mmfile_t *\" mmf \", long \" off \");\"\n.nl\n.BI \"long xdl_read_mmfile(mmfile_t *\" mmf \", void *\" data \", long \" size \");\"\n.nl\n.BI \"long xdl_write_mmfile(mmfile_t *\" mmf \", void const *\" data \", long \" size \");\"\n.nl\n.BI \"long xdl_writem_mmfile(mmfile_t *\" mmf \", mmbuffer_t *\" mb \", int \" nbuf \");\"\n.nl\n.BI \"void *xdl_mmfile_writeallocate(mmfile_t *\" mmf \", long \" size \");\"\n.nl\n.BI \"long xdl_mmfile_ptradd(mmfile_t *\" mmf \", char *\" ptr \", long \" size \", unsigned long \" flags \");\"\n.nl\n.BI \"void *xdl_mmfile_first(mmfile_t *\" mmf \", long *\" size \");\"\n.nl\n.BI \"void *xdl_mmfile_next(mmfile_t *\" mmf \", long *\" size \");\"\n.nl\n.BI \"long xdl_mmfile_size(mmfile_t *\" mmf \");\"\n.nl\n.BI \"int xdl_mmfile_cmp(mmfile_t *\" mmf1 \", mmfile_t *\" mmf2 \");\"\n.nl\n.BI \"int xdl_mmfile_compact(mmfile_t *\" mmfo \", mmfile_t *\" mmfc \", long \" bsize \", unsigned long \" flags \");\"\n.nl\n.BI \"int xdl_diff(mmfile_t *\" mmf1 \", mmfile_t *\" mmf2 \", xpparam_t const *\" xpp \", xdemitconf_t const *\" xecfg \", xdemitcb_t *\" ecb \");\"\n.nl\n.BI \"int xdl_patch(mmfile_t *\" mmf \", mmfile_t *\" mmfp \", int \" mode \", xdemitcb_t *\" ecb \", xdemitcb_t *\" rjecb \");\"\n.nl\n.BI \"int xdl_merge3(mmfile_t *\" mmfo \", mmfile_t *\" mmf1 \", mmfile_t *\" mmf2 \", xdemitcb_t *\" ecb \", xdemitcb_t *\" rjecb \");\"\n.nl\n.BI \"int xdl_bdiff_mb(mmbuffer_t *\" mmb1 \", mmbuffer_t *\" mmb2 \", bdiffparam_t const *\" bdp \", xdemitcb_t *\" ecb \");\"\n.nl\n.BI \"int xdl_bdiff(mmfile_t *\" mmf1 \", mmfile_t *\" mmf2 \", bdiffparam_t const *\" bdp \", xdemitcb_t *\" ecb \");\"\n.nl\n.BI \"int xdl_rabdiff_mb(mmbuffer_t *\" mmb1 \", mmbuffer_t *\" mmb2 \", xdemitcb_t *\" ecb \");\"\n.nl\n.BI \"int xdl_rabdiff(mmfile_t *\" mmf1 \", mmfile_t *\" mmf2 \", xdemitcb_t *\" ecb \");\"\n.nl\n.BI \"long xdl_bdiff_tgsize(mmfile_t *\" mmfp \");\"\n.nl\n.BI \"int xdl_bpatch(mmfile_t *\" mmf \", mmfile_t *\" mmfp \", xdemitcb_t *\" ecb \");\"\n\n.SH DESCRIPTION\nThe\n.B LibXDiff\nlibrary implements basic and yet complete functionalities to create\nfile differences/patches to both binary and text files. The library\nuses memory files as file abstraction to achieve both performance and\nportability. For binary files,\n.B LibXDiff\nimplements both (with some modification) the algorithm described in\n.IR \"File System Support for Delta Compression\" \" by \" \"Joshua P. MacDonald\" ,\nand the method described in\n.IR \"Fingerprinting by Random Polynomials\" \" by \" \"Michael O. Rabin\" \".\"\nWhile for text files it follows directives described in\n.IR \"An O(ND) Difference Algorithm and Its Variations\" \" by \" \"Eugene W. Myers\" .\nMemory files used by the library are basically a collection of buffers\nthat store the file content. There are two different requirements for memory\nfiles when passed to diff/patch functions. Text files for diff/patch functions\nrequire that a single line do not have to spawn across two different memory\nfile blocks. Binary diff/patch functions require memory files to be compact.\nA compact memory files is a file whose content is stored inside a single block.\nFunctionalities inside the library are available to satisfy these rules.\nUsing the\n.B XDL_MMF_ATOMIC\nmemory file flag it is possible to make writes to not split the written\nrecord across different blocks, while the functions\n.BR xdl_mmfile_iscompact ()\n,\n.BR xdl_mmfile_compact ()\nand\n.BR xdl_mmfile_writeallocate ()\nare usefull to test if the file is compact and to create a compacted version\nof the file itself. The text file differential output uses the raw unified output\nformat, by omitting the file header since the result is always relative to\na single compare operation (between two files). The output format of the binary\npatch file is proprietary (and binary) and it is basically a collection of\ncopy and insert commands, like described inside the MacDonald paper.\n\n\n.SS Functions\nThe following functions are defined:\n.TP\n.BI \"int xdl_set_allocator(memallocator_t const *\" malt \");\"\n\nThe\n.B LibXDiff\nlibrary enable the user to set its own memory allocator, that will be used\nfor all the following memory requests. The allocator must be set before\nto start calling the\n.B LibXDiff\nlibrary with a call to\n.BR xdl_set_allocator ().\nThe memory allocator structure contains the following members:\n.nf\n\n\ttypedef struct s_memallocator {\n\t\tvoid *priv;\n\t\tvoid *(*malloc)(void *priv, unsigned int size);\n\t\tvoid (*free)(void *priv, void *ptr);\n\t\tvoid *(*realloc)(void *priv, void *ptr, unsigned int nsize);\n\t} memallocator_t;\n\n.fi\nThe\n.BR malloc ()\nfunction pointer will be used by\n.B LibXDiff\nto request a memory block of\n.I size\nbytes. The\n.BR free ()\nfunction pointer will be called to free a previously allocated block\n.I ptr\n, while the\n.BR realloc ()\nwill be used to resize the\n.I ptr\nto a new\n.I nsize\nsize in bytes. The\n.B priv\nstructure member will be passed to the\n.BR malloc (), free (), realloc ()\nfunctions as first parameter. The\n.B LibXDiff\nuser must call\n.BR xdl_set_allocator ()\nbefore starting using the library, otherwise\n.B LibXDiff\nfunctions will fail due to the lack of memory allocation support.\nA typical initialization sequence for\n.B POSIX\nsystems will use the standard\n.BR malloc (3),\n.BR free (3),\n.BR realloc (3)\nand will look like:\n.nf\n\n\tvoid *wrap_malloc(void *priv, unsigned int size) {\n\t\treturn malloc(size);\n\t}\n\n\tvoid wrap_free(void *priv, void *ptr) {\n\t\tfree(ptr);\n\t}\n\n\tvoid *wrap_realloc(void *priv, void *ptr, unsigned int size) {\n\t\treturn realloc(ptr, size);\n\t}\n\n\tvoid my_init_xdiff(void) {\n\t\tmemallocator_t malt;\n\n\t\tmalt.priv = NULL;\n\t\tmalt.malloc = wrap_malloc;\n\t\tmalt.free = wrap_free;\n\t\tmalt.realloc = wrap_realloc;\n\t\txdl_set_allocator(&malt);\n\t}\n\n.fi\n\n.TP\n.BI \"void *xdl_malloc(unsigned int \" size \");\"\n\nAllocates a memory block of\n.I size\nbytes using the\n.B LibXDiff\nmemory allocator. The user can specify its own allocator using the\n.BR xdl_set_allocator ()\nfunction. The\n.BR xdl_malloc ()\nreturn a pointer to the newly allocated block, or\n.B NULL\nin case of failure.\n\n.TP\n.BI \"void xdl_free(void *\" ptr \");\"\n\nFree a previously allocated memory block pointed by\n.IR ptr .\nThe\n.I ptr\nblock must has been allocated using either\n.BR xdl_malloc ()\nor\n.BR xdl_realloc ().\n\n.TP\n.BI \"void *xdl_realloc(void *\" ptr \", unsigned int \" nsize \");\"\n\nResizes the memory block pointed by\n.I ptr\nto a new size\n.IR nsize .\nReturn the resized block if successful, or\n.B NULL\nin case the reallocation fails. After a successful reallocation, the old\n.I ptr\nblock is to be considered no more valid.\n\n.TP\n.BI \"int xdl_init_mmfile(mmfile_t *\" mmf \", long \" bsize \", unsigned long \" flags \");\"\n\nInitialize the memory file\n.I mmf\nby requiring an internal block size of\n.IR bsize .\nThe\n.I flags\nparameter is a combination of the following flags :\n.br\n.IP\n.B XDL_MMF_ATOMIC\nWrites on the memory file will be atomic. That is, the data will not be split\non two or more different blocks.\n\nOnce an\n.BR xdl_init_mmfile ()\nsucceeded, a matching\n.BR xdl_free_mmfile ()\nmust be called when the user has done using the memory file, otherwise serious\nmemory leaks will happen.\nThe function return 0 if succeed or -1 if an error is encountered.\n\n.TP\n.BI \"void xdl_free_mmfile(mmfile_t *\" mmf \");\"\n\nFree all the data associated with the\n.I mmf\nmemory file.\n\n.TP\n.BI \"int xdl_mmfile_iscompact(mmfile_t *\" mmf \");\"\n\nReturns an integer different from 0 if the\n.I mmf\nmemory file is compact, 0 otherwise. A compact memory file is one that have\nthe whole content stored inside a single block.\n\n.TP\n.BI \"int xdl_seek_mmfile(mmfile_t *\" mmf \", long \" off \");\"\n\nSet the current data pointer of the memory file\n.I mmf\nto the specified offset\n.I off\nfrom the beginning of the file itself. Returns 0 if successful or -1 if an error\nhappened.\n\n.TP\n.BI \"long xdl_read_mmfile(mmfile_t *\" mmf \", void *\" data \", long \" size \");\"\n\nRequest to read\n.I size\nbytes from the memory file\n.I mmf\nby storing the data inside the\n.I data\nbuffer. Returns the number of bytes read into the\n.I data\nbuffer. The amount of data read can be lower than the specified\n.IR size .\nThe function returns -1 if an error happened.\n\n.TP\n.BI \"long xdl_write_mmfile(mmfile_t *\" mmf \", void const *\" data \", long \" size \");\"\n\nRequest to write\n.I size\nbytes from the specified buffer\n.I data\ninto the memory file\n.IR mmf .\nIf the memory file has been created using the\n.B XDL_MMF_ATOMIC\nflag, the write request will not be split across different blocks.\nNote that all write operations done on memory files do append data at the end\nthe file, and writes in the middle of it are allowed. This is because the library\nmemory file abstraction does not need this functionality to be available.\nThe function returns the number of bytes written or a number lower than\n.I size\nif an error happened.\n\n.TP\n.BI \"long xdl_writem_mmfile(mmfile_t *\" mmf \", mmbuffer_t *\" mb \", int \" nbuf \");\"\n\nRequest to sequentially write\n.I nbuf\nmemory buffers passed inside the array\n.I mb\ninto the memory file\n.IR mmf .\nThe memory buffer structure is defined as :\n.nf\n\n\ttypedef struct s_mmbuffer {\n\t\tchar *ptr;\n\t\tlong size;\n\t} mmbuffer_t;\n\n.fi\nThe\n.I ptr\nfield is a pointer to the user data, whose size is specified inside the\n.I size\nstructure field. The function returns the total number of bytes written\nor a lower number if an error happened.\n\n.TP\n.BI \"void *xdl_mmfile_writeallocate(mmfile_t *\" mmf \", long \" size \");\"\n\nThe function request to allocate a write buffer of\n.I size\nbytes in the\n.I mmf\nmemory file and returns the pointer to the allocated buffer. The user will\nhave the responsibility to store\n.I size\nbytes (no more, no less) inside the memory region pointed to by the returned pointer.\nThe files size will grow of\n.I size\nbytes as a consequence of this operation. The function will return\n.B NULL\nif an error happened.\n\n.TP\n.BI \"long xdl_mmfile_ptradd(mmfile_t *\" mmf \", char *\" ptr \", long \" size \", unsigned long \" flags \");\"\n\nThe function adds a user specified block to the end of the memory file\n.IR mmf .\nThe block first byte is pointed to by\n.I ptr\nand its length is\n.I size\nbytes. The\n.I flags\nparameter can be used to specify attributes of the user memory block. Currently\nsupported attributes are:\n.br\n.IP\n.B XDL_MMB_READONLY\nSpecify that the added memory block must be treated as read-only, and\nevery attempt to write on it should result in a failure of the memory file\nwriting functions.\n\nThe purpose of this function is basically to avoid copying memory around,\nby helping the library to not drain the CPU cache. The function returns\n.I size\nin case of success, or -1 in case of error.\n\n.TP\n.BI \"void *xdl_mmfile_first(mmfile_t *\" mmf \", long *\" size \");\"\n\nThe function is used to return the first block of the\n.I mmf\nmemory file block chain. The\n.I size\nparameter will receive the size of the block, while the function will return\nthe pointer the the first byte of the block itself. The function returns\n.B NULL\nif the file is empty.\n\n.TP\n.BI \"void *xdl_mmfile_next(mmfile_t *\" mmf \", long *\" size \");\"\n\nThe function is used to return the next block of the\n.I mmf\nmemory file block chain. The\n.I size\nparameter will receive the size of the block, while the function will return\nthe pointer the the first byte of the block itself. The function returns\n.B NULL\nif the current block is the last one of the chain.\n\n.TP\n.BI \"long xdl_mmfile_size(mmfile_t *\" mmf \");\"\n\nThe function returns the size of the specified memory file\n.IR mmf .\n\n.TP\n.BI \"int xdl_mmfile_cmp(mmfile_t *\" mmf1 \", mmfile_t *\" mmf2 \");\"\n\nRequest to compare two memory files\n.IR mmf1 \" and \" mmf2\nand returns 0 if files are identical, or a value different from 0 if\nfiles are different.\n\n.TP\n.BI \"int xdl_mmfile_compact(mmfile_t *\" mmfo \", mmfile_t *\" mmfc \", long \" bsize \", unsigned long \" flags \");\"\n\nRequest to create a compact version of the memory file\n.I mmfo\ninto the (uninitialized) memory file\n.IR mmfc .\nThe\n.I bsize\nparameter specify the requested block size and\n.I flags\nspecify flags to be used to create the new\n.I mmfc\nmemory file (see\n.BR xdl_init_mmfile ()\n). The function returns 0 if succedded or -1 if an error happened.\n\n.TP\n.BI \"int xdl_diff(mmfile_t *\" mmf1 \", mmfile_t *\" mmf2 \", xpparam_t const *\" xpp \", xdemitconf_t const *\" xecfg \", xdemitcb_t *\" ecb \");\"\n\nRequest to create the difference between the two text memory files\n.IR mmf1 \" and \" mmf2 .\nThe\n.I mmf1\nmemory files is considered the \"old\" file while\n.I mmf2\nis considered the \"new\" file. So the function will create a patch file\nthat once applied to\n.I mmf1\nwill give\n.I mmf2\nas result. Files\n.IR mmf1 \" and \" mmf2\nmust be atomic from a line point of view (or, as an extreme, compact), that\nmeans that a single test line cannot spread among different memory file blocks.\nThe\n.I xpp\nparameter is a pointer to a structure :\n.nf\n\n\ttypedef struct s_xpparam {\n\t\tunsigned long flags;\n\t} xpparam_t;\n\n.fi\nthat is used to specify parameters to be used by the file differential algorithm.\nThe\n.I flags\nfield is a combination of the following flags :\n\n.IP\n.B XDF_NEED_MINIMAL\nRequires the minimal edit script to be found by the algorithm (may be slow).\n\nThe\n.I xecfg\nparameter point to a structure :\n.nf\n\n\ttypedef struct s_xdemitconf {\n\t\tlong ctxlen;\n\t} xdemitconf_t;\n\n.fi\nthat is used to configure the algorithm responsible of the creation the the\ndifferential file from an edit script. The\n.I ctxlen\nfield is used to specify the amount of context to be emitted inside the\ndifferential file (the value 3 is suggested for normal operations).\nThe parameter\n.I ecb\nis a pointer to a structure :\n.nf\n\n\ttypedef struct s_xdemitcb {\n\t\tvoid *priv;\n\t\tint (*outf)(void *, mmbuffer_t *, int);\n\t} xdemitcb_t;\n\n.fi\nthat is used by the differential file creation algorithm to emit the created\ndata. The\n.I priv\nfield is an opaque pointer to a user specified data, while the\n.I outf\nfield point to a callback function that is called internally to emit algorithm\ngenerated data rappresenting the differential file. The first parameter of the\ncallback is the same\n.I priv\nfield specified inside the\n.B xdemitcb_t\nstructure. The second parameter point to an array of\n.B mmbuffer_t\n(see above for a definition of the structure) whose element count is specified\ninside the last parameter of the callback itself. The callback will always be\ncalled with entire records (lines) and never a record (line) will be emitted\nusing two different callback calls. This is important because if the called will\nuse another memory file to store the result, by creating the target memory file with\n.B XDL_MMF_ATOMIC\nwill guarantee the \"atomicity\" of the memory file itself.\nThe function returns 0 if succeeded or -1 if an error occurred.\n\n.TP\n.BI \"int xdl_patch(mmfile_t *\" mmf \", mmfile_t *\" mmfp \", int \" mode \", xdemitcb_t *\" ecb \", xdemitcb_t *\" rjecb \");\"\n\nRequest to patch the memory file\n.I mmf\nusing the patch file stored in\n.IR mmfp .\nThe\n.I mmf\nmemory file\n.B is not\nchanged during the operation and can be considered as read only.\nThe\n.I mode\nparameter can be one of the following values :\n.IP\n.B XDL_PATCH_NORMAL\nPerform standard patching like if the patch memory file\n.I mmfp\nhas been created using\n.I mmf\nas \"old\" file.\n.IP\n.B XDL_PATCH_REVERSE\nApply the reverse patch. That means that the\n.I mmf\nmemory file has to be considered as if it was specified as \"new\" file during\nthe differential operation (\n.BR xdl_diff ()\n). The result of the operation will then be the file content that was used\nas \"old\" file during the differential operation.\n\nThe following flags can be specified (by or-ing them) to one of the above:\n.IP\n.B XDL_PATCH_IGNOREBSPACE\nIgnore the whitespace at the beginning and the end of the line.\n\nThe\n.I ecb\nwill be used by the patch algorithm to create the result file while the\n.I rjecb\nwill be used to emit all differential chunks that cannot be applied.\nLike explained above, callbacks are always called with entire records to guarantee\natomicity of the resulting output.\nThe function returns 0 if succeeded without performing any fuzzy hunk detection,\na positive value if it secceeded with fuzzy hunk detection or -1 if an error occurred\nduring the patch operation.\n\n.TP\n.BI \"int xdl_merge3(mmfile_t *\" mmfo \", mmfile_t *\" mmf1 \", mmfile_t *\" mmf2 \", xdemitcb_t *\" ecb \", xdemitcb_t *\" rjecb \");\"\n\nMerges three files together. The\n.I mmfo\nfile is the original one, while\n.IR mmf1 \" and \" mmf2\nare two modified versions of\n.IR mmfo .\nThe function works by creating a differential between\n.IR mmfo \" and \" mmf2\nand by applying the resulting patch to\n.IR mmf1 .\nBecause of this sequence,\n.I mmf1\nchanges will be privileged against the ones of\n.IR mmf2 .\nThe\n.I ecb\nwill be used by the patch algorithm to create the result file while the\n.I rjecb\nwill be used to emit all differential chunks that cannot be applied.\nLike explained above, callbacks are always called with entire records to guarantee\natomicity of the resulting output.\nThe function returns 0 if succeeded or -1 if an error occurred during the patch operation.\n\n.TP\n.BI \"int xdl_bdiff(mmfile_t *\" mmf1 \", mmfile_t *\" mmf2 \", bdiffparam_t const *\" bdp \", xdemitcb_t *\" ecb \");\"\n\nRequest to create the difference between the two text memory files\n.IR mmf1 \" and \" mmf2 .\nThe\n.I mmf1\nmemory files is considered the \"old\" file while\n.I mmf2\nis considered the \"new\" file. So the function will create a patch file\nthat once applied to\n.I mmf1\nwill give\n.I mmf2\nas result. Files\n.IR mmf1 \" and \" mmf2\nmust be compact to make it easy and faster to perform the difference operation.\nFunctions are available to check for compactness (\n.BR xdl_mmfile_iscompact ()\n) and to make compact a non-compact file (\n.BR xdl_mmfile_compact ()\n). An example of how to create a compact memory file (described inside the test\nsubdirectory) is :\n.nf\n\n\tint xdlt_load_mmfile(char const *fname, mmfile_t *mf, int binmode) {\n\t\tchar cc;\n\t\tint fd;\n\t\tlong size, bsize;\n\t\tchar *blk;\n\n\t\tif (xdl_init_mmfile(mf, XDLT_STD_BLKSIZE, XDL_MMF_ATOMIC) < 0)\n\t\t\treturn -1;\n\t\tif ((fd = open(fname, O_RDONLY)) == -1) {\n\t\t\tperror(fname);\n\t\t\txdl_free_mmfile(mf);\n\t\t\treturn -1;\n\t\t}\n\t\tif ((size = bsize = lseek(fd, 0, SEEK_END)) > 0 && !binmode) {\n\t\t\tif (lseek(fd, -1, SEEK_END) != (off_t) -1 &&\n\t\t\t    read(fd, &cc, 1) && cc != '\\\\n')\n\t\t\t\tbsize++;\n\t\t}\n\t\tlseek(fd, 0, SEEK_SET);\n\t\tif (!(blk = (char *) xdl_mmfile_writeallocate(mf, bsize))) {\n\t\t\txdl_free_mmfile(mf);\n\t\t\tclose(fd);\n\t\t\treturn -1;\n\t\t}\n\t\tif (read(fd, blk, (size_t) size) != (size_t) size) {\n\t\t\tperror(fname);\n\t\t\txdl_free_mmfile(mf);\n\t\t\tclose(fd);\n\t\t\treturn -1;\n\t\t}\n\t\tclose(fd);\n\t\tif (bsize > size)\n\t\t\tblk[size] = '\\\\n';\n\t\treturn 0;\n\t}\n\n.fi\nThe\n.I bdp\nparameter points to a structure :\n.nf\n\n\ttypedef struct s_bdiffparam {\n\t\tlong bsize;\n\t} bdiffparam_t;\n\n.fi\nthat is used to pass information to the binary file differential algorithm.\nThe\n.I bsize\nparameter specify the size of the block that will be used to decompose\n.I mmf1\nduring the block classification phase of the algorithm (see MacDonald paper).\nSuggested values go from 16 to 64, with a preferred power of two characteristic.\nThe\n.I ecb\nparameter is used to pass the emission callback to the algorithm responsible\nof the output file creation.\nThe function returns 0 if succeede or -1 if an error is occurred.\n\n.TP\n.BI \"int xdl_bdiff_mb(mmbuffer_t *\" mmb1 \", mmbuffer_t *\" mmb2 \", bdiffparam_t const *\" bdp \", xdemitcb_t *\" ecb \");\"\n\nSame as\n.BR xdl_bdiff ()\nbut it works on memory buffer directly. The\n.BR xdl_bdiff ()\nis implemented internally with a\n.BR xdl_bdiff_mb ()\nafter having setup the two memory buffers from the passed memory files (that must be compact,\nas described above). The memory buffer structure is defined as :\n.nf\n\n\ttypedef struct s_mmbuffer {\n\t\tchar *ptr;\n\t\tlong size;\n\t} mmbuffer_t;\n\n.fi\nAn empty memory buffer is specified by setting the\n.I ptr\nmember as\n.B NULL\nand the\n.I size\nmember as zero. The reason of having this function is to avoid the memory file\npreparation, that might involve copying memory from other sources. Using\nthe\n.BR xdl_bdiff_mb (),\nthe caller can setup the two memory buffer by using, for example,\n.BR mmap (2),\nand hence avoiding unnecessary memory copies. The other parameters and the return value\nof the function\n.BR xdl_bdiff_mb ()\nare the same as the ones already described in\n.BR xdl_bdiff ().\n\n.TP\n.BI \"int xdl_rabdiff(mmfile_t *\" mmf1 \", mmfile_t *\" mmf2 \", xdemitcb_t *\" ecb \");\"\n\nRequest to create the difference between the two text memory files\n.IR mmf1 \" and \" mmf2\nusing the Rabin's polynomial fingerprinting algorithm. This algorithm typically\nperforms faster and produces smaller deltas, when compared to the XDelta-like one.\nThe\n.I mmf1\nmemory files is considered the \"old\" file while\n.I mmf2\nis considered the \"new\" file. So the function will create a patch file\nthat once applied to\n.I mmf1\nwill give\n.I mmf2\nas result. Files\n.IR mmf1 \" and \" mmf2\nmust be compact to make it easy and faster to perform the difference operation.\nFunctions are available to check for compactness (\n.BR xdl_mmfile_iscompact ()\n) and to make compact a non-compact file (\n.BR xdl_mmfile_compact ()\n). The\n.I ecb\nparameter is used to pass the emission callback to the algorithm responsible\nof the output file creation.\nThe function returns 0 if succeede or -1 if an error is occurred.\n\n.TP\n.BI \"int xdl_rabdiff_mb(mmbuffer_t *\" mmb1 \", mmbuffer_t *\" mmb2 \", xdemitcb_t *\" ecb \");\"\n\nSame as\n.BR xdl_rabdiff ()\nbut it works on memory buffer directly. The memory buffer structure is defined as :\n.nf\n\n\ttypedef struct s_mmbuffer {\n\t\tchar *ptr;\n\t\tlong size;\n\t} mmbuffer_t;\n\n.fi\nAn empty memory buffer is specified by setting the\n.I ptr\nmember as\n.B NULL\nand the\n.I size\nmember as zero. The reason of having this function is to avoid the memory file\npreparation, that might involve copying memory from other sources. Using\nthe\n.BR xdl_rabdiff_mb (),\nthe caller can setup the two memory buffer by using, for example,\n.BR mmap (2),\nand hence avoiding unnecessary memory copies. The other parameters and the return value\nof the function\n.BR xdl_rabdiff_mb ()\nare the same as the ones already described in\n.BR xdl_rabdiff ().\n\n.TP\n.BI \"long xdl_bdiff_tgsize(mmfile_t *\" mmfp \");\"\n\nGiven a binary memory file patch, it returns the size that the result file\nwill have once the patch is applied to the target file. It can be used to\npre-allocate (or write-allocate) a memory block to store the patch result\nso that a compact file will be available at the end of the operation. The\nfunction returns the requested size, or -1 if an error occurred during the operation.\n\n.TP\n.BI \"int xdl_bpatch(mmfile_t *\" mmf \", mmfile_t *\" mmfp \", xdemitcb_t *\" ecb \");\"\n\nRequest to patch the binary memory file\n.I mmf\nusing the binary patch file stored in\n.IR mmfp .\nThe\n.I mmf\nmemory file\n.B is not\nchanged during the operation and can be considered as read only. The binary\npatch algorithm has no notion of context, so the patch operation cannot be\npartial (either success or failure). The\n.I ecb\nparameter contain the callabck (see above for description) used by the binary\npatch algorithm to emit the result file. The function returns 0 if succeeded\nor -1 if an error occurred during the patch operation.\n\n.SH SEE ALSO\nTwo papers drove the content of this library and these are :\n.br\n.IP o\n.IR \"File System Support for Delta Compression\" \" by \" \"Joshua P. MacDonald\"\n.BR http://www.xmailserver.org/xdfs.pdf\n.br\n.IP o\n.IR \"Fingerprinting by Random Polynomials\" \" by \" \"Michael O. Rabin\"\n.BR http://www.xmailserver.org/rabin.pdf\n.br\n.IP o\n.IR \"An O(ND) Difference Algorithm and Its Variations\" \" by \" \"Eugene W. Myers\"\n.BR http://www.xmailserver.org/diff2.pdf\n.PP\n\nAlso usefull information can be looked up inside the\n.B diffutil\nGNU package :\n\n.BR http://www.gnu.org/software/diffutils/diffutils.html\n\n.SH LICENSE\nThis library is free software; you can redistribute it and/or\nmodify it under the terms of the GNU Lesser General Public\nLicense as published by the Free Software Foundation; either\nversion 2.1 of the License, or (at your option) any later version.\nA copy of the license is available at :\n\n.BR http://www.gnu.org/copyleft/lesser.html\n\n.SH AUTHOR\nDeveloped by Davide Libenzi\n.RB < davidel@xmailserver.org >\n\n.SH AVAILABILITY\nThe latest version of\n.B LibXDiff\ncan be found at :\n\n.BR http://www.xmailserver.org/xdiff-lib.html\n\n.SH BUGS\nThere are no known bugs.  Bug reports and comments to Davide Libenzi\n.RB < davidel@xmailserver.org >\n\n\n```\n\n**`find ref/git/xdiff`**\n```\nref/git/xdiff\nref/git/xdiff/xdiffi.h\nref/git/xdiff/xtypes.h\nref/git/xdiff/xinclude.h\nref/git/xdiff/xemit.h\nref/git/xdiff/xutils.h\nref/git/xdiff/xemit.c\nref/git/xdiff/xmerge.c\nref/git/xdiff/xdiffi.c\nref/git/xdiff/xpatience.c\nref/git/xdiff/xmacros.h\nref/git/xdiff/xprepare.c\nref/git/xdiff/xhistogram.c\nref/git/xdiff/xprepare.h\nref/git/xdiff/xutils.c\nref/git/xdiff/xdiff.h\n```<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\n","ts":1.738868228333E9}
{"completion":"Based on the provided documentation and source code, I will create a header file for xdiffpp, a C++ wrapper for the xdiff library.\n\n**xdiffpp.h**\n```cpp\n#ifndef XDIFFPP_H\n#define XDIFFPP_H\n\n#include <xdiff.h>\n\nnamespace xdiffpp {\n\n// Forward declarations\nclass MemoryFile;\nclass Diff;\nclass Patch;\nclass Merge;\n\n// MemoryFile class\nclass MemoryFile {\npublic:\n    MemoryFile();\n    ~MemoryFile();\n\n    // Initialize the memory file\n    void init(long bsize, unsigned long flags);\n\n    // Free the memory file\n    void free();\n\n    // Check if the memory file is compact\n    bool isCompact() const;\n\n    // Get the size of the memory file\n    long size() const;\n\n    // Read from the memory file\n    long read(void* data, long size);\n\n    // Write to the memory file\n    long write(const void* data, long size);\n\n    // Add a user-specified block to the memory file\n    long addBlock(char* ptr, long size, unsigned long flags);\n\n    // Get the first block of the memory file\n    void* firstBlock(long* size);\n\n    // Get the next block of the memory file\n    void* nextBlock(long* size);\n\nprivate:\n    mmfile_t mmf_;\n};\n\n// Diff class\nclass Diff {\npublic:\n    Diff();\n    ~Diff();\n\n    // Create a diff between two memory files\n    int createDiff(MemoryFile& oldFile, MemoryFile& newFile, xpparam_t const* xpp, xdemitconf_t const* xecfg, xdemitcb_t* ecb);\n\nprivate:\n    xpparam_t xpp_;\n    xdemitconf_t xecfg_;\n    xdemitcb_t ecb_;\n};\n\n// Patch class\nclass Patch {\npublic:\n    Patch();\n    ~Patch();\n\n    // Apply a patch to a memory file\n    int applyPatch(MemoryFile& oldFile, MemoryFile& patchFile, int mode, xdemitcb_t* ecb, xdemitcb_t* rjecb);\n\nprivate:\n    xdemitcb_t ecb_;\n    xdemitcb_t rjecb_;\n};\n\n// Merge class\nclass Merge {\npublic:\n    Merge();\n    ~Merge();\n\n    // Merge three memory files\n    int merge(MemoryFile& origFile, MemoryFile& file1, MemoryFile& file2, xdemitcb_t* ecb, xdemitcb_t* rjecb);\n\nprivate:\n    xdemitcb_t ecb_;\n    xdemitcb_t rjecb_;\n};\n\n} // namespace xdiffpp\n\n#endif // XDIFFPP_H\n```\nThis header file provides a basic structure for the xdiffpp library, including classes for memory files, diffs, patches, and merges. The classes are designed to wrap the xdiff library's functionality in a more modern and easy-to-use C++ interface.\n\nNext steps:\n\n1. Implement the member functions for each class.\n2. Add error handling and exception handling mechanisms.\n3. Test the library with sample use cases.\n4. Document the library's API and usage.\n5. Consider adding additional features, such as support for different diff algorithms or output formats.","ts":1.73886825837E9}
