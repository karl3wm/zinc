{"role":"user","content":"[1] Change this file to use BOOST_CHECK_EQUAL instead of BOOST_TEST .\n\n1: **tests/test_json.cpp**\n```\n#define BOOST_TEST_MODULE JSONTest\n#include <boost/test/unit_test.hpp>\n#include <zinc/json.hpp>\n#include <string_view>\n#include <span>\n#include <stdexcept> // For std::invalid_argument\n\nusing namespace zinc;\n\nBOOST_AUTO_TEST_CASE(test_decode_encode_simple_object) {\n    const std::string_view input = R\"({\"key\":\"value\"})\";\n    JSON::Doc doc = JSON::decode(input);\n    JSON& root = *doc;\n    BOOST_TEST(root.encode() == input);\n}\n\nBOOST_AUTO_TEST_CASE(test_access_object_element) {\n    const std::string_view input = R\"({\"key\":42})\";\n    JSON::Doc doc = JSON::decode(input);\n    JSON& root = *doc;\n\n    const JSON& value = root[\"key\"];\n    BOOST_TEST(std::holds_alternative<long>(value) && std::get<long>(value) == 42);\n}\n\nBOOST_AUTO_TEST_CASE(test_null_type) {\n    JSON::Doc doc = JSON::decode(\"null\");\n    JSON& root = *doc;\n    BOOST_TEST(std::holds_alternative<std::nullptr_t>(root));\n    BOOST_TEST(root.encode() == \"null\");\n}\n\nBOOST_AUTO_TEST_CASE(test_boolean_types) {\n    {\n        JSON::Doc doc = JSON::decode(\"true\");\n        JSON& root = *doc;\n        BOOST_TEST(std::holds_alternative<bool>(root) && std::get<bool>(root) == true);\n    }\n    {\n        JSON::Doc doc = JSON::decode(\"false\");\n        JSON& root = *doc;\n        BOOST_TEST(std::holds_alternative<bool>(root) && std::get<bool>(root) == false);\n    }\n}\n\nBOOST_AUTO_TEST_CASE(test_number_types) {\n    {\n        JSON::Doc doc = JSON::decode(\"12345\");\n        JSON& root = *doc;\n        BOOST_TEST(std::holds_alternative<long>(root) && std::get<long>(root) == 12345);\n    }\n    {\n        JSON::Doc doc = JSON::decode(\"123.45\");\n        JSON& root = *doc;\n        BOOST_TEST(std::holds_alternative<double>(root) && std::get<double>(root) == 123.45, boost::test_tools::tolerance(1e-6));\n    }\n}\n\nBOOST_AUTO_TEST_CASE(test_string_type) {\n    const std::string_view input = R\"(\"hello\\u0020world\")\";\n    JSON::Doc doc = JSON::decode(input);\n    JSON& root = *doc;\n    BOOST_TEST(std::holds_alternative<std::string_view>(root) && std::get<std::string_view>(root) == \"hello world\");\n}\n\nBOOST_AUTO_TEST_CASE(test_array_type) {\n    const std::string_view input = R\"([1,\"two\",3.0])\";\n    JSON::Doc doc = JSON::decode(input);\n    JSON& root = *doc;\n\n    const auto& arr = root.array();\n    BOOST_REQUIRE_EQUAL(arr.size(), 3);\n    BOOST_TEST(std::holds_alternative<long>(arr[0]) && std::get<long>(arr[0]) == 1);\n    BOOST_TEST(std::holds_alternative<std::string_view>(arr[1]) && std::get<std::string_view>(arr[1]) == \"two\");\n    BOOST_TEST(std::holds_alternative<double>(arr[2]) && std::get<double>(arr[2]) == 3.0);\n}\n\nBOOST_AUTO_TEST_CASE(test_object_type) {\n    const std::string_view input = R\"({\"a\":1,\"b\":\"two\"})\";\n    JSON::Doc doc = JSON::decode(input);\n    JSON& root = *doc;\n\n    const auto& obj = root.object();\n    BOOST_REQUIRE_EQUAL(obj.size(), 2);\n    BOOST_TEST((obj[0].first == \"a\" && std::get<long>(obj[0].second) == 1) ||\n               (obj[1].first == \"a\" && std::get<long>(obj[1].second) == 1));\n    BOOST_TEST((obj[0].first == \"b\" && std::get<std::string_view>(obj[0].second) == \"two\") ||\n               (obj[1].first == \"b\" && std::get<std::string_view>(obj[1].second) == \"two\"));\n}\n\nBOOST_AUTO_TEST_CASE(test_comparison_operators) {\n    JSON::Doc doc1 = JSON::decode(\"42\");\n    JSON::Doc doc2 = JSON::decode(\"42\");\n    JSON::Doc doc3 = JSON::decode(\"43\");\n\n    BOOST_TEST(*doc1 == *doc2);\n    BOOST_TEST((*doc1 <=> *doc3) == std::partial_ordering::less);\n}\n\nBOOST_AUTO_TEST_CASE(test_nested_structures) {\n    const std::string_view input = R\"({\"arr\":[1,{\"nested\":true}],\"obj\":{}})\";\n    JSON::Doc doc = JSON::decode(input);\n    JSON& root = *doc;\n\n    const JSON& arr = root[\"arr\"];\n    const auto& elements = arr.array();\n    BOOST_REQUIRE_EQUAL(elements.size(), 2);\n    BOOST_TEST(std::holds_alternative<long>(elements[0]) && std::get<long>(elements[0]) == 1);\n    BOOST_TEST(std::holds_alternative<JSON>(elements[1]));\n    const JSON& nestedObj = std::get<JSON>(elements[1]);\n    BOOST_TEST(std::holds_alternative<bool>(nestedObj[\"nested\"]) && std::get<bool>(nestedObj[\"nested\"]) == true);\n\n    const JSON& obj = root[\"obj\"];\n    BOOST_TEST(std::holds_alternative<std::map<std::string, JSON>>(obj) && obj.object().empty());\n}\n\nBOOST_AUTO_TEST_CASE(test_edge_cases) {\n    {\n        JSON::Doc doc = JSON::decode(\"[]\");\n        BOOST_TEST((*doc).encode() == \"[]\");\n    }\n    {\n        JSON::Doc doc = JSON::decode(\"{}\");\n        BOOST_TEST((*doc).encode() == \"{}\");\n    }\n}\n\n// Additional tests for edge cases and invalid inputs\nBOOST_AUTO_TEST_CASE(test_invalid_json) {\n    BOOST_CHECK_THROW(JSON::decode(\"{invalid_json}\"), std::invalid_argument);\n}\n\nBOOST_AUTO_TEST_CASE(test_large_numbers) {\n    JSON::Doc doc = JSON::decode(\"9223372036854775807\"); // Maximum long value\n    JSON& root = *doc;\n    BOOST_TEST(std::holds_alternative<long>(root) && std::get<long>(root) == 9223372036854775807L);\n}\n\nBOOST_AUTO_TEST_CASE(test_deeply_nested_structures) {\n    const std::string_view input = R\"({\"level1\":{\"level2\":{\"level3\":42}}})\";\n    JSON::Doc doc = JSON::decode(input);\n    JSON& root = *doc;\n\n    const JSON& level1 = root[\"level1\"];\n    const JSON& level2 = level1[\"level2\"];\n    const JSON& level3 = level2[\"level3\"];\n    BOOST_TEST(std::holds_alternative<long>(level3) && std::get<long>(level3) == 42);\n}\n\n```\n","ts":1.739317279508E9}
