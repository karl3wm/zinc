{"prompt":"<|begin_of_text|><|start_header_id|>user<|end_header_id|>\n\nUpdate doc.txt to contain any information on the public interface for xdiff that it is missing from xdiffi.c and xdiffi.h . Present doct.txt surrounded by backticks.\n\n**doc.txt**\n```\n`doc.txt`\n\nPublic Interface for xdiff\n==========================\n\n### Data Structures\n\n* `mmfile_t`: represents a memory-mapped file\n\t+ `char *ptr`: pointer to the file's contents\n\t+ `long size`: size of the file's contents\n* `mmbuffer_t`: represents a memory-mapped buffer\n\t+ `char *ptr`: pointer to the buffer's contents\n\t+ `long size`: size of the buffer's contents\n* `xpparam_t`: represents parameters for the xdiff algorithm\n\t+ `unsigned long flags`: flags controlling the algorithm's behavior\n\t+ `regex_t **ignore_regex`: array of regular expressions to ignore\n\t+ `size_t ignore_regex_nr`: number of regular expressions to ignore\n\t+ `char **anchors`: array of anchor strings\n\t+ `size_t anchors_nr`: number of anchor strings\n* `xdemitcb_t`: represents a callback function for emitting differences\n\t+ `void *priv`: private data for the callback function\n\t+ `int (*out_hunk)(void *, long, long, long, long, const char *, long)`: callback function for emitting a hunk\n\t+ `int (*out_line)(void *, mmbuffer_t *, int)`: callback function for emitting a line\n* `xdemitconf_t`: represents configuration for emitting differences\n\t+ `long ctxlen`: length of the context for emitting differences\n\t+ `long interhunkctxlen`: length of the inter-hunk context for emitting differences\n\t+ `unsigned long flags`: flags controlling the emission of differences\n\t+ `find_func_t find_func`: function for finding the next match\n\t+ `void *find_func_priv`: private data for the find function\n\t+ `xdl_emit_hunk_consume_func_t hunk_func`: function for consuming a hunk\n* `bdiffparam_t`: represents parameters for the bdiff algorithm\n\t+ `long bsize`: size of the buffer for the bdiff algorithm\n\n### Functions\n\n* `xdl_diff(mmfile_t *mf1, mmfile_t *mf2, xpparam_t const *xpp, xdemitconf_t const *xecfg, xdemitcb_t *ecb)`: computes the differences between two files\n* `xdl_merge(mmfile_t *orig, mmfile_t *mf1, mmfile_t *mf2, xmparam_t const *xmp, mmbuffer_t *result)`: merges two files\n* `xdl_do_diff(mmfile_t *mf1, mmfile_t *mf2, xpparam_t const *xpp, xdfenv_t *xe)`: internal function for computing differences\n* `xdl_build_script(xdfenv_t *xe, xdchange_t **xscr)`: builds a script for emitting differences\n* `xdl_free_script(xdchange_t *xscr)`: frees a script for emitting differences\n* `xdl_call_hunk_func(xdfenv_t *xe, xdchange_t *xscr, xdemitcb_t *ecb, xdemitconf_t const *xecfg)`: internal function for emitting a hunk\n* `xdl_mark_ignorable_lines(xdchange_t *xscr, xdfenv_t *xe, long flags)`: marks ignorable lines in a script\n* `xdl_mark_ignorable_regex(xdchange_t *xscr, const xdfenv_t *xe, xpparam_t const *xpp)`: marks ignorable lines in a script using regular expressions\n\n```\n\n**ref/git/xdiff/xdiff.h**\n```\n/*\n *  LibXDiff by Davide Libenzi ( File Differential Library )\n *  Copyright (C) 2003  Davide Libenzi\n *\n *  This library is free software; you can redistribute it and/or\n *  modify it under the terms of the GNU Lesser General Public\n *  License as published by the Free Software Foundation; either\n *  version 2.1 of the License, or (at your option) any later version.\n *\n *  This library is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n *  Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; if not, see\n *  <http://www.gnu.org/licenses/>.\n *\n *  Davide Libenzi <davidel@xmailserver.org>\n *\n */\n\n#if !defined(XDIFF_H)\n#define XDIFF_H\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif /* #ifdef __cplusplus */\n\n/* xpparm_t.flags */\n#define XDF_NEED_MINIMAL (1 << 0)\n\n#define XDF_IGNORE_WHITESPACE (1 << 1)\n#define XDF_IGNORE_WHITESPACE_CHANGE (1 << 2)\n#define XDF_IGNORE_WHITESPACE_AT_EOL (1 << 3)\n#define XDF_IGNORE_CR_AT_EOL (1 << 4)\n#define XDF_WHITESPACE_FLAGS (XDF_IGNORE_WHITESPACE | \\\n\t\t\t      XDF_IGNORE_WHITESPACE_CHANGE | \\\n\t\t\t      XDF_IGNORE_WHITESPACE_AT_EOL | \\\n\t\t\t      XDF_IGNORE_CR_AT_EOL)\n\n#define XDF_IGNORE_BLANK_LINES (1 << 7)\n\n#define XDF_PATIENCE_DIFF (1 << 14)\n#define XDF_HISTOGRAM_DIFF (1 << 15)\n#define XDF_DIFF_ALGORITHM_MASK (XDF_PATIENCE_DIFF | XDF_HISTOGRAM_DIFF)\n#define XDF_DIFF_ALG(x) ((x) & XDF_DIFF_ALGORITHM_MASK)\n\n#define XDF_INDENT_HEURISTIC (1 << 23)\n\n/* xdemitconf_t.flags */\n#define XDL_EMIT_FUNCNAMES (1 << 0)\n#define XDL_EMIT_NO_HUNK_HDR (1 << 1)\n#define XDL_EMIT_FUNCCONTEXT (1 << 2)\n\n/* merge simplification levels */\n#define XDL_MERGE_MINIMAL 0\n#define XDL_MERGE_EAGER 1\n#define XDL_MERGE_ZEALOUS 2\n#define XDL_MERGE_ZEALOUS_ALNUM 3\n\n/* merge favor modes */\n#define XDL_MERGE_FAVOR_OURS 1\n#define XDL_MERGE_FAVOR_THEIRS 2\n#define XDL_MERGE_FAVOR_UNION 3\n\n/* merge output styles */\n#define XDL_MERGE_DIFF3 1\n#define XDL_MERGE_ZEALOUS_DIFF3 2\n\ntypedef struct s_mmfile {\n\tchar *ptr;\n\tlong size;\n} mmfile_t;\n\ntypedef struct s_mmbuffer {\n\tchar *ptr;\n\tlong size;\n} mmbuffer_t;\n\ntypedef struct s_xpparam {\n\tunsigned long flags;\n\n\t/* -I<regex> */\n\tregex_t **ignore_regex;\n\tsize_t ignore_regex_nr;\n\n\t/* See Documentation/diff-options.txt. */\n\tchar **anchors;\n\tsize_t anchors_nr;\n} xpparam_t;\n\ntypedef struct s_xdemitcb {\n\tvoid *priv;\n\tint (*out_hunk)(void *,\n\t\t\tlong old_begin, long old_nr,\n\t\t\tlong new_begin, long new_nr,\n\t\t\tconst char *func, long funclen);\n\tint (*out_line)(void *, mmbuffer_t *, int);\n} xdemitcb_t;\n\ntypedef long (*find_func_t)(const char *line, long line_len, char *buffer, long buffer_size, void *priv);\n\ntypedef int (*xdl_emit_hunk_consume_func_t)(long start_a, long count_a,\n\t\t\t\t\t    long start_b, long count_b,\n\t\t\t\t\t    void *cb_data);\n\ntypedef struct s_xdemitconf {\n\tlong ctxlen;\n\tlong interhunkctxlen;\n\tunsigned long flags;\n\tfind_func_t find_func;\n\tvoid *find_func_priv;\n\txdl_emit_hunk_consume_func_t hunk_func;\n} xdemitconf_t;\n\ntypedef struct s_bdiffparam {\n\tlong bsize;\n} bdiffparam_t;\n\n\n#define xdl_malloc(x) xmalloc(x)\n#define xdl_calloc(n, sz) xcalloc(n, sz)\n#define xdl_free(ptr) free(ptr)\n#define xdl_realloc(ptr,x) xrealloc(ptr,x)\n\nvoid *xdl_mmfile_first(mmfile_t *mmf, long *size);\nlong xdl_mmfile_size(mmfile_t *mmf);\n\nint xdl_diff(mmfile_t *mf1, mmfile_t *mf2, xpparam_t const *xpp,\n\t     xdemitconf_t const *xecfg, xdemitcb_t *ecb);\n\ntypedef struct s_xmparam {\n\txpparam_t xpp;\n\tint marker_size;\n\tint level;\n\tint favor;\n\tint style;\n\tconst char *ancestor;\t/* label for orig */\n\tconst char *file1;\t/* label for mf1 */\n\tconst char *file2;\t/* label for mf2 */\n} xmparam_t;\n\n#define DEFAULT_CONFLICT_MARKER_SIZE 7\n\nint xdl_merge(mmfile_t *orig, mmfile_t *mf1, mmfile_t *mf2,\n\t\txmparam_t const *xmp, mmbuffer_t *result);\n\n#ifdef __cplusplus\n}\n#endif /* #ifdef __cplusplus */\n\n#endif /* #if !defined(XDIFF_H) */\n\n```\n\n**ref/git/xdiff/xdiffi.c**\n```\n/*\n *  LibXDiff by Davide Libenzi ( File Differential Library )\n *  Copyright (C) 2003\tDavide Libenzi\n *\n *  This library is free software; you can redistribute it and/or\n *  modify it under the terms of the GNU Lesser General Public\n *  License as published by the Free Software Foundation; either\n *  version 2.1 of the License, or (at your option) any later version.\n *\n *  This library is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n *  Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; if not, see\n *  <http://www.gnu.org/licenses/>.\n *\n *  Davide Libenzi <davidel@xmailserver.org>\n *\n */\n#define DISABLE_SIGN_COMPARE_WARNINGS\n\n#include \"xinclude.h\"\n\n#define XDL_MAX_COST_MIN 256\n#define XDL_HEUR_MIN_COST 256\n#define XDL_LINE_MAX (long)((1UL << (CHAR_BIT * sizeof(long) - 1)) - 1)\n#define XDL_SNAKE_CNT 20\n#define XDL_K_HEUR 4\n\ntypedef struct s_xdpsplit {\n\tlong i1, i2;\n\tint min_lo, min_hi;\n} xdpsplit_t;\n\n/*\n * See \"An O(ND) Difference Algorithm and its Variations\", by Eugene Myers.\n * Basically considers a \"box\" (off1, off2, lim1, lim2) and scan from both\n * the forward diagonal starting from (off1, off2) and the backward diagonal\n * starting from (lim1, lim2). If the K values on the same diagonal crosses\n * returns the furthest point of reach. We might encounter expensive edge cases\n * using this algorithm, so a little bit of heuristic is needed to cut the\n * search and to return a suboptimal point.\n */\nstatic long xdl_split(unsigned long const *ha1, long off1, long lim1,\n\t\t      unsigned long const *ha2, long off2, long lim2,\n\t\t      long *kvdf, long *kvdb, int need_min, xdpsplit_t *spl,\n\t\t      xdalgoenv_t *xenv) {\n\tlong dmin = off1 - lim2, dmax = lim1 - off2;\n\tlong fmid = off1 - off2, bmid = lim1 - lim2;\n\tlong odd = (fmid - bmid) & 1;\n\tlong fmin = fmid, fmax = fmid;\n\tlong bmin = bmid, bmax = bmid;\n\tlong ec, d, i1, i2, prev1, best, dd, v, k;\n\n\t/*\n\t * Set initial diagonal values for both forward and backward path.\n\t */\n\tkvdf[fmid] = off1;\n\tkvdb[bmid] = lim1;\n\n\tfor (ec = 1;; ec++) {\n\t\tint got_snake = 0;\n\n\t\t/*\n\t\t * We need to extend the diagonal \"domain\" by one. If the next\n\t\t * values exits the box boundaries we need to change it in the\n\t\t * opposite direction because (max - min) must be a power of\n\t\t * two.\n\t\t *\n\t\t * Also we initialize the external K value to -1 so that we can\n\t\t * avoid extra conditions in the check inside the core loop.\n\t\t */\n\t\tif (fmin > dmin)\n\t\t\tkvdf[--fmin - 1] = -1;\n\t\telse\n\t\t\t++fmin;\n\t\tif (fmax < dmax)\n\t\t\tkvdf[++fmax + 1] = -1;\n\t\telse\n\t\t\t--fmax;\n\n\t\tfor (d = fmax; d >= fmin; d -= 2) {\n\t\t\tif (kvdf[d - 1] >= kvdf[d + 1])\n\t\t\t\ti1 = kvdf[d - 1] + 1;\n\t\t\telse\n\t\t\t\ti1 = kvdf[d + 1];\n\t\t\tprev1 = i1;\n\t\t\ti2 = i1 - d;\n\t\t\tfor (; i1 < lim1 && i2 < lim2 && ha1[i1] == ha2[i2]; i1++, i2++);\n\t\t\tif (i1 - prev1 > xenv->snake_cnt)\n\t\t\t\tgot_snake = 1;\n\t\t\tkvdf[d] = i1;\n\t\t\tif (odd && bmin <= d && d <= bmax && kvdb[d] <= i1) {\n\t\t\t\tspl->i1 = i1;\n\t\t\t\tspl->i2 = i2;\n\t\t\t\tspl->min_lo = spl->min_hi = 1;\n\t\t\t\treturn ec;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * We need to extend the diagonal \"domain\" by one. If the next\n\t\t * values exits the box boundaries we need to change it in the\n\t\t * opposite direction because (max - min) must be a power of\n\t\t * two.\n\t\t *\n\t\t * Also we initialize the external K value to -1 so that we can\n\t\t * avoid extra conditions in the check inside the core loop.\n\t\t */\n\t\tif (bmin > dmin)\n\t\t\tkvdb[--bmin - 1] = XDL_LINE_MAX;\n\t\telse\n\t\t\t++bmin;\n\t\tif (bmax < dmax)\n\t\t\tkvdb[++bmax + 1] = XDL_LINE_MAX;\n\t\telse\n\t\t\t--bmax;\n\n\t\tfor (d = bmax; d >= bmin; d -= 2) {\n\t\t\tif (kvdb[d - 1] < kvdb[d + 1])\n\t\t\t\ti1 = kvdb[d - 1];\n\t\t\telse\n\t\t\t\ti1 = kvdb[d + 1] - 1;\n\t\t\tprev1 = i1;\n\t\t\ti2 = i1 - d;\n\t\t\tfor (; i1 > off1 && i2 > off2 && ha1[i1 - 1] == ha2[i2 - 1]; i1--, i2--);\n\t\t\tif (prev1 - i1 > xenv->snake_cnt)\n\t\t\t\tgot_snake = 1;\n\t\t\tkvdb[d] = i1;\n\t\t\tif (!odd && fmin <= d && d <= fmax && i1 <= kvdf[d]) {\n\t\t\t\tspl->i1 = i1;\n\t\t\t\tspl->i2 = i2;\n\t\t\t\tspl->min_lo = spl->min_hi = 1;\n\t\t\t\treturn ec;\n\t\t\t}\n\t\t}\n\n\t\tif (need_min)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * If the edit cost is above the heuristic trigger and if\n\t\t * we got a good snake, we sample current diagonals to see\n\t\t * if some of them have reached an \"interesting\" path. Our\n\t\t * measure is a function of the distance from the diagonal\n\t\t * corner (i1 + i2) penalized with the distance from the\n\t\t * mid diagonal itself. If this value is above the current\n\t\t * edit cost times a magic factor (XDL_K_HEUR) we consider\n\t\t * it interesting.\n\t\t */\n\t\tif (got_snake && ec > xenv->heur_min) {\n\t\t\tfor (best = 0, d = fmax; d >= fmin; d -= 2) {\n\t\t\t\tdd = d > fmid ? d - fmid: fmid - d;\n\t\t\t\ti1 = kvdf[d];\n\t\t\t\ti2 = i1 - d;\n\t\t\t\tv = (i1 - off1) + (i2 - off2) - dd;\n\n\t\t\t\tif (v > XDL_K_HEUR * ec && v > best &&\n\t\t\t\t    off1 + xenv->snake_cnt <= i1 && i1 < lim1 &&\n\t\t\t\t    off2 + xenv->snake_cnt <= i2 && i2 < lim2) {\n\t\t\t\t\tfor (k = 1; ha1[i1 - k] == ha2[i2 - k]; k++)\n\t\t\t\t\t\tif (k == xenv->snake_cnt) {\n\t\t\t\t\t\t\tbest = v;\n\t\t\t\t\t\t\tspl->i1 = i1;\n\t\t\t\t\t\t\tspl->i2 = i2;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (best > 0) {\n\t\t\t\tspl->min_lo = 1;\n\t\t\t\tspl->min_hi = 0;\n\t\t\t\treturn ec;\n\t\t\t}\n\n\t\t\tfor (best = 0, d = bmax; d >= bmin; d -= 2) {\n\t\t\t\tdd = d > bmid ? d - bmid: bmid - d;\n\t\t\t\ti1 = kvdb[d];\n\t\t\t\ti2 = i1 - d;\n\t\t\t\tv = (lim1 - i1) + (lim2 - i2) - dd;\n\n\t\t\t\tif (v > XDL_K_HEUR * ec && v > best &&\n\t\t\t\t    off1 < i1 && i1 <= lim1 - xenv->snake_cnt &&\n\t\t\t\t    off2 < i2 && i2 <= lim2 - xenv->snake_cnt) {\n\t\t\t\t\tfor (k = 0; ha1[i1 + k] == ha2[i2 + k]; k++)\n\t\t\t\t\t\tif (k == xenv->snake_cnt - 1) {\n\t\t\t\t\t\t\tbest = v;\n\t\t\t\t\t\t\tspl->i1 = i1;\n\t\t\t\t\t\t\tspl->i2 = i2;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (best > 0) {\n\t\t\t\tspl->min_lo = 0;\n\t\t\t\tspl->min_hi = 1;\n\t\t\t\treturn ec;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Enough is enough. We spent too much time here and now we\n\t\t * collect the furthest reaching path using the (i1 + i2)\n\t\t * measure.\n\t\t */\n\t\tif (ec >= xenv->mxcost) {\n\t\t\tlong fbest, fbest1, bbest, bbest1;\n\n\t\t\tfbest = fbest1 = -1;\n\t\t\tfor (d = fmax; d >= fmin; d -= 2) {\n\t\t\t\ti1 = XDL_MIN(kvdf[d], lim1);\n\t\t\t\ti2 = i1 - d;\n\t\t\t\tif (lim2 < i2)\n\t\t\t\t\ti1 = lim2 + d, i2 = lim2;\n\t\t\t\tif (fbest < i1 + i2) {\n\t\t\t\t\tfbest = i1 + i2;\n\t\t\t\t\tfbest1 = i1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbbest = bbest1 = XDL_LINE_MAX;\n\t\t\tfor (d = bmax; d >= bmin; d -= 2) {\n\t\t\t\ti1 = XDL_MAX(off1, kvdb[d]);\n\t\t\t\ti2 = i1 - d;\n\t\t\t\tif (i2 < off2)\n\t\t\t\t\ti1 = off2 + d, i2 = off2;\n\t\t\t\tif (i1 + i2 < bbest) {\n\t\t\t\t\tbbest = i1 + i2;\n\t\t\t\t\tbbest1 = i1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ((lim1 + lim2) - bbest < fbest - (off1 + off2)) {\n\t\t\t\tspl->i1 = fbest1;\n\t\t\t\tspl->i2 = fbest - fbest1;\n\t\t\t\tspl->min_lo = 1;\n\t\t\t\tspl->min_hi = 0;\n\t\t\t} else {\n\t\t\t\tspl->i1 = bbest1;\n\t\t\t\tspl->i2 = bbest - bbest1;\n\t\t\t\tspl->min_lo = 0;\n\t\t\t\tspl->min_hi = 1;\n\t\t\t}\n\t\t\treturn ec;\n\t\t}\n\t}\n}\n\n\n/*\n * Rule: \"Divide et Impera\" (divide & conquer). Recursively split the box in\n * sub-boxes by calling the box splitting function. Note that the real job\n * (marking changed lines) is done in the two boundary reaching checks.\n */\nint xdl_recs_cmp(diffdata_t *dd1, long off1, long lim1,\n\t\t diffdata_t *dd2, long off2, long lim2,\n\t\t long *kvdf, long *kvdb, int need_min, xdalgoenv_t *xenv) {\n\tunsigned long const *ha1 = dd1->ha, *ha2 = dd2->ha;\n\n\t/*\n\t * Shrink the box by walking through each diagonal snake (SW and NE).\n\t */\n\tfor (; off1 < lim1 && off2 < lim2 && ha1[off1] == ha2[off2]; off1++, off2++);\n\tfor (; off1 < lim1 && off2 < lim2 && ha1[lim1 - 1] == ha2[lim2 - 1]; lim1--, lim2--);\n\n\t/*\n\t * If one dimension is empty, then all records on the other one must\n\t * be obviously changed.\n\t */\n\tif (off1 == lim1) {\n\t\tchar *rchg2 = dd2->rchg;\n\t\tlong *rindex2 = dd2->rindex;\n\n\t\tfor (; off2 < lim2; off2++)\n\t\t\trchg2[rindex2[off2]] = 1;\n\t} else if (off2 == lim2) {\n\t\tchar *rchg1 = dd1->rchg;\n\t\tlong *rindex1 = dd1->rindex;\n\n\t\tfor (; off1 < lim1; off1++)\n\t\t\trchg1[rindex1[off1]] = 1;\n\t} else {\n\t\txdpsplit_t spl;\n\t\tspl.i1 = spl.i2 = 0;\n\n\t\t/*\n\t\t * Divide ...\n\t\t */\n\t\tif (xdl_split(ha1, off1, lim1, ha2, off2, lim2, kvdf, kvdb,\n\t\t\t      need_min, &spl, xenv) < 0) {\n\n\t\t\treturn -1;\n\t\t}\n\n\t\t/*\n\t\t * ... et Impera.\n\t\t */\n\t\tif (xdl_recs_cmp(dd1, off1, spl.i1, dd2, off2, spl.i2,\n\t\t\t\t kvdf, kvdb, spl.min_lo, xenv) < 0 ||\n\t\t    xdl_recs_cmp(dd1, spl.i1, lim1, dd2, spl.i2, lim2,\n\t\t\t\t kvdf, kvdb, spl.min_hi, xenv) < 0) {\n\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n\nint xdl_do_diff(mmfile_t *mf1, mmfile_t *mf2, xpparam_t const *xpp,\n\t\txdfenv_t *xe) {\n\tlong ndiags;\n\tlong *kvd, *kvdf, *kvdb;\n\txdalgoenv_t xenv;\n\tdiffdata_t dd1, dd2;\n\tint res;\n\n\tif (xdl_prepare_env(mf1, mf2, xpp, xe) < 0)\n\t\treturn -1;\n\n\tif (XDF_DIFF_ALG(xpp->flags) == XDF_PATIENCE_DIFF) {\n\t\tres = xdl_do_patience_diff(xpp, xe);\n\t\tgoto out;\n\t}\n\n\tif (XDF_DIFF_ALG(xpp->flags) == XDF_HISTOGRAM_DIFF) {\n\t\tres = xdl_do_histogram_diff(xpp, xe);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Allocate and setup K vectors to be used by the differential\n\t * algorithm.\n\t *\n\t * One is to store the forward path and one to store the backward path.\n\t */\n\tndiags = xe->xdf1.nreff + xe->xdf2.nreff + 3;\n\tif (!XDL_ALLOC_ARRAY(kvd, 2 * ndiags + 2)) {\n\n\t\txdl_free_env(xe);\n\t\treturn -1;\n\t}\n\tkvdf = kvd;\n\tkvdb = kvdf + ndiags;\n\tkvdf += xe->xdf2.nreff + 1;\n\tkvdb += xe->xdf2.nreff + 1;\n\n\txenv.mxcost = xdl_bogosqrt(ndiags);\n\tif (xenv.mxcost < XDL_MAX_COST_MIN)\n\t\txenv.mxcost = XDL_MAX_COST_MIN;\n\txenv.snake_cnt = XDL_SNAKE_CNT;\n\txenv.heur_min = XDL_HEUR_MIN_COST;\n\n\tdd1.nrec = xe->xdf1.nreff;\n\tdd1.ha = xe->xdf1.ha;\n\tdd1.rchg = xe->xdf1.rchg;\n\tdd1.rindex = xe->xdf1.rindex;\n\tdd2.nrec = xe->xdf2.nreff;\n\tdd2.ha = xe->xdf2.ha;\n\tdd2.rchg = xe->xdf2.rchg;\n\tdd2.rindex = xe->xdf2.rindex;\n\n\tres = xdl_recs_cmp(&dd1, 0, dd1.nrec, &dd2, 0, dd2.nrec,\n\t\t\t   kvdf, kvdb, (xpp->flags & XDF_NEED_MINIMAL) != 0,\n\t\t\t   &xenv);\n\txdl_free(kvd);\n out:\n\tif (res < 0)\n\t\txdl_free_env(xe);\n\n\treturn res;\n}\n\n\nstatic xdchange_t *xdl_add_change(xdchange_t *xscr, long i1, long i2, long chg1, long chg2) {\n\txdchange_t *xch;\n\n\tif (!(xch = (xdchange_t *) xdl_malloc(sizeof(xdchange_t))))\n\t\treturn NULL;\n\n\txch->next = xscr;\n\txch->i1 = i1;\n\txch->i2 = i2;\n\txch->chg1 = chg1;\n\txch->chg2 = chg2;\n\txch->ignore = 0;\n\n\treturn xch;\n}\n\n\nstatic int recs_match(xrecord_t *rec1, xrecord_t *rec2)\n{\n\treturn (rec1->ha == rec2->ha);\n}\n\n/*\n * If a line is indented more than this, get_indent() just returns this value.\n * This avoids having to do absurd amounts of work for data that are not\n * human-readable text, and also ensures that the output of get_indent fits\n * within an int.\n */\n#define MAX_INDENT 200\n\n/*\n * Return the amount of indentation of the specified line, treating TAB as 8\n * columns. Return -1 if line is empty or contains only whitespace. Clamp the\n * output value at MAX_INDENT.\n */\nstatic int get_indent(xrecord_t *rec)\n{\n\tlong i;\n\tint ret = 0;\n\n\tfor (i = 0; i < rec->size; i++) {\n\t\tchar c = rec->ptr[i];\n\n\t\tif (!XDL_ISSPACE(c))\n\t\t\treturn ret;\n\t\telse if (c == ' ')\n\t\t\tret += 1;\n\t\telse if (c == '\\t')\n\t\t\tret += 8 - ret % 8;\n\t\t/* ignore other whitespace characters */\n\n\t\tif (ret >= MAX_INDENT)\n\t\t\treturn MAX_INDENT;\n\t}\n\n\t/* The line contains only whitespace. */\n\treturn -1;\n}\n\n/*\n * If more than this number of consecutive blank rows are found, just return\n * this value. This avoids requiring O(N^2) work for pathological cases, and\n * also ensures that the output of score_split fits in an int.\n */\n#define MAX_BLANKS 20\n\n/* Characteristics measured about a hypothetical split position. */\nstruct split_measurement {\n\t/*\n\t * Is the split at the end of the file (aside from any blank lines)?\n\t */\n\tint end_of_file;\n\n\t/*\n\t * How much is the line immediately following the split indented (or -1\n\t * if the line is blank):\n\t */\n\tint indent;\n\n\t/*\n\t * How many consecutive lines above the split are blank?\n\t */\n\tint pre_blank;\n\n\t/*\n\t * How much is the nearest non-blank line above the split indented (or\n\t * -1 if there is no such line)?\n\t */\n\tint pre_indent;\n\n\t/*\n\t * How many lines after the line following the split are blank?\n\t */\n\tint post_blank;\n\n\t/*\n\t * How much is the nearest non-blank line after the line following the\n\t * split indented (or -1 if there is no such line)?\n\t */\n\tint post_indent;\n};\n\nstruct split_score {\n\t/* The effective indent of this split (smaller is preferred). */\n\tint effective_indent;\n\n\t/* Penalty for this split (smaller is preferred). */\n\tint penalty;\n};\n\n/*\n * Fill m with information about a hypothetical split of xdf above line split.\n */\nstatic void measure_split(const xdfile_t *xdf, long split,\n\t\t\t  struct split_measurement *m)\n{\n\tlong i;\n\n\tif (split >= xdf->nrec) {\n\t\tm->end_of_file = 1;\n\t\tm->indent = -1;\n\t} else {\n\t\tm->end_of_file = 0;\n\t\tm->indent = get_indent(xdf->recs[split]);\n\t}\n\n\tm->pre_blank = 0;\n\tm->pre_indent = -1;\n\tfor (i = split - 1; i >= 0; i--) {\n\t\tm->pre_indent = get_indent(xdf->recs[i]);\n\t\tif (m->pre_indent != -1)\n\t\t\tbreak;\n\t\tm->pre_blank += 1;\n\t\tif (m->pre_blank == MAX_BLANKS) {\n\t\t\tm->pre_indent = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tm->post_blank = 0;\n\tm->post_indent = -1;\n\tfor (i = split + 1; i < xdf->nrec; i++) {\n\t\tm->post_indent = get_indent(xdf->recs[i]);\n\t\tif (m->post_indent != -1)\n\t\t\tbreak;\n\t\tm->post_blank += 1;\n\t\tif (m->post_blank == MAX_BLANKS) {\n\t\t\tm->post_indent = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n/*\n * The empirically-determined weight factors used by score_split() below.\n * Larger values means that the position is a less favorable place to split.\n *\n * Note that scores are only ever compared against each other, so multiplying\n * all of these weight/penalty values by the same factor wouldn't change the\n * heuristic's behavior. Still, we need to set that arbitrary scale *somehow*.\n * In practice, these numbers are chosen to be large enough that they can be\n * adjusted relative to each other with sufficient precision despite using\n * integer math.\n */\n\n/* Penalty if there are no non-blank lines before the split */\n#define START_OF_FILE_PENALTY 1\n\n/* Penalty if there are no non-blank lines after the split */\n#define END_OF_FILE_PENALTY 21\n\n/* Multiplier for the number of blank lines around the split */\n#define TOTAL_BLANK_WEIGHT (-30)\n\n/* Multiplier for the number of blank lines after the split */\n#define POST_BLANK_WEIGHT 6\n\n/*\n * Penalties applied if the line is indented more than its predecessor\n */\n#define RELATIVE_INDENT_PENALTY (-4)\n#define RELATIVE_INDENT_WITH_BLANK_PENALTY 10\n\n/*\n * Penalties applied if the line is indented less than both its predecessor and\n * its successor\n */\n#define RELATIVE_OUTDENT_PENALTY 24\n#define RELATIVE_OUTDENT_WITH_BLANK_PENALTY 17\n\n/*\n * Penalties applied if the line is indented less than its predecessor but not\n * less than its successor\n */\n#define RELATIVE_DEDENT_PENALTY 23\n#define RELATIVE_DEDENT_WITH_BLANK_PENALTY 17\n\n/*\n * We only consider whether the sum of the effective indents for splits are\n * less than (-1), equal to (0), or greater than (+1) each other. The resulting\n * value is multiplied by the following weight and combined with the penalty to\n * determine the better of two scores.\n */\n#define INDENT_WEIGHT 60\n\n/*\n * How far do we slide a hunk at most?\n */\n#define INDENT_HEURISTIC_MAX_SLIDING 100\n\n/*\n * Compute a badness score for the hypothetical split whose measurements are\n * stored in m. The weight factors were determined empirically using the tools\n * and corpus described in\n *\n *     https://github.com/mhagger/diff-slider-tools\n *\n * Also see that project if you want to improve the weights based on, for\n * example, a larger or more diverse corpus.\n */\nstatic void score_add_split(const struct split_measurement *m, struct split_score *s)\n{\n\t/*\n\t * A place to accumulate penalty factors (positive makes this index more\n\t * favored):\n\t */\n\tint post_blank, total_blank, indent, any_blanks;\n\n\tif (m->pre_indent == -1 && m->pre_blank == 0)\n\t\ts->penalty += START_OF_FILE_PENALTY;\n\n\tif (m->end_of_file)\n\t\ts->penalty += END_OF_FILE_PENALTY;\n\n\t/*\n\t * Set post_blank to the number of blank lines following the split,\n\t * including the line immediately after the split:\n\t */\n\tpost_blank = (m->indent == -1) ? 1 + m->post_blank : 0;\n\ttotal_blank = m->pre_blank + post_blank;\n\n\t/* Penalties based on nearby blank lines: */\n\ts->penalty += TOTAL_BLANK_WEIGHT * total_blank;\n\ts->penalty += POST_BLANK_WEIGHT * post_blank;\n\n\tif (m->indent != -1)\n\t\tindent = m->indent;\n\telse\n\t\tindent = m->post_indent;\n\n\tany_blanks = (total_blank != 0);\n\n\t/* Note that the effective indent is -1 at the end of the file: */\n\ts->effective_indent += indent;\n\n\tif (indent == -1) {\n\t\t/* No additional adjustments needed. */\n\t} else if (m->pre_indent == -1) {\n\t\t/* No additional adjustments needed. */\n\t} else if (indent > m->pre_indent) {\n\t\t/*\n\t\t * The line is indented more than its predecessor.\n\t\t */\n\t\ts->penalty += any_blanks ?\n\t\t\tRELATIVE_INDENT_WITH_BLANK_PENALTY :\n\t\t\tRELATIVE_INDENT_PENALTY;\n\t} else if (indent == m->pre_indent) {\n\t\t/*\n\t\t * The line has the same indentation level as its predecessor.\n\t\t * No additional adjustments needed.\n\t\t */\n\t} else {\n\t\t/*\n\t\t * The line is indented less than its predecessor. It could be\n\t\t * the block terminator of the previous block, but it could\n\t\t * also be the start of a new block (e.g., an \"else\" block, or\n\t\t * maybe the previous block didn't have a block terminator).\n\t\t * Try to distinguish those cases based on what comes next:\n\t\t */\n\t\tif (m->post_indent != -1 && m->post_indent > indent) {\n\t\t\t/*\n\t\t\t * The following line is indented more. So it is likely\n\t\t\t * that this line is the start of a block.\n\t\t\t */\n\t\t\ts->penalty += any_blanks ?\n\t\t\t\tRELATIVE_OUTDENT_WITH_BLANK_PENALTY :\n\t\t\t\tRELATIVE_OUTDENT_PENALTY;\n\t\t} else {\n\t\t\t/*\n\t\t\t * That was probably the end of a block.\n\t\t\t */\n\t\t\ts->penalty += any_blanks ?\n\t\t\t\tRELATIVE_DEDENT_WITH_BLANK_PENALTY :\n\t\t\t\tRELATIVE_DEDENT_PENALTY;\n\t\t}\n\t}\n}\n\nstatic int score_cmp(struct split_score *s1, struct split_score *s2)\n{\n\t/* -1 if s1.effective_indent < s2->effective_indent, etc. */\n\tint cmp_indents = ((s1->effective_indent > s2->effective_indent) -\n\t\t\t   (s1->effective_indent < s2->effective_indent));\n\n\treturn INDENT_WEIGHT * cmp_indents + (s1->penalty - s2->penalty);\n}\n\n/*\n * Represent a group of changed lines in an xdfile_t (i.e., a contiguous group\n * of lines that was inserted or deleted from the corresponding version of the\n * file). We consider there to be such a group at the beginning of the file, at\n * the end of the file, and between any two unchanged lines, though most such\n * groups will usually be empty.\n *\n * If the first line in a group is equal to the line following the group, then\n * the group can be slid down. Similarly, if the last line in a group is equal\n * to the line preceding the group, then the group can be slid up. See\n * group_slide_down() and group_slide_up().\n *\n * Note that loops that are testing for changed lines in xdf->rchg do not need\n * index bounding since the array is prepared with a zero at position -1 and N.\n */\nstruct xdlgroup {\n\t/*\n\t * The index of the first changed line in the group, or the index of\n\t * the unchanged line above which the (empty) group is located.\n\t */\n\tlong start;\n\n\t/*\n\t * The index of the first unchanged line after the group. For an empty\n\t * group, end is equal to start.\n\t */\n\tlong end;\n};\n\n/*\n * Initialize g to point at the first group in xdf.\n */\nstatic void group_init(xdfile_t *xdf, struct xdlgroup *g)\n{\n\tg->start = g->end = 0;\n\twhile (xdf->rchg[g->end])\n\t\tg->end++;\n}\n\n/*\n * Move g to describe the next (possibly empty) group in xdf and return 0. If g\n * is already at the end of the file, do nothing and return -1.\n */\nstatic inline int group_next(xdfile_t *xdf, struct xdlgroup *g)\n{\n\tif (g->end == xdf->nrec)\n\t\treturn -1;\n\n\tg->start = g->end + 1;\n\tfor (g->end = g->start; xdf->rchg[g->end]; g->end++)\n\t\t;\n\n\treturn 0;\n}\n\n/*\n * Move g to describe the previous (possibly empty) group in xdf and return 0.\n * If g is already at the beginning of the file, do nothing and return -1.\n */\nstatic inline int group_previous(xdfile_t *xdf, struct xdlgroup *g)\n{\n\tif (g->start == 0)\n\t\treturn -1;\n\n\tg->end = g->start - 1;\n\tfor (g->start = g->end; xdf->rchg[g->start - 1]; g->start--)\n\t\t;\n\n\treturn 0;\n}\n\n/*\n * If g can be slid toward the end of the file, do so, and if it bumps into a\n * following group, expand this group to include it. Return 0 on success or -1\n * if g cannot be slid down.\n */\nstatic int group_slide_down(xdfile_t *xdf, struct xdlgroup *g)\n{\n\tif (g->end < xdf->nrec &&\n\t    recs_match(xdf->recs[g->start], xdf->recs[g->end])) {\n\t\txdf->rchg[g->start++] = 0;\n\t\txdf->rchg[g->end++] = 1;\n\n\t\twhile (xdf->rchg[g->end])\n\t\t\tg->end++;\n\n\t\treturn 0;\n\t} else {\n\t\treturn -1;\n\t}\n}\n\n/*\n * If g can be slid toward the beginning of the file, do so, and if it bumps\n * into a previous group, expand this group to include it. Return 0 on success\n * or -1 if g cannot be slid up.\n */\nstatic int group_slide_up(xdfile_t *xdf, struct xdlgroup *g)\n{\n\tif (g->start > 0 &&\n\t    recs_match(xdf->recs[g->start - 1], xdf->recs[g->end - 1])) {\n\t\txdf->rchg[--g->start] = 1;\n\t\txdf->rchg[--g->end] = 0;\n\n\t\twhile (xdf->rchg[g->start - 1])\n\t\t\tg->start--;\n\n\t\treturn 0;\n\t} else {\n\t\treturn -1;\n\t}\n}\n\n/*\n * Move back and forward change groups for a consistent and pretty diff output.\n * This also helps in finding joinable change groups and reducing the diff\n * size.\n */\nint xdl_change_compact(xdfile_t *xdf, xdfile_t *xdfo, long flags) {\n\tstruct xdlgroup g, go;\n\tlong earliest_end, end_matching_other;\n\tlong groupsize;\n\n\tgroup_init(xdf, &g);\n\tgroup_init(xdfo, &go);\n\n\twhile (1) {\n\t\t/*\n\t\t * If the group is empty in the to-be-compacted file, skip it:\n\t\t */\n\t\tif (g.end == g.start)\n\t\t\tgoto next;\n\n\t\t/*\n\t\t * Now shift the change up and then down as far as possible in\n\t\t * each direction. If it bumps into any other changes, merge\n\t\t * them.\n\t\t */\n\t\tdo {\n\t\t\tgroupsize = g.end - g.start;\n\n\t\t\t/*\n\t\t\t * Keep track of the last \"end\" index that causes this\n\t\t\t * group to align with a group of changed lines in the\n\t\t\t * other file. -1 indicates that we haven't found such\n\t\t\t * a match yet:\n\t\t\t */\n\t\t\tend_matching_other = -1;\n\n\t\t\t/* Shift the group backward as much as possible: */\n\t\t\twhile (!group_slide_up(xdf, &g))\n\t\t\t\tif (group_previous(xdfo, &go))\n\t\t\t\t\tBUG(\"group sync broken sliding up\");\n\n\t\t\t/*\n\t\t\t * This is this highest that this group can be shifted.\n\t\t\t * Record its end index:\n\t\t\t */\n\t\t\tearliest_end = g.end;\n\n\t\t\tif (go.end > go.start)\n\t\t\t\tend_matching_other = g.end;\n\n\t\t\t/* Now shift the group forward as far as possible: */\n\t\t\twhile (1) {\n\t\t\t\tif (group_slide_down(xdf, &g))\n\t\t\t\t\tbreak;\n\t\t\t\tif (group_next(xdfo, &go))\n\t\t\t\t\tBUG(\"group sync broken sliding down\");\n\n\t\t\t\tif (go.end > go.start)\n\t\t\t\t\tend_matching_other = g.end;\n\t\t\t}\n\t\t} while (groupsize != g.end - g.start);\n\n\t\t/*\n\t\t * If the group can be shifted, then we can possibly use this\n\t\t * freedom to produce a more intuitive diff.\n\t\t *\n\t\t * The group is currently shifted as far down as possible, so\n\t\t * the heuristics below only have to handle upwards shifts.\n\t\t */\n\n\t\tif (g.end == earliest_end) {\n\t\t\t/* no shifting was possible */\n\t\t} else if (end_matching_other != -1) {\n\t\t\t/*\n\t\t\t * Move the possibly merged group of changes back to\n\t\t\t * line up with the last group of changes from the\n\t\t\t * other file that it can align with.\n\t\t\t */\n\t\t\twhile (go.end == go.start) {\n\t\t\t\tif (group_slide_up(xdf, &g))\n\t\t\t\t\tBUG(\"match disappeared\");\n\t\t\t\tif (group_previous(xdfo, &go))\n\t\t\t\t\tBUG(\"group sync broken sliding to match\");\n\t\t\t}\n\t\t} else if (flags & XDF_INDENT_HEURISTIC) {\n\t\t\t/*\n\t\t\t * Indent heuristic: a group of pure add/delete lines\n\t\t\t * implies two splits, one between the end of the\n\t\t\t * \"before\" context and the start of the group, and\n\t\t\t * another between the end of the group and the\n\t\t\t * beginning of the \"after\" context. Some splits are\n\t\t\t * aesthetically better and some are worse. We compute\n\t\t\t * a badness \"score\" for each split, and add the scores\n\t\t\t * for the two splits to define a \"score\" for each\n\t\t\t * position that the group can be shifted to. Then we\n\t\t\t * pick the shift with the lowest score.\n\t\t\t */\n\t\t\tlong shift, best_shift = -1;\n\t\t\tstruct split_score best_score;\n\n\t\t\tshift = earliest_end;\n\t\t\tif (g.end - groupsize - 1 > shift)\n\t\t\t\tshift = g.end - groupsize - 1;\n\t\t\tif (g.end - INDENT_HEURISTIC_MAX_SLIDING > shift)\n\t\t\t\tshift = g.end - INDENT_HEURISTIC_MAX_SLIDING;\n\t\t\tfor (; shift <= g.end; shift++) {\n\t\t\t\tstruct split_measurement m;\n\t\t\t\tstruct split_score score = {0, 0};\n\n\t\t\t\tmeasure_split(xdf, shift, &m);\n\t\t\t\tscore_add_split(&m, &score);\n\t\t\t\tmeasure_split(xdf, shift - groupsize, &m);\n\t\t\t\tscore_add_split(&m, &score);\n\t\t\t\tif (best_shift == -1 ||\n\t\t\t\t    score_cmp(&score, &best_score) <= 0) {\n\t\t\t\t\tbest_score.effective_indent = score.effective_indent;\n\t\t\t\t\tbest_score.penalty = score.penalty;\n\t\t\t\t\tbest_shift = shift;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\twhile (g.end > best_shift) {\n\t\t\t\tif (group_slide_up(xdf, &g))\n\t\t\t\t\tBUG(\"best shift unreached\");\n\t\t\t\tif (group_previous(xdfo, &go))\n\t\t\t\t\tBUG(\"group sync broken sliding to blank line\");\n\t\t\t}\n\t\t}\n\n\tnext:\n\t\t/* Move past the just-processed group: */\n\t\tif (group_next(xdf, &g))\n\t\t\tbreak;\n\t\tif (group_next(xdfo, &go))\n\t\t\tBUG(\"group sync broken moving to next group\");\n\t}\n\n\tif (!group_next(xdfo, &go))\n\t\tBUG(\"group sync broken at end of file\");\n\n\treturn 0;\n}\n\n\nint xdl_build_script(xdfenv_t *xe, xdchange_t **xscr) {\n\txdchange_t *cscr = NULL, *xch;\n\tchar *rchg1 = xe->xdf1.rchg, *rchg2 = xe->xdf2.rchg;\n\tlong i1, i2, l1, l2;\n\n\t/*\n\t * Trivial. Collects \"groups\" of changes and creates an edit script.\n\t */\n\tfor (i1 = xe->xdf1.nrec, i2 = xe->xdf2.nrec; i1 >= 0 || i2 >= 0; i1--, i2--)\n\t\tif (rchg1[i1 - 1] || rchg2[i2 - 1]) {\n\t\t\tfor (l1 = i1; rchg1[i1 - 1]; i1--);\n\t\t\tfor (l2 = i2; rchg2[i2 - 1]; i2--);\n\n\t\t\tif (!(xch = xdl_add_change(cscr, i1, i2, l1 - i1, l2 - i2))) {\n\t\t\t\txdl_free_script(cscr);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tcscr = xch;\n\t\t}\n\n\t*xscr = cscr;\n\n\treturn 0;\n}\n\n\nvoid xdl_free_script(xdchange_t *xscr) {\n\txdchange_t *xch;\n\n\twhile ((xch = xscr) != NULL) {\n\t\txscr = xscr->next;\n\t\txdl_free(xch);\n\t}\n}\n\nstatic int xdl_call_hunk_func(xdfenv_t *xe UNUSED, xdchange_t *xscr, xdemitcb_t *ecb,\n\t\t\t      xdemitconf_t const *xecfg)\n{\n\txdchange_t *xch, *xche;\n\n\tfor (xch = xscr; xch; xch = xche->next) {\n\t\txche = xdl_get_hunk(&xch, xecfg);\n\t\tif (!xch)\n\t\t\tbreak;\n\t\tif (xecfg->hunk_func(xch->i1, xche->i1 + xche->chg1 - xch->i1,\n\t\t\t\t     xch->i2, xche->i2 + xche->chg2 - xch->i2,\n\t\t\t\t     ecb->priv) < 0)\n\t\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic void xdl_mark_ignorable_lines(xdchange_t *xscr, xdfenv_t *xe, long flags)\n{\n\txdchange_t *xch;\n\n\tfor (xch = xscr; xch; xch = xch->next) {\n\t\tint ignore = 1;\n\t\txrecord_t **rec;\n\t\tlong i;\n\n\t\trec = &xe->xdf1.recs[xch->i1];\n\t\tfor (i = 0; i < xch->chg1 && ignore; i++)\n\t\t\tignore = xdl_blankline(rec[i]->ptr, rec[i]->size, flags);\n\n\t\trec = &xe->xdf2.recs[xch->i2];\n\t\tfor (i = 0; i < xch->chg2 && ignore; i++)\n\t\t\tignore = xdl_blankline(rec[i]->ptr, rec[i]->size, flags);\n\n\t\txch->ignore = ignore;\n\t}\n}\n\nstatic int record_matches_regex(xrecord_t *rec, xpparam_t const *xpp) {\n\tregmatch_t regmatch;\n\tint i;\n\n\tfor (i = 0; i < xpp->ignore_regex_nr; i++)\n\t\tif (!regexec_buf(xpp->ignore_regex[i], rec->ptr, rec->size, 1,\n\t\t\t\t &regmatch, 0))\n\t\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic void xdl_mark_ignorable_regex(xdchange_t *xscr, const xdfenv_t *xe,\n\t\t\t\t     xpparam_t const *xpp)\n{\n\txdchange_t *xch;\n\n\tfor (xch = xscr; xch; xch = xch->next) {\n\t\txrecord_t **rec;\n\t\tint ignore = 1;\n\t\tlong i;\n\n\t\t/*\n\t\t * Do not override --ignore-blank-lines.\n\t\t */\n\t\tif (xch->ignore)\n\t\t\tcontinue;\n\n\t\trec = &xe->xdf1.recs[xch->i1];\n\t\tfor (i = 0; i < xch->chg1 && ignore; i++)\n\t\t\tignore = record_matches_regex(rec[i], xpp);\n\n\t\trec = &xe->xdf2.recs[xch->i2];\n\t\tfor (i = 0; i < xch->chg2 && ignore; i++)\n\t\t\tignore = record_matches_regex(rec[i], xpp);\n\n\t\txch->ignore = ignore;\n\t}\n}\n\nint xdl_diff(mmfile_t *mf1, mmfile_t *mf2, xpparam_t const *xpp,\n\t     xdemitconf_t const *xecfg, xdemitcb_t *ecb) {\n\txdchange_t *xscr;\n\txdfenv_t xe;\n\temit_func_t ef = xecfg->hunk_func ? xdl_call_hunk_func : xdl_emit_diff;\n\n\tif (xdl_do_diff(mf1, mf2, xpp, &xe) < 0) {\n\n\t\treturn -1;\n\t}\n\tif (xdl_change_compact(&xe.xdf1, &xe.xdf2, xpp->flags) < 0 ||\n\t    xdl_change_compact(&xe.xdf2, &xe.xdf1, xpp->flags) < 0 ||\n\t    xdl_build_script(&xe, &xscr) < 0) {\n\n\t\txdl_free_env(&xe);\n\t\treturn -1;\n\t}\n\tif (xscr) {\n\t\tif (xpp->flags & XDF_IGNORE_BLANK_LINES)\n\t\t\txdl_mark_ignorable_lines(xscr, &xe, xpp->flags);\n\n\t\tif (xpp->ignore_regex)\n\t\t\txdl_mark_ignorable_regex(xscr, &xe, xpp);\n\n\t\tif (ef(&xe, xscr, ecb, xecfg) < 0) {\n\n\t\t\txdl_free_script(xscr);\n\t\t\txdl_free_env(&xe);\n\t\t\treturn -1;\n\t\t}\n\t\txdl_free_script(xscr);\n\t}\n\txdl_free_env(&xe);\n\n\treturn 0;\n}\n\n```\n\n**ref/git/xdiff/xdiffi.h**\n```\n/*\n *  LibXDiff by Davide Libenzi ( File Differential Library )\n *  Copyright (C) 2003  Davide Libenzi\n *\n *  This library is free software; you can redistribute it and/or\n *  modify it under the terms of the GNU Lesser General Public\n *  License as published by the Free Software Foundation; either\n *  version 2.1 of the License, or (at your option) any later version.\n *\n *  This library is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n *  Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; if not, see\n *  <http://www.gnu.org/licenses/>.\n *\n *  Davide Libenzi <davidel@xmailserver.org>\n *\n */\n\n#if !defined(XDIFFI_H)\n#define XDIFFI_H\n\n\ntypedef struct s_diffdata {\n\tlong nrec;\n\tunsigned long const *ha;\n\tlong *rindex;\n\tchar *rchg;\n} diffdata_t;\n\ntypedef struct s_xdalgoenv {\n\tlong mxcost;\n\tlong snake_cnt;\n\tlong heur_min;\n} xdalgoenv_t;\n\ntypedef struct s_xdchange {\n\tstruct s_xdchange *next;\n\tlong i1, i2;\n\tlong chg1, chg2;\n\tint ignore;\n} xdchange_t;\n\n\n\nint xdl_recs_cmp(diffdata_t *dd1, long off1, long lim1,\n\t\t diffdata_t *dd2, long off2, long lim2,\n\t\t long *kvdf, long *kvdb, int need_min, xdalgoenv_t *xenv);\nint xdl_do_diff(mmfile_t *mf1, mmfile_t *mf2, xpparam_t const *xpp,\n\t\txdfenv_t *xe);\nint xdl_change_compact(xdfile_t *xdf, xdfile_t *xdfo, long flags);\nint xdl_build_script(xdfenv_t *xe, xdchange_t **xscr);\nvoid xdl_free_script(xdchange_t *xscr);\nint xdl_emit_diff(xdfenv_t *xe, xdchange_t *xscr, xdemitcb_t *ecb,\n\t\t  xdemitconf_t const *xecfg);\nint xdl_do_patience_diff(xpparam_t const *xpp, xdfenv_t *env);\nint xdl_do_histogram_diff(xpparam_t const *xpp, xdfenv_t *env);\n\n#endif /* #if !defined(XDIFFI_H) */\n\n```<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\n","ts":1.738870042735E9}
{"completion":"Here is the updated `doc.txt` with the missing information from `xdiffi.c` and `xdiffi.h`:\n\n```\n`doc.txt`\n\nPublic Interface for xdiff\n==========================\n\n### Data Structures\n\n* `mmfile_t`: represents a memory-mapped file\n\t+ `char *ptr`: pointer to the file's contents\n\t+ `long size`: size of the file's contents\n* `mmbuffer_t`: represents a memory-mapped buffer\n\t+ `char *ptr`: pointer to the buffer's contents\n\t+ `long size`: size of the buffer's contents\n* `xpparam_t`: represents parameters for the xdiff algorithm\n\t+ `unsigned long flags`: flags controlling the algorithm's behavior\n\t+ `regex_t **ignore_regex`: array of regular expressions to ignore\n\t+ `size_t ignore_regex_nr`: number of regular expressions to ignore\n\t+ `char **anchors`: array of anchor strings\n\t+ `size_t anchors_nr`: number of anchor strings\n* `xdemitcb_t`: represents a callback function for emitting differences\n\t+ `void *priv`: private data for the callback function\n\t+ `int (*out_hunk)(void *, long, long, long, long, const char *, long)`: callback function for emitting a hunk\n\t+ `int (*out_line)(void *, mmbuffer_t *, int)`: callback function for emitting a line\n* `xdemitconf_t`: represents configuration for emitting differences\n\t+ `long ctxlen`: length of the context for emitting differences\n\t+ `long interhunkctxlen`: length of the inter-hunk context for emitting differences\n\t+ `unsigned long flags`: flags controlling the emission of differences\n\t+ `find_func_t find_func`: function for finding the next match\n\t+ `void *find_func_priv`: private data for the find function\n\t+ `xdl_emit_hunk_consume_func_t hunk_func`: function for consuming a hunk\n* `bdiffparam_t`: represents parameters for the bdiff algorithm\n\t+ `long bsize`: size of the buffer for the bdiff algorithm\n* `diffdata_t`: represents data for the xdiff algorithm\n\t+ `long nrec`: number of records\n\t+ `unsigned long const *ha`: array of hash values\n\t+ `long *rindex`: array of record indices\n\t+ `char *rchg`: array of record changes\n* `xdalgoenv_t`: represents environment for the xdiff algorithm\n\t+ `long mxcost`: maximum cost\n\t+ `long snake_cnt`: snake count\n\t+ `long heur_min`: heuristic minimum\n* `xdchange_t`: represents a change in the xdiff algorithm\n\t+ `struct s_xdchange *next`: next change\n\t+ `long i1`, `i2`: indices of the change\n\t+ `long chg1`, `chg2`: changes\n\t+ `int ignore`: ignore flag\n\n### Functions\n\n* `xdl_diff(mmfile_t *mf1, mmfile_t *mf2, xpparam_t const *xpp, xdemitconf_t const *xecfg, xdemitcb_t *ecb)`: computes the differences between two files\n* `xdl_merge(mmfile_t *orig, mmfile_t *mf1, mmfile_t *mf2, xmparam_t const *xmp, mmbuffer_t *result)`: merges two files\n* `xdl_do_diff(mmfile_t *mf1, mmfile_t *mf2, xpparam_t const *xpp, xdfenv_t *xe)`: internal function for computing differences\n* `xdl_build_script(xdfenv_t *xe, xdchange_t **xscr)`: builds a script for emitting differences\n* `xdl_free_script(xdchange_t *xscr)`: frees a script for emitting differences\n* `xdl_call_hunk_func(xdfenv_t *xe, xdchange_t *xscr, xdemitcb_t *ecb, xdemitconf_t const *xecfg)`: internal function for emitting a hunk\n* `xdl_mark_ignorable_lines(xdchange_t *xscr, xdfenv_t *xe, long flags)`: marks ignorable lines in a script\n* `xdl_mark_ignorable_regex(xdchange_t *xscr, const xdfenv_t *xe, xpparam_t const *xpp)`: marks ignorable lines in a script using regular expressions\n* `xdl_recs_cmp(diffdata_t *dd1, long off1, long lim1, diffdata_t *dd2, long off2, long lim2, long *kvdf, long *kvdb, int need_min, xdalgoenv_t *xenv)`: compares records\n* `xdl_do_patience_diff(xpparam_t const *xpp, xdfenv_t *env)`: internal function for patience diff\n* `xdl_do_histogram_diff(xpparam_t const *xpp, xdfenv_t *env)`: internal function for histogram diff\n* `xdl_change_compact(xdfile_t *xdf, xdfile_t *xdfo, long flags)`: compacts changes\n* `xdl_emit_diff(xdfenv_t *xe, xdchange_t *xscr, xdemitcb_t *ecb, xdemitconf_t const *xecfg)`: emits differences\n```\n\nNote that I've added the missing data structures and functions from `xdiffi.c` and `xdiffi.h`, and also reformatted the text to match the original style. Let me know if you need any further changes!","ts":1.738870072886E9}
