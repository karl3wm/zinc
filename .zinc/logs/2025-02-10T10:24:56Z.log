{"role":"user","content":"[1] [2] Please quote the regions of code between the dbg_walk that was immediately prior to the failure, up through the dgb_walk that failed. Hilight where the allocation, free, and use-after-free were caused.\n\n1: **../build/log.txt**\n```\nThe following will be replaced:\n- $(<pathname) will read a file\n- $(commands) will capture output from commands\n- `commands` is the same as $(commands)\n- http://url will fetch a url\n- https://url will also fetch a url\nPresently no escaping is processed, so be careful not to end commands early.\n\n\nuser: \nassistant: =================================================================\n==78000==ERROR: AddressSanitizer: heap-use-after-free on address 0x50c00005a440 at pc 0x7f4ce20f2956 bp 0x7fff406b8970 sp 0x7fff406b8130\nREAD of size 2 at 0x50c00005a440 thread T0\n    #0 0x7f4ce20f2955 in memcpy ../../../../src/libsanitizer/sanitizer_common/sanitizer_common_interceptors_memintrinsics.inc:115\n    #1 0x558eee3be5c7 in std::char_traits<char>::copy(char*, char const*, unsigned long) /usr/include/c++/12/bits/char_traits.h:431\n    #2 0x558eee3c928d in std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_S_copy(char*, char const*, unsigned long) /usr/include/c++/12/bits/basic_string.h:423\n    #3 0x558eee3ce0dc in std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_S_copy_chars(char*, char const*, char const*) /usr/include/c++/12/bits/basic_string.h:477\n    #4 0x558eee3c80a8 in void std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_construct<char const*>(char const*, char const*, std::forward_iterator_tag) /usr/include/c++/12/bits/basic_string.tcc:243\n    #5 0x558eee3c146d in std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::basic_string(char const*, unsigned long, std::allocator<char> const&) /usr/include/c++/12/bits/basic_string.h:620\n    #6 0x558eee3c90b6 in std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::basic_string(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::__sv_wrapper, std::allocator<char> const&) /usr/include/c++/12/bits/basic_string.h:188\n    #7 0x558eee3c1f2b in std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::basic_string<std::basic_string_view<char, std::char_traits<char> >, void>(std::basic_string_view<char, std::char_traits<char> > const&, std::allocator<char> const&) /usr/include/c++/12/bits/basic_string.h:787\n    #8 0x7f4ce148a6b7 in dbg_walk /home/karl3/projects/zinc/src/json_boost.cpp:28\n    #9 0x7f4ce1491aee in reserve /home/karl3/projects/zinc/src/json_boost.cpp:172\n    #10 0x7f4ce1491e51 in store_chars /home/karl3/projects/zinc/src/json_boost.cpp:179\n    #11 0x7f4ce1498615 in on_string /home/karl3/projects/zinc/src/json_boost.cpp:337\n    #12 0x7f4ce14c8de0 in parse_unescaped<true, false> /usr/include/boost/json/basic_parser_impl.hpp:1126\n    #13 0x7f4ce14adc81 in parse_value<true, false> /usr/include/boost/json/basic_parser_impl.hpp:605\n    #14 0x7f4ce14cb718 in parse_object<true, false> /usr/include/boost/json/basic_parser_impl.hpp:1805\n    #15 0x7f4ce14add2f in parse_value<true, false> /usr/include/boost/json/basic_parser_impl.hpp:609\n    #16 0x7f4ce14a8cea in parse_document<true> /usr/include/boost/json/basic_parser_impl.hpp:520\n    #17 0x7f4ce14a5b99 in write_some /usr/include/boost/json/basic_parser_impl.hpp:2728\n    #18 0x7f4ce14a086a in write_some /usr/include/boost/json/basic_parser_impl.hpp:2784\n    #19 0x7f4ce1499d3d in zinc::JSON::decode(std::basic_string_view<char, std::char_traits<char> >) /home/karl3/projects/zinc/src/json_boost.cpp:652\n    #20 0x7f4ce1572937 in process_response_lines /home/karl3/projects/zinc/src/openai.cpp:49\n    #21 0x7f4ce15713d4 in process_response_lines /home/karl3/projects/zinc/src/openai.cpp:35\n    #22 0x7f4ce1581a65 in chat /home/karl3/projects/zinc/src/openai.cpp:243\n    #23 0x7f4ce157d970 in zinc::OpenAI::chat(std::span<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > const, 18446744073709551615ul>, std::span<std::pair<std::basic_string_view<char, std::char_traits<char> >, zinc::JSON> const, 18446744073709551615ul>) const /home/karl3/projects/zinc/src/openai.cpp:202\n    #24 0x558eee3bd4d5 in main /home/karl3/projects/zinc/cli/chatabout.cpp:177\n    #25 0x7f4cdfa33d67 in __libc_start_call_main ../sysdeps/nptl/libc_start_call_main.h:58\n    #26 0x7f4cdfa33e24 in __libc_start_main_impl ../csu/libc-start.c:360\n    #27 0x558eee3b75d0 in _start (/home/karl3/projects/zinc/build/chatabout+0x325d0) (BuildId: 3f0d03fbfdeabc37d33918379be84d70228d7b14)\n\n0x50c00005a440 is located 64 bytes inside of 128-byte region [0x50c00005a400,0x50c00005a480)\nfreed by thread T0 here:\n    #0 0x7f4ce20f6698 in operator delete(void*, unsigned long) ../../../../src/libsanitizer/asan/asan_new_delete.cpp:164\n    #1 0x7f4ce1550336 in boost::container::new_allocator<char>::deallocate(char*, unsigned long) /usr/include/boost/container/new_allocator.hpp:169\n    #2 0x7f4ce1536c61 in boost::container::allocator_traits<boost::container::new_allocator<char> >::deallocate(boost::container::new_allocator<char>&, char*, unsigned long) /usr/include/boost/container/allocator_traits.hpp:308\n    #3 0x7f4ce1536c61 in boost::container::devector<char, void, void>::deallocate_buffer() /usr/include/boost/container/devector.hpp:2231\n    #4 0x7f4ce15283be in boost::container::devector<char, void, void>::reallocate_at(unsigned long, unsigned long) (/home/karl3/projects/zinc/build/libzinc.so+0xd283be) (BuildId: 16d61aab66040207d97921d44688980606c0e268)\n    #5 0x7f4ce14916c8 in boost::container::devector<char, void, void>::reserve_back(unsigned long) /usr/include/boost/container/devector.hpp:1264\n    #6 0x7f4ce14916c8 in reserve /home/karl3/projects/zinc/src/json_boost.cpp:169\n    #7 0x7f4ce1491e51 in store_chars /home/karl3/projects/zinc/src/json_boost.cpp:179\n    #8 0x7f4ce1498615 in on_string /home/karl3/projects/zinc/src/json_boost.cpp:337\n    #9 0x7f4ce14c8de0 in parse_unescaped<true, false> /usr/include/boost/json/basic_parser_impl.hpp:1126\n    #10 0x7f4ce14adc81 in parse_value<true, false> /usr/include/boost/json/basic_parser_impl.hpp:605\n    #11 0x7f4ce14cb718 in parse_object<true, false> /usr/include/boost/json/basic_parser_impl.hpp:1805\n    #12 0x7f4ce14add2f in parse_value<true, false> /usr/include/boost/json/basic_parser_impl.hpp:609\n    #13 0x7f4ce14a8cea in parse_document<true> /usr/include/boost/json/basic_parser_impl.hpp:520\n    #14 0x7f4ce14a5b99 in write_some /usr/include/boost/json/basic_parser_impl.hpp:2728\n    #15 0x7f4ce14a086a in write_some /usr/include/boost/json/basic_parser_impl.hpp:2784\n    #16 0x7f4ce1499d3d in zinc::JSON::decode(std::basic_string_view<char, std::char_traits<char> >) /home/karl3/projects/zinc/src/json_boost.cpp:652\n    #17 0x7f4ce1572937 in process_response_lines /home/karl3/projects/zinc/src/openai.cpp:49\n    #18 0x7f4ce15713d4 in process_response_lines /home/karl3/projects/zinc/src/openai.cpp:35\n    #19 0x7f4ce1581a65 in chat /home/karl3/projects/zinc/src/openai.cpp:243\n    #20 0x7f4ce157d970 in zinc::OpenAI::chat(std::span<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > const, 18446744073709551615ul>, std::span<std::pair<std::basic_string_view<char, std::char_traits<char> >, zinc::JSON> const, 18446744073709551615ul>) const /home/karl3/projects/zinc/src/openai.cpp:202\n    #21 0x558eee3bd4d5 in main /home/karl3/projects/zinc/cli/chatabout.cpp:177\n    #22 0x7f4cdfa33d67 in __libc_start_call_main ../sysdeps/nptl/libc_start_call_main.h:58\n\npreviously allocated by thread T0 here:\n    #0 0x7f4ce20f5798 in operator new(unsigned long) ../../../../src/libsanitizer/asan/asan_new_delete.cpp:95\n    #1 0x7f4ce155d755 in boost::container::new_allocator<char>::allocate(unsigned long) /usr/include/boost/container/new_allocator.hpp:160\n    #2 0x7f4ce15445a1 in boost::container::allocator_traits<boost::container::new_allocator<char> >::allocate(boost::container::new_allocator<char>&, unsigned long) /usr/include/boost/container/allocator_traits.hpp:302\n    #3 0x7f4ce15445a1 in boost::container::devector<char, void, void>::impl::do_allocate(boost::container::new_allocator<char>&, unsigned long) /usr/include/boost/container/devector.hpp:2818\n    #4 0x7f4ce15364ae in boost::container::devector<char, void, void>::allocate(unsigned long) /usr/include/boost/container/devector.hpp:2212\n    #5 0x7f4ce15279c6 in boost::container::devector<char, void, void>::reallocate_at(unsigned long, unsigned long) (/home/karl3/projects/zinc/build/libzinc.so+0xd279c6) (BuildId: 16d61aab66040207d97921d44688980606c0e268)\n    #6 0x7f4ce14916c8 in boost::container::devector<char, void, void>::reserve_back(unsigned long) /usr/include/boost/container/devector.hpp:1264\n    #7 0x7f4ce14916c8 in reserve /home/karl3/projects/zinc/src/json_boost.cpp:169\n    #8 0x7f4ce1491e51 in store_chars /home/karl3/projects/zinc/src/json_boost.cpp:179\n    #9 0x7f4ce1498059 in on_key /home/karl3/projects/zinc/src/json_boost.cpp:323\n    #10 0x7f4ce14f6128 in parse_unescaped<true, true> /usr/include/boost/json/basic_parser_impl.hpp:1125\n    #11 0x7f4ce14dba79 in parse_string<true, true> /usr/include/boost/json/basic_parser_impl.hpp:995\n    #12 0x7f4ce14cb190 in parse_object<true, false> /usr/include/boost/json/basic_parser_impl.hpp:1778\n    #13 0x7f4ce14add2f in parse_value<true, false> /usr/include/boost/json/basic_parser_impl.hpp:609\n    #14 0x7f4ce14a8cea in parse_document<true> /usr/include/boost/json/basic_parser_impl.hpp:520\n    #15 0x7f4ce14a5b99 in write_some /usr/include/boost/json/basic_parser_impl.hpp:2728\n    #16 0x7f4ce14a086a in write_some /usr/include/boost/json/basic_parser_impl.hpp:2784\n    #17 0x7f4ce1499d3d in zinc::JSON::decode(std::basic_string_view<char, std::char_traits<char> >) /home/karl3/projects/zinc/src/json_boost.cpp:652\n    #18 0x7f4ce1572937 in process_response_lines /home/karl3/projects/zinc/src/openai.cpp:49\n    #19 0x7f4ce15713d4 in process_response_lines /home/karl3/projects/zinc/src/openai.cpp:35\n    #20 0x7f4ce1581a65 in chat /home/karl3/projects/zinc/src/openai.cpp:243\n    #21 0x7f4ce157d970 in zinc::OpenAI::chat(std::span<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > const, 18446744073709551615ul>, std::span<std::pair<std::basic_string_view<char, std::char_traits<char> >, zinc::JSON> const, 18446744073709551615ul>) const /home/karl3/projects/zinc/src/openai.cpp:202\n    #22 0x558eee3bd4d5 in main /home/karl3/projects/zinc/cli/chatabout.cpp:177\n    #23 0x7f4cdfa33d67 in __libc_start_call_main ../sysdeps/nptl/libc_start_call_main.h:58\n\nSUMMARY: AddressSanitizer: heap-use-after-free ../../../../src/libsanitizer/sanitizer_common/sanitizer_common_interceptors_memintrinsics.inc:115 in memcpy\nShadow bytes around the buggy address:\n  0x50c00005a180: fa fa fa fa fa fa fa fa 00 00 00 00 00 00 00 00\n  0x50c00005a200: 00 00 00 00 00 00 00 00 fa fa fa fa fa fa fa fa\n  0x50c00005a280: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x50c00005a300: fa fa fa fa fa fa fa fa 00 00 00 00 00 00 00 00\n  0x50c00005a380: 00 00 00 00 00 00 00 04 fa fa fa fa fa fa fa fa\n=>0x50c00005a400: fd fd fd fd fd fd fd fd[fd]fd fd fd fd fd fd fd\n  0x50c00005a480: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x50c00005a500: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x50c00005a580: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x50c00005a600: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x50c00005a680: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n==78000==ABORTING\n\n```\n\n2: **../src/json_boost.cpp**\n```\n#include <zinc/json.hpp>\n\n#include <boost/container/devector.hpp>\n#include <boost/json/basic_parser_impl.hpp>\n#define enum public: enum // make serializer public in boost 1.81.0\n#include <boost/json/serializer.hpp>\n#undef enum\n#include <boost/json/impl/serializer.ipp>\n\n#include <map>\n\nusing namespace boost::json;\n\nnamespace zinc {\n\nnamespace {\n\nvoid dbg_walk(JSON const*json) {\n    if (auto*array = std::get_if<std::span<JSON>>(json)) {\n        for (auto & elem : *array) {\n            dbg_walk(&elem);\n        }\n    } else if(auto*dict = std::get_if<std::span<KeyJSONPair>>(json)) {\n        for (auto & [k,v] : *dict) {\n            dbg_walk(&v);\n        }\n    } else if(auto*str = std::get_if<std::string_view>(json)) {\n        std::string string(*str);\n    }\n}\n\nstruct ParseHandler\n{\n    static constexpr std::size_t max_object_size = (size_t)-1;\n    static constexpr std::size_t max_array_size = (size_t)-1;\n    static constexpr std::size_t max_key_size = (size_t)-1;\n    static constexpr std::size_t max_string_size = (size_t)-1;\n\n    struct DocImpl : public zinc::JSON {\n        DocImpl(\n            JSON root, ParseHandler* handler,\n            char* store_start, char* store_end,\n            JSON** ptrs_start, JSON** ptrs_end\n        ) : JSON(root), handler(handler),\n            store_start(store_start), store_end(store_end),\n            ptrs_start(ptrs_start), ptrs_end(ptrs_end)\n        { }\n        ParseHandler * handler;\n        char* store_start;\n        char* store_end;\n        JSON** ptrs_start;\n        JSON** ptrs_end;\n    };\n    DocImpl* docimpl;\n\n    std::vector<JSON> stack;\n    boost::container::devector<char> store;\n    boost::container::devector<JSON*> ptr_jsons;\n    boost::container::devector<DocImpl*> docs;\n\n    JSON* get() {\n        auto ptr = docimpl;\n        docimpl = nullptr;\n        return ptr;\n    }\n    void abort() {\n        assert(docs.back() == docimpl);\n        store.erase(docimpl->store_start, store.end());\n        ptr_jsons.erase(docimpl->ptrs_start, ptr_jsons.end());\n        docs.pop_back();\n        docimpl = nullptr;\n    }\n    void del(DocImpl& doc) {\n        assert((store.end() == doc.store_end || store.begin() == doc.store_start) && \"deallocate jsons in forward or reverse order\");\n        assert((ptr_jsons.end() == doc.ptrs_end || ptr_jsons.begin() == doc.ptrs_start) && \"deallocate jsons in forward or reverse order\");\n        decltype(docs)::iterator doc_it;\n        if (docs.back() == &doc) {\n            doc_it = docs.end() - 1;\n        } else if (docs.front() == &doc) {\n            doc_it = docs.begin();\n        } else {\n            assert(!\"deallocate jsons in forward or reverse order\");\n        }\n        assert(doc.store_start >= store.begin() && doc.store_end <= store.end());\n        assert(doc.store_start <= doc.store_end);\n        assert(doc.ptrs_start >= ptr_jsons.begin() && doc.ptrs_end <= ptr_jsons.end());\n        assert(doc.ptrs_start <= doc.ptrs_end);\n        store.erase(doc.store_start, doc.store_end);\n        ptr_jsons.erase(doc.ptrs_start, doc.ptrs_end);\n        docs.erase(doc_it);\n    }\n    static void del(JSON* doc_) {\n        DocImpl & doc = *(DocImpl*)doc_;\n        doc.handler->del(doc);\n    }\n\n    inline void adjust_store_json_ptrs(JSON*json, ptrdiff_t store_offset)\n    {\n        if (auto span = std::get_if<std::span<JSON>>(json)) {\n            *span = {\n                (JSON*)((char*)span->data() + store_offset),\n                span->size()\n            };\n        } else if (auto span = std::get_if<std::span<KeyJSONPair>>(json)) {\n            *span = {\n                (KeyJSONPair*)((char*)span->data() + store_offset),\n                span->size()\n            };\n        } else if (auto sv = std::get_if<std::string_view>(json)) {\n            *sv = {\n                sv->data() + store_offset,\n                sv->size()\n            };\n        } else {\n            throw std::logic_error(\"non-pointer json in ptr_jsons\");\n        }\n    }\n    inline void adjust_store_pointers(ptrdiff_t store_offset)\n    {\n        if (!store_offset) {\n            return;\n        }\n        for (JSON & json : stack) {\n            if (json_is_ptr(json)) {\n                adjust_store_json_ptrs(&json, store_offset);\n            }\n        }\n        for (JSON *& json : ptr_jsons) {\n            json = (JSON*)((char*)json + store_offset);\n            adjust_store_json_ptrs(json, store_offset);\n        }   \n        for (DocImpl*& doc : docs) {\n            doc = (DocImpl*)((char*)doc + store_offset);\n            assert(doc->handler == this);\n            doc->store_start += store_offset;\n            doc->store_end += store_offset;\n            assert(doc->store_start >= store.begin() && doc->store_end <= store.end());\n            assert(doc->store_start <= doc->store_end);\n        }\n        if (docimpl != nullptr) {\n            docimpl = (DocImpl*)((char*)docimpl + store_offset);\n        }\n    }\n\n    inline void adjust_ptr_pointers(ptrdiff_t ptrs_offset)\n    {\n        if (!ptrs_offset) {\n            return;\n        }\n        for (DocImpl*& doc : docs) {\n            assert(doc->handler == this);\n            doc->ptrs_start = (JSON**)((char*)doc->ptrs_start + ptrs_offset);\n            doc->ptrs_end = (JSON**)((char*)doc->ptrs_end + ptrs_offset);\n            assert(doc->ptrs_start >= ptr_jsons.begin() && doc->ptrs_end <= ptr_jsons.end());\n            assert(doc->ptrs_start <= doc->ptrs_end);\n        }\n    }\n\n    inline char* reserve(size_t n) {\n        for (auto &json : stack) {\n            dbg_walk(&json);\n        }\n        if (store.back_free_capacity() < n) {\n            size_t new_capacity = std::max(store.size(), 64ul);\n            while (new_capacity < store.size() + n) {\n                new_capacity *= 2;\n            }\n            char* old = store.data();\n            store.reserve_back(new_capacity);\n            adjust_store_pointers(store.data() - old);\n            for (auto &json : stack) {\n                dbg_walk(&json);\n            }\n        }\n        return store.end();\n    }\n    inline char* store_chars(std::string_view chars)\n    {\n        reserve(chars.size());\n        store.insert(store.end(), chars.begin(), chars.end());\n        return store.end();\n    }\n    inline char* store_key(std::string_view key)\n    {\n        //auto seat = (std::string_view*)reserve(sizeof(key));\n        store.insert(reserve(sizeof(key)), (char*)&key, (char*)(&key+1));\n        //store.resize_back(store.size() + sizeof(key));\n        //new (seat) std::string_view(key);\n        return store.end();\n    }\n    bool json_is_ptr(JSON const & json) {\n        if (\n            std::holds_alternative<std::span<JSON>>(json) ||\n            std::holds_alternative<std::span<KeyJSONPair>>(json)\n        ) {\n            return true;\n        } else if (std::string_view const * sv = std::get_if<std::string_view>(&json)) {\n            if (sv->data() >= store.data()\n             && sv->data() < &*store.end()) {\n                return true;\n            }\n        }\n        return false;\n    }\n    void add_ptr_json(JSON* json)\n    {\n        char* old = (char*)ptr_jsons.data();\n        ptr_jsons.push_back(json);\n        if ((char*)ptr_jsons.data() != old) {\n            adjust_ptr_pointers((char*)ptr_jsons.data() - old);\n        }\n    }\n    inline char* store_json(JSON const & json)\n    {\n        bool is_ptr = json_is_ptr(json);\n        dbg_walk(&json);\n        for (auto &json : stack) {\n            dbg_walk(&json);\n        }\n\n        auto seat = (JSON*)reserve(sizeof(JSON));\n        dbg_walk(&json);\n        store.insert(store.end(), (char*)&json, (char*)(&json + 1));\n        //store.resize_back(store.size() + sizeof(json));\n        //new (seat) JSON(json);\n        dbg_walk(seat);\n\n        if (is_ptr) {\n            add_ptr_json(seat);\n        }\n\n        return store.end();\n    }\n\n    inline char* store_doc()\n    {\n        assert(nullptr == docimpl);\n        char* storeptr = reserve(sizeof(DocImpl));\n        JSON** ptrsptr = ptr_jsons.end();\n        docimpl = (DocImpl*)storeptr;\n        docs.push_back(docimpl);\n        store.resize_back(store.size() + sizeof(DocImpl));\n        new (docimpl) DocImpl(\n            nullptr, this,\n            storeptr, storeptr,\n            ptrsptr, ptrsptr\n        );\n        return store.end();\n    }\n\n    //inline void set_raw(std::string_view raw) {\n    //    JSON & json = stack.back();\n    //    assert(json.raw.empty());\n    //    json.raw = raw;\n    //}\n\n    inline bool on_document_begin(error_code&) {\n        store_doc();\n        return true;\n    }\n    inline bool on_document_end(error_code&) {\n        assert(1 == stack.size());\n        assert(docimpl->handler == this);\n        *(JSON*)docimpl = stack.back();\n        stack.clear();\n        if (json_is_ptr(*docimpl)) {\n            add_ptr_json(docimpl);\n        }\n        docimpl->store_end = store.end();\n        docimpl->ptrs_end = ptr_jsons.end();\n        return true;\n    }\n    inline bool on_object_begin(error_code&) {\n        return true;\n    }\n    inline bool on_object_end(std::size_t n, error_code&) {\n        auto bot_start = (KeyJSONPair*)reserve(sizeof(KeyJSONPair) * n + sizeof(JSON));\n        auto top_end = stack.end(), top_start = top_end - (ssize_t)n * 2;\n        for (auto &json : stack) {\n            dbg_walk(&json);\n        }\n        for (auto json = top_start; json != top_end;) {\n            store_key(std::get<std::string_view>(*json));\n            ++ json;\n            store_json(*json);\n            ++ json;\n        }\n        auto bot_end = (KeyJSONPair*)&*store.end();\n        stack.erase(top_start, top_end);\n        stack.emplace_back(std::span<KeyJSONPair>(bot_start, bot_end));\n        return true;\n    }\n    inline bool on_array_begin(error_code&)\n    {\n        return true;\n    }\n    inline bool on_array_end(std::size_t n, error_code&)\n    {\n        auto bot_start = (JSON*)reserve(sizeof(JSON) * n + sizeof(JSON));\n        auto top_end = stack.end(), top_start = top_end - (ssize_t)n;\n        for (auto json = top_start; json != top_end; ++ json) {\n            store_json(*json);\n        }\n        auto bot_end = (JSON*)&*store.end();\n        stack.erase(top_start, top_end);\n        stack.emplace_back(std::span<JSON>(bot_start, bot_end));\n        return true;\n    }\n    /*\n     * boost does not forward the original document ranges to on_key* and\n     * on_part*. rather, it puts the data in a buffer on the stack, and hands\n     * pointers that point into this buffer.\n     */\n    inline bool on_key_part(string_view s, std::size_t, error_code&) {\n        store_chars(s);\n        return true;\n    }\n    inline bool on_key(string_view s, std::size_t n, error_code&) {\n        /* if boost::json were adjusted or if the raw pointer offsets were tracked\n         * then the original data could be referenced directly here.\n         * escaping can possibly be checked for with s.size() != n.\n         */\n        store_chars(s);\n        auto end = store.end(), start = end - n;\n        stack.emplace_back(std::string_view{start, end});\n        return true;\n    }\n    inline bool on_string_part(string_view s, std::size_t, error_code&) {\n        store_chars(s);\n        return true;\n    }\n    inline bool on_string(string_view s, std::size_t n, error_code&) {\n        /* if boost::json were adjusted or if the raw pointer offsets were tracked\n         * then the original data could be referenced directly here.\n         * escaping can possibly be checked for with s.size() != n.\n         */\n        store_chars(s);\n        auto end = store.end(), start = end - n;\n        stack.emplace_back(std::string_view{start, end});\n        return true;\n    }\n    inline bool on_number_part(string_view, error_code&)\n    {\n        return true;\n    }\n    inline bool on_int64(std::int64_t i, string_view, error_code&)\n    {\n        stack.emplace_back((long)i);\n        return true;\n    }\n    inline bool on_uint64(std::uint64_t u, string_view, error_code&)\n    {\n        stack.emplace_back((long)u);\n        return true;\n    }\n    inline bool on_double(double d, string_view, error_code&)\n    {\n        stack.emplace_back(d);\n        return true;\n    }\n    inline bool on_bool(bool b, error_code&)\n    {\n        stack.emplace_back(b);\n        return true;\n    }\n    inline bool on_null(error_code&)\n    {\n        stack.emplace_back(nullptr);\n        return true;\n    }\n    inline bool on_comment_part(string_view, error_code&)\n    {\n        return true;\n    }\n    inline bool on_comment(string_view, error_code&)\n    {\n        return true;\n    }\n};\n\nclass Serializer : public boost::json::serializer\n{\n    union\n    {\n        JSON const* pj_;\n        std::span<KeyJSONPair const> const* po_;\n        std::span<JSON const> const* pa_;\n    };\n    JSON const* jj_ = nullptr;\n    boost::json::value boost_value;\npublic:\n\n    bool suspend(\n        state st,\n        std::span<JSON const>::iterator it,\n        std::span<JSON const> const* pa)\n    {\n        st_.push(pa);\n        st_.push(it);\n        st_.push(st);\n        return false;\n    }\n\n    bool suspend(\n        state st,\n        std::span<KeyJSONPair const>::iterator it,\n        std::span<KeyJSONPair const> const* po)\n    {\n        st_.push(po);\n        st_.push(it);\n        st_.push(st);\n        return false;\n    }\n\n    void reset(JSON const* j) noexcept\n    {\n        //pv_ = j;\n        pj_ = j;\n        fn0_ = (fn_t)&Serializer::write_value<true>;\n        fn1_ = (fn_t)&Serializer::write_value<false>;\n\n        jj_ = j;\n        st_.clear();\n        done_ = false;\n    }\n\n    template<bool StackEmpty>\n    bool write_array(stream& ss0)\n    {\n        std::span<JSON const> const* pa;\n        local_stream ss(ss0);\n        std::span<JSON const>::iterator it, end;\n        if(StackEmpty || st_.empty())\n        {\n            pa = pa_;\n            it = pa->begin();\n            end = pa->end();\n        } else {\n            state st;\n            st_.pop(st);\n            st_.pop(it);\n            st_.pop(pa);\n            end = pa->end();\n            switch(st)\n            {\n            default:\n            case state::arr1: goto do_arr1;\n            case state::arr2: goto do_arr2;\n            case state::arr3: goto do_arr3;\n            case state::arr4: goto do_arr4;\n                break;\n            }\n        }\ndo_arr1:\n        if(BOOST_JSON_LIKELY(ss))\n            ss.append('[');\n        else\n            return suspend(\n                state::arr1, it, pa);\n        if(it == end)\n            goto do_arr4;\n        for(;;)\n        {\ndo_arr2:\n            jj_ = &*it;\n            if(! write_value<StackEmpty>(ss))\n                return suspend(\n                    state::arr2, it, pa);\n            if(BOOST_JSON_UNLIKELY(\n                ++it == end))\n                break;\ndo_arr3:\n            if(BOOST_JSON_LIKELY(ss))\n                ss.append(',');\n            else\n                return suspend(\n                    state::arr3, it, pa);\n        }\ndo_arr4:\n        if(BOOST_JSON_LIKELY(ss))\n            ss.append(']');\n        else\n            return suspend(\n                state::arr4, it, pa);\n        return true;\n    }\n\n    template<bool StackEmpty>\n    bool write_object(stream& ss0)\n    {\n        std::span<KeyJSONPair const> const* po;\n        local_stream ss(ss0);\n        std::span<KeyJSONPair const>::iterator it, end;\n        if(StackEmpty || st_.empty())\n        {\n            po = po_;\n            it = po->begin();\n            end = po->end();\n        } else {\n            state st;\n            st_.pop(st);\n            st_.pop(it);\n            st_.pop(po);\n            end = po->end();\n            switch(st)\n            {\n            default:\n            case state::obj1: goto do_obj1;\n            case state::obj2: goto do_obj2;\n            case state::obj3: goto do_obj3;\n            case state::obj4: goto do_obj4;\n            case state::obj5: goto do_obj5;\n            case state::obj6: goto do_obj6;\n                break;\n            }\n        }\ndo_obj1:\n        if(BOOST_JSON_LIKELY(ss))\n            ss.append('{');\n        else\n            return suspend(\n                state::obj1, it, po);\n        if(BOOST_JSON_UNLIKELY(\n            it == end))\n            goto do_obj6;\n        for(;;)\n        {\n            cs0_ = {\n                it->first.data(),\n                it->first.size() };\ndo_obj2:\n            if(BOOST_JSON_UNLIKELY(\n                ! write_string<StackEmpty>(ss)))\n                return suspend(\n                    state::obj2, it, po);\ndo_obj3:\n            if(BOOST_JSON_LIKELY(ss))\n                ss.append(':');\n            else\n                return suspend(\n                    state::obj3, it, po);\ndo_obj4:\n            jj_ = &it->second;\n            if(BOOST_JSON_UNLIKELY(\n                ! write_value<StackEmpty>(ss)))\n                return suspend(\n                    state::obj4, it, po);\n            ++it;\n            if(BOOST_JSON_UNLIKELY(it == end))\n                break;\ndo_obj5:\n            if(BOOST_JSON_UNLIKELY(ss))\n                ss.append(',');\n            else\n                return suspend(\n                    state::obj5, it, po);\n        }\ndo_obj6:\n        if(BOOST_JSON_LIKELY(ss))\n        {\n            ss.append('}');\n            return true;\n        }\n        return suspend(\n            state::obj6, it, po);\n    }\n\n    template<bool StackEmpty>\n    bool write_value(stream& ss)\n    {\n        auto const& jj(*jj_);\n        if (StackEmpty || st_.empty()) {\n            switch(jj.index()) {\n            default:\n            case JSON::OBJECT:\n                po_ = (std::span<KeyJSONPair const>const*)&jj.object();\n                return write_object<true>(ss);\n            case JSON::ARRAY:\n                pa_ = (std::span<JSON const>const*)&jj.array();\n                return write_array<true>(ss);\n            case JSON::STRING:\n            {\n                auto const& js = std::get<std::string_view>(jj);\n                cs0_ = { js.data(), js.size() };\n                return write_string<true>(ss);\n            }\n            case JSON::INTEGER:\n                boost_value = std::get<long>(jj);\n                jv_ = &boost_value;\n                return write_number<true>(ss);\n            case JSON::NUMBER:\n                boost_value = std::get<double>(jj);\n                jv_ = &boost_value;\n                return write_number<true>(ss);\n            case JSON::BOOLEAN:\n                if (std::get<bool>(jj)) {\n                    if(BOOST_JSON_LIKELY(\n                        ss.remain() >= 4))\n                    {\n                        ss.append(\"true\", 4);\n                        return true;\n                    }\n                    return write_true<true>(ss);\n                } else {\n                    if(BOOST_JSON_LIKELY(\n                        ss.remain() >= 5))\n                    {\n                        ss.append(\"false\", 5);\n                        return true;\n                    }\n                    return write_false<true>(ss);\n                }\n            case (JSON::Index)NULL:\n                if(BOOST_JSON_LIKELY(\n                    ss.remain() >= 4))\n                {\n                    ss.append(\"null\", 4);\n                    return true;\n                }\n                return write_null<true>(ss);\n            }\n        } else {\n            state st;\n            st_.peek(st);\n            switch(st)\n            {\n            default:\n                return serializer::write_value<StackEmpty>(ss);\n\n            case state::arr1: case state::arr2:\n            case state::arr3: case state::arr4:\n                return write_array<StackEmpty>(ss);\n\n            case state::obj1: case state::obj2:\n            case state::obj3: case state::obj4:\n            case state::obj5: case state::obj6:\n                return write_object<StackEmpty>(ss);\n            }\n        }\n    }\n};\n\nthread_local boost::json::basic_parser<ParseHandler> parser({});\n\n}\n\nJSON::Doc JSON::decode(std::string_view text)\n{\n    std::error_code ec;\n    parser.reset();\n    try {\n        /*size_t parsed_size = */parser.write_some(false, text.data(), text.size(), ec);\n        if (ec) { throw std::system_error(ec); }\n    } catch(...) {\n        parser.handler().abort();\n        throw;\n    }\n    return parser.handler().get();\n}\n\nstd::string_view JSON::encode() const\n{\n    static thread_local Serializer serializer;\n    static thread_local std::string storage;\n    serializer.reset(this);\n    storage.clear();\n    while (!serializer.done()) {\n        if (storage.capacity() == storage.size()) {\n            storage.reserve(storage.size() * 2);\n        }\n        storage += serializer.read(&*storage.end(), storage.capacity() - storage.size());\n    }\n    return storage;\n}\n\nstd::partial_ordering JSON::operator<=>(JSON const& json) const\n{\n    if (index() != json.index()) {\n        return std::partial_ordering::unordered;\n    }\n    if (auto sv = std::get_if<std::string_view>(this)) {\n        return *sv <=> std::get<std::string_view>(json);\n    } else if (auto d = std::get_if<double>(this)) {\n        return *d <=> std::get<double>(json);\n    } else if (auto l = std::get_if<long>(this)) {\n        return *l <=> std::get<long>(json);\n    } else if (auto b = std::get_if<bool>(this)) {\n        return *b <=> std::get<bool>(json);\n    } else if (auto span = std::get_if<std::span<JSON>>(this)) {\n        auto &lhs = *span;\n        auto &rhs = std::get<std::span<JSON>>(json);\n        std::partial_ordering cmp = std::partial_ordering::equivalent;\n        for (size_t idx = 0; 0 == cmp && lhs.size() > idx; ++ idx) {\n            cmp = lhs[idx] <=> rhs[idx];\n        }\n        return cmp;\n    } else if (auto span = std::get_if<std::span<KeyJSONPair>>(this)) {\n        static thread_local std::map<KeyJSONPair::first_type,KeyJSONPair::second_type> lhs, rhs;\n        auto & rhs_ =std::get<std::span<KeyJSONPair>>(json);\n        lhs.clear(); lhs.insert(span->begin(), span->end());\n        rhs.clear(); rhs.insert(rhs_.begin(), rhs_.end());\n        if (lhs.size() != rhs.size()) {\n            return lhs.size() <=> rhs.size();\n        }\n        std::partial_ordering cmp = std::partial_ordering::equivalent;\n        for (auto lit = lhs.begin(), rit = rhs.begin(); lit != lhs.end() && rit != rhs.end(); ++ lit, ++ rit) {\n            auto & [lk, lv] = *lit;\n            auto & [rk, rv] = *rit;\n            cmp = lk <=> rk; if (cmp != 0) break;\n            cmp = lv <=> rv; if (cmp != 0) break;\n        }\n        return cmp;\n    } else {\n        return std::partial_ordering::equivalent;\n    }\n}\n\nJSON const& JSON::operator[](std::string_view key) const\n{\n    JSON * result = nullptr;\n    for (auto & [k, json] : object()) {\n        if (k == key) {\n            if (result != nullptr) {\n                throw std::out_of_range(\"multiple entries\");\n            }\n            result = &json;\n        }\n    }\n    if (result == nullptr) {\n        throw std::out_of_range(\"not found\");\n    }\n    return *result;\n}\n\nJSON const& JSON::operator[](size_t idx) const\n{\n    return array()[idx];\n}\n\nJSON::Doc::Doc(JSON*root)\n: root_(root)\n{ }\n\nJSON::Doc::Doc(Doc&&doc)\n: root_(doc.root_)\n{\n    doc.root_ = nullptr;\n}\n\nJSON::Doc::~Doc()\n{\n    if (root_) {\n        ParseHandler::del(root_);\n    }\n}\n\n}\n\n```\n","ts":1.739201143047E9}
