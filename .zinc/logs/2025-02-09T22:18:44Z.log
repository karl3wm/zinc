{"role":"user","content":"[1] [2] Can you review logical consistency around adjust_store_pointers()? Somehow part of my json is referencing deallocated memory, but it seems to still work.\n\n1: **../src/json_boost.cpp**\n```\n#include <zinc/json.hpp>\n\n#include <boost/container/devector.hpp>\n#include <boost/json/basic_parser_impl.hpp>\n#define enum public: enum // make serializer public in boost 1.81.0\n#include <boost/json/serializer.hpp>\n#undef enum\n#include <boost/json/impl/serializer.ipp>\n\n#include <map>\n\nusing namespace boost::json;\n\nnamespace zinc {\n\nnamespace {\n\nstruct ParseHandler\n{\n    static constexpr std::size_t max_object_size = (size_t)-1;\n    static constexpr std::size_t max_array_size = (size_t)-1;\n    static constexpr std::size_t max_key_size = (size_t)-1;\n    static constexpr std::size_t max_string_size = (size_t)-1;\n\n    struct DocImpl : public zinc::JSON {\n        DocImpl(\n            JSON root, ParseHandler* handler,\n            char* store_start, char* store_end,\n            JSON** ptrs_start, JSON** ptrs_end\n        ) : JSON(root), handler(handler),\n            store_start(store_start), store_end(store_end),\n            ptrs_start(ptrs_start), ptrs_end(ptrs_end)\n        { }\n        ParseHandler * handler;\n        char* store_start;\n        char* store_end;\n        JSON** ptrs_start;\n        JSON** ptrs_end;\n    };\n    DocImpl* docimpl;\n\n    std::vector<JSON> stack;\n    boost::container::devector<char> store;\n    boost::container::devector<JSON*> ptr_jsons;\n    boost::container::devector<DocImpl*> docs;\n\n    JSON* get() {\n        auto ptr = docimpl;\n        docimpl = nullptr;\n        return ptr;\n    }\n    void abort() {\n        assert(docs.back() == docimpl);\n        store.erase(docimpl->store_start, store.end());\n        ptr_jsons.erase(docimpl->ptrs_start, ptr_jsons.end());\n        docs.pop_back();\n        docimpl = nullptr;\n    }\n    void del(DocImpl& doc) {\n        assert((store.end() == doc.store_end || store.begin() == doc.store_start) && \"deallocate jsons in forward or reverse order\");\n        assert((ptr_jsons.end() == doc.ptrs_end || ptr_jsons.begin() == doc.ptrs_start) && \"deallocate jsons in forward or reverse order\");\n        decltype(docs)::iterator doc_it;\n        if (docs.back() == &doc) {\n            doc_it = docs.end() - 1;\n        } else if (docs.front() == &doc) {\n            doc_it = docs.begin();\n        } else {\n            assert(!\"deallocate jsons in forward or reverse order\");\n        }\n        assert(doc.store_start >= store.begin() && doc.store_end <= store.end());\n        assert(doc.store_start <= doc.store_end);\n        assert(doc.ptrs_start >= ptr_jsons.begin() && doc.ptrs_end <= ptr_jsons.end());\n        assert(doc.ptrs_start <= doc.ptrs_end);\n        store.erase(doc.store_start, doc.store_end);\n        ptr_jsons.erase(doc.ptrs_start, doc.ptrs_end);\n        docs.erase(doc_it);\n    }\n    static void del(JSON* doc_) {\n        DocImpl & doc = *(DocImpl*)doc_;\n        doc.handler->del(doc);\n    }\n\n    inline void adjust_store_pointers(ptrdiff_t store_offset)\n    {\n        if (!store_offset) {\n            return;\n        }\n        for (JSON *& json : ptr_jsons) {\n            json = (JSON*)((char*)json + store_offset);\n            if (auto span = std::get_if<std::span<JSON>>(json)) {\n                *span = {\n                    (JSON*)((char*)span->data() + store_offset),\n                    span->size()\n                };\n            } else if (auto span = std::get_if<std::span<KeyJSONPair>>(json)) {\n                *span = {\n                    (KeyJSONPair*)((char*)span->data() + store_offset),\n                    span->size()\n                };\n            } else if (auto sv = std::get_if<std::string_view>(json)) {\n                *sv = {\n                    sv->data() + store_offset,\n                    sv->size()\n                };\n            } else {\n                throw std::logic_error(\"non-pointer json in ptr_jsons\");\n            }\n        }   \n        for (DocImpl*& doc : docs) {\n            doc = (DocImpl*)((char*)doc + store_offset);\n            assert(doc->handler == this);\n            doc->store_start += store_offset;\n            doc->store_end += store_offset;\n            assert(doc->store_start >= store.begin() && doc->store_end <= store.end());\n            assert(doc->store_start <= doc->store_end);\n        }\n        if (docimpl != nullptr) {\n            docimpl = (DocImpl*)((char*)docimpl + store_offset);\n        }\n    }\n\n    inline void adjust_ptr_pointers(ptrdiff_t ptrs_offset)\n    {\n        if (!ptrs_offset) {\n            return;\n        }\n        for (DocImpl*& doc : docs) {\n            assert(doc->handler == this);\n            doc->ptrs_start = (JSON**)((char*)doc->ptrs_start + ptrs_offset);\n            doc->ptrs_end = (JSON**)((char*)doc->ptrs_end + ptrs_offset);\n            assert(doc->ptrs_start >= ptr_jsons.begin() && doc->ptrs_end <= ptr_jsons.end());\n            assert(doc->ptrs_start <= doc->ptrs_end);\n        }\n    }\n\n    inline char* reserve(size_t n) {\n        if (store.back_free_capacity() < n) {\n            size_t new_capacity = std::max(store.size(), 64ul);\n            while (new_capacity < store.size() + n) {\n                new_capacity *= 2;\n            }\n            char* old = store.data();\n            store.reserve_back(new_capacity);\n            adjust_store_pointers(store.data() - old);\n        }\n        return store.end();\n    }\n    inline char* store_chars(std::string_view chars)\n    {\n        reserve(chars.size());\n        store.insert(store.end(), chars.begin(), chars.end());\n        return store.end();\n    }\n    inline char* store_key(std::string_view key)\n    {\n        //auto seat = (std::string_view*)reserve(sizeof(key));\n        store.insert(reserve(sizeof(key)), (char*)&key, (char*)(&key+1));\n        //store.resize_back(store.size() + sizeof(key));\n        //new (seat) std::string_view(key);\n        return store.end();\n    }\n    bool json_is_ptr(JSON const & json) {\n        if (\n            std::holds_alternative<std::span<JSON>>(json) ||\n            std::holds_alternative<std::span<KeyJSONPair>>(json)\n        ) {\n            return true;\n        } else if (std::string_view const * sv = std::get_if<std::string_view>(&json)) {\n            if (sv->data() >= store.data()\n             && sv->data() < &*store.end()) {\n                return true;\n            }\n        }\n        return false;\n    }\n    void add_ptr_json(JSON* json)\n    {\n        char* old = (char*)ptr_jsons.data();\n        ptr_jsons.push_back(json);\n        if ((char*)ptr_jsons.data() != old) {\n            adjust_ptr_pointers((char*)ptr_jsons.data() - old);\n        }\n    }\n    inline char* store_json(JSON const & json)\n    {\n        bool is_ptr = json_is_ptr(json);\n\n        auto seat = (JSON*)reserve(sizeof(JSON));\n        store.insert(store.end(), (char*)&json, (char*)(&json + 1));\n        //store.resize_back(store.size() + sizeof(json));\n        //new (seat) JSON(json);\n\n        if (is_ptr) {\n            add_ptr_json(seat);\n        }\n\n        return store.end();\n    }\n\n    inline char* store_doc()\n    {\n        assert(nullptr == docimpl);\n        char* storeptr = reserve(sizeof(DocImpl));\n        JSON** ptrsptr = ptr_jsons.end();\n        docimpl = (DocImpl*)storeptr;\n        docs.push_back(docimpl);\n        store.resize_back(store.size() + sizeof(DocImpl));\n        new (docimpl) DocImpl(\n            nullptr, this,\n            storeptr, storeptr,\n            ptrsptr, ptrsptr\n        );\n        return store.end();\n    }\n\n    //inline void set_raw(std::string_view raw) {\n    //    JSON & json = stack.back();\n    //    assert(json.raw.empty());\n    //    json.raw = raw;\n    //}\n\n    inline bool on_document_begin(error_code&) {\n        store_doc();\n        return true;\n    }\n    inline bool on_document_end(error_code&) {\n        assert(1 == stack.size());\n        assert(docimpl->handler == this);\n        *(JSON*)docimpl = stack.back();\n        stack.clear();\n        if (json_is_ptr(*docimpl)) {\n            add_ptr_json(docimpl);\n        }\n        docimpl->store_end = store.end();\n        docimpl->ptrs_end = ptr_jsons.end();\n        return true;\n    }\n    inline bool on_object_begin(error_code&) {\n        return true;\n    }\n    inline bool on_object_end(std::size_t n, error_code&) {\n        auto bot_start = (KeyJSONPair*)reserve(sizeof(KeyJSONPair) * n + sizeof(JSON));\n        auto top_end = stack.end(), top_start = top_end - (ssize_t)n * 2;\n        for (auto json = top_start; json != top_end;) {\n            store_key(std::get<std::string_view>(*json));\n            ++ json;\n            store_json(*json);\n            ++ json;\n        }\n        auto bot_end = (KeyJSONPair*)&*store.end();\n        stack.erase(top_start, top_end);\n        stack.emplace_back(std::span<KeyJSONPair>(bot_start, bot_end));\n        return true;\n    }\n    inline bool on_array_begin(error_code&)\n    {\n        return true;\n    }\n    inline bool on_array_end(std::size_t n, error_code&)\n    {\n        auto bot_start = (JSON*)reserve(sizeof(JSON) * n + sizeof(JSON));\n        auto top_end = stack.end(), top_start = top_end - (ssize_t)n;\n        for (auto json = top_start; json != top_end; ++ json) {\n            store_json(*json);\n        }\n        auto bot_end = (JSON*)&*store.end();\n        stack.erase(top_start, top_end);\n        stack.emplace_back(std::span<JSON>(bot_start, bot_end));\n        return true;\n    }\n    inline bool on_key_part(string_view s, std::size_t, error_code&) {\n        store_chars(s);\n        return true;\n    }\n    inline bool on_key(string_view s, std::size_t n, error_code&) {\n        if (s.size() < n) {\n            store_chars(s);\n            auto end = store.end(), start = end - n;\n            stack.emplace_back(std::string_view{start, end});\n        } else {\n            stack.emplace_back(s);\n        }\n        return true;\n    }\n    inline bool on_string_part(string_view s, std::size_t, error_code&) {\n        store_chars(s);\n        return true;\n    }\n    inline bool on_string(string_view s, std::size_t n, error_code&) {\n        if (s.size() < n) {\n            store_chars(s);\n            auto end = store.end(), start = end - n;\n            stack.emplace_back(std::string_view{start, end});\n        } else {\n            stack.emplace_back(s);\n        }\n        return true;\n    }\n    inline bool on_number_part(string_view, error_code&)\n    {\n        return true;\n    }\n    inline bool on_int64(std::int64_t i, string_view, error_code&)\n    {\n        stack.emplace_back((long)i);\n        return true;\n    }\n    inline bool on_uint64(std::uint64_t u, string_view, error_code&)\n    {\n        stack.emplace_back((long)u);\n        return true;\n    }\n    inline bool on_double(double d, string_view, error_code&)\n    {\n        stack.emplace_back(d);\n        return true;\n    }\n    inline bool on_bool(bool b, error_code&)\n    {\n        stack.emplace_back(b);\n        return true;\n    }\n    inline bool on_null(error_code&)\n    {\n        stack.emplace_back(nullptr);\n        return true;\n    }\n    inline bool on_comment_part(string_view, error_code&)\n    {\n        return true;\n    }\n    inline bool on_comment(string_view, error_code&)\n    {\n        return true;\n    }\n};\n\nclass Serializer : public boost::json::serializer\n{\n    union\n    {\n        JSON const* pj_;\n        std::span<KeyJSONPair const> const* po_;\n        std::span<JSON const> const* pa_;\n    };\n    JSON const* jj_ = nullptr;\n    boost::json::value boost_value;\npublic:\n\n    bool suspend(\n        state st,\n        std::span<JSON const>::iterator it,\n        std::span<JSON const> const* pa)\n    {\n        st_.push(pa);\n        st_.push(it);\n        st_.push(st);\n        return false;\n    }\n\n    bool suspend(\n        state st,\n        std::span<KeyJSONPair const>::iterator it,\n        std::span<KeyJSONPair const> const* po)\n    {\n        st_.push(po);\n        st_.push(it);\n        st_.push(st);\n        return false;\n    }\n\n    void reset(JSON const* j) noexcept\n    {\n        //pv_ = j;\n        pj_ = j;\n        fn0_ = (fn_t)&Serializer::write_value<true>;\n        fn1_ = (fn_t)&Serializer::write_value<false>;\n\n        jj_ = j;\n        st_.clear();\n        done_ = false;\n    }\n\n    template<bool StackEmpty>\n    bool write_array(stream& ss0)\n    {\n        std::span<JSON const> const* pa;\n        local_stream ss(ss0);\n        std::span<JSON const>::iterator it, end;\n        if(StackEmpty || st_.empty())\n        {\n            pa = pa_;\n            it = pa->begin();\n            end = pa->end();\n        } else {\n            state st;\n            st_.pop(st);\n            st_.pop(it);\n            st_.pop(pa);\n            end = pa->end();\n            switch(st)\n            {\n            default:\n            case state::arr1: goto do_arr1;\n            case state::arr2: goto do_arr2;\n            case state::arr3: goto do_arr3;\n            case state::arr4: goto do_arr4;\n                break;\n            }\n        }\ndo_arr1:\n        if(BOOST_JSON_LIKELY(ss))\n            ss.append('[');\n        else\n            return suspend(\n                state::arr1, it, pa);\n        if(it == end)\n            goto do_arr4;\n        for(;;)\n        {\ndo_arr2:\n            jj_ = &*it;\n            if(! write_value<StackEmpty>(ss))\n                return suspend(\n                    state::arr2, it, pa);\n            if(BOOST_JSON_UNLIKELY(\n                ++it == end))\n                break;\ndo_arr3:\n            if(BOOST_JSON_LIKELY(ss))\n                ss.append(',');\n            else\n                return suspend(\n                    state::arr3, it, pa);\n        }\ndo_arr4:\n        if(BOOST_JSON_LIKELY(ss))\n            ss.append(']');\n        else\n            return suspend(\n                state::arr4, it, pa);\n        return true;\n    }\n\n    template<bool StackEmpty>\n    bool write_object(stream& ss0)\n    {\n        std::span<KeyJSONPair const> const* po;\n        local_stream ss(ss0);\n        std::span<KeyJSONPair const>::iterator it, end;\n        if(StackEmpty || st_.empty())\n        {\n            po = po_;\n            it = po->begin();\n            end = po->end();\n        } else {\n            state st;\n            st_.pop(st);\n            st_.pop(it);\n            st_.pop(po);\n            end = po->end();\n            switch(st)\n            {\n            default:\n            case state::obj1: goto do_obj1;\n            case state::obj2: goto do_obj2;\n            case state::obj3: goto do_obj3;\n            case state::obj4: goto do_obj4;\n            case state::obj5: goto do_obj5;\n            case state::obj6: goto do_obj6;\n                break;\n            }\n        }\ndo_obj1:\n        if(BOOST_JSON_LIKELY(ss))\n            ss.append('{');\n        else\n            return suspend(\n                state::obj1, it, po);\n        if(BOOST_JSON_UNLIKELY(\n            it == end))\n            goto do_obj6;\n        for(;;)\n        {\n            cs0_ = {\n                it->first.data(),\n                it->first.size() };\ndo_obj2:\n            if(BOOST_JSON_UNLIKELY(\n                ! write_string<StackEmpty>(ss)))\n                return suspend(\n                    state::obj2, it, po);\ndo_obj3:\n            if(BOOST_JSON_LIKELY(ss))\n                ss.append(':');\n            else\n                return suspend(\n                    state::obj3, it, po);\ndo_obj4:\n            jj_ = &it->second;\n            if(BOOST_JSON_UNLIKELY(\n                ! write_value<StackEmpty>(ss)))\n                return suspend(\n                    state::obj4, it, po);\n            ++it;\n            if(BOOST_JSON_UNLIKELY(it == end))\n                break;\ndo_obj5:\n            if(BOOST_JSON_UNLIKELY(ss))\n                ss.append(',');\n            else\n                return suspend(\n                    state::obj5, it, po);\n        }\ndo_obj6:\n        if(BOOST_JSON_LIKELY(ss))\n        {\n            ss.append('}');\n            return true;\n        }\n        return suspend(\n            state::obj6, it, po);\n    }\n\n    template<bool StackEmpty>\n    bool write_value(stream& ss)\n    {\n        auto const& jj(*jj_);\n        if (StackEmpty || st_.empty()) {\n            switch(jj.index()) {\n            default:\n            case JSON::OBJECT:\n                po_ = (std::span<KeyJSONPair const>const*)&jj.object();\n                return write_object<true>(ss);\n            case JSON::ARRAY:\n                pa_ = (std::span<JSON const>const*)&jj.array();\n                return write_array<true>(ss);\n            case JSON::STRING:\n            {\n                auto const& js = std::get<std::string_view>(jj);\n                cs0_ = { js.data(), js.size() };\n                return write_string<true>(ss);\n            }\n            case JSON::INTEGER:\n                boost_value = std::get<long>(jj);\n                jv_ = &boost_value;\n                return write_number<true>(ss);\n            case JSON::NUMBER:\n                boost_value = std::get<double>(jj);\n                jv_ = &boost_value;\n                return write_number<true>(ss);\n            case JSON::BOOLEAN:\n                if (std::get<bool>(jj)) {\n                    if(BOOST_JSON_LIKELY(\n                        ss.remain() >= 4))\n                    {\n                        ss.append(\"true\", 4);\n                        return true;\n                    }\n                    return write_true<true>(ss);\n                } else {\n                    if(BOOST_JSON_LIKELY(\n                        ss.remain() >= 5))\n                    {\n                        ss.append(\"false\", 5);\n                        return true;\n                    }\n                    return write_false<true>(ss);\n                }\n            case (JSON::Index)NULL:\n                if(BOOST_JSON_LIKELY(\n                    ss.remain() >= 4))\n                {\n                    ss.append(\"null\", 4);\n                    return true;\n                }\n                return write_null<true>(ss);\n            }\n        } else {\n            state st;\n            st_.peek(st);\n            switch(st)\n            {\n            default:\n                return serializer::write_value<StackEmpty>(ss);\n\n            case state::arr1: case state::arr2:\n            case state::arr3: case state::arr4:\n                return write_array<StackEmpty>(ss);\n\n            case state::obj1: case state::obj2:\n            case state::obj3: case state::obj4:\n            case state::obj5: case state::obj6:\n                return write_object<StackEmpty>(ss);\n            }\n        }\n    }\n};\n\nthread_local boost::json::basic_parser<ParseHandler> parser({});\n\n}\n\nJSON::Doc JSON::decode(std::string_view text)\n{\n    std::error_code ec;\n    parser.reset();\n    try {\n        /*size_t parsed_size = */parser.write_some(false, text.data(), text.size(), ec);\n        if (ec) { throw std::system_error(ec); }\n    } catch(...) {\n        parser.handler().abort();\n        throw;\n    }\n    return parser.handler().get();\n}\n\nstd::string_view JSON::encode() const\n{\n    static thread_local Serializer serializer;\n    static thread_local std::string storage;\n    serializer.reset(this);\n    storage.clear();\n    while (!serializer.done()) {\n        if (storage.capacity() == storage.size()) {\n            storage.reserve(storage.size() * 2);\n        }\n        storage += serializer.read(&*storage.end(), storage.capacity() - storage.size());\n    }\n    return storage;\n}\n\nstd::partial_ordering JSON::operator<=>(JSON const& json) const\n{\n    if (index() != json.index()) {\n        return std::partial_ordering::unordered;\n    }\n    if (auto sv = std::get_if<std::string_view>(this)) {\n        return *sv <=> std::get<std::string_view>(json);\n    } else if (auto d = std::get_if<double>(this)) {\n        return *d <=> std::get<double>(json);\n    } else if (auto l = std::get_if<long>(this)) {\n        return *l <=> std::get<long>(json);\n    } else if (auto b = std::get_if<bool>(this)) {\n        return *b <=> std::get<bool>(json);\n    } else if (auto span = std::get_if<std::span<JSON>>(this)) {\n        auto &lhs = *span;\n        auto &rhs = std::get<std::span<JSON>>(json);\n        std::partial_ordering cmp = std::partial_ordering::equivalent;\n        for (size_t idx = 0; 0 == cmp && lhs.size() > idx; ++ idx) {\n            cmp = lhs[idx] <=> rhs[idx];\n        }\n        return cmp;\n    } else if (auto span = std::get_if<std::span<KeyJSONPair>>(this)) {\n        static thread_local std::map<KeyJSONPair::first_type,KeyJSONPair::second_type> lhs, rhs;\n        auto & rhs_ =std::get<std::span<KeyJSONPair>>(json);\n        lhs.clear(); lhs.insert(span->begin(), span->end());\n        rhs.clear(); rhs.insert(rhs_.begin(), rhs_.end());\n        if (lhs.size() != rhs.size()) {\n            return lhs.size() <=> rhs.size();\n        }\n        std::partial_ordering cmp = std::partial_ordering::equivalent;\n        for (auto lit = lhs.begin(), rit = rhs.begin(); lit != lhs.end() && rit != rhs.end(); ++ lit, ++ rit) {\n            auto & [lk, lv] = *lit;\n            auto & [rk, rv] = *rit;\n            cmp = lk <=> rk; if (cmp != 0) break;\n            cmp = lv <=> rv; if (cmp != 0) break;\n        }\n        return cmp;\n    } else {\n        return std::partial_ordering::equivalent;\n    }\n}\n\nJSON const& JSON::operator[](std::string_view key) const\n{\n    auto & span = std::get<std::span<KeyJSONPair>>(*this);\n    JSON * result = nullptr;\n    for (auto & [k, json] : span) {\n        if (k == key) {\n            if (result != nullptr) {\n                throw std::out_of_range(\"multiple entries\");\n            }\n            result = &json;\n        }\n    }\n    if (result == nullptr) {\n        throw std::out_of_range(\"not found\");\n    }\n    return *result;\n}\n\nJSON::Doc::Doc(JSON*root)\n: root_(root)\n{ }\n\nJSON::Doc::Doc(Doc&&doc)\n: root_(doc.root_)\n{\n    doc.root_ = nullptr;\n}\n\nJSON::Doc::~Doc()\n{\n    if (root_) {\n        ParseHandler::del(root_);\n    }\n}\n\n}\n\n```\n\n2: **/usr/include/boost/container/devector.hpp**\n```\n//////////////////////////////////////////////////////////////////////////////\n//\n// (C) Copyright Benedek Thaler 2015-2016\n// (C) Copyright Ion Gaztanaga 2019-2020. Distributed under the Boost\n// Software License, Version 1.0. (See accompanying file\n// LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n//\n// See http://www.boost.org/libs/container for documentation.\n//\n//////////////////////////////////////////////////////////////////////////////\n\n#ifndef BOOST_CONTAINER_DEVECTOR_HPP\n#define BOOST_CONTAINER_DEVECTOR_HPP\n\n#include <boost/container/detail/config_begin.hpp>\n#include <boost/container/detail/workaround.hpp>\n\n//#include <algorithm>\n#include <cstring> // memcpy\n\n#include <boost/assert.hpp>\n#include <boost/type_traits/aligned_storage.hpp>\n\n#include <boost/container/detail/copy_move_algo.hpp>\n#include <boost/container/new_allocator.hpp> //new_allocator\n#include <boost/container/allocator_traits.hpp> //allocator_traits\n#include <boost/container/detail/algorithm.hpp> //equal()\n#include <boost/container/throw_exception.hpp>\n#include <boost/container/options.hpp>\n\n#include <boost/container/detail/guards_dended.hpp>\n#include <boost/container/detail/iterator.hpp>\n#include <boost/container/detail/iterators.hpp>\n#include <boost/container/detail/destroyers.hpp>\n#include <boost/container/detail/min_max.hpp>\n#include <boost/container/detail/next_capacity.hpp>\n#include <boost/container/detail/alloc_helpers.hpp>\n#include <boost/container/detail/advanced_insert_int.hpp>\n\n// move\n#if defined(BOOST_NO_CXX11_VARIADIC_TEMPLATES)\n#include <boost/move/detail/fwd_macros.hpp>\n#endif\n#include <boost/move/detail/move_helpers.hpp>\n#include <boost/move/adl_move_swap.hpp>\n#include <boost/move/iterator.hpp>\n#include <boost/move/traits.hpp>\n#include <boost/move/utility_core.hpp>\n#include <boost/move/detail/to_raw_pointer.hpp>\n#include <boost/move/algo/detail/merge.hpp>\n#include <boost/move/detail/force_ptr.hpp>\n\n#include <boost/type_traits/is_nothrow_move_constructible.hpp>\n\n//std\n#if !defined(BOOST_NO_CXX11_HDR_INITIALIZER_LIST)\n#include <initializer_list>    //for std::initializer_list\n#endif\n\nnamespace boost {\nnamespace container {\n\n#if !defined(BOOST_CONTAINER_DOXYGEN_INVOKED)\n\nstruct growth_factor_60;\n\ntemplate<class Options, class AllocatorSizeType>\nstruct get_devector_opt\n{\n    typedef devector_opt< typename default_if_void<typename Options::growth_factor_type, growth_factor_60>::type\n                        , typename default_if_void<typename Options::stored_size_type, AllocatorSizeType>::type\n                        , default_if_zero<Options::free_fraction, relocate_on_90::value>::value\n                        > type;\n};\n\ntemplate<class AllocatorSizeType>\nstruct get_devector_opt<void, AllocatorSizeType>\n{\n    typedef devector_opt< growth_factor_60, AllocatorSizeType, relocate_on_90::value> type;\n};\n\n#endif    //#if defined(BOOST_CONTAINER_DOXYGEN_INVOKED)\n\nstruct reserve_only_tag_t {};\nstruct reserve_uninitialized_t {};\nstruct review_implementation_t {};\n\n//struct unsafe_uninitialized_tag_t {};\n\n/**\n * A vector-like sequence container providing front and back operations\n * (e.g: `push_front`/`pop_front`/`push_back`/`pop_back`) with amortized constant complexity.\n *\n * Models the [SequenceContainer], [ReversibleContainer], and [AllocatorAwareContainer] concepts.\n *\n * **Requires**:\n *   - `T` shall be [MoveInsertable] into the devector.\n *   - `T` shall be [Erasable] from any `devector<T, allocator_type, GP>`.\n *   - `GrowthFactor`, and `Allocator` must model the concepts with the same names or be void.\n *\n * **Definition**: `T` is `NothrowConstructible` if it's either nothrow move constructible or\n * nothrow copy constructible.\n *\n * **Definition**: `T` is `NothrowAssignable` if it's either nothrow move assignable or\n * nothrow copy assignable.\n *\n * **Exceptions**: The exception specifications assume `T` is nothrow [Destructible].\n *\n * Most methods providing the strong exception guarantee assume `T` either has a move\n * constructor marked noexcept or is [CopyInsertable] into the devector. If it isn't true,\n * and the move constructor throws, the guarantee is waived and the effects are unspecified.\n *\n * In addition to the exceptions specified in the **Throws** clause, the following operations\n * of `T` can throw when any of the specified concept is required:\n *   - [DefaultInsertable][]: Default constructor\n *   - [MoveInsertable][]: Move constructor\n *   - [CopyInsertable][]: Copy constructor\n *   - [DefaultConstructible][]: Default constructor\n *   - [EmplaceConstructible][]: Constructor selected by the given arguments\n *   - [MoveAssignable][]: Move assignment operator\n *   - [CopyAssignable][]: Copy assignment operator\n *\n * Furthermore, not `noexcept` methods throws whatever the allocator throws\n * if memory allocation fails. Such methods also throw `length_error` if the capacity\n * exceeds `max_size()`.\n *\n * **Remark**: If a method invalidates some iterators, it also invalidates references\n * and pointers to the elements pointed by the invalidated iterators.\n *\n *! \\tparam Options A type produced from \\c boost::container::devector_options.\n *\n * [SequenceContainer]: http://en.cppreference.com/w/cpp/concept/SequenceContainer\n * [ReversibleContainer]: http://en.cppreference.com/w/cpp/concept/ReversibleContainer\n * [AllocatorAwareContainer]: http://en.cppreference.com/w/cpp/concept/AllocatorAwareContainer\n * [DefaultInsertable]: http://en.cppreference.com/w/cpp/concept/DefaultInsertable\n * [MoveInsertable]: http://en.cppreference.com/w/cpp/concept/MoveInsertable\n * [CopyInsertable]: http://en.cppreference.com/w/cpp/concept/CopyInsertable\n * [Erasable]: http://en.cppreference.com/w/cpp/concept/Erasable\n * [DefaultConstructible]: http://en.cppreference.com/w/cpp/concept/DefaultConstructible\n * [Destructible]: http://en.cppreference.com/w/cpp/concept/Destructible\n * [EmplaceConstructible]: http://en.cppreference.com/w/cpp/concept/EmplaceConstructible\n * [MoveAssignable]: http://en.cppreference.com/w/cpp/concept/MoveAssignable\n * [CopyAssignable]: http://en.cppreference.com/w/cpp/concept/CopyAssignable\n */\ntemplate < typename T, class A BOOST_CONTAINER_DOCONLY(= void), class Options BOOST_CONTAINER_DOCONLY(= void)>\nclass devector\n{\n   #ifndef BOOST_CONTAINER_DOXYGEN_INVOKED\n   typedef boost::container::allocator_traits\n      <typename real_allocator<T, A>::type>                                      allocator_traits_type;\n   typedef typename allocator_traits_type::size_type                             alloc_size_type;\n   typedef typename get_devector_opt<Options, alloc_size_type>::type             options_type;\n   typedef typename options_type::growth_factor_type                             growth_factor_type;\n   typedef typename options_type::stored_size_type                               stored_size_type;\n   static const std::size_t devector_min_free_fraction =\n      options_type::free_fraction;\n\n   #endif // ifndef BOOST_CONTAINER_DOXYGEN_INVOKED\n\n   public:\n   // Standard Interface Types:\n   typedef T                                                                     value_type;\n   typedef BOOST_CONTAINER_IMPDEF\n      (typename real_allocator<T BOOST_MOVE_I A>::type)                          allocator_type;\n   typedef allocator_type                                                        stored_allocator_type;\n   typedef typename    allocator_traits<allocator_type>::pointer                 pointer;\n   typedef typename    allocator_traits<allocator_type>::const_pointer           const_pointer;\n   typedef typename    allocator_traits<allocator_type>::reference               reference;\n   typedef typename    allocator_traits<allocator_type>::const_reference         const_reference;\n   typedef typename    allocator_traits<allocator_type>::size_type               size_type;\n   typedef typename    allocator_traits<allocator_type>::difference_type         difference_type;\n   typedef pointer                                                               iterator;\n   typedef const_pointer                                                         const_iterator;\n   typedef BOOST_CONTAINER_IMPDEF\n      (boost::container::reverse_iterator<iterator>)                             reverse_iterator;\n   typedef BOOST_CONTAINER_IMPDEF\n      (boost::container::reverse_iterator<const_iterator>)                       const_reverse_iterator;\n\n   #ifndef BOOST_CONTAINER_DOXYGEN_INVOKED\n   private:\n   BOOST_COPYABLE_AND_MOVABLE(devector)\n\n   // Guard to deallocate buffer on exception\n   typedef typename detail::allocation_guard<allocator_type> allocation_guard;\n\n   // Random access pseudo iterator always yielding to the same result\n   typedef constant_iterator<T> cvalue_iterator;\n\n   static size_type to_internal_capacity(size_type desired_capacity)\n   {\n      const size_type rounder = devector_min_free_fraction - 2u;\n      const size_type divisor = devector_min_free_fraction - 1u;\n      size_type const nc = ((desired_capacity + rounder) / divisor) * devector_min_free_fraction;\n      BOOST_ASSERT(desired_capacity <= (nc - nc / devector_min_free_fraction));\n      return nc;\n   }\n\n   #endif // ifndef BOOST_CONTAINER_DOXYGEN_INVOKED\n\n   // Standard Interface\n   public:\n   // construct/copy/destroy\n\n   /**\n   * **Effects**: Constructs an empty devector.\n   *\n   * **Postcondition**: `empty() && front_free_capacity() == 0\n   * && back_free_capacity() == 0`.\n   *\n   * **Complexity**: Constant.\n   */\n   devector() BOOST_NOEXCEPT\n      : m_()\n   {}\n\n   /**\n   * **Effects**: Constructs an empty devector, using the specified allocator.\n   *\n   * **Postcondition**: `empty() && front_free_capacity() == 0\n   * && back_free_capacity() == 0`.\n   *\n   * **Complexity**: Constant.\n   */\n   explicit devector(const allocator_type& allocator) BOOST_NOEXCEPT\n      : m_(allocator)\n   {}\n\n   /**\n   * **Effects**: Constructs an empty devector, using the specified allocator\n   * and reserves `n` slots as if `reserve(n)` was called.\n   *\n   * **Postcondition**: `empty() && capacity() >= n`.\n   *\n   * **Exceptions**: Strong exception guarantee.\n   *\n   * **Complexity**: Constant.\n   */\n   devector(size_type n, reserve_only_tag_t, const allocator_type& allocator = allocator_type())\n      : m_(reserve_only_tag_t(), allocator, to_internal_capacity(n))\n   {}\n\n   /**\n   * **Effects**: Constructs an empty devector, using the specified allocator\n   * and reserves at least `front_free_cap + back_free_cap` slots as if `reserve_front(front_cap)` and\n   * `reserve_back(back_cap)` was called.\n   *\n   * **Postcondition**: `empty() && front_free_capacity() >= front_free_cap\n   * && back_free_capacity() >= back_free_cap`.\n   *\n   * **Exceptions**: Strong exception guarantee.\n   *\n   * **Complexity**: Constant.\n   */\n   devector(size_type front_free_cap, size_type back_free_cap, reserve_only_tag_t, const allocator_type& allocator = allocator_type())\n      : m_(reserve_only_tag_t(), allocator, front_free_cap, back_free_cap)\n   {}\n\n   /**\n   * [DefaultInsertable]: http://en.cppreference.com/w/cpp/concept/DefaultInsertable\n   *\n   * **Effects**: Constructs a devector with `n` value_initialized elements using the specified allocator.\n   *\n   * **Requires**: `T` shall be [DefaultInsertable] into `*this`.\n   *\n   * **Postcondition**: `size() == n`.\n   *\n   * **Exceptions**: Strong exception guarantee.\n   *\n   * **Complexity**: Linear in `n`.\n   */\n   explicit devector(size_type n, const allocator_type& allocator = allocator_type())\n      : m_(reserve_uninitialized_t(), allocator, n)\n   {\n      allocation_guard buffer_guard(m_.buffer, m_.capacity, get_allocator_ref());\n      boost::container::uninitialized_value_init_alloc_n(get_allocator_ref(), n, this->priv_raw_begin());\n      buffer_guard.release();\n      BOOST_ASSERT(invariants_ok());\n   }\n\n   /**\n   * **Effects**: Constructs a devector with `n` default-initialized elements using the specified allocator.\n   *\n   * **Requires**: `T` shall be [DefaultInsertable] into `*this`.\n   *\n   * **Postcondition**: `size() == n`.\n   *\n   * **Exceptions**: Strong exception guarantee.\n   *\n   * **Complexity**: Linear in `n`.\n   */\n   explicit devector(size_type n, default_init_t, const allocator_type& allocator = allocator_type())\n      : m_(reserve_uninitialized_t(), allocator, n)\n   {\n      allocation_guard buffer_guard(m_.buffer, m_.capacity, get_allocator_ref());\n      boost::container::uninitialized_default_init_alloc_n(get_allocator_ref(), n, this->priv_raw_begin());\n      buffer_guard.release();\n      BOOST_ASSERT(invariants_ok());\n   }\n\n   /**\n   * [CopyInsertable]: http://en.cppreference.com/w/cpp/concept/CopyInsertable\n   *\n   * **Effects**: Constructs a devector with `n` copies of `value`, using the specified allocator.\n   *\n   * **Requires**: `T` shall be [CopyInsertable] into `*this`.\n   *\n   * **Postcondition**: `size() == n`.\n   *\n   * **Exceptions**: Strong exception guarantee.\n   *\n   * **Complexity**: Linear in `n`.\n   */\n   devector(size_type n, const T& value, const allocator_type& allocator = allocator_type())\n      : m_(reserve_uninitialized_t(), allocator, n)\n   {\n      construct_from_range(cvalue_iterator(value, n), cvalue_iterator());\n      BOOST_ASSERT(invariants_ok());\n   }\n\n   /**\n   * **Effects**: Constructs a devector equal to the range `[first,last)`, using the specified allocator.\n   *\n   * **Requires**: `T` shall be [EmplaceConstructible] into `*this` from `*first`. If the specified\n   * iterator does not meet the forward iterator requirements, `T` shall also be [MoveInsertable]\n   * into `*this`.\n   *\n   * **Postcondition**: `size() == boost::container::iterator_distance(first, last)\n   *\n   * **Exceptions**: Strong exception guarantee.\n   *\n   * **Complexity**: Makes only `N` calls to the copy constructor of `T` (where `N` is the distance between `first`\n   * and `last`), at most one allocation and no reallocations if iterators first and last are of forward,\n   * bidirectional, or random access categories. It makes `O(N)` calls to the copy constructor of `T`\n   * and `O(log(N)) reallocations if they are just input iterators.\n   *\n   * **Remarks**: Each iterator in the range `[first,last)` shall be dereferenced exactly once,\n   * unless an exception is thrown.\n   *\n   * [EmplaceConstructible]: http://en.cppreference.com/w/cpp/concept/EmplaceConstructible\n   * [MoveInsertable]: http://en.cppreference.com/w/cpp/concept/MoveInsertable\n   */\n   template <class InputIterator>\n   devector(InputIterator first, InputIterator last, const allocator_type& allocator = allocator_type()\n      //Input iterators\n      BOOST_CONTAINER_DOCIGN(BOOST_MOVE_I typename dtl::disable_if_or\n            < void\n            BOOST_MOVE_I dtl::is_convertible<InputIterator BOOST_MOVE_I size_type>\n            BOOST_MOVE_I dtl::is_not_input_iterator<InputIterator>\n            >::type * = 0)\n      )\n      : m_(allocator)\n   {\n      BOOST_TRY{\n         while (first != last) {\n            this->emplace_back(*first++);\n         }\n         BOOST_ASSERT(invariants_ok());\n      }\n      BOOST_CATCH(...){\n         this->destroy_elements(m_.buffer + m_.front_idx, m_.buffer + m_.back_idx);\n         this->deallocate_buffer();\n      }\n      BOOST_CATCH_END\n   }\n\n   #ifndef BOOST_CONTAINER_DOXYGEN_INVOKED\n\n   template <class ForwardIterator>\n   devector(ForwardIterator first, ForwardIterator last, const allocator_type& allocator = allocator_type()\n      //Other iterators\n      BOOST_CONTAINER_DOCIGN(BOOST_MOVE_I typename dtl::disable_if_or\n            < void\n            BOOST_MOVE_I dtl::is_convertible<ForwardIterator BOOST_MOVE_I size_type>\n            BOOST_MOVE_I dtl::is_input_iterator<ForwardIterator>\n            >::type * = 0)\n      )\n      : m_(reserve_uninitialized_t(), allocator, boost::container::iterator_udistance(first, last))\n   {\n      this->construct_from_range(first, last);\n      BOOST_ASSERT(invariants_ok());\n   }\n\n   #endif // ifndef BOOST_CONTAINER_DOXYGEN_INVOKED\n\n   /**\n   * [CopyInsertable]: http://en.cppreference.com/w/cpp/concept/CopyInsertable\n   *\n   * **Effects**: Copy constructs a devector.\n   *\n   * **Requires**: `T` shall be [CopyInsertable] into `*this`.\n   *\n   * **Postcondition**: `this->size() == x.size()`.\n   *\n   * **Exceptions**: Strong exception guarantee.\n   *\n   * **Complexity**: Linear in the size of `x`.\n   */\n   devector(const devector& x)\n      : m_(reserve_uninitialized_t(), allocator_traits_type::select_on_container_copy_construction(x.get_allocator_ref()), x.size())\n   {\n      this->construct_from_range(x.begin(), x.end());\n      BOOST_ASSERT(invariants_ok());\n   }\n\n   /**\n   * [CopyInsertable]: http://en.cppreference.com/w/cpp/concept/CopyInsertable\n   *\n   * **Effects**: Copy constructs a devector, using the specified allocator.\n   *\n   * **Requires**: `T` shall be [CopyInsertable] into `*this`.\n   *\n   * **Postcondition**: `*this == x`.\n   *\n   * **Exceptions**: Strong exception guarantee.\n   *\n   * **Complexity**: Linear in the size of `x`.\n   */\n   devector(const devector& x, const allocator_type& allocator)\n      : m_(reserve_uninitialized_t(), allocator, x.size())\n   {\n      this->construct_from_range(x.begin(), x.end());\n      BOOST_ASSERT(invariants_ok());\n   }\n\n   /**\n   * **Effects**: Moves `rhs`'s resources to `*this`.\n   *\n   * **Throws**: Nothing.\n   *\n   * **Postcondition**: *this has the same value `rhs` had before the operation.\n   *                    `rhs` is left in an unspecified but valid state.\n   *\n   * **Exceptions**: Strong exception guarantee if not `noexcept`.\n   *\n   * **Complexity**: Constant.\n   */\n   devector(BOOST_RV_REF(devector) rhs) BOOST_NOEXCEPT_OR_NOTHROW\n      : m_(::boost::move(rhs.m_))\n   {\n      BOOST_ASSERT(      invariants_ok());\n      BOOST_ASSERT(rhs.invariants_ok());\n   }\n\n   /**\n   * **Effects**: Moves `rhs`'s resources to `*this`, using the specified allocator.\n   *\n   * **Throws**: If allocation or T's move constructor throws.\n   *\n   * **Postcondition**: *this has the same value `rhs` had before the operation.\n   *                    `rhs` is left in an unspecified but valid state.\n   *\n   * **Exceptions**: Strong exception guarantee if not `noexcept`.\n   *\n   * **Complexity**: Linear if allocator != rhs.get_allocator(), otherwise constant.\n   */\n   devector(BOOST_RV_REF(devector) rhs, const allocator_type& allocator)\n      : m_(review_implementation_t(), allocator, rhs.m_.buffer, rhs.m_.front_idx, rhs.m_.back_idx, rhs.m_.capacity)\n   {\n      // TODO should move elems-by-elems if the two allocators differ\n      // buffer is already acquired, reset rhs\n      rhs.m_.capacity = 0u;\n      rhs.m_.buffer = pointer();\n      rhs.m_.front_idx = 0;\n      rhs.m_.back_idx = 0;\n      BOOST_ASSERT(      invariants_ok());\n      BOOST_ASSERT(rhs.invariants_ok());\n   }\n\n   #if !defined(BOOST_NO_CXX11_HDR_INITIALIZER_LIST)\n   /**\n   * **Equivalent to**: `devector(il.begin(), il.end(), allocator)`.\n   */\n   devector(const std::initializer_list<T>& il, const allocator_type& allocator = allocator_type())\n      : m_(reserve_uninitialized_t(), allocator, il.size())\n   {\n      this->construct_from_range(il.begin(), il.end());\n      BOOST_ASSERT(invariants_ok());\n   }\n   #endif\n\n/**\n   * **Effects**: Destroys the devector. All stored values are destroyed and\n   * used memory, if any, deallocated.\n   *\n   * **Complexity**: Linear in the size of `*this`.\n   */\n~devector() BOOST_NOEXCEPT\n{\n   destroy_elements(m_.buffer + m_.front_idx, m_.buffer + m_.back_idx);\n   deallocate_buffer();\n}\n\n/**\n   * **Effects**: Copies elements of `x` to `*this`. Previously\n   * held elements get copy assigned to or destroyed.\n   *\n   * **Requires**: `T` shall be [CopyInsertable] into `*this`.\n   *\n   * **Postcondition**: `this->size() == x.size()`, the elements of\n   * `*this` are copies of elements in `x` in the same order.\n   *\n   * **Returns**: `*this`.\n   *\n   * **Exceptions**: Strong exception guarantee if `T` is `NothrowConstructible`\n   * and the allocator is allowed to be propagated\n   * ([propagate_on_container_copy_assignment] is true),\n   * Basic exception guarantee otherwise.\n   *\n   * **Complexity**: Linear in the size of `x` and `*this`.\n   *\n   * [CopyInsertable]: http://en.cppreference.com/w/cpp/concept/CopyInsertable\n   * [propagate_on_container_copy_assignment]: http://en.cppreference.com/w/cpp/memory/allocator_traits\n   */\n\n   BOOST_CONTAINER_FORCEINLINE devector& operator=(BOOST_COPY_ASSIGN_REF(devector) rhs)\n   {\n      const devector &x = rhs;\n      if (this == &x) { return *this; } // skip self\n\n      BOOST_IF_CONSTEXPR(allocator_traits_type::propagate_on_container_copy_assignment::value)\n      {\n            allocator_type &this_alloc = this->get_allocator_ref();\n            const allocator_type &other_alloc = x.get_allocator_ref();\n            if (this_alloc != other_alloc)\n            {\n               // new allocator cannot free existing storage\n               this->clear();\n               this->deallocate_buffer();\n               m_.capacity = 0u;\n               m_.buffer = pointer();\n            }\n\n            this_alloc = other_alloc;\n      }\n\n      size_type n = x.size();\n      if (m_.capacity >= n)\n      {\n            this->overwrite_buffer(x.begin(), x.end());\n      }\n      else\n      {\n            this->allocate_and_copy_range(x.begin(), x.end());\n      }\n\n      BOOST_ASSERT(invariants_ok());\n\n      return *this;\n   }\n\n   /**\n   * [MoveInsertable]: http://en.cppreference.com/w/cpp/concept/MoveInsertable\n   *\n   * **Effects**: Moves elements of `x` to `*this`. Previously\n   * held elements get move/copy assigned to or destroyed.\n   *\n   * **Requires**: `T` shall be [MoveInsertable] into `*this`.\n   *\n   * **Postcondition**: `x` is left in an unspecified but valid state.\n   *\n   * **Returns**: `*this`.\n   *\n   * **Exceptions**: Basic exception guarantee if not `noexcept`.\n   *\n   * **Complexity**: Constant if allocator_traits_type::\n   *   propagate_on_container_move_assignment is true or\n   *   this->get>allocator() == x.get_allocator(). Linear otherwise.\n   */\n   devector& operator=(BOOST_RV_REF(devector) x)\n      BOOST_NOEXCEPT_IF(allocator_traits_type::propagate_on_container_move_assignment::value\n                                 || allocator_traits_type::is_always_equal::value)\n   {\n      BOOST_CONSTEXPR_OR_CONST bool copy_alloc = allocator_traits_type::propagate_on_container_move_assignment::value;\n\n      BOOST_IF_CONSTEXPR (copy_alloc || get_allocator_ref() == x.get_allocator_ref())\n      {\n         this->clear();\n         this->deallocate_buffer();\n\n         if (copy_alloc)\n         {\n            this->get_allocator_ref() = boost::move(x.get_allocator_ref());\n         }\n\n         m_.capacity = x.m_.capacity;\n         m_.buffer = x.m_.buffer;\n         m_.front_idx = x.m_.front_idx;\n         m_.back_idx = x.m_.back_idx;\n\n         // leave x in valid state\n         x.m_.capacity = 0u;\n         x.m_.buffer = pointer();\n         x.m_.back_idx = x.m_.front_idx = 0;\n      }\n      else\n      {\n         // if the allocator shouldn't be copied and they do not compare equal\n         // we can't steal memory.\n\n         move_iterator<iterator> xbegin = boost::make_move_iterator(x.begin());\n         move_iterator<iterator> xend = boost::make_move_iterator(x.end());\n\n         if (copy_alloc)\n         {\n            get_allocator_ref() = boost::move(x.get_allocator_ref());\n         }\n\n         if (m_.capacity >= x.size())\n         {\n            overwrite_buffer(xbegin, xend);\n         }\n         else\n         {\n            allocate_and_copy_range(xbegin, xend);\n         }\n      }\n\n      BOOST_ASSERT(invariants_ok());\n\n      return *this;\n   }\n\n   #if !defined(BOOST_NO_CXX11_HDR_INITIALIZER_LIST)\n   /**\n   * **Effects**: Copies elements of `il` to `*this`. Previously\n   * held elements get copy assigned to or destroyed.\n   *\n   * **Requires**: `T` shall be [CopyInsertable] into `*this` and [CopyAssignable].\n   *\n   * **Postcondition**: `this->size() == il.size()`, the elements of\n   * `*this` are copies of elements in `il` in the same order.\n   *\n   * **Exceptions**: Strong exception guarantee if `T` is nothrow copy assignable\n   * from `T` and `NothrowConstructible`, Basic exception guarantee otherwise.\n   *\n   * **Returns**: `*this`.\n   *\n   * **Complexity**: Linear in the size of `il` and `*this`.\n   *\n   * [CopyInsertable]: http://en.cppreference.com/w/cpp/concept/CopyInsertable\n   * [CopyAssignable]: http://en.cppreference.com/w/cpp/concept/CopyAssignable\n   */\n   BOOST_CONTAINER_FORCEINLINE devector& operator=(std::initializer_list<T> il)\n   {\n      this->assign(il.begin(), il.end());\n      return *this;\n   }\n   #endif\n\n   /**\n   * **Effects**: Replaces elements of `*this` with a copy of `[first,last)`.\n   * Previously held elements get copy assigned to or destroyed.\n   *\n   * **Requires**: `T` shall be [EmplaceConstructible] from `*first`. If the specified iterator\n   * does not meet the forward iterator requirements, `T` shall be also [MoveInsertable] into `*this`.\n   *\n   * **Precondition**: `first` and `last` are not iterators into `*this`.\n   *\n   * **Postcondition**: `size() == N`, where `N` is the distance between `first` and `last`.\n   *\n   * **Exceptions**: Strong exception guarantee if `T` is nothrow copy assignable\n   * from `*first` and `NothrowConstructible`, Basic exception guarantee otherwise.\n   *\n   * **Complexity**: Linear in the distance between `first` and `last`.\n   * Makes a single reallocation at most if the iterators `first` and `last`\n   * are of forward, bidirectional, or random access categories. It makes\n   * `O(log(N))` reallocations if they are just input iterators.\n   *\n   * **Remarks**: Each iterator in the range `[first,last)` shall be dereferenced exactly once,\n   * unless an exception is thrown.\n   *\n   * [EmplaceConstructible]: http://en.cppreference.com/w/cpp/concept/EmplaceConstructible\n   * [MoveInsertable]: http://en.cppreference.com/w/cpp/concept/MoveInsertable\n   */\n   template <class InputIterator>\n   void assign(InputIterator first, InputIterator last\n      //Input iterators\n      BOOST_CONTAINER_DOCIGN(BOOST_MOVE_I typename dtl::disable_if_or\n            < void\n            BOOST_MOVE_I dtl::is_convertible<InputIterator BOOST_MOVE_I size_type>\n            BOOST_MOVE_I dtl::is_not_input_iterator<InputIterator>\n            >::type * = 0)\n      )\n   {\n      first = overwrite_buffer_impl(first, last, dtl::false_());\n      while (first != last)\n      {\n         this->emplace_back(*first++);\n      }\n   }\n\n   #ifndef BOOST_CONTAINER_DOXYGEN_INVOKED\n\n   template <class ForwardIterator>\n   void assign(ForwardIterator first, ForwardIterator last\n      //Other iterators\n      BOOST_CONTAINER_DOCIGN(BOOST_MOVE_I typename dtl::disable_if_or\n            < void\n            BOOST_MOVE_I dtl::is_convertible<ForwardIterator BOOST_MOVE_I size_type>\n            BOOST_MOVE_I dtl::is_input_iterator<ForwardIterator>\n            >::type * = 0)\n      )\n   {\n      const size_type n = boost::container::iterator_udistance(first, last);\n\n      if (m_.capacity >= n)\n      {\n         overwrite_buffer(first, last);\n      }\n      else\n      {\n         allocate_and_copy_range(first, last);\n      }\n\n      BOOST_ASSERT(invariants_ok());\n   }\n\n   #endif // ifndef BOOST_CONTAINER_DOXYGEN_INVOKED\n\n   /**\n    * **Effects**: Replaces elements of `*this` with `n` copies of `u`.\n    * Previously held elements get copy assigned to or destroyed.\n    *\n    * **Requires**: `T` shall be [CopyInsertable] into `*this` and\n    * [CopyAssignable].\n    *\n    * **Precondition**: `u` is not a reference into `*this`.\n    *\n    * **Postcondition**: `size() == n` and the elements of\n    * `*this` are copies of `u`.\n    *\n    * **Exceptions**: Strong exception guarantee if `T` is nothrow copy assignable\n    * from `u` and `NothrowConstructible`, Basic exception guarantee otherwise.\n    *\n    * **Complexity**: Linear in `n` and the size of `*this`.\n    *\n    * [CopyInsertable]: http://en.cppreference.com/w/cpp/concept/CopyInsertable\n    * [CopyAssignable]: http://en.cppreference.com/w/cpp/concept/CopyAssignable\n    */\n   BOOST_CONTAINER_FORCEINLINE void assign(size_type n, const T& u)\n   {\n      cvalue_iterator first(u, n);\n      cvalue_iterator last;\n      this->assign(first, last);\n   }\n\n    #if !defined(BOOST_NO_CXX11_HDR_INITIALIZER_LIST)\n    /** **Equivalent to**: `assign(il.begin(), il.end())`. */\n   BOOST_CONTAINER_FORCEINLINE void assign(std::initializer_list<T> il)\n    {\n         this->assign(il.begin(), il.end());\n    }\n    #endif\n\n   /**\n    * **Returns**: A copy of the allocator associated with the container.\n    *\n    * **Complexity**: Constant.\n    */\n   BOOST_CONTAINER_ATTRIBUTE_NODISCARD BOOST_CONTAINER_FORCEINLINE\n    allocator_type get_allocator() const BOOST_NOEXCEPT\n   {\n      return static_cast<const allocator_type&>(m_);\n   }\n\n   BOOST_CONTAINER_ATTRIBUTE_NODISCARD BOOST_CONTAINER_FORCEINLINE\n    const allocator_type &get_stored_allocator() const BOOST_NOEXCEPT\n   {\n      return static_cast<const allocator_type&>(m_);\n   }\n\n   BOOST_CONTAINER_ATTRIBUTE_NODISCARD BOOST_CONTAINER_FORCEINLINE\n         allocator_type &get_stored_allocator() BOOST_NOEXCEPT\n   {\n      return static_cast<allocator_type&>(m_);\n   }\n\n   // iterators\n\n   /**\n    * **Returns**: A iterator pointing to the first element in the devector,\n    * or the past the end iterator if the devector is empty.\n    *\n    * **Complexity**: Constant.\n    */\n   BOOST_CONTAINER_ATTRIBUTE_NODISCARD BOOST_CONTAINER_FORCEINLINE\n         iterator begin() BOOST_NOEXCEPT\n   {\n      return m_.buffer + m_.front_idx;\n   }\n\n   /**\n    * **Returns**: A constant iterator pointing to the first element in the devector,\n    * or the past the end iterator if the devector is empty.\n    *\n    * **Complexity**: Constant.\n    */\n   BOOST_CONTAINER_ATTRIBUTE_NODISCARD BOOST_CONTAINER_FORCEINLINE\n    const_iterator begin() const BOOST_NOEXCEPT\n   {\n      return m_.buffer + m_.front_idx;\n   }\n\n   /**\n    * **Returns**: An iterator pointing past the last element of the container.\n    *\n    * **Complexity**: Constant.\n    */\n   BOOST_CONTAINER_ATTRIBUTE_NODISCARD BOOST_CONTAINER_FORCEINLINE\n         iterator end() BOOST_NOEXCEPT\n   {\n      return m_.buffer + m_.back_idx;\n   }\n\n   /**\n    * **Returns**: A constant iterator pointing past the last element of the container.\n    *\n    * **Complexity**: Constant.\n    */\n   BOOST_CONTAINER_ATTRIBUTE_NODISCARD BOOST_CONTAINER_FORCEINLINE\n    const_iterator end() const BOOST_NOEXCEPT\n   {\n      return m_.buffer + m_.back_idx;\n   }\n\n   /**\n    * **Returns**: A reverse iterator pointing to the first element in the reversed devector,\n    * or the reverse past the end iterator if the devector is empty.\n    *\n    * **Complexity**: Constant.\n    */\n   BOOST_CONTAINER_ATTRIBUTE_NODISCARD BOOST_CONTAINER_FORCEINLINE\n    reverse_iterator rbegin() BOOST_NOEXCEPT\n   {\n      return reverse_iterator(m_.buffer + m_.back_idx);\n   }\n\n   /**\n    * **Returns**: A constant reverse iterator\n    * pointing to the first element in the reversed devector,\n    * or the reverse past the end iterator if the devector is empty.\n    *\n    * **Complexity**: Constant.\n    */\n   BOOST_CONTAINER_ATTRIBUTE_NODISCARD BOOST_CONTAINER_FORCEINLINE\n    const_reverse_iterator rbegin() const BOOST_NOEXCEPT\n   {\n      return const_reverse_iterator(m_.buffer + m_.back_idx);\n   }\n\n   /**\n    * **Returns**: A reverse iterator pointing past the last element in the\n    * reversed container, or to the beginning of the reversed container if it's empty.\n    *\n    * **Complexity**: Constant.\n    */\n   BOOST_CONTAINER_ATTRIBUTE_NODISCARD BOOST_CONTAINER_FORCEINLINE\n    reverse_iterator rend() BOOST_NOEXCEPT\n   {\n      return reverse_iterator(m_.buffer + m_.front_idx);\n   }\n\n   /**\n    * **Returns**: A constant reverse iterator pointing past the last element in the\n    * reversed container, or to the beginning of the reversed container if it's empty.\n    *\n    * **Complexity**: Constant.\n    */\n   BOOST_CONTAINER_ATTRIBUTE_NODISCARD BOOST_CONTAINER_FORCEINLINE\n    const_reverse_iterator rend() const BOOST_NOEXCEPT\n   {\n      return const_reverse_iterator(m_.buffer + m_.front_idx);\n   }\n\n   /**\n    * **Returns**: A constant iterator pointing to the first element in the devector,\n    * or the past the end iterator if the devector is empty.\n    *\n    * **Complexity**: Constant.\n    */\n   BOOST_CONTAINER_ATTRIBUTE_NODISCARD BOOST_CONTAINER_FORCEINLINE\n    const_iterator cbegin() const BOOST_NOEXCEPT\n   {\n      return m_.buffer + m_.front_idx;\n   }\n\n   /**\n    * **Returns**: A constant iterator pointing past the last element of the container.\n    *\n    * **Complexity**: Constant.\n    */\n   const_iterator cend() const BOOST_NOEXCEPT\n   {\n      return m_.buffer + m_.back_idx;\n   }\n\n   /**\n    * **Returns**: A constant reverse iterator\n    * pointing to the first element in the reversed devector,\n    * or the reverse past the end iterator if the devector is empty.\n    *\n    * **Complexity**: Constant.\n    */\n   BOOST_CONTAINER_ATTRIBUTE_NODISCARD BOOST_CONTAINER_FORCEINLINE\n    const_reverse_iterator crbegin() const BOOST_NOEXCEPT\n   {\n      return const_reverse_iterator(m_.buffer + m_.back_idx);\n   }\n\n   /**\n    * **Returns**: A constant reverse iterator pointing past the last element in the\n    * reversed container, or to the beginning of the reversed container if it's empty.\n    *\n    * **Complexity**: Constant.\n    */\n   BOOST_CONTAINER_ATTRIBUTE_NODISCARD BOOST_CONTAINER_FORCEINLINE\n    const_reverse_iterator crend() const BOOST_NOEXCEPT\n   {\n      return const_reverse_iterator(m_.buffer + m_.front_idx);\n   }\n\n   // capacity\n\n   /**\n    * **Returns**: True, if `size() == 0`, false otherwise.\n    *\n    * **Complexity**: Constant.\n    */\n   BOOST_CONTAINER_ATTRIBUTE_NODISCARD BOOST_CONTAINER_FORCEINLINE\n    bool empty() const BOOST_NOEXCEPT\n   {\n      return m_.front_idx == m_.back_idx;\n   }\n\n   /**\n    * **Returns**: The number of elements the devector contains.\n    *\n    * **Complexity**: Constant.\n    */\n   BOOST_CONTAINER_ATTRIBUTE_NODISCARD BOOST_CONTAINER_FORCEINLINE\n    size_type size() const BOOST_NOEXCEPT\n   {\n      return size_type(m_.back_idx - m_.front_idx);\n   }\n\n   /**\n    * **Returns**: The maximum number of elements the devector could possibly hold.\n    *\n    * **Complexity**: Constant.\n    */\n   BOOST_CONTAINER_ATTRIBUTE_NODISCARD BOOST_CONTAINER_FORCEINLINE\n    size_type max_size() const BOOST_NOEXCEPT\n   {\n      size_type alloc_max = allocator_traits_type::max_size(get_allocator_ref());\n      size_type size_type_max = (size_type)-1;\n      return (alloc_max <= size_type_max) ? size_type(alloc_max) : size_type_max;\n   }\n\n   /**\n   * **Returns**: The *minimum* number of elements that can be inserted into devector using\n   *   position-based insertions without requiring a reallocation. Note that, unlike in \n   *   typical sequence containers like `vector`, `capacity()`, `capacity()` can be smaller than `size()`.\n   *   This can happen if a user inserts elements in a particular way (usually inserting at\n   *   front up to front_free_capacity() and at back up to back_free_capacity()).\n   * \n   * **Complexity**: Constant.\n   */\n   BOOST_CONTAINER_ATTRIBUTE_NODISCARD BOOST_CONTAINER_FORCEINLINE\n   size_type capacity() const BOOST_NOEXCEPT\n   {\n      size_type const cap_reserve = m_.capacity/devector_min_free_fraction;\n      return m_.capacity > cap_reserve ? (m_.capacity - cap_reserve) : 0u;\n   }\n\n   /**\n    * **Returns**: The total number of elements that can be pushed to the front of the\n    * devector without requiring reallocation.\n    *\n    * **Complexity**: Constant.\n    */\n   BOOST_CONTAINER_ATTRIBUTE_NODISCARD BOOST_CONTAINER_FORCEINLINE\n   size_type front_free_capacity() const BOOST_NOEXCEPT\n   {\n      return m_.front_idx;\n   }\n\n   /**\n    * **Returns**: The total number of elements that can be pushed to the back of the\n    * devector without requiring reallocation.\n    *\n    * **Complexity**: Constant.\n    */\n   BOOST_CONTAINER_ATTRIBUTE_NODISCARD BOOST_CONTAINER_FORCEINLINE\n    size_type back_free_capacity() const BOOST_NOEXCEPT\n   {\n      return size_type(m_.capacity - m_.back_idx);\n   }\n\n   /**\n   * **Effects**: If `sz` is greater than the size of `*this`,\n   * additional value-initialized elements are inserted. Invalidates iterators\n   * if reallocation is needed. If `sz` is smaller than than the size of `*this`,\n   * elements are erased from the extremes.\n   *\n   * **Requires**: T shall be [MoveInsertable] into *this and [DefaultConstructible].\n   *\n   * **Postcondition**: `sz == size()`.\n   *\n   * **Exceptions**: Strong exception guarantee.\n   *\n   * **Complexity**: Linear in the size of `*this` and `sz`.\n   *\n   * [MoveInsertable]: http://en.cppreference.com/w/cpp/concept/MoveInsertable\n   * [DefaultConstructible]: http://en.cppreference.com/w/cpp/concept/DefaultConstructible\n   */\n   BOOST_CONTAINER_FORCEINLINE void resize(size_type sz)\n   {\n      this->resize_back(sz);\n   }\n\n   /**\n    * **Effects**: Same as resize(sz) but creates default-initialized\n    * value-initialized.\n    */\n   BOOST_CONTAINER_FORCEINLINE void resize(size_type sz, default_init_t)\n   {\n      this->resize_back(sz, default_init);\n   }\n\n   /**\n   * [CopyInsertable]: http://en.cppreference.com/w/cpp/concept/CopyInsertable\n   *\n   * **Effects**: If `sz` is greater than the size of `*this`,\n   * copies of `c` are inserted at extremes.\n   * If `sz` is smaller than than the size of `*this`,\n   * elements are popped from the extremes.\n   *\n   * **Postcondition**: `sz == size()`.\n   *\n   * **Requires**: `T` shall be [CopyInsertable] into `*this`.\n   *\n   * **Exceptions**: Strong exception guarantee.\n   *\n   * **Complexity**: Linear in the size of `*this` and `sz`.\n   */\n   BOOST_CONTAINER_FORCEINLINE void resize(size_type sz, const T& c)\n   {\n      this->resize_back(sz, c);\n   }\n\n   /**\n    * **Effects**: If `sz` is greater than the size of `*this`,\n    * additional value-initialized elements are inserted\n    * to the front. Invalidates iterators if reallocation is needed.\n    * If `sz` is smaller than than the size of `*this`,\n    * elements are popped from the front.\n    *\n    * **Requires**: T shall be [MoveInsertable] into *this and [DefaultConstructible].\n    *\n    * **Postcondition**: `sz == size()`.\n    *\n    * **Exceptions**: Strong exception guarantee.\n    *\n    * **Complexity**: Linear in the size of `*this` and `sz`.\n    *\n    * [MoveInsertable]: http://en.cppreference.com/w/cpp/concept/MoveInsertable\n    * [DefaultConstructible]: http://en.cppreference.com/w/cpp/concept/DefaultConstructible\n    */\n   BOOST_CONTAINER_FORCEINLINE void resize_front(size_type sz)\n   {\n      resize_front_impl(sz);\n      BOOST_ASSERT(invariants_ok());\n   }\n\n   /**\n    * **Effects**: If `sz` is greater than the size of `*this`,\n    * additional value-initialized elements are inserted\n    * to the front. Invalidates iterators if reallocation is needed.\n    * If `sz` is smaller than than the size of `*this`,\n    * elements are popped from the front.\n    *\n    * **Requires**: T shall be [MoveInsertable] into *this and default_initializable.\n    *\n    * **Postcondition**: `sz == size()`.\n    *\n    * **Exceptions**: Strong exception guarantee.\n    *\n    * **Complexity**: Linear in the size of `*this` and `sz`.\n    *\n    * [MoveInsertable]: http://en.cppreference.com/w/cpp/concept/MoveInsertable\n    */\n   BOOST_CONTAINER_FORCEINLINE void resize_front(size_type sz, default_init_t)\n   {\n      resize_front_impl(sz, default_init);\n      BOOST_ASSERT(invariants_ok());\n   }\n\n   /**\n    * [CopyInsertable]: http://en.cppreference.com/w/cpp/concept/CopyInsertable\n    *\n    * **Effects**: If `sz` is greater than the size of `*this`,\n    * copies of `c` are inserted to the front.\n    * Invalidates iterators if reallocation is needed.\n    * If `sz` is smaller than than the size of `*this`,\n    * elements are popped from the front.\n    *\n    * **Postcondition**: `sz == size()`.\n    *\n    * **Requires**: `T` shall be [CopyInsertable] into `*this`.\n    *\n    * **Exceptions**: Strong exception guarantee.\n    *\n    * **Complexity**: Linear in the size of `*this` and `sz`.\n    */\n   BOOST_CONTAINER_FORCEINLINE void resize_front(size_type sz, const T& c)\n   {\n      resize_front_impl(sz, c);\n      BOOST_ASSERT(invariants_ok());\n   }\n\n   /**\n    * **Effects**: If `sz` is greater than the size of `*this`,\n    * additional value-initialized elements are inserted\n    * to the back. Invalidates iterators if reallocation is needed.\n    * If `sz` is smaller than than the size of `*this`,\n    * elements are popped from the back.\n    *\n    * **Requires**: T shall be [MoveInsertable] into *this and [DefaultConstructible].\n    *\n    * **Postcondition**: `sz == size()`.\n    *\n    * **Exceptions**: Strong exception guarantee.\n    *\n    * **Complexity**: Linear in the size of `*this` and `sz`.\n    *\n    * [MoveInsertable]: http://en.cppreference.com/w/cpp/concept/MoveInsertable\n    * [DefaultConstructible]: http://en.cppreference.com/w/cpp/concept/DefaultConstructible\n    */\n   BOOST_CONTAINER_FORCEINLINE void resize_back(size_type sz)\n   {\n      resize_back_impl(sz);\n      BOOST_ASSERT(invariants_ok());\n   }\n\n   /**\n    * **Effects**: If `sz` is greater than the size of `*this`,\n    * additional value-initialized elements are inserted\n    * to the back. Invalidates iterators if reallocation is needed.\n    * If `sz` is smaller than than the size of `*this`,\n    * elements are popped from the back.\n    *\n    * **Requires**: T shall be [MoveInsertable] into *this and default initializable.\n    *\n    * **Postcondition**: `sz == size()`.\n    *\n    * **Exceptions**: Strong exception guarantee.\n    *\n    * **Complexity**: Linear in the size of `*this` and `sz`.\n    *\n    * [MoveInsertable]: http://en.cppreference.com/w/cpp/concept/MoveInsertable\n    */\n   BOOST_CONTAINER_FORCEINLINE void resize_back(size_type sz, default_init_t)\n   {\n      resize_back_impl(sz, default_init);\n      BOOST_ASSERT(invariants_ok());\n   }\n\n   /**\n    * [CopyInsertable]: http://en.cppreference.com/w/cpp/concept/CopyInsertable\n    *\n    * **Effects**: If `sz` is greater than the size of `*this`,\n    * copies of `c` are inserted to the back.\n    * If `sz` is smaller than than the size of `*this`,\n    * elements are popped from the back.\n    *\n    * **Postcondition**: `sz == size()`.\n    *\n    * **Requires**: `T` shall be [CopyInsertable] into `*this`.\n    *\n    * **Exceptions**: Strong exception guarantee.\n    *\n    * **Complexity**: Linear in the size of `*this` and `sz`.\n    */\n   BOOST_CONTAINER_FORCEINLINE void resize_back(size_type sz, const T& c)\n   {\n      resize_back_impl(sz, c);\n      BOOST_ASSERT(invariants_ok());\n   }\n\n   /**\n    * [MoveInsertable]: http://en.cppreference.com/w/cpp/concept/MoveInsertable\n    *\n    * **Effects**: Ensures that at least `n` elements can be inserted\n    * without requiring reallocation, where `n` is `new_capacity - size()`,\n    * if `n` is positive. Otherwise, there are no effects.\n    * Invalidates iterators if reallocation is needed.\n    *\n    * **Requires**: `T` shall be [MoveInsertable] into `*this`.\n    *\n    * **Complexity**: Linear in the size of *this.\n    *\n    * **Exceptions**: Strong exception guarantee.\n    *\n    * **Throws**: length_error if `new_capacity > max_size()`.\n    */\n   BOOST_CONTAINER_FORCEINLINE void reserve(size_type new_capacity)\n   {\n      if (this->capacity() < new_capacity) {\n         const size_type rounder = devector_min_free_fraction - 2u;\n         const size_type divisor = devector_min_free_fraction - 1u;\n         size_type const nc = ((new_capacity + rounder)/divisor)*devector_min_free_fraction;\n         BOOST_ASSERT(new_capacity <= (nc - nc / devector_min_free_fraction));\n         size_type const sz = this->size();\n         reallocate_at(nc, (nc-sz)/2u);\n      }\n      BOOST_ASSERT(invariants_ok());\n   }\n\n   /**\n    * [MoveInsertable]: http://en.cppreference.com/w/cpp/concept/MoveInsertable\n    *\n    * **Effects**: Ensures that `n` elements can be pushed to the front\n    * without requiring reallocation, where `n` is `new_capacity - size()`,\n    * if `n` is positive. Otherwise, there are no effects.\n    * Invalidates iterators if reallocation is needed.\n    *\n    * **Requires**: `T` shall be [MoveInsertable] into `*this`.\n    *\n    * **Complexity**: Linear in the size of *this.\n    *\n    * **Exceptions**: Strong exception guarantee.\n    *\n    * **Throws**: `length_error` if `new_capacity > max_size()`.\n    */\n   BOOST_CONTAINER_FORCEINLINE void reserve_front(size_type new_capacity)\n   {\n      if (front_capacity() >= new_capacity) { return; }\n\n      reallocate_at(new_capacity + back_free_capacity(), new_capacity - size());\n\n      BOOST_ASSERT(invariants_ok());\n   }\n\n   /**\n    * [MoveInsertable]: http://en.cppreference.com/w/cpp/concept/MoveInsertable\n    *\n    * **Effects**: Ensures that `n` elements can be pushed to the back\n    * without requiring reallocation, where `n` is `new_capacity - size()`,\n    * if `n` is positive. Otherwise, there are no effects.\n    * Invalidates iterators if reallocation is needed.\n    *\n    * **Requires**: `T` shall be [MoveInsertable] into `*this`.\n    *\n    * **Complexity**: Linear in the size of *this.\n    *\n    * **Exceptions**: Strong exception guarantee.\n    *\n    * **Throws**: length_error if `new_capacity > max_size()`.\n    */\n   BOOST_CONTAINER_FORCEINLINE void reserve_back(size_type new_capacity)\n   {\n      if (back_capacity() >= new_capacity) { return; }\n\n      reallocate_at(new_capacity + front_free_capacity(), m_.front_idx);\n\n      BOOST_ASSERT(invariants_ok());\n   }\n\n\n   /**\n    * [MoveInsertable]: http://en.cppreference.com/w/cpp/concept/MoveInsertable\n    *\n    * **Effects**: Reduces `capacity()` to `size()`. Invalidates iterators.\n    *\n    * **Requires**: `T` shall be [MoveInsertable] into `*this`.\n    *\n    * **Exceptions**: Strong exception guarantee.\n    *\n    * **Complexity**: Linear in the size of *this.\n    */\n   BOOST_CONTAINER_FORCEINLINE void shrink_to_fit()\n   {\n      if(this->front_capacity() || this->back_capacity())\n            this->reallocate_at(size(), 0);\n   }\n\n   // element access:\n\n   /**\n    * **Returns**: A reference to the `n`th element in the devector.\n    *\n    * **Precondition**: `n < size()`.\n    *\n    * **Complexity**: Constant.\n    */\n   BOOST_CONTAINER_ATTRIBUTE_NODISCARD BOOST_CONTAINER_FORCEINLINE\n   reference operator[](size_type n) BOOST_NOEXCEPT\n   {\n      BOOST_ASSERT(n < size());\n      return m_.buffer[m_.front_idx + n];\n   }\n\n   /**\n    * **Returns**: A constant reference to the `n`th element in the devector.\n    *\n    * **Precondition**: `n < size()`.\n    *\n    * **Complexity**: Constant.\n    */\n   BOOST_CONTAINER_ATTRIBUTE_NODISCARD BOOST_CONTAINER_FORCEINLINE\n   const_reference operator[](size_type n) const BOOST_NOEXCEPT\n   {\n      BOOST_ASSERT(n < size());\n      return m_.buffer[m_.front_idx + n];\n   }\n\n   /**\n   * **Returns**: A reference to the `n`th element in the devector.\n   *\n   * **Throws**: `out_of_range`, if `n >= size()`.\n   *\n   * **Complexity**: Constant.\n   */\n   BOOST_CONTAINER_ATTRIBUTE_NODISCARD BOOST_CONTAINER_FORCEINLINE\n      reference at(size_type n)\n   {\n      if (size() <= n)\n            throw_out_of_range(\"devector::at out of range\");\n      return (*this)[n];\n   }\n\n   /**\n   * **Returns**: A constant reference to the `n`th element in the devector.\n   *\n   * **Throws**: `out_of_range`, if `n >= size()`.\n   *\n   * **Complexity**: Constant.\n   */\n   BOOST_CONTAINER_ATTRIBUTE_NODISCARD BOOST_CONTAINER_FORCEINLINE\n      const_reference at(size_type n) const\n   {\n      if (size() <= n)\n            throw_out_of_range(\"devector::at out of range\");\n      return (*this)[n];\n   }\n\n   /**\n   * **Returns**: A reference to the first element in the devector.\n   *\n   * **Precondition**: `!empty()`.\n   *\n   * **Complexity**: Constant.\n   */\n   BOOST_CONTAINER_ATTRIBUTE_NODISCARD BOOST_CONTAINER_FORCEINLINE\n      reference front() BOOST_NOEXCEPT\n   {\n      BOOST_ASSERT(!empty());\n\n      return m_.buffer[m_.front_idx];\n   }\n\n   /**\n   * **Returns**: A constant reference to the first element in the devector.\n   *\n   * **Precondition**: `!empty()`.\n   *\n   * **Complexity**: Constant.\n   */\n   BOOST_CONTAINER_ATTRIBUTE_NODISCARD BOOST_CONTAINER_FORCEINLINE\n      const_reference front() const BOOST_NOEXCEPT\n   {\n      BOOST_ASSERT(!empty());\n\n      return m_.buffer[m_.front_idx];\n   }\n\n   /**\n   * **Returns**: A reference to the last element in the devector.\n   *\n   * **Precondition**: `!empty()`.\n   *\n   * **Complexity**: Constant.\n   */\n   BOOST_CONTAINER_ATTRIBUTE_NODISCARD BOOST_CONTAINER_FORCEINLINE\n      reference back() BOOST_NOEXCEPT\n   {\n      BOOST_ASSERT(!empty());\n\n      return m_.buffer[m_.back_idx - 1u];\n   }\n\n   /**\n   * **Returns**: A constant reference to the last element in the devector.\n   *\n   * **Precondition**: `!empty()`.\n   *\n   * **Complexity**: Constant.\n   */\n   BOOST_CONTAINER_ATTRIBUTE_NODISCARD BOOST_CONTAINER_FORCEINLINE\n      const_reference back() const BOOST_NOEXCEPT\n   {\n      BOOST_ASSERT(!empty());\n\n      return m_.buffer[m_.back_idx - 1u];\n   }\n\n   /**\n   * **Returns**: A pointer to the underlying array serving as element storage.\n   * The range `[data(); data() + size())` is always valid. For a non-empty devector,\n   * `data() == &front()`.\n   *\n   * **Complexity**: Constant.\n   */\n   BOOST_CONTAINER_ATTRIBUTE_NODISCARD BOOST_CONTAINER_FORCEINLINE\n      T* data() BOOST_NOEXCEPT\n   {\n      return boost::movelib::to_raw_pointer(m_.buffer) + m_.front_idx;\n   }\n\n   /**\n   * **Returns**: A constant pointer to the underlying array serving as element storage.\n   * The range `[data(); data() + size())` is always valid. For a non-empty devector,\n   * `data() == &front()`.\n   *\n   * **Complexity**: Constant.\n   */\n   BOOST_CONTAINER_ATTRIBUTE_NODISCARD BOOST_CONTAINER_FORCEINLINE\n      const T* data() const BOOST_NOEXCEPT\n   {\n      return boost::movelib::to_raw_pointer(m_.buffer) + m_.front_idx;\n   }\n\n   // modifiers:\n\n   /**\n   * **Effects**: Pushes a new element to the front of the devector.\n   * The element is constructed in-place, using the perfect forwarded `args`\n   * as constructor arguments. Invalidates iterators if reallocation is needed.\n   * (`front_free_capacity() == 0`)\n   *\n   * **Requires**: `T` shall be [EmplaceConstructible] from `args` and [MoveInsertable] into `*this`.\n   *\n   * **Exceptions**: Strong exception guarantee.\n   *\n   * **Complexity**: Amortized constant in the size of `*this`.\n   * (Constant, if `front_free_capacity() > 0`)\n   *\n   * [EmplaceConstructible]: http://en.cppreference.com/w/cpp/concept/EmplaceConstructible\n   * [MoveInsertable]: http://en.cppreference.com/w/cpp/concept/MoveInsertable\n   */\n   #if !defined(BOOST_NO_CXX11_VARIADIC_TEMPLATES) || defined(BOOST_CONTAINER_DOXYGEN_INVOKED)\n   template <class... Args>\n   reference emplace_front(Args&&... args)\n   {\n      if (BOOST_LIKELY(front_free_capacity() != 0)) // fast path\n      {\n         pointer const p = m_.buffer + (m_.front_idx - 1u);\n         this->alloc_construct(p, boost::forward<Args>(args)...);\n         --m_.front_idx;\n         BOOST_ASSERT(invariants_ok());\n         return *p;\n      }\n      else\n      {\n         typedef dtl::insert_emplace_proxy<allocator_type, Args...> proxy_t;\n         return *this->insert_range_slow_path(this->begin(), 1, proxy_t(::boost::forward<Args>(args)...));\n      }\n   }\n\n   #else //!defined(BOOST_NO_CXX11_VARIADIC_TEMPLATES) || defined(BOOST_CONTAINER_DOXYGEN_INVOKED)\n\n   #define BOOST_CONTAINER_DEVECTOR_EMPLACE_FRONT(N) \\\n   BOOST_MOVE_TMPL_LT##N BOOST_MOVE_CLASS##N BOOST_MOVE_GT##N \\\n   BOOST_CONTAINER_FORCEINLINE reference emplace_front(BOOST_MOVE_UREF##N)\\\n   {\\\n      if (front_free_capacity())\\\n      {\\\n         pointer const p = m_.buffer + (m_.front_idx - 1u);\\\n         this->alloc_construct(p BOOST_MOVE_I##N BOOST_MOVE_FWD##N);\\\n         --m_.front_idx;\\\n         return *p;\\\n      }\\\n      else\\\n      {\\\n         typedef dtl::insert_emplace_proxy_arg##N<allocator_type BOOST_MOVE_I##N BOOST_MOVE_TARG##N> proxy_t;\\\n         return *this->insert_range_slow_path(this->begin(), 1, proxy_t(BOOST_MOVE_FWD##N));\\\n      }\\\n   }\\\n   //\n   BOOST_MOVE_ITERATE_0TO9(BOOST_CONTAINER_DEVECTOR_EMPLACE_FRONT)\n   #undef BOOST_CONTAINER_DEVECTOR_EMPLACE_FRONT\n\n   #endif\n\n   #if defined(BOOST_CONTAINER_DOXYGEN_INVOKED)\n   /**\n   * [CopyInsertable]: http://en.cppreference.com/w/cpp/concept/CopyInsertable\n   *\n   * **Effects**: Pushes the copy of `x` to the front of the devector.\n   * Invalidates iterators if reallocation is needed.\n   * (`front_free_capacity() == 0`)\n   *\n   * **Requires**: `T` shall be [CopyInsertable] into `*this`.\n   *\n   * **Exceptions**: Strong exception guarantee.\n   *\n   * **Complexity**: Amortized constant in the size of `*this`.\n   * (Constant, if `front_free_capacity() > 0`)\n   */\n   void push_front(const T& x);\n\n   /**\n   * [MoveInsertable]: http://en.cppreference.com/w/cpp/concept/MoveInsertable\n   *\n   * **Effects**: Move constructs a new element at the front of the devector using `x`.\n   * Invalidates iterators if reallocation is needed.\n   * (`front_free_capacity() == 0`)\n   *\n   * **Requires**: `T` shall be [MoveInsertable] into `*this`.\n   *\n   * **Exceptions**: Strong exception guarantee, not regarding the state of `x`.\n   *\n   * **Complexity**: Amortized constant in the size of `*this`.\n   * (Constant, if `front_free_capacity() > 0`)\n   */\n   void push_front(T&& x);\n\n   #else\n   BOOST_MOVE_CONVERSION_AWARE_CATCH(push_front, T, void, priv_push_front)\n   #endif\n\n   /**\n   * **Effects**: Removes the first element of `*this`.\n   *\n   * **Precondition**: `!empty()`.\n   *\n   * **Postcondition**: `front_free_capacity()` is incremented by 1.\n   *\n   * **Complexity**: Constant.\n   */\n   void pop_front() BOOST_NOEXCEPT\n   {\n      BOOST_ASSERT(!empty());\n      allocator_traits_type::destroy(get_allocator_ref(), boost::movelib::to_raw_pointer(m_.buffer + m_.front_idx));\n      ++m_.front_idx;\n      BOOST_ASSERT(invariants_ok());\n   }\n\n   /**\n   * **Effects**: Pushes a new element to the back of the devector.\n   * The element is constructed in-place, using the perfect forwarded `args`\n   * as constructor arguments. Invalidates iterators if reallocation is needed.\n   * (`back_free_capacity() == 0`)\n   *\n   * **Requires**: `T` shall be [EmplaceConstructible] from `args` and [MoveInsertable] into `*this`,\n   * and [MoveAssignable].\n   *\n   * **Exceptions**: Strong exception guarantee.\n   *\n   * **Complexity**: Amortized constant in the size of `*this`.\n   * (Constant, if `back_free_capacity() > 0`)\n   *\n   * [EmplaceConstructible]: http://en.cppreference.com/w/cpp/concept/EmplaceConstructible\n   * [MoveInsertable]: http://en.cppreference.com/w/cpp/concept/MoveInsertable\n   * [MoveAssignable]: http://en.cppreference.com/w/cpp/concept/MoveAssignable\n   */\n   #if !defined(BOOST_NO_CXX11_VARIADIC_TEMPLATES) || defined(BOOST_CONTAINER_DOXYGEN_INVOKED)\n   template <class... Args>\n   BOOST_CONTAINER_FORCEINLINE reference emplace_back(Args&&... args)\n   {\n      if (BOOST_LIKELY(this->back_free_capacity() != 0)){\n         pointer const p = m_.buffer + m_.back_idx;\n         this->alloc_construct(p, boost::forward<Args>(args)...);\n         ++m_.back_idx;\n         BOOST_ASSERT(invariants_ok());\n         return *p;\n      }\n      else {\n         typedef dtl::insert_emplace_proxy<allocator_type, Args...> proxy_t;\n         return *this->insert_range_slow_path(this->end(), 1, proxy_t(::boost::forward<Args>(args)...));\n      }\n   }\n\n   #else //!defined(BOOST_NO_CXX11_VARIADIC_TEMPLATES) || defined(BOOST_CONTAINER_DOXYGEN_INVOKED)\n\n   #define BOOST_CONTAINER_DEVECTOR_EMPLACE_BACK(N) \\\n   BOOST_MOVE_TMPL_LT##N BOOST_MOVE_CLASS##N BOOST_MOVE_GT##N \\\n   BOOST_CONTAINER_FORCEINLINE reference emplace_back(BOOST_MOVE_UREF##N)\\\n   {\\\n      if (this->back_free_capacity()){\\\n         pointer const p = m_.buffer + m_.back_idx;\\\n         this->alloc_construct(p BOOST_MOVE_I##N BOOST_MOVE_FWD##N);\\\n         ++m_.back_idx;\\\n         return *p;\\\n      }\\\n      else {\\\n         typedef dtl::insert_emplace_proxy_arg##N<allocator_type BOOST_MOVE_I##N BOOST_MOVE_TARG##N> proxy_t;\\\n         return *this->insert_range_slow_path(this->end(), 1, proxy_t(BOOST_MOVE_FWD##N));\\\n      }\\\n   }\\\n   //\n   BOOST_MOVE_ITERATE_0TO9(BOOST_CONTAINER_DEVECTOR_EMPLACE_BACK)\n   #undef BOOST_CONTAINER_DEVECTOR_EMPLACE_BACK\n\n   #endif    //!defined(BOOST_NO_CXX11_VARIADIC_TEMPLATES) || defined(BOOST_CONTAINER_DOXYGEN_INVOKED)\n\n\n   #if defined(BOOST_CONTAINER_DOXYGEN_INVOKED)\n   /**\n   * [CopyInsertable]: http://en.cppreference.com/w/cpp/concept/CopyInsertable\n   *\n   * **Effects**: Pushes the copy of `x` to the back of the devector.\n   * Invalidates iterators if reallocation is needed.\n   * (`back_free_capacity() == 0`)\n   *\n   * **Requires**: `T` shall be [CopyInsertable] into `*this`.\n   *\n   * **Exceptions**: Strong exception guarantee.\n   *\n   * **Complexity**: Amortized constant in the size of `*this`.\n   * (Constant, if `back_free_capacity() > 0`)\n   */\n   void push_back(const T& x);\n\n   /**\n   * [MoveInsertable]: http://en.cppreference.com/w/cpp/concept/MoveInsertable\n   *\n   * **Effects**: Move constructs a new element at the back of the devector using `x`.\n   * Invalidates iterators if reallocation is needed.\n   * (`back_free_capacity() == 0`)\n   *\n   * **Requires**: `T` shall be [MoveInsertable] into `*this`.\n   *\n   * **Exceptions**: Strong exception guarantee, not regarding the state of `x`.\n   *\n   * **Complexity**: Amortized constant in the size of `*this`.\n   * (Constant, if `back_free_capacity() > 0`)\n   */\n   void push_back(T&& x);\n\n   #else\n   BOOST_MOVE_CONVERSION_AWARE_CATCH(push_back, T, void, priv_push_back)\n   #endif\n\n   /**\n   * **Effects**: Removes the last element of `*this`.\n   *\n   * **Precondition**: `!empty()`.\n   *\n   * **Postcondition**: `back_free_capacity()` is incremented by 1.\n   *\n   * **Complexity**: Constant.\n   */\n   void pop_back() BOOST_NOEXCEPT\n   {\n      BOOST_ASSERT(! empty());\n      --m_.back_idx;\n      allocator_traits_type::destroy(get_allocator_ref(), boost::movelib::to_raw_pointer(m_.buffer + m_.back_idx));\n      BOOST_ASSERT(invariants_ok());\n   }\n\n   /**\n   * **Effects**: Constructs a new element before the element pointed by `position`.\n   * The element is constructed in-place, using the perfect forwarded `args`\n   * as constructor arguments. Invalidates iterators if reallocation is needed.\n   *\n   * **Requires**: `T` shall be [EmplaceConstructible], and [MoveInsertable] into `*this`,\n   * and [MoveAssignable].\n   *\n   * **Returns**: Iterator pointing to the newly constructed element.\n   *\n   * **Exceptions**: Strong exception guarantee if `T` is `NothrowConstructible`\n   * and `NothrowAssignable`, Basic exception guarantee otherwise.\n   *\n   * **Complexity**: Linear in the size of `*this`.\n   *\n   * [EmplaceConstructible]: http://en.cppreference.com/w/cpp/concept/EmplaceConstructible\n   * [MoveInsertable]: http://en.cppreference.com/w/cpp/concept/MoveInsertable\n   * [MoveAssignable]: http://en.cppreference.com/w/cpp/concept/MoveAssignable\n   */\n   #if !defined(BOOST_NO_CXX11_VARIADIC_TEMPLATES) || defined(BOOST_CONTAINER_DOXYGEN_INVOKED)\n   template <class... Args>\n   iterator emplace(const_iterator position, Args&&... args)\n   {\n      BOOST_ASSERT(position >= begin());\n      BOOST_ASSERT(position <= end());\n      typedef dtl::insert_emplace_proxy<allocator_type, Args...> proxy_t;\n      bool prefer_move_back;\n      if (position == end()){\n         if(back_free_capacity()) // fast path\n         {\n            pointer const p = m_.buffer + m_.back_idx;\n            this->alloc_construct(p, boost::forward<Args>(args)...);\n            ++m_.back_idx;\n            return iterator(p);\n         }\n         prefer_move_back = true;\n      }\n      else if (position == begin()){\n         if(front_free_capacity()) // secondary fast path\n         {\n            pointer const p = m_.buffer + (m_.front_idx - 1);\n            this->alloc_construct(p, boost::forward<Args>(args)...);\n            --m_.front_idx;\n            return iterator(p);\n         }\n         prefer_move_back = false;\n      }\n      else{\n         iterator nonconst_pos = unconst_iterator(position);\n         prefer_move_back = should_move_back(position);\n\n         if(prefer_move_back){\n            if(back_free_capacity()){\n               boost::container::expand_forward_and_insert_nonempty_middle_alloc\n                  ( get_allocator_ref()\n                  , boost::movelib::to_raw_pointer(nonconst_pos)\n                  , this->priv_raw_end()\n                  , 1, proxy_t(::boost::forward<Args>(args)...));\n               ++m_.back_idx;\n               return nonconst_pos;\n            }\n         }\n         else{\n            if (front_free_capacity()){\n               boost::container::expand_backward_and_insert_nonempty_middle_alloc\n               (get_allocator_ref()\n                  , this->priv_raw_begin()\n                  , boost::movelib::to_raw_pointer(nonconst_pos)\n                  , 1, proxy_t(::boost::forward<Args>(args)...));\n               --m_.front_idx;\n               return --nonconst_pos;\n            }\n         }\n      }\n      return this->insert_range_slow_path(position, 1, proxy_t(::boost::forward<Args>(args)...));\n   }\n\n   #else //!defined(BOOST_NO_CXX11_VARIADIC_TEMPLATES) || defined(BOOST_CONTAINER_DOXYGEN_INVOKED)\n\n   #define BOOST_CONTAINER_DEVECTOR_EMPLACE(N) \\\n   BOOST_MOVE_TMPL_LT##N BOOST_MOVE_CLASS##N BOOST_MOVE_GT##N \\\n   iterator emplace(const_iterator position BOOST_MOVE_I##N BOOST_MOVE_UREF##N)\\\n   {\\\n      BOOST_ASSERT(position >= begin());\\\n      BOOST_ASSERT(position <= end());\\\n      typedef dtl::insert_emplace_proxy_arg##N<allocator_type  BOOST_MOVE_I##N BOOST_MOVE_TARG##N> proxy_t;\\\n      bool prefer_move_back;\\\n      if (position == end()){\\\n         if(back_free_capacity())\\\n         {\\\n            pointer const p = m_.buffer + m_.back_idx;\\\n            this->alloc_construct(p BOOST_MOVE_I##N BOOST_MOVE_FWD##N);\\\n            ++m_.back_idx;\\\n            return iterator(p);\\\n         }\\\n         prefer_move_back = true;\\\n      }\\\n      else if (position == begin()){\\\n         if(front_free_capacity())\\\n         {\\\n            pointer const p = m_.buffer + (m_.front_idx - 1);\\\n            this->alloc_construct(p BOOST_MOVE_I##N BOOST_MOVE_FWD##N);\\\n            --m_.front_idx;\\\n            return iterator(p);\\\n         }\\\n         prefer_move_back = false;\\\n      }\\\n      else{\\\n         iterator nonconst_pos = unconst_iterator(position);\\\n         prefer_move_back = should_move_back(position);\\\n         \\\n         if(prefer_move_back){\\\n            if(back_free_capacity()){\\\n               boost::container::expand_forward_and_insert_nonempty_middle_alloc\\\n                  ( get_allocator_ref()\\\n                  , boost::movelib::to_raw_pointer(nonconst_pos)\\\n                  , this->priv_raw_end()\\\n                  , 1, proxy_t(BOOST_MOVE_FWD##N));\\\n               ++m_.back_idx;\\\n               return nonconst_pos;\\\n            }\\\n         }\\\n         else{\\\n            if (front_free_capacity()){\\\n               boost::container::expand_backward_and_insert_nonempty_middle_alloc\\\n               (get_allocator_ref()\\\n                  , this->priv_raw_begin()\\\n                  , boost::movelib::to_raw_pointer(nonconst_pos)\\\n                  , 1, proxy_t(BOOST_MOVE_FWD##N));\\\n               --m_.front_idx;\\\n               return --nonconst_pos;\\\n            }\\\n         }\\\n      }\\\n      return this->insert_range_slow_path(position, 1, proxy_t(BOOST_MOVE_FWD##N));\\\n   }\\\n   //\n   BOOST_MOVE_ITERATE_0TO9(BOOST_CONTAINER_DEVECTOR_EMPLACE)\n   #undef BOOST_CONTAINER_DEVECTOR_EMPLACE\n\n   #endif    //!defined(BOOST_NO_CXX11_VARIADIC_TEMPLATES) || defined(BOOST_CONTAINER_DOXYGEN_INVOKED)\n\n\n   #if defined(BOOST_CONTAINER_DOXYGEN_INVOKED)\n   /**\n   * **Effects**: Copy constructs a new element before the element pointed by `position`,\n   * using `x` as constructor argument. Invalidates iterators if reallocation is needed.\n   *\n   * **Requires**: `T` shall be [CopyInsertable] into `*this` and and [CopyAssignable].\n   *\n   * **Returns**: Iterator pointing to the newly constructed element.\n   *\n   * **Exceptions**: Strong exception guarantee if `T` is `NothrowConstructible`\n   * and `NothrowAssignable`, Basic exception guarantee otherwise.\n   *\n   * **Complexity**: Linear in the size of `*this`.\n   *\n   * [CopyInsertable]: http://en.cppreference.com/w/cpp/concept/CopyInsertable\n   * [CopyAssignable]: http://en.cppreference.com/w/cpp/concept/CopyAssignable\n   */\n   iterator insert(const_iterator position, const T &x);\n\n   /**\n   * **Effects**: Move constructs a new element before the element pointed by `position`,\n   * using `x` as constructor argument. Invalidates iterators if reallocation is needed.\n   *\n   * **Requires**: `T` shall be [MoveInsertable] into `*this` and and [CopyAssignable].\n   *\n   * **Returns**: Iterator pointing to the newly constructed element.\n   *\n   * **Exceptions**: Strong exception guarantee if `T` is `NothrowConstructible`\n   * and `NothrowAssignable` (not regarding the state of `x`),\n   * Basic exception guarantee otherwise.\n   *\n   * **Complexity**: Linear in the size of `*this`.\n   *\n   * [MoveInsertable]: http://en.cppreference.com/w/cpp/concept/MoveInsertable\n   * [CopyAssignable]: http://en.cppreference.com/w/cpp/concept/CopyAssignable\n   */\n   iterator insert(const_iterator position, T &&x);\n   #else\n   BOOST_MOVE_CONVERSION_AWARE_CATCH_1ARG(insert, T, iterator, priv_insert, const_iterator, const_iterator)\n   #endif\n\n   /**\n   * **Effects**: Copy constructs `n` elements before the element pointed by `position`,\n   * using `x` as constructor argument. Invalidates iterators if reallocation is needed.\n   *\n   * **Requires**: `T` shall be [CopyInsertable] into `*this` and and [CopyAssignable].\n   *\n   * **Returns**: Iterator pointing to the first inserted element, or `position`, if `n` is zero.\n   *\n   * **Exceptions**: Strong exception guarantee if `T` is `NothrowConstructible`\n   * and `NothrowAssignable`, Basic exception guarantee otherwise.\n   *\n   * **Complexity**: Linear in the size of `*this` and `n`.\n   *\n   * [CopyInsertable]: http://en.cppreference.com/w/cpp/concept/CopyInsertable\n   * [CopyAssignable]: http://en.cppreference.com/w/cpp/concept/CopyAssignable\n   */\n   BOOST_CONTAINER_FORCEINLINE iterator insert(const_iterator position, size_type n, const T& x)\n   {\n      cvalue_iterator first(x, n);\n      cvalue_iterator last = first + n;\n      return this->insert_range(position, first, last);\n   }\n\n   /**\n   * **Effects**: Copy constructs elements before the element pointed by position\n   * using each element in the range pointed by `first` and `last` as constructor arguments.\n   * Invalidates iterators if reallocation is needed.\n   *\n   * **Requires**: `T` shall be [EmplaceConstructible] into `*this` from `*first`. If the specified iterator\n   * does not meet the forward iterator requirements, `T` shall also be [MoveInsertable] into `*this`\n   * and [MoveAssignable].\n   *\n   * **Precondition**: `first` and `last` are not iterators into `*this`.\n   *\n   * **Returns**: Iterator pointing to the first inserted element, or `position`, if `first == last`.\n   *\n   * **Complexity**: Linear in the size of `*this` and `N` (where `N` is the distance between `first` and `last`).\n   * Makes only `N` calls to the constructor of `T` and no reallocations if iterators `first` and `last`\n   * are of forward, bidirectional, or random access categories. It makes 2N calls to the copy constructor of `T`\n   * and `O(log(N)) reallocations if they are just input iterators.\n   *\n   * **Exceptions**: Strong exception guarantee if `T` is `NothrowConstructible`\n   * and `NothrowAssignable`, Basic exception guarantee otherwise.\n   *\n   * **Remarks**: Each iterator in the range `[first,last)` shall be dereferenced exactly once,\n   * unless an exception is thrown.\n   *\n   * [EmplaceConstructible]: http://en.cppreference.com/w/cpp/concept/EmplaceConstructible\n   * [MoveInsertable]: http://en.cppreference.com/w/cpp/concept/MoveInsertable\n   * [MoveAssignable]: http://en.cppreference.com/w/cpp/concept/MoveAssignable\n   */\n   template <class InputIterator>\n   iterator insert(const_iterator position, InputIterator first, InputIterator last\n      //Input iterators\n      BOOST_CONTAINER_DOCIGN(BOOST_MOVE_I typename dtl::disable_if_or\n            < void\n            BOOST_MOVE_I dtl::is_convertible<InputIterator BOOST_MOVE_I size_type>\n            BOOST_MOVE_I dtl::is_not_input_iterator<InputIterator>\n            >::type * = 0)\n      )\n   {\n      if (position == end())\n      {\n         size_type insert_index = size();\n\n         for (; first != last; ++first)\n         {\n            this->emplace_back(*first);\n         }\n\n         return begin() + insert_index;\n      }\n      else\n      {\n         const size_type insert_index = static_cast<size_type>(position - this->cbegin());\n         const size_type old_size = static_cast<size_type>(this->size());\n\n         for (; first != last; ++first) {\n            this->emplace_back(*first);\n         }\n         iterator rit (this->begin() + insert_index);\n         boost::movelib::rotate_gcd(rit, this->begin() + old_size, this->begin() + this->size());\n         return rit;\n      }\n   }\n\n   #ifndef BOOST_CONTAINER_DOXYGEN_INVOKED\n\n   template <class ForwardIterator>\n   BOOST_CONTAINER_FORCEINLINE iterator insert(const_iterator position, ForwardIterator first, ForwardIterator last\n      //Other iterators\n      BOOST_CONTAINER_DOCIGN(BOOST_MOVE_I typename dtl::disable_if_or\n            < void\n            BOOST_MOVE_I dtl::is_convertible<ForwardIterator BOOST_MOVE_I size_type>\n            BOOST_MOVE_I dtl::is_input_iterator<ForwardIterator>\n            >::type * = 0)\n      )\n   {\n      return insert_range(position, first, last);\n   }\n\n   #endif // ifndef BOOST_CONTAINER_DOXYGEN_INVOKED\n\n   #if !defined(BOOST_NO_CXX11_HDR_INITIALIZER_LIST)\n   /** **Equivalent to**: `insert(position, il.begin(), il.end())` */\n   BOOST_CONTAINER_FORCEINLINE iterator insert(const_iterator position, std::initializer_list<T> il)\n   {\n      return this->insert(position, il.begin(), il.end());\n   }\n   #endif\n\n   /**\n   * [MoveAssignable]: http://en.cppreference.com/w/cpp/concept/MoveAssignable\n   *\n   * **Effects**: Destroys the element pointed by `position` and removes it from the devector.\n   * Invalidates iterators.\n   *\n   * **Requires**: `T` shall be [MoveAssignable].\n   *\n   * **Precondition**: `position` must be in the range of `[begin(), end())`.\n   *\n   * **Returns**: Iterator pointing to the element immediately following the erased element\n   * prior to its erasure. If no such element exists, `end()` is returned.\n   *\n   * **Exceptions**: Strong exception guarantee if `T` is `NothrowAssignable`,\n   * Basic exception guarantee otherwise.\n   *\n   * **Complexity**: Linear in half the size of `*this`.\n   */\n   iterator erase(const_iterator position)\n   {\n      return erase(position, position + 1);\n   }\n\n   /**\n   * [MoveAssignable]: http://en.cppreference.com/w/cpp/concept/MoveAssignable\n   *\n   * **Effects**: Destroys the range `[first,last)` and removes it from the devector.\n   * Invalidates iterators.\n   *\n   * **Requires**: `T` shall be [MoveAssignable].\n   *\n   * **Precondition**: `[first,last)` must be in the range of `[begin(), end())`.\n   *\n   * **Returns**: Iterator pointing to the element pointed to by `last` prior to any elements\n   * being erased. If no such element exists, `end()` is returned.\n   *\n   * **Exceptions**: Strong exception guarantee if `T` is `NothrowAssignable`,\n   * Basic exception guarantee otherwise.\n   *\n   * **Complexity**: Linear in half the size of `*this`\n   * plus the distance between `first` and `last`.\n   */\n   iterator erase(const_iterator first, const_iterator last)\n   {\n      iterator nc_first = unconst_iterator(first);\n      iterator nc_last  = unconst_iterator(last);\n      return erase(nc_first, nc_last);\n   }\n\n   /**\n   * [MoveAssignable]: http://en.cppreference.com/w/cpp/concept/MoveAssignable\n   *\n   * **Effects**: Destroys the range `[first,last)` and removes it from the devector.\n   * Invalidates iterators.\n   *\n   * **Requires**: `T` shall be [MoveAssignable].\n   *\n   * **Precondition**: `[first,last)` must be in the range of `[begin(), end())`.\n   *\n   * **Returns**: Iterator pointing to the element pointed to by `last` prior to any elements\n   * being erased. If no such element exists, `end()` is returned.\n   *\n   * **Exceptions**: Strong exception guarantee if `T` is `NothrowAssignable`,\n   * Basic exception guarantee otherwise.\n   *\n   * **Complexity**: Linear in half the size of `*this`.\n   */\n   iterator erase(iterator first, iterator last)\n   {\n      size_type front_distance = pos_to_index(last);\n      size_type back_distance  = size_type(end() - first);\n      size_type n = boost::container::iterator_udistance(first, last);\n\n      if (front_distance < back_distance)\n      {\n            // move n to the right\n            boost::container::move_backward(begin(), first, last);\n\n            for (iterator i = begin(); i != begin() + n; ++i)\n            {\n               allocator_traits_type::destroy(get_allocator_ref(), boost::movelib::to_raw_pointer(i));\n            }\n            //n is always less than max stored_size_type\n            m_.set_front_idx(m_.front_idx + n);\n\n            BOOST_ASSERT(invariants_ok());\n            return last;\n      }\n      else {\n            // move n to the left\n            boost::container::move(last, end(), first);\n\n            for (iterator i = end() - n; i != end(); ++i)\n            {\n               allocator_traits_type::destroy(get_allocator_ref(), boost::movelib::to_raw_pointer(i));\n            }\n            //n is always less than max stored_size_type\n            m_.set_back_idx(m_.back_idx - n);\n\n            BOOST_ASSERT(invariants_ok());\n            return first;\n      }\n   }\n\n   /**\n   * [MoveInsertable]: http://en.cppreference.com/w/cpp/concept/MoveInsertable\n   *\n   * **Effects**: exchanges the contents of `*this` and `b`.\n   *\n   * **Requires**: instances of `T` must be swappable by unqualified call of `swap`\n   * and `T` must be [MoveInsertable] into `*this`.\n   *\n   * **Precondition**: The allocators should allow propagation or should compare equal.\n   *\n   * **Exceptions**: Basic exceptions guarantee if not `noexcept`.\n   *\n   * **Complexity**: Constant.\n   */\n   void swap(devector& b)\n      BOOST_NOEXCEPT_IF( allocator_traits_type::propagate_on_container_swap::value\n                                 || allocator_traits_type::is_always_equal::value)\n   {\n      BOOST_CONSTEXPR_OR_CONST bool propagate_alloc = allocator_traits_type::propagate_on_container_swap::value;\n      BOOST_ASSERT(propagate_alloc || get_allocator_ref() == b.get_allocator_ref()); // else it's undefined behavior\n\n      swap_big_big(*this, b);\n\n      // swap indices\n      boost::adl_move_swap(m_.front_idx, b.m_.front_idx);\n      boost::adl_move_swap(m_.back_idx, b.m_.back_idx);\n\n      //And now swap the allocator\n      dtl::swap_alloc(this->get_allocator_ref(), b.get_allocator_ref(), dtl::bool_<propagate_alloc>());\n\n      BOOST_ASSERT(   invariants_ok());\n      BOOST_ASSERT(b.invariants_ok());\n   }\n\n   /**\n   * **Effects**: Destroys all elements in the devector.\n   * Invalidates all references, pointers and iterators to the\n   * elements of the devector.\n   *\n   * **Postcondition**: `empty() && front_free_capacity() == 0\n   * && back_free_capacity() == old capacity`.\n   *\n   * **Complexity**: Linear in the size of `*this`.\n   *\n   * **Remarks**: Does not free memory.\n   */\n   void clear() BOOST_NOEXCEPT\n   {\n      destroy_elements(begin(), end());\n      m_.front_idx = m_.back_idx = 0;\n   }\n\n   BOOST_CONTAINER_ATTRIBUTE_NODISCARD BOOST_CONTAINER_FORCEINLINE\n      friend bool operator==(const devector& x, const devector& y)\n   {   return x.size() == y.size() && ::boost::container::algo_equal(x.begin(), x.end(), y.begin());   }\n\n   BOOST_CONTAINER_ATTRIBUTE_NODISCARD BOOST_CONTAINER_FORCEINLINE\n      friend bool operator!=(const devector& x, const devector& y)\n   {   return !(x == y); }\n\n   BOOST_CONTAINER_ATTRIBUTE_NODISCARD BOOST_CONTAINER_FORCEINLINE\n      friend bool operator< (const devector& x, const devector& y)\n   {   return boost::container::algo_lexicographical_compare(x.begin(), x.end(), y.begin(), y.end());   }\n\n   BOOST_CONTAINER_ATTRIBUTE_NODISCARD BOOST_CONTAINER_FORCEINLINE\n      friend bool operator>(const devector& x, const devector& y)\n   {   return y < x;   }\n\n   BOOST_CONTAINER_ATTRIBUTE_NODISCARD BOOST_CONTAINER_FORCEINLINE\n      friend bool operator<=(const devector& x, const devector& y)\n   {   return !(y < x);   }\n\n   BOOST_CONTAINER_ATTRIBUTE_NODISCARD BOOST_CONTAINER_FORCEINLINE\n      friend bool operator>=(const devector& x, const devector& y)\n   {   return !(x < y);   }\n\n   BOOST_CONTAINER_FORCEINLINE friend void swap(devector& x, devector& y)\n      BOOST_NOEXCEPT_IF( allocator_traits_type::propagate_on_container_swap::value\n                                 || allocator_traits_type::is_always_equal::value)\n   {   x.swap(y);   }\n\n   private:\n\n   BOOST_CONTAINER_ATTRIBUTE_NODISCARD BOOST_CONTAINER_FORCEINLINE\n   size_type pos_to_index(const_iterator i) const \n   {\n      return static_cast<size_type>(i - cbegin());\n   }\n\n   BOOST_CONTAINER_ATTRIBUTE_NODISCARD BOOST_CONTAINER_FORCEINLINE\n   bool should_move_back(const_iterator i) const \n   {\n      return static_cast<size_type>(this->pos_to_index(i)) >= this->size()/2u;\n   }\n\n   BOOST_CONTAINER_FORCEINLINE static iterator unconst_iterator(const_iterator i)\n   {\n      return boost::intrusive::pointer_traits<pointer>::const_cast_from(i);\n   }\n\n   BOOST_CONTAINER_FORCEINLINE size_type front_capacity() const\n   {\n      return m_.back_idx;\n   }\n\n   BOOST_CONTAINER_FORCEINLINE size_type back_capacity() const\n   {\n      return size_type(m_.capacity - m_.front_idx);\n   }\n\n   #ifndef BOOST_CONTAINER_DOXYGEN_INVOKED\n\n   BOOST_CONTAINER_FORCEINLINE T* priv_raw_begin() BOOST_NOEXCEPT\n   {   return boost::movelib::to_raw_pointer(m_.buffer) + m_.front_idx;   }\n\n   BOOST_CONTAINER_FORCEINLINE T* priv_raw_end() BOOST_NOEXCEPT\n   {   return boost::movelib::to_raw_pointer(m_.buffer) + m_.back_idx;    }\n\n\n   template <class U>\n   BOOST_CONTAINER_FORCEINLINE void priv_push_front(BOOST_FWD_REF(U) u)\n   {\n      this->emplace_front(boost::forward<U>(u));\n   }\n\n   template <class U>\n   BOOST_CONTAINER_FORCEINLINE void priv_push_back(BOOST_FWD_REF(U) u)\n   {\n      this->emplace_back(boost::forward<U>(u));\n   }\n\n   template <class U>\n   BOOST_CONTAINER_FORCEINLINE iterator priv_insert(const_iterator pos, BOOST_FWD_REF(U) u)\n   {\n      return this->emplace(pos, boost::forward<U>(u));\n   }\n\n   // allocator_type wrappers\n\n   BOOST_CONTAINER_FORCEINLINE allocator_type& get_allocator_ref() BOOST_NOEXCEPT\n   {\n      return static_cast<allocator_type&>(m_);\n   }\n\n   BOOST_CONTAINER_FORCEINLINE const allocator_type& get_allocator_ref() const BOOST_NOEXCEPT\n   {\n      return static_cast<const allocator_type&>(m_);\n   }\n\n   pointer allocate(size_type capacity)\n   {\n      pointer const p = impl::do_allocate(get_allocator_ref(), capacity);\n      #ifdef BOOST_CONTAINER_DEVECTOR_ALLOC_STATS\n      ++m_.capacity_alloc_count;\n      #endif // BOOST_CONTAINER_DEVECTOR_ALLOC_STATS\n      return p;\n   }\n\n   void destroy_elements(pointer begin, pointer end)\n   {\n      for (; begin != end; ++begin)\n      {\n         allocator_traits_type::destroy(get_allocator_ref(), boost::movelib::to_raw_pointer(begin));\n      }\n   }\n\n   void deallocate_buffer()\n   {\n      if (m_.buffer)\n      {\n         allocator_traits_type::deallocate(get_allocator_ref(), m_.buffer, m_.capacity);\n      }\n   }\n\n   #if !defined(BOOST_NO_CXX11_VARIADIC_TEMPLATES) || defined(BOOST_CONTAINER_DOXYGEN_INVOKED)\n   template <typename... Args>\n   BOOST_CONTAINER_FORCEINLINE void alloc_construct(pointer dst, Args&&... args)\n   {\n      allocator_traits_type::construct(\n            get_allocator_ref(),\n            boost::movelib::to_raw_pointer(dst),\n            boost::forward<Args>(args)...\n      );\n   }\n\n   template <typename... Args>\n   void construct_n(pointer buffer, size_type n, Args&&... args)\n   {\n      detail::construction_guard<allocator_type> ctr_guard(buffer, get_allocator_ref());\n      guarded_construct_n(buffer, n, ctr_guard, boost::forward<Args>(args)...);\n      ctr_guard.release();\n   }\n\n   template <typename... Args>\n   void guarded_construct_n(pointer buffer, size_type n, detail::construction_guard<allocator_type>& ctr_guard, Args&&... args)\n   {\n      for (size_type i = 0; i < n; ++i) {\n         this->alloc_construct(buffer + i, boost::forward<Args>(args)...);\n         ctr_guard.extend();\n      }\n   }\n\n   #else //!defined(BOOST_NO_CXX11_VARIADIC_TEMPLATES) || defined(BOOST_CONTAINER_DOXYGEN_INVOKED)\n\n   #define BOOST_CONTAINER_DEVECTOR_ALLOC_CONSTRUCT(N) \\\n   BOOST_MOVE_TMPL_LT##N BOOST_MOVE_CLASS##N BOOST_MOVE_GT##N \\\n   BOOST_CONTAINER_FORCEINLINE void alloc_construct(pointer dst BOOST_MOVE_I##N BOOST_MOVE_UREF##N)\\\n   {\\\n      allocator_traits_type::construct(\\\n            get_allocator_ref(), boost::movelib::to_raw_pointer(dst) BOOST_MOVE_I##N BOOST_MOVE_FWD##N );\\\n   }\\\n   \\\n   BOOST_MOVE_TMPL_LT##N BOOST_MOVE_CLASS##N BOOST_MOVE_GT##N \\\n   void construct_n(pointer buffer, size_type n BOOST_MOVE_I##N BOOST_MOVE_UREF##N)\\\n   {\\\n      detail::construction_guard<allocator_type> ctr_guard(buffer, get_allocator_ref());\\\n      guarded_construct_n(buffer, n, ctr_guard BOOST_MOVE_I##N BOOST_MOVE_FWD##N);\\\n      ctr_guard.release();\\\n   }\\\n   \\\n   BOOST_MOVE_TMPL_LT##N BOOST_MOVE_CLASS##N BOOST_MOVE_GT##N \\\n   void guarded_construct_n(pointer buffer, size_type n, detail::construction_guard<allocator_type>& ctr_guard BOOST_MOVE_I##N BOOST_MOVE_UREF##N)\\\n   {\\\n      for (size_type i = 0; i < n; ++i) {\\\n            this->alloc_construct(buffer + i BOOST_MOVE_I##N BOOST_MOVE_FWD##N);\\\n            ctr_guard.extend();\\\n      }\\\n   }\n   //\n   BOOST_MOVE_ITERATE_0TO9(BOOST_CONTAINER_DEVECTOR_ALLOC_CONSTRUCT)\n   #undef BOOST_CONTAINER_DEVECTOR_ALLOC_CONSTRUCT\n\n   #endif    //!defined(BOOST_NO_CXX11_VARIADIC_TEMPLATES) || defined(BOOST_CONTAINER_DOXYGEN_INVOKED)\n\n   size_type calculate_new_capacity(size_type requested_capacity)\n   {\n      size_type max = allocator_traits_type::max_size(this->get_allocator_ref());\n      (clamp_by_stored_size_type)(max, stored_size_type());\n      const size_type remaining_additional_cap = max - size_type(m_.capacity);\n      const size_type min_additional_cap = requested_capacity - size_type(m_.capacity);\n      if ( remaining_additional_cap < min_additional_cap )\n            boost::container::throw_length_error(\"devector: get_next_capacity, max size exceeded\");\n\n      return growth_factor_type()( size_type(m_.capacity), min_additional_cap, max);\n   }\n\n   void buffer_move_or_copy(pointer dst)\n   {\n      detail::construction_guard<allocator_type> guard(dst, get_allocator_ref());\n\n      buffer_move_or_copy(dst, guard);\n\n      guard.release();\n   }\n\n   void buffer_move_or_copy(pointer dst, detail::construction_guard<allocator_type>& guard)\n   {\n      opt_move_or_copy(begin(), end(), dst, guard);\n\n      destroy_elements(data(), data() + size());\n      deallocate_buffer();\n   }\n\n   template <typename Guard>\n   void opt_move_or_copy(pointer begin, pointer end, pointer dst, Guard& guard)\n   {\n      // if trivial copy and default allocator, memcpy\n      boost::container::uninitialized_move_alloc(get_allocator_ref(), begin, end, dst);\n      guard.extend();\n   }\n\n   #if !defined(BOOST_NO_CXX11_VARIADIC_TEMPLATES) || defined(BOOST_CONTAINER_DOXYGEN_INVOKED)\n\n   template <typename... Args>\n   void resize_impl(size_type sz, Args&&... args)\n   {\n      const size_type old_sz = this->size();\n      if (sz > old_sz)\n      {\n         const size_type n = sz - old_sz;\n\n         if (sz <= m_.capacity)\n         {\n            //Construct at back\n            const size_type bfc = this->back_free_capacity();\n            const size_type b = n < bfc ? n : bfc;\n            construct_n(m_.buffer + m_.back_idx, b, boost::forward<Args>(args)...);\n            m_.set_back_idx(m_.back_idx + b);\n\n            //Construct remaining at front\n            const size_type f = n - b;\n            construct_n(m_.buffer + m_.front_idx - f, f, boost::forward<Args>(args)...);\n            m_.set_front_idx(m_.front_idx - f);\n         }\n         else\n         {\n            resize_back_slow_path(sz, n, boost::forward<Args>(args)...);\n         }\n      }\n      else\n      {\n         const size_type n = old_sz - sz;\n         const size_type new_bidx = m_.back_idx - n;\n         destroy_elements(m_.buffer + new_bidx, m_.buffer + m_.back_idx);\n         m_.set_back_idx(new_bidx);\n      }\n   }\n\n   template <typename... Args>\n   void resize_front_impl(size_type sz , Args&&... args)\n   {\n      const size_type old_sz = this->size();\n      if (sz > old_sz)\n      {\n         const size_type n = sz - old_sz;\n\n         if (sz <= this->front_capacity())\n         {\n            construct_n(m_.buffer + m_.front_idx - n, n, boost::forward<Args>(args)...);\n            m_.set_front_idx(m_.front_idx - n);\n         }\n         else\n         {\n            resize_front_slow_path(sz, n, boost::forward<Args>(args)...);\n         }\n      }\n      else {\n         const size_type n = old_sz - sz;\n         const size_type new_fidx = m_.front_idx + n;\n         destroy_elements(m_.buffer + m_.front_idx, m_.buffer + new_fidx);\n         m_.set_front_idx(new_fidx);\n      }\n   }\n\n   template <typename... Args>\n   void resize_front_slow_path(size_type sz, size_type n, Args&&... args)\n   {\n      const size_type new_capacity = calculate_new_capacity(sz + back_free_capacity());\n      pointer new_buffer = allocate(new_capacity);\n      allocation_guard new_buffer_guard(new_buffer, new_capacity, get_allocator_ref());\n\n      const size_type old_sz = this->size();\n      const size_type new_old_elem_index = new_capacity - old_sz;\n      const size_type new_elem_index = new_old_elem_index - n;\n\n      detail::construction_guard<allocator_type> guard(new_buffer + new_elem_index, get_allocator_ref());\n      guarded_construct_n(new_buffer + new_elem_index, n, guard, boost::forward<Args>(args)...);\n\n      buffer_move_or_copy(new_buffer + new_old_elem_index, guard);\n\n      guard.release();\n      new_buffer_guard.release();\n\n      m_.buffer = new_buffer;\n      m_.set_capacity(new_capacity);\n      m_.set_front_idx(new_elem_index);\n      m_.set_back_idx(new_elem_index + old_sz + n);\n   }\n\n   template <typename... Args>\n   void resize_back_impl(size_type sz, Args&&... args)\n   {\n      const size_type old_sz = this->size();\n      if (sz > old_sz)\n      {\n         const size_type n = sz - old_sz;\n\n         if (sz <= this->back_capacity())\n         {\n            construct_n(m_.buffer + m_.back_idx, n, boost::forward<Args>(args)...);\n            m_.set_back_idx(m_.back_idx + n);\n         }\n         else\n         {\n            resize_back_slow_path(sz, n, boost::forward<Args>(args)...);\n         }\n      }\n      else\n      {\n         const size_type n = old_sz - sz;\n         const size_type new_bidx = m_.back_idx - n;\n         destroy_elements(m_.buffer + new_bidx, m_.buffer + m_.back_idx);\n         m_.set_back_idx(new_bidx);\n      }\n   }\n\n   template <typename... Args>\n   void resize_back_slow_path(size_type sz, size_type n, Args&&... args)\n   {\n      const size_type new_capacity = calculate_new_capacity(sz + front_free_capacity());\n      pointer new_buffer = allocate(new_capacity);\n      allocation_guard new_buffer_guard(new_buffer, new_capacity, get_allocator_ref());\n\n      detail::construction_guard<allocator_type> guard(new_buffer + m_.back_idx, get_allocator_ref());\n      guarded_construct_n(new_buffer + m_.back_idx, n, guard, boost::forward<Args>(args)...);\n\n      buffer_move_or_copy(new_buffer + m_.front_idx);\n\n      guard.release();\n      new_buffer_guard.release();\n\n      m_.buffer = new_buffer;\n      m_.set_capacity(new_capacity);\n      m_.set_back_idx(m_.back_idx + n);\n   }\n\n   #else //!defined(BOOST_NO_CXX11_VARIADIC_TEMPLATES) || defined(BOOST_CONTAINER_DOXYGEN_INVOKED)\n\n   #define BOOST_CONTAINER_DEVECTOR_SLOW_PATH(N) \\\n   BOOST_MOVE_TMPL_LT##N BOOST_MOVE_CLASS##N BOOST_MOVE_GT##N \\\n   void resize_front_impl(size_type sz BOOST_MOVE_I##N BOOST_MOVE_UREF##N)\\\n   {\\\n      if (sz > size())\\\n      {\\\n         const size_type n = sz - size();\\\n         if (sz <= front_capacity()){\\\n            construct_n(m_.buffer + m_.front_idx - n, n BOOST_MOVE_I##N BOOST_MOVE_FWD##N);\\\n            m_.set_front_idx(m_.front_idx - n);\\\n         }\\\n         else\\\n         {\\\n            resize_front_slow_path(sz, n BOOST_MOVE_I##N BOOST_MOVE_FWD##N);\\\n         }\\\n      }\\\n      else {\\\n         while (this->size() > sz)\\\n         {\\\n            this->pop_front();\\\n         }\\\n      }\\\n   }\\\n   \\\n   BOOST_MOVE_TMPL_LT##N BOOST_MOVE_CLASS##N BOOST_MOVE_GT##N \\\n   void resize_front_slow_path(size_type sz, size_type n BOOST_MOVE_I##N BOOST_MOVE_UREF##N)\\\n   {\\\n      const size_type new_capacity = calculate_new_capacity(sz + back_free_capacity());\\\n      pointer new_buffer = allocate(new_capacity);\\\n      allocation_guard new_buffer_guard(new_buffer, new_capacity, get_allocator_ref());\\\n   \\\n      const size_type new_old_elem_index = new_capacity - size();\\\n      const size_type new_elem_index = new_old_elem_index - n;\\\n   \\\n      detail::construction_guard<allocator_type> guard(new_buffer + new_elem_index, get_allocator_ref());\\\n      guarded_construct_n(new_buffer + new_elem_index, n, guard BOOST_MOVE_I##N BOOST_MOVE_FWD##N);\\\n   \\\n      buffer_move_or_copy(new_buffer + new_old_elem_index, guard);\\\n   \\\n      guard.release();\\\n      new_buffer_guard.release();\\\n      m_.buffer = new_buffer;\\\n      m_.set_capacity(new_capacity);\\\n      m_.set_back_idx(new_old_elem_index + m_.back_idx - m_.front_idx);\\\n      m_.set_front_idx(new_elem_index);\\\n   }\\\n   \\\n   BOOST_MOVE_TMPL_LT##N BOOST_MOVE_CLASS##N BOOST_MOVE_GT##N \\\n   void resize_back_impl(size_type sz BOOST_MOVE_I##N BOOST_MOVE_UREF##N)\\\n   {\\\n      if (sz > size())\\\n      {\\\n         const size_type n = sz - size();\\\n      \\\n         if (sz <= back_capacity())\\\n         {\\\n            construct_n(m_.buffer + m_.back_idx, n BOOST_MOVE_I##N BOOST_MOVE_FWD##N);\\\n            m_.set_back_idx(m_.back_idx + n);\\\n         }\\\n         else\\\n         {\\\n            resize_back_slow_path(sz, n BOOST_MOVE_I##N BOOST_MOVE_FWD##N);\\\n         }\\\n      }\\\n      else\\\n      {\\\n         while (size() > sz)\\\n         {\\\n            pop_back();\\\n         }\\\n      }\\\n   }\\\n   \\\n   BOOST_MOVE_TMPL_LT##N BOOST_MOVE_CLASS##N BOOST_MOVE_GT##N \\\n   void resize_back_slow_path(size_type sz, size_type n BOOST_MOVE_I##N BOOST_MOVE_UREF##N)\\\n   {\\\n      const size_type new_capacity = calculate_new_capacity(sz + front_free_capacity());\\\n      pointer new_buffer = allocate(new_capacity);\\\n      allocation_guard new_buffer_guard(new_buffer, new_capacity, get_allocator_ref());\\\n   \\\n      detail::construction_guard<allocator_type> guard(new_buffer + m_.back_idx, get_allocator_ref());\\\n      guarded_construct_n(new_buffer + m_.back_idx, n, guard BOOST_MOVE_I##N BOOST_MOVE_FWD##N);\\\n   \\\n      buffer_move_or_copy(new_buffer + m_.front_idx);\\\n   \\\n      guard.release();\\\n      new_buffer_guard.release();\\\n   \\\n      m_.buffer = new_buffer;\\\n      m_.set_capacity(new_capacity);\\\n      m_.set_back_idx(m_.back_idx + n);\\\n   }\\\n   \\\n   //\n   BOOST_MOVE_ITERATE_0TO9(BOOST_CONTAINER_DEVECTOR_SLOW_PATH)\n   #undef BOOST_CONTAINER_DEVECTOR_SLOW_PATH\n\n   #endif    //!defined(BOOST_NO_CXX11_VARIADIC_TEMPLATES) || defined(BOOST_CONTAINER_DOXYGEN_INVOKED)\n\n   void reallocate_at(size_type new_capacity, size_type buffer_offset)\n   {\n      pointer new_buffer = allocate(new_capacity);\n      {\n         allocation_guard new_buffer_guard(new_buffer, new_capacity, get_allocator_ref());\n         boost::container::uninitialized_move_alloc(get_allocator_ref(), this->begin(), this->end(), new_buffer + buffer_offset);\n         new_buffer_guard.release();\n      }\n      destroy_elements(m_.buffer + m_.front_idx, m_.buffer + m_.back_idx);\n      deallocate_buffer();\n\n      m_.buffer = new_buffer;\n      //Safe cast, allocate() will handle stored_size_type overflow\n      m_.set_capacity(new_capacity);\n      m_.set_back_idx(size_type(m_.back_idx - m_.front_idx) + buffer_offset);\n      m_.set_front_idx(buffer_offset);\n\n      BOOST_ASSERT(invariants_ok());\n   }\n\n   template <typename ForwardIterator>\n   iterator insert_range(const_iterator position, ForwardIterator first, ForwardIterator last)\n   {\n      BOOST_ASSERT(position >= begin());\n      BOOST_ASSERT(position <= end());\n      typedef dtl::insert_range_proxy<allocator_type, ForwardIterator> proxy_t;\n\n      size_type const n = boost::container::iterator_udistance(first, last);\n      bool prefer_move_back;\n      if (BOOST_UNLIKELY(!n)) {\n         return begin() + size_type(position - cbegin());\n      }\n      else if (position == end()) {\n         if(back_free_capacity() >= n) // fast path\n         {\n            iterator r(this->end());\n            boost::container::uninitialized_copy_alloc(get_allocator_ref(), first, last, this->priv_raw_end());\n            m_.set_back_idx(m_.back_idx + n);\n            return r;\n         }\n         prefer_move_back = true;\n      }\n      else if (position == begin()) {\n         if(front_free_capacity() >= n) {// secondary fast path\n            boost::container::uninitialized_copy_alloc(get_allocator_ref(), first, last, this->priv_raw_begin() - n);\n            m_.set_front_idx(m_.front_idx - n);\n            return begin();\n         }\n         prefer_move_back = false;\n      }\n      else{\n         iterator nonconst_pos = unconst_iterator(position);\n         prefer_move_back = should_move_back(position);\n\n         if(prefer_move_back){\n            if(back_free_capacity() >= n){\n               boost::container::expand_forward_and_insert_nonempty_middle_alloc\n                  ( get_allocator_ref()\n                  , boost::movelib::to_raw_pointer(nonconst_pos)\n                  , this->priv_raw_end()\n                  , n, proxy_t(first));\n               m_.set_back_idx(m_.back_idx + n);\n               return nonconst_pos;\n            }\n         }\n         else{\n            if (front_free_capacity() >= n){\n               boost::container::expand_backward_and_insert_nonempty_middle_alloc\n                  ( get_allocator_ref()\n                  , this->priv_raw_begin()\n                  , boost::movelib::to_raw_pointer(nonconst_pos)\n                  , n, proxy_t(first));\n               m_.set_front_idx(m_.front_idx - n);\n               return (nonconst_pos -= n);\n            }\n         }\n      }\n      return this->insert_range_slow_path(position, n, proxy_t(first));\n   }\n\n   template <class InsertionProxy>\n   BOOST_CONTAINER_NOINLINE iterator insert_range_slow_path\n      (const_iterator p, const size_type n, const InsertionProxy proxy)\n   {\n      size_type const back_free_cap = back_free_capacity();\n      size_type const front_free_cap = front_free_capacity();\n      size_type const free_cap = front_free_cap + back_free_cap;\n      size_type const index = size_type(p - cbegin());\n\n      size_type const cap = m_.capacity;\n      //Test if enough free memory would be left\n      if (free_cap >= n && (free_cap - n) >= cap/devector_min_free_fraction) {\n         //Make sure relocation is happening because there was no enough space\n         size_type const old_size = this->size();\n         BOOST_ASSERT(should_move_back(p) ? (back_free_cap < n) : (front_free_cap < n));\n\n         T* const raw_pos = const_cast<T*>(boost::movelib::to_raw_pointer(p));\n         size_type const new_size = old_size + n;\n         size_type const new_front_idx = (cap - new_size) / 2u;\n\n         T* const raw_beg = this->priv_raw_begin();\n         T* const new_raw_beg = raw_beg - std::ptrdiff_t(m_.front_idx - new_front_idx);\n         m_.back_idx = 0u;\n         m_.front_idx = 0u;\n         boost::container::expand_backward_forward_and_insert_alloc\n            (raw_beg, old_size, new_raw_beg, raw_pos, n, proxy, get_allocator_ref());\n         m_.set_front_idx(new_front_idx);\n         m_.set_back_idx(new_front_idx + new_size);\n      }\n      else {\n         // reallocate\n         const size_type new_capacity = calculate_new_capacity(m_.capacity + n);\n         pointer new_buffer = allocate(new_capacity);\n\n         // guard allocation\n         allocation_guard new_buffer_guard(new_buffer, new_capacity, get_allocator_ref());\n\n         size_type const old_size = this->size();\n         const size_type new_front_index = (new_capacity - old_size - n) / 2u;\n\n         T* const raw_pos = const_cast<T*>(boost::movelib::to_raw_pointer(p));\n         T* const raw_new_start = const_cast<T*>(boost::movelib::to_raw_pointer(new_buffer)) + new_front_index;\n\n         boost::container::uninitialized_move_and_insert_alloc\n            (get_allocator_ref(), this->priv_raw_begin(), raw_pos, this->priv_raw_end(), raw_new_start, n, proxy);\n         new_buffer_guard.release();\n\n         // cleanup\n         destroy_elements(begin(), end());\n         deallocate_buffer();\n\n         // rebind members\n         m_.set_capacity(new_capacity);\n         m_.buffer = new_buffer;\n         m_.set_back_idx(new_front_index + old_size + n);\n         m_.set_front_idx(new_front_index);\n      }\n      return begin() + index;\n   }\n\n\n   template <typename Iterator>\n   void construct_from_range(Iterator begin, Iterator end)\n   {\n      allocation_guard buffer_guard(m_.buffer, m_.capacity, get_allocator_ref());\n      boost::container::uninitialized_copy_alloc(get_allocator_ref(), begin, end, m_.buffer);\n      buffer_guard.release();\n   }\n\n   template <typename ForwardIterator>\n   void allocate_and_copy_range(ForwardIterator first, ForwardIterator last)\n   {\n      size_type n = boost::container::iterator_udistance(first, last);\n\n      pointer new_buffer = n ? allocate(n) : pointer();\n      allocation_guard new_buffer_guard(new_buffer, n, get_allocator_ref());\n      boost::container::uninitialized_copy_alloc(get_allocator_ref(), first, last, new_buffer);\n      destroy_elements(begin(), end());\n      deallocate_buffer();\n\n      m_.set_capacity(n);\n      m_.buffer = new_buffer;\n      m_.front_idx = 0;\n      m_.set_back_idx(n);\n\n      new_buffer_guard.release();\n   }\n\n   static void swap_big_big(devector& a, devector& b) BOOST_NOEXCEPT\n   {\n      boost::adl_move_swap(a.m_.capacity, b.m_.capacity);\n      boost::adl_move_swap(a.m_.buffer, b.m_.buffer);\n   }\n\n   template <typename ForwardIterator>\n   void overwrite_buffer_impl(ForwardIterator first, ForwardIterator last, dtl::true_)\n   {\n      const size_type n = boost::container::iterator_udistance(first, last);\n\n      BOOST_ASSERT(m_.capacity >= n);\n      boost::container::uninitialized_copy_alloc_n\n            ( get_allocator_ref(), first\n            , n, boost::movelib::to_raw_pointer(m_.buffer));\n      m_.front_idx = 0;\n      m_.set_back_idx(n);\n   }\n\n   template <typename InputIterator>\n   InputIterator overwrite_buffer_impl(InputIterator first, InputIterator last, dtl::false_)\n   {\n      pointer pos = m_.buffer;\n      detail::construction_guard<allocator_type> front_guard(pos, get_allocator_ref());\n\n      while (first != last && pos != begin()) {\n         this->alloc_construct(pos++, *first++);\n         front_guard.extend();\n      }\n\n      while (first != last && pos != end()) {\n         *pos++ = *first++;\n      }\n\n      detail::construction_guard<allocator_type> back_guard(pos, get_allocator_ref());\n\n      iterator capacity_end = m_.buffer + m_.capacity;\n      while (first != last && pos != capacity_end) {\n         this->alloc_construct(pos++, *first++);\n         back_guard.extend();\n      }\n\n      pointer destroy_after = dtl::min_value(dtl::max_value(begin(), pos), end());\n      destroy_elements(destroy_after, end());\n\n      front_guard.release();\n      back_guard.release();\n\n      m_.front_idx = 0;\n      m_.set_back_idx(pos_to_index(pos));\n      return first;\n   }\n\n   template <typename ForwardIterator>\n   BOOST_CONTAINER_FORCEINLINE void overwrite_buffer(ForwardIterator first, ForwardIterator last)\n   {\n      this->overwrite_buffer_impl(first, last, \n            dtl::bool_<dtl::is_trivially_destructible<T>::value>());\n   }\n\n   bool invariants_ok()\n   {\n      return  (! m_.capacity || m_.buffer )\n              && m_.front_idx <= m_.back_idx\n              && m_.back_idx <= m_.capacity;\n   }\n\n   struct impl : allocator_type\n   {\n      BOOST_MOVABLE_BUT_NOT_COPYABLE(impl)\n\n      public:\n      allocator_type &get_al()\n      {   return *this;   }\n\n      static pointer do_allocate(allocator_type &a, size_type cap)\n      {\n         if (cap) {\n            //First detect overflow on smaller stored_size_types\n            if (cap > stored_size_type(-1)){\n                  boost::container::throw_length_error(\"get_next_capacity, allocator's max size reached\");\n            }\n            return allocator_traits_type::allocate(a, cap);\n         }\n         else {\n            return pointer();\n         }\n      }\n\n      impl()\n         : allocator_type(), buffer(), front_idx(), back_idx(), capacity()\n         #ifdef BOOST_CONTAINER_DEVECTOR_ALLOC_STATS\n         , capacity_alloc_count(0)\n         #endif\n      {}\n\n      explicit impl(const allocator_type &a)\n         : allocator_type(a), buffer(), front_idx(), back_idx(), capacity()\n         #ifdef BOOST_CONTAINER_DEVECTOR_ALLOC_STATS\n         , capacity_alloc_count(0)\n         #endif\n      {}\n\n      impl(reserve_uninitialized_t, const allocator_type& a, size_type c)\n         : allocator_type(a), buffer(do_allocate(get_al(), c) )\n         //static cast sizes, as the allocation function will take care of overflows\n         , front_idx(static_cast<stored_size_type>(0u))\n         , back_idx(static_cast<stored_size_type>(c))\n         , capacity(static_cast<stored_size_type>(c))\n         #ifdef BOOST_CONTAINER_DEVECTOR_ALLOC_STATS\n         , capacity_alloc_count(size_type(buffer != pointer()))\n         #endif\n      {}\n\n      impl(reserve_only_tag_t, const allocator_type &a, size_type const ffc, size_type const bfc)\n         : allocator_type(a), buffer(do_allocate(get_al(), ffc+bfc) )\n         //static cast sizes, as the allocation function will take care of overflows\n         , front_idx(static_cast<stored_size_type>(ffc))\n         , back_idx(static_cast<stored_size_type>(ffc))\n         , capacity(static_cast<stored_size_type>(ffc + bfc))\n         #ifdef BOOST_CONTAINER_DEVECTOR_ALLOC_STATS\n         , capacity_alloc_count(size_type(buffer != pointer()))\n         #endif\n      {}\n\n      impl(reserve_only_tag_t, const allocator_type &a, size_type const c)\n         : allocator_type(a), buffer(do_allocate(get_al(), c) )\n         //static cast sizes, as the allocation function will take care of overflows\n         , front_idx(static_cast<stored_size_type>(c/2u))\n         , back_idx(static_cast<stored_size_type>(c/2u))\n         , capacity(static_cast<stored_size_type>(c))\n         #ifdef BOOST_CONTAINER_DEVECTOR_ALLOC_STATS\n         , capacity_alloc_count(size_type(buffer != pointer()))\n         #endif\n      {}\n\n      impl(review_implementation_t, const allocator_type &a, pointer p, size_type fi, size_type bi, size_type c)\n         : allocator_type(a), buffer(p)\n         //static cast sizes, as the allocation function will take care of overflows\n         , front_idx(static_cast<stored_size_type>(fi))\n         , back_idx(static_cast<stored_size_type>(bi))\n         , capacity(static_cast<stored_size_type>(c))\n         #ifdef BOOST_CONTAINER_DEVECTOR_ALLOC_STATS\n         , capacity_alloc_count(0)\n         #endif\n      {}\n\n      impl(BOOST_RV_REF(impl) m)\n         : allocator_type(BOOST_MOVE_BASE(allocator_type, m))\n         , buffer(static_cast<impl&>(m).buffer)\n         , front_idx(static_cast<impl&>(m).front_idx)\n         , back_idx(static_cast<impl&>(m).back_idx)\n         , capacity(static_cast<impl&>(m).capacity)\n         #ifdef BOOST_CONTAINER_DEVECTOR_ALLOC_STATS\n         , capacity_alloc_count(0)\n         #endif\n      {\n         impl &i = static_cast<impl&>(m);\n         // buffer is already acquired, reset rhs\n         i.capacity = 0u;\n         i.buffer = pointer();\n         i.front_idx = 0;\n         i.back_idx = 0;\n      }\n\n      BOOST_CONTAINER_FORCEINLINE void set_back_idx(size_type bi)\n      {\n         back_idx = static_cast<stored_size_type>(bi);\n      }\n\n      BOOST_CONTAINER_FORCEINLINE void set_front_idx(size_type fi)\n      {\n         front_idx = static_cast<stored_size_type>(fi);\n      }\n\n      BOOST_CONTAINER_FORCEINLINE void set_capacity(size_type c)\n      {\n         capacity = static_cast<stored_size_type>(c);\n      }\n\n      pointer           buffer;\n      stored_size_type  front_idx;\n      stored_size_type  back_idx;\n      stored_size_type  capacity;\n      #ifdef BOOST_CONTAINER_DEVECTOR_ALLOC_STATS\n      size_type capacity_alloc_count;\n      #endif\n   } m_;\n\n   #ifdef BOOST_CONTAINER_DEVECTOR_ALLOC_STATS\n   public:\n   void reset_alloc_stats()\n   {\n      m_.capacity_alloc_count = 0;\n   }\n\n   size_type get_alloc_count() const\n   {\n      return m_.capacity_alloc_count;\n   }\n\n   #endif // ifdef BOOST_CONTAINER_DEVECTOR_ALLOC_STATS\n\n   #endif // ifndef BOOST_CONTAINER_DOXYGEN_INVOKED\n};\n\n}} // namespace boost::container\n\n#ifndef BOOST_CONTAINER_DOXYGEN_INVOKED\n\nnamespace boost {\n\n//!has_trivial_destructor_after_move<> == true_type\n//!specialization for optimizations\ntemplate <class T, class Allocator, class Options>\nstruct has_trivial_destructor_after_move<boost::container::devector<T, Allocator, Options> >\n{\n    typedef typename boost::container::devector<T, Allocator, Options>::allocator_type allocator_type;\n    typedef typename ::boost::container::allocator_traits<allocator_type>::pointer pointer;\n    static const bool value = ::boost::has_trivial_destructor_after_move<allocator_type>::value &&\n                                           ::boost::has_trivial_destructor_after_move<pointer>::value;\n};\n\n}\n\n#endif    //#ifndef BOOST_CONTAINER_DOXYGEN_INVOKED\n\n#include <boost/container/detail/config_end.hpp>\n\n#endif // BOOST_CONTAINER_DEVECTOR_HPP\n\n```\n","ts":1.739157548572E9}
{"role":"assistant","content":"","ts":1.739157549872E9}
