{"prompt":"<|begin_of_text|><|start_header_id|>user<|end_header_id|>\n\nUpdate doc.txt via xpatience.c with any and all new or missing information on xdiff's public interface.\n\n**doc.txt**\n```\n`doc.txt`\n\nPublic Interface for xdiff\n==========================\n\n### Data Structures\n\n* `mmfile_t`: represents a memory-mapped file\n\t+ `char *ptr`: pointer to the file's contents\n\t+ `long size`: size of the file's contents\n* `mmbuffer_t`: represents a memory-mapped buffer\n\t+ `char *ptr`: pointer to the buffer's contents\n\t+ `long size`: size of the buffer's contents\n* `xpparam_t`: represents parameters for the xdiff algorithm\n\t+ `unsigned long flags`: flags controlling the algorithm's behavior\n\t+ `regex_t **ignore_regex`: array of regular expressions to ignore\n\t+ `size_t ignore_regex_nr`: number of regular expressions to ignore\n\t+ `char **anchors`: array of anchor strings\n\t+ `size_t anchors_nr`: number of anchor strings\n* `xdemitcb_t`: represents a callback function for emitting differences\n\t+ `void *priv`: private data for the callback function\n\t+ `int (*out_hunk)(void *, long, long, long, long, const char *, long)`: callback function for emitting a hunk\n\t+ `int (*out_line)(void *, mmbuffer_t *, int)`: callback function for emitting a line\n* `xdemitconf_t`: represents configuration for emitting differences\n\t+ `long ctxlen`: length of the context for emitting differences\n\t+ `long interhunkctxlen`: length of the inter-hunk context for emitting differences\n\t+ `unsigned long flags`: flags controlling the emission of differences\n\t+ `find_func_t find_func`: function for finding the next match\n\t+ `void *find_func_priv`: private data for the find function\n\t+ `xdl_emit_hunk_consume_func_t hunk_func`: function for consuming a hunk\n* `bdiffparam_t`: represents parameters for the bdiff algorithm\n\t+ `long bsize`: size of the buffer for the bdiff algorithm\n* `diffdata_t`: represents data for the xdiff algorithm\n\t+ `long nrec`: number of records\n\t+ `unsigned long const *ha`: array of hash values\n\t+ `long *rindex`: array of record indices\n\t+ `char *rchg`: array of record changes\n* `xdalgoenv_t`: represents environment for the xdiff algorithm\n\t+ `long mxcost`: maximum cost\n\t+ `long snake_cnt`: snake count\n\t+ `long heur_min`: heuristic minimum\n* `xdchange_t`: represents a change in the xdiff algorithm\n\t+ `struct s_xdchange *next`: next change\n\t+ `long i1`, `i2`: indices of the change\n\t+ `long chg1`, `chg2`: changes\n\t+ `int ignore`: ignore flag\n* `xmparam_t`: represents parameters for the merge algorithm\n\t+ `xpparam_t xpp`: parameters for the xdiff algorithm\n\t+ `int marker_size`: size of the conflict marker\n\t+ `int level`: merge level\n\t+ `int favor`: favor mode\n\t+ `int style`: merge style\n\t+ `const char *ancestor`: label for the original file\n\t+ `const char *file1`: label for the first file\n\t+ `const char *file2`: label for the second file\n* `chastore_t`: represents a store for changed records\n\t+ `chanode_t *head`, `*tail`: head and tail of the store\n\t+ `long isize`, `nsize`: size of the store\n\t+ `chanode_t *ancur`, `*sncur`: current nodes\n\t+ `long scurr`: current size\n* `chanode_t`: represents a node in the changed record store\n\t+ `struct s_chanode *next`: next node\n\t+ `long icurr`: current index\n* `xrecord_t`: represents a record in the xdiff algorithm\n\t+ `struct s_xrecord *next`: next record\n\t+ `char const *ptr`: pointer to the record's contents\n\t+ `long size`: size of the record's contents\n\t+ `unsigned long ha`: hash value of the record\n* `xdfile_t`: represents a file in the xdiff algorithm\n\t+ `chastore_t rcha`: store for changed records\n\t+ `long nrec`: number of records\n\t+ `unsigned int hbits`: number of hash bits\n\t+ `xrecord_t **rhash`: array of record hashes\n\t+ `long dstart`, `dend`: start and end indices of the file\n\t+ `xrecord_t **recs`: array of records\n\t+ `char *rchg`: array of record changes\n\t+ `long *rindex`: array of record indices\n\t+ `long nreff`: number of referenced records\n\t+ `unsigned long *ha`: array of hash values\n* `xdfenv_t`: represents an environment for the xdiff algorithm\n\t+ `xdfile_t xdf1`, `xdf2`: files in the xdiff algorithm\n* `xdmerge_t`: represents a merge\n\t+ `struct s_xdmerge *next`: next merge\n\t+ `int mode`: merge mode\n\t+ `long i1`, `i2`: indices of the merge\n\t+ `long chg1`, `chg2`: changes\n\t+ `int ignore`: ignore flag\n\n### Functions\n\n* `xdl_diff(mmfile_t *mf1, mmfile_t *mf2, xpparam_t const *xpp, xdemitconf_t const *xecfg, xdemitcb_t *ecb)`: computes the differences between two files\n* `xdl_merge(mmfile_t *orig, mmfile_t *mf1, mmfile_t *mf2, xmparam_t const *xmp, mmbuffer_t *result)`: merges two files\n* `xdl_do_diff(mmfile_t *mf1, mmfile_t *mf2, xpparam_t const *xpp, xdfenv_t *xe)`: internal function for computing differences\n* `xdl_build_script(xdfenv_t *xe, xdchange_t **xscr)`: builds a script for emitting differences\n* `xdl_free_script(xdchange_t *xscr)`: frees a script for emitting differences\n* `xdl_call_hunk_func(xdfenv_t *xe, xdchange_t *xscr, xdemitcb_t *ecb, xdemitconf_t const *xecfg)`: internal function for emitting a hunk\n* `xdl_mark_ignorable_lines(xdchange_t *xscr, xdfenv_t *xe, long flags)`: marks ignorable lines in a script\n* `xdl_mark_ignorable_regex(xdchange_t *xscr, const xdfenv_t *xe, xpparam_t const *xpp)`: marks ignorable lines in a script using regular expressions\n* `xdl_recs_cmp(diffdata_t *dd1, long off1, long lim1, diffdata_t *dd2, long off2, long lim2, long *kvdf, long *kvdb, int need_min, xdalgoenv_t *xenv)`: compares records\n* `xdl_do_patience_diff(xpparam_t const *xpp, xdfenv_t *env)`: internal function for patience diff\n* `xdl_do_histogram_diff(xpparam_t const *xpp, xdfenv_t *env)`: internal function for histogram diff\n* `xdl_change_compact(xdfile_t *xdf, xdfile_t *xdfo, long flags)`: compacts changes\n* `xdl_emit_diff(xdfenv_t *xe, xdchange_t *xscr, xdemitcb_t *ecb, xdemitconf_t const *xecfg)`: emits differences\n* `xdl_get_hunk(xdchange_t **xscr, xdemitconf_t const *xecfg)`: gets the next hunk\n* `xdl_emit_record(xdfile_t *xdf, long ri, char const *pre, xdemitcb_t *ecb)`: emits a record\n* `xdl_get_rec(xdfile_t *xdf, long ri, char const **rec)`: gets a record\n* `xdl_mmfile_first(mmfile_t *mmf, long *size)`: gets the first memory-mapped file\n* `xdl_mmfile_size(mmfile_t *mmf)`: gets the size of a memory-mapped file\n* `xdl_do_histogram_diff(xpparam_t const *xpp, xdfenv_t *env)`: computes the differences between two files using the histogram diff algorithm\n* `xdl_fill_merge_buffer(xdfenv_t *xe1, const char *name1, xdfenv_t *xe2, const char *name2, const char *ancestor_name, int favor, xdmerge_t *m, char *dest, int style, int marker_size)`: fills a merge buffer\n* `xdl_refine_zdiff3_conflicts(xdfenv_t *xe1, xdfenv_t *xe2, xdmerge_t *m, xpparam_t const *xpp)`: refines conflicts for zdiff3\n* `xdl_refine_conflicts(xdfenv_t *xe1, xdfenv_t *xe2, xdmerge_t *m, xpparam_t const *xpp)`: refines conflicts\n* `xdl_simplify_non_conflicts(xdfenv_t *xe1, xdmerge_t *m, int simplify_if_no_alnum)`: simplifies non-conflicts\n* `xdl_do_merge(xdfenv_t *xe1, xdchange_t *xscr1, xdfenv_t *xe2, xdchange_t *xscr2, xmparam_t const *xmp, mmbuffer_t *result)`: performs a merge\n* `xdl_bogosqrt(long n)`: computes the square root of a number\n* `xdl_emit_diffrec(char const *rec, long size, char const *pre, long psize, xdemitcb_t *ecb)`: emits a difference record\n* `xdl_cha_init(chastore_t *cha, long isize, long icount)`: initializes a changed record store\n* `xdl_cha_free(chastore_t *cha)`: frees a changed record store\n* `xdl_cha_alloc(chastore_t *cha)`: allocates a changed record\n* `xdl_guess_lines(mmfile_t *mf, long sample)`: guesses the number of lines in a file\n* `xdl_blankline(const char *line, long size, long flags)`: checks if a line is blank\n* `xdl_recmatch(const char *l1, long s1, const char *l2, long s2, long flags)`: checks if two records match\n* `xdl_hash_record(char const **data, char const *top, long flags)`: computes the hash value of a record\n* `xdl_hashbits(unsigned int size)`: computes the number of hash bits\n* `xdl_num_out(char *out, long val)`: converts a number to a string\n* `xdl_emit_hunk_hdr(long s1, long c1, long s2, long c2, const char *func, long funclen, xdemitcb_t *ecb)`: emits a hunk header\n* `xdl_fall_back_diff(xdfenv_t *diff_env, xpparam_t const *xpp, int line1, int count1, int line2, int count2)`: falls back to a different diff algorithm\n* `xdl_alloc_grow_helper(void *p, long nr, long *alloc, size_t size)`: grows an array\n\n### Flags\n\n* `XDF_NEED_MINIMAL`: flag for minimal diff\n* `XDF_IGNORE_WHITESPACE`: flag for ignoring whitespace\n* `XDF_IGNORE_WHITESPACE_CHANGE`: flag for ignoring whitespace changes\n* `XDF_IGNORE_WHITESPACE_AT_EOL`: flag for ignoring whitespace at end of line\n* `XDF_IGNORE_CR_AT_EOL`: flag for ignoring CR at end of line\n* `XDF_WHITESPACE_FLAGS`: flag for ignoring whitespace\n* `XDF_IGNORE_BLANK_LINES`: flag for ignoring blank lines\n* `XDF_PATIENCE_DIFF`: flag for patience diff\n* `XDF_HISTOGRAM_DIFF`: flag for histogram diff\n* `XDF_DIFF_ALGORITHM_MASK`: mask for diff algorithm\n* `XDF_DIFF_ALG(x)`: gets the diff algorithm\n* `XDF_INDENT_HEURISTIC`: flag for indent heuristic\n* `XDL_EMIT_FUNCNAMES`: flag for emitting function names\n* `XDL_EMIT_NO_HUNK_HDR`: flag for not emitting hunk headers\n* `XDL_EMIT_FUNCCONTEXT`: flag for emitting function context\n\n### Merge Simplification Levels\n\n* `XDL_MERGE_MINIMAL`: minimal merge level\n* `XDL_MERGE_EAGER`: eager merge level\n* `XDL_MERGE_ZEALOUS`: zealous merge level\n* `XDL_MERGE_ZEALOUS_ALNUM`: zealous alnum merge level\n\n### Merge Favor Modes\n\n* `XDL_MERGE_FAVOR_OURS`: favor our changes\n* `XDL_MERGE_FAVOR_THEIRS`: favor their changes\n* `XDL_MERGE_FAVOR_UNION`: favor union of changes\n\n### Merge Output Styles\n\n* `XDL_MERGE_DIFF3`: diff3 output style\n* `XDL_MERGE_ZEALOUS_DIFF3`: zealous diff3 output style\n\n### Macros\n\n* `XDL_MIN(a, b)`: returns the minimum of two values\n* `XDL_MAX(a, b)`: returns the maximum of two values\n* `XDL_ABS(v)`: returns the absolute value of a value\n* `XDL_ISDIGIT(c)`: checks if a character is a digit\n* `XDL_ISSPACE(c)`: checks if a character is a whitespace\n* `XDL_ADDBITS(v,b)`: adds bits to a value\n* `XDL_MASKBITS(b)`: masks bits of a value\n* `XDL_HASHLONG(v,b)`: hashes a long value\n* `XDL_LE32_PUT(p, v)`: puts a 32-bit little-endian value\n* `XDL_LE32_GET(p, v)`: gets a 32-bit little-endian value\n* `XDL_ALLOC_ARRAY(p, nr)`: allocates an array\n* `XDL_CALLOC_ARRAY(p, nr)`: allocates a zeroed-out array\n* `XDL_ALLOC_GROW(p, nr, alloc)`: grows an array\n\n```\n\n**ref/git/xdiff/xdiff.h**\n```\n/*\n *  LibXDiff by Davide Libenzi ( File Differential Library )\n *  Copyright (C) 2003  Davide Libenzi\n *\n *  This library is free software; you can redistribute it and/or\n *  modify it under the terms of the GNU Lesser General Public\n *  License as published by the Free Software Foundation; either\n *  version 2.1 of the License, or (at your option) any later version.\n *\n *  This library is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n *  Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; if not, see\n *  <http://www.gnu.org/licenses/>.\n *\n *  Davide Libenzi <davidel@xmailserver.org>\n *\n */\n\n#if !defined(XDIFF_H)\n#define XDIFF_H\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif /* #ifdef __cplusplus */\n\n/* xpparm_t.flags */\n#define XDF_NEED_MINIMAL (1 << 0)\n\n#define XDF_IGNORE_WHITESPACE (1 << 1)\n#define XDF_IGNORE_WHITESPACE_CHANGE (1 << 2)\n#define XDF_IGNORE_WHITESPACE_AT_EOL (1 << 3)\n#define XDF_IGNORE_CR_AT_EOL (1 << 4)\n#define XDF_WHITESPACE_FLAGS (XDF_IGNORE_WHITESPACE | \\\n\t\t\t      XDF_IGNORE_WHITESPACE_CHANGE | \\\n\t\t\t      XDF_IGNORE_WHITESPACE_AT_EOL | \\\n\t\t\t      XDF_IGNORE_CR_AT_EOL)\n\n#define XDF_IGNORE_BLANK_LINES (1 << 7)\n\n#define XDF_PATIENCE_DIFF (1 << 14)\n#define XDF_HISTOGRAM_DIFF (1 << 15)\n#define XDF_DIFF_ALGORITHM_MASK (XDF_PATIENCE_DIFF | XDF_HISTOGRAM_DIFF)\n#define XDF_DIFF_ALG(x) ((x) & XDF_DIFF_ALGORITHM_MASK)\n\n#define XDF_INDENT_HEURISTIC (1 << 23)\n\n/* xdemitconf_t.flags */\n#define XDL_EMIT_FUNCNAMES (1 << 0)\n#define XDL_EMIT_NO_HUNK_HDR (1 << 1)\n#define XDL_EMIT_FUNCCONTEXT (1 << 2)\n\n/* merge simplification levels */\n#define XDL_MERGE_MINIMAL 0\n#define XDL_MERGE_EAGER 1\n#define XDL_MERGE_ZEALOUS 2\n#define XDL_MERGE_ZEALOUS_ALNUM 3\n\n/* merge favor modes */\n#define XDL_MERGE_FAVOR_OURS 1\n#define XDL_MERGE_FAVOR_THEIRS 2\n#define XDL_MERGE_FAVOR_UNION 3\n\n/* merge output styles */\n#define XDL_MERGE_DIFF3 1\n#define XDL_MERGE_ZEALOUS_DIFF3 2\n\ntypedef struct s_mmfile {\n\tchar *ptr;\n\tlong size;\n} mmfile_t;\n\ntypedef struct s_mmbuffer {\n\tchar *ptr;\n\tlong size;\n} mmbuffer_t;\n\ntypedef struct s_xpparam {\n\tunsigned long flags;\n\n\t/* -I<regex> */\n\tregex_t **ignore_regex;\n\tsize_t ignore_regex_nr;\n\n\t/* See Documentation/diff-options.txt. */\n\tchar **anchors;\n\tsize_t anchors_nr;\n} xpparam_t;\n\ntypedef struct s_xdemitcb {\n\tvoid *priv;\n\tint (*out_hunk)(void *,\n\t\t\tlong old_begin, long old_nr,\n\t\t\tlong new_begin, long new_nr,\n\t\t\tconst char *func, long funclen);\n\tint (*out_line)(void *, mmbuffer_t *, int);\n} xdemitcb_t;\n\ntypedef long (*find_func_t)(const char *line, long line_len, char *buffer, long buffer_size, void *priv);\n\ntypedef int (*xdl_emit_hunk_consume_func_t)(long start_a, long count_a,\n\t\t\t\t\t    long start_b, long count_b,\n\t\t\t\t\t    void *cb_data);\n\ntypedef struct s_xdemitconf {\n\tlong ctxlen;\n\tlong interhunkctxlen;\n\tunsigned long flags;\n\tfind_func_t find_func;\n\tvoid *find_func_priv;\n\txdl_emit_hunk_consume_func_t hunk_func;\n} xdemitconf_t;\n\ntypedef struct s_bdiffparam {\n\tlong bsize;\n} bdiffparam_t;\n\n\n#define xdl_malloc(x) xmalloc(x)\n#define xdl_calloc(n, sz) xcalloc(n, sz)\n#define xdl_free(ptr) free(ptr)\n#define xdl_realloc(ptr,x) xrealloc(ptr,x)\n\nvoid *xdl_mmfile_first(mmfile_t *mmf, long *size);\nlong xdl_mmfile_size(mmfile_t *mmf);\n\nint xdl_diff(mmfile_t *mf1, mmfile_t *mf2, xpparam_t const *xpp,\n\t     xdemitconf_t const *xecfg, xdemitcb_t *ecb);\n\ntypedef struct s_xmparam {\n\txpparam_t xpp;\n\tint marker_size;\n\tint level;\n\tint favor;\n\tint style;\n\tconst char *ancestor;\t/* label for orig */\n\tconst char *file1;\t/* label for mf1 */\n\tconst char *file2;\t/* label for mf2 */\n} xmparam_t;\n\n#define DEFAULT_CONFLICT_MARKER_SIZE 7\n\nint xdl_merge(mmfile_t *orig, mmfile_t *mf1, mmfile_t *mf2,\n\t\txmparam_t const *xmp, mmbuffer_t *result);\n\n#ifdef __cplusplus\n}\n#endif /* #ifdef __cplusplus */\n\n#endif /* #if !defined(XDIFF_H) */\n\n```\n\n**ref/git/xdiff/xpatience.c**\n```\n/*\n *  LibXDiff by Davide Libenzi ( File Differential Library )\n *  Copyright (C) 2003-2016 Davide Libenzi, Johannes E. Schindelin\n *\n *  This library is free software; you can redistribute it and/or\n *  modify it under the terms of the GNU Lesser General Public\n *  License as published by the Free Software Foundation; either\n *  version 2.1 of the License, or (at your option) any later version.\n *\n *  This library is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n *  Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; if not, see\n *  <http://www.gnu.org/licenses/>.\n *\n *  Davide Libenzi <davidel@xmailserver.org>\n *\n */\n#include \"xinclude.h\"\n\n/*\n * The basic idea of patience diff is to find lines that are unique in\n * both files.  These are intuitively the ones that we want to see as\n * common lines.\n *\n * The maximal ordered sequence of such line pairs (where ordered means\n * that the order in the sequence agrees with the order of the lines in\n * both files) naturally defines an initial set of common lines.\n *\n * Now, the algorithm tries to extend the set of common lines by growing\n * the line ranges where the files have identical lines.\n *\n * Between those common lines, the patience diff algorithm is applied\n * recursively, until no unique line pairs can be found; these line ranges\n * are handled by the well-known Myers algorithm.\n */\n\n#define NON_UNIQUE ULONG_MAX\n\n/*\n * This is a hash mapping from line hash to line numbers in the first and\n * second file.\n */\nstruct hashmap {\n\tint nr, alloc;\n\tstruct entry {\n\t\tunsigned long hash;\n\t\t/*\n\t\t * 0 = unused entry, 1 = first line, 2 = second, etc.\n\t\t * line2 is NON_UNIQUE if the line is not unique\n\t\t * in either the first or the second file.\n\t\t */\n\t\tunsigned long line1, line2;\n\t\t/*\n\t\t * \"next\" & \"previous\" are used for the longest common\n\t\t * sequence;\n\t\t * initially, \"next\" reflects only the order in file1.\n\t\t */\n\t\tstruct entry *next, *previous;\n\n\t\t/*\n\t\t * If 1, this entry can serve as an anchor. See\n\t\t * Documentation/diff-options.txt for more information.\n\t\t */\n\t\tunsigned anchor : 1;\n\t} *entries, *first, *last;\n\t/* were common records found? */\n\tunsigned long has_matches;\n\txdfenv_t *env;\n\txpparam_t const *xpp;\n};\n\nstatic int is_anchor(xpparam_t const *xpp, const char *line)\n{\n\tint i;\n\tfor (i = 0; i < xpp->anchors_nr; i++) {\n\t\tif (!strncmp(line, xpp->anchors[i], strlen(xpp->anchors[i])))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n/* The argument \"pass\" is 1 for the first file, 2 for the second. */\nstatic void insert_record(xpparam_t const *xpp, int line, struct hashmap *map,\n\t\t\t  int pass)\n{\n\txrecord_t **records = pass == 1 ?\n\t\tmap->env->xdf1.recs : map->env->xdf2.recs;\n\txrecord_t *record = records[line - 1];\n\t/*\n\t * After xdl_prepare_env() (or more precisely, due to\n\t * xdl_classify_record()), the \"ha\" member of the records (AKA lines)\n\t * is _not_ the hash anymore, but a linearized version of it.  In\n\t * other words, the \"ha\" member is guaranteed to start with 0 and\n\t * the second record's ha can only be 0 or 1, etc.\n\t *\n\t * So we multiply ha by 2 in the hope that the hashing was\n\t * \"unique enough\".\n\t */\n\tint index = (int)((record->ha << 1) % map->alloc);\n\n\twhile (map->entries[index].line1) {\n\t\tif (map->entries[index].hash != record->ha) {\n\t\t\tif (++index >= map->alloc)\n\t\t\t\tindex = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (pass == 2)\n\t\t\tmap->has_matches = 1;\n\t\tif (pass == 1 || map->entries[index].line2)\n\t\t\tmap->entries[index].line2 = NON_UNIQUE;\n\t\telse\n\t\t\tmap->entries[index].line2 = line;\n\t\treturn;\n\t}\n\tif (pass == 2)\n\t\treturn;\n\tmap->entries[index].line1 = line;\n\tmap->entries[index].hash = record->ha;\n\tmap->entries[index].anchor = is_anchor(xpp, map->env->xdf1.recs[line - 1]->ptr);\n\tif (!map->first)\n\t\tmap->first = map->entries + index;\n\tif (map->last) {\n\t\tmap->last->next = map->entries + index;\n\t\tmap->entries[index].previous = map->last;\n\t}\n\tmap->last = map->entries + index;\n\tmap->nr++;\n}\n\n/*\n * This function has to be called for each recursion into the inter-hunk\n * parts, as previously non-unique lines can become unique when being\n * restricted to a smaller part of the files.\n *\n * It is assumed that env has been prepared using xdl_prepare().\n */\nstatic int fill_hashmap(xpparam_t const *xpp, xdfenv_t *env,\n\t\tstruct hashmap *result,\n\t\tint line1, int count1, int line2, int count2)\n{\n\tresult->xpp = xpp;\n\tresult->env = env;\n\n\t/* We know exactly how large we want the hash map */\n\tresult->alloc = count1 * 2;\n\tif (!XDL_CALLOC_ARRAY(result->entries, result->alloc))\n\t\treturn -1;\n\n\t/* First, fill with entries from the first file */\n\twhile (count1--)\n\t\tinsert_record(xpp, line1++, result, 1);\n\n\t/* Then search for matches in the second file */\n\twhile (count2--)\n\t\tinsert_record(xpp, line2++, result, 2);\n\n\treturn 0;\n}\n\n/*\n * Find the longest sequence with a smaller last element (meaning a smaller\n * line2, as we construct the sequence with entries ordered by line1).\n */\nstatic int binary_search(struct entry **sequence, int longest,\n\t\tstruct entry *entry)\n{\n\tint left = -1, right = longest;\n\n\twhile (left + 1 < right) {\n\t\tint middle = left + (right - left) / 2;\n\t\t/* by construction, no two entries can be equal */\n\t\tif (sequence[middle]->line2 > entry->line2)\n\t\t\tright = middle;\n\t\telse\n\t\t\tleft = middle;\n\t}\n\t/* return the index in \"sequence\", _not_ the sequence length */\n\treturn left;\n}\n\n/*\n * The idea is to start with the list of common unique lines sorted by\n * the order in file1.  For each of these pairs, the longest (partial)\n * sequence whose last element's line2 is smaller is determined.\n *\n * For efficiency, the sequences are kept in a list containing exactly one\n * item per sequence length: the sequence with the smallest last\n * element (in terms of line2).\n */\nstatic int find_longest_common_sequence(struct hashmap *map, struct entry **res)\n{\n\tstruct entry **sequence;\n\tint longest = 0, i;\n\tstruct entry *entry;\n\n\t/*\n\t * If not -1, this entry in sequence must never be overridden.\n\t * Therefore, overriding entries before this has no effect, so\n\t * do not do that either.\n\t */\n\tint anchor_i = -1;\n\n\tif (!XDL_ALLOC_ARRAY(sequence, map->nr))\n\t\treturn -1;\n\n\tfor (entry = map->first; entry; entry = entry->next) {\n\t\tif (!entry->line2 || entry->line2 == NON_UNIQUE)\n\t\t\tcontinue;\n\t\ti = binary_search(sequence, longest, entry);\n\t\tentry->previous = i < 0 ? NULL : sequence[i];\n\t\t++i;\n\t\tif (i <= anchor_i)\n\t\t\tcontinue;\n\t\tsequence[i] = entry;\n\t\tif (entry->anchor) {\n\t\t\tanchor_i = i;\n\t\t\tlongest = anchor_i + 1;\n\t\t} else if (i == longest) {\n\t\t\tlongest++;\n\t\t}\n\t}\n\n\t/* No common unique lines were found */\n\tif (!longest) {\n\t\t*res = NULL;\n\t\txdl_free(sequence);\n\t\treturn 0;\n\t}\n\n\t/* Iterate starting at the last element, adjusting the \"next\" members */\n\tentry = sequence[longest - 1];\n\tentry->next = NULL;\n\twhile (entry->previous) {\n\t\tentry->previous->next = entry;\n\t\tentry = entry->previous;\n\t}\n\t*res = entry;\n\txdl_free(sequence);\n\treturn 0;\n}\n\nstatic int match(struct hashmap *map, int line1, int line2)\n{\n\txrecord_t *record1 = map->env->xdf1.recs[line1 - 1];\n\txrecord_t *record2 = map->env->xdf2.recs[line2 - 1];\n\treturn record1->ha == record2->ha;\n}\n\nstatic int patience_diff(xpparam_t const *xpp, xdfenv_t *env,\n\t\tint line1, int count1, int line2, int count2);\n\nstatic int walk_common_sequence(struct hashmap *map, struct entry *first,\n\t\tint line1, int count1, int line2, int count2)\n{\n\tint end1 = line1 + count1, end2 = line2 + count2;\n\tint next1, next2;\n\n\tfor (;;) {\n\t\t/* Try to grow the line ranges of common lines */\n\t\tif (first) {\n\t\t\tnext1 = first->line1;\n\t\t\tnext2 = first->line2;\n\t\t\twhile (next1 > line1 && next2 > line2 &&\n\t\t\t\t\tmatch(map, next1 - 1, next2 - 1)) {\n\t\t\t\tnext1--;\n\t\t\t\tnext2--;\n\t\t\t}\n\t\t} else {\n\t\t\tnext1 = end1;\n\t\t\tnext2 = end2;\n\t\t}\n\t\twhile (line1 < next1 && line2 < next2 &&\n\t\t\t\tmatch(map, line1, line2)) {\n\t\t\tline1++;\n\t\t\tline2++;\n\t\t}\n\n\t\t/* Recurse */\n\t\tif (next1 > line1 || next2 > line2) {\n\t\t\tif (patience_diff(map->xpp, map->env,\n\t\t\t\t\tline1, next1 - line1,\n\t\t\t\t\tline2, next2 - line2))\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tif (!first)\n\t\t\treturn 0;\n\n\t\twhile (first->next &&\n\t\t\t\tfirst->next->line1 == first->line1 + 1 &&\n\t\t\t\tfirst->next->line2 == first->line2 + 1)\n\t\t\tfirst = first->next;\n\n\t\tline1 = first->line1 + 1;\n\t\tline2 = first->line2 + 1;\n\n\t\tfirst = first->next;\n\t}\n}\n\nstatic int fall_back_to_classic_diff(struct hashmap *map,\n\t\tint line1, int count1, int line2, int count2)\n{\n\txpparam_t xpp;\n\n\tmemset(&xpp, 0, sizeof(xpp));\n\txpp.flags = map->xpp->flags & ~XDF_DIFF_ALGORITHM_MASK;\n\n\treturn xdl_fall_back_diff(map->env, &xpp,\n\t\t\t\t  line1, count1, line2, count2);\n}\n\n/*\n * Recursively find the longest common sequence of unique lines,\n * and if none was found, ask xdl_do_diff() to do the job.\n *\n * This function assumes that env was prepared with xdl_prepare_env().\n */\nstatic int patience_diff(xpparam_t const *xpp, xdfenv_t *env,\n\t\tint line1, int count1, int line2, int count2)\n{\n\tstruct hashmap map;\n\tstruct entry *first;\n\tint result = 0;\n\n\t/* trivial case: one side is empty */\n\tif (!count1) {\n\t\twhile(count2--)\n\t\t\tenv->xdf2.rchg[line2++ - 1] = 1;\n\t\treturn 0;\n\t} else if (!count2) {\n\t\twhile(count1--)\n\t\t\tenv->xdf1.rchg[line1++ - 1] = 1;\n\t\treturn 0;\n\t}\n\n\tmemset(&map, 0, sizeof(map));\n\tif (fill_hashmap(xpp, env, &map,\n\t\t\tline1, count1, line2, count2))\n\t\treturn -1;\n\n\t/* are there any matching lines at all? */\n\tif (!map.has_matches) {\n\t\twhile(count1--)\n\t\t\tenv->xdf1.rchg[line1++ - 1] = 1;\n\t\twhile(count2--)\n\t\t\tenv->xdf2.rchg[line2++ - 1] = 1;\n\t\txdl_free(map.entries);\n\t\treturn 0;\n\t}\n\n\tresult = find_longest_common_sequence(&map, &first);\n\tif (result)\n\t\tgoto out;\n\tif (first)\n\t\tresult = walk_common_sequence(&map, first,\n\t\t\tline1, count1, line2, count2);\n\telse\n\t\tresult = fall_back_to_classic_diff(&map,\n\t\t\tline1, count1, line2, count2);\n out:\n\txdl_free(map.entries);\n\treturn result;\n}\n\nint xdl_do_patience_diff(xpparam_t const *xpp, xdfenv_t *env)\n{\n\treturn patience_diff(xpp, env, 1, env->xdf1.nrec, 1, env->xdf2.nrec);\n}\n\n```<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\n","ts":1.738870802433E9}
{"completion":"After reviewing the provided code and documentation, I have identified some missing information in the `doc.txt` file. Here are the updates:\n\n**Data Structures**\n\n* `hashmap`: a hash mapping from line hash to line numbers in the first and second file\n\t+ `int nr`: number of entries in the hashmap\n\t+ `int alloc`: allocated size of the hashmap\n\t+ `struct entry *entries`: array of entries in the hashmap\n\t+ `struct entry *first`: first entry in the hashmap\n\t+ `struct entry *last`: last entry in the hashmap\n\t+ `unsigned long has_matches`: flag indicating whether common records were found\n\t+ `xdfenv_t *env`: environment for the xdiff algorithm\n\t+ `xpparam_t const *xpp`: parameters for the xdiff algorithm\n* `entry`: an entry in the hashmap\n\t+ `unsigned long hash`: hash value of the line\n\t+ `unsigned long line1`: line number in the first file\n\t+ `unsigned long line2`: line number in the second file\n\t+ `struct entry *next`: next entry in the hashmap\n\t+ `struct entry *previous`: previous entry in the hashmap\n\t+ `unsigned anchor`: flag indicating whether the entry can serve as an anchor\n\n**Functions**\n\n* `fill_hashmap(xpparam_t const *xpp, xdfenv_t *env, struct hashmap *result, int line1, int count1, int line2, int count2)`: fills a hashmap with entries from the first and second files\n* `find_longest_common_sequence(struct hashmap *map, struct entry **res)`: finds the longest common sequence of unique lines in the hashmap\n* `walk_common_sequence(struct hashmap *map, struct entry *first, int line1, int count1, int line2, int count2)`: walks the common sequence of unique lines in the hashmap\n* `patience_diff(xpparam_t const *xpp, xdfenv_t *env, int line1, int count1, int line2, int count2)`: recursively finds the longest common sequence of unique lines\n* `fall_back_to_classic_diff(struct hashmap *map, int line1, int count1, int line2, int count2)`: falls back to the classic diff algorithm if no common unique lines are found\n\n**Macros**\n\n* `NON_UNIQUE`: a special value indicating that a line is not unique in either file\n\nThese updates should provide a more complete and accurate documentation of the xdiff library's public interface.","ts":1.738870822131E9}
