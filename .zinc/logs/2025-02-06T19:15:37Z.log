{"prompt":"<|begin_of_text|><|start_header_id|>user<|end_header_id|>\n\nUpdate xdiffpp.hpp to remove the information in the README. Instead add clear documentation of function parameters.\n\n**README.md**\n```\n# xdiffpp\n\nA C++ wrapper for the xdiff library, providing a modern and easy-to-use interface for file differential functionality.\n\n## Overview\n\nxdiffpp is a C++ wrapper for the xdiff library, which is a file differential library used in the Git project. The goal of xdiffpp is to provide a modern and easy-to-use C++ interface to the xdiff library, making it easier for developers to integrate xdiff functionality into their applications.\n\n## Usage\n\n### Producing a Diff\n\n1. Create two `MemoryFile` objects, one for the old file and one for the new file.\n2. Initialize the `MemoryFile` objects using the `init()` method.\n3. Write the file contents to the `MemoryFile` objects using the `write()` method.\n4. Create a `Diff` object and call the `createDiff()` method, passing in the two `MemoryFile` objects and any desired diff options.\n5. The diff output will be emitted through the `xdemitcb_t` callback function.\n\n### Applying a Patch\n\n1. Create a `MemoryFile` object for the old file and a `MemoryFile` object for the patch file.\n2. Initialize the `MemoryFile` objects using the `init()` method.\n3. Write the file contents to the `MemoryFile` objects using the `write()` method.\n4. Create a `Patch` object and call the `applyPatch()` method, passing in the two `MemoryFile` objects and any desired patch options.\n5. The patched output will be emitted through the `xdemitcb_t` callback function.\n\n### Merging Three Files\n\n1. Create three `MemoryFile` objects, one for the original file and two for the modified files.\n2. Initialize the `MemoryFile` objects using the `init()` method.\n3. Write the file contents to the `MemoryFile` objects using the `write()` method.\n4. Create a `Merge` object and call the `merge()` method, passing in the three `MemoryFile` objects and any desired merge options.\n5. The merged output will be emitted through the `xdemitcb_t` callback function.\n\n## Building and Installation\n\nxdiffpp uses CMake as its build system. To build and install xdiffpp, follow these steps:\n\n1. Clone the xdiffpp repository.\n2. Create a build directory and navigate to it.\n3. Run `cmake ..` to generate the build files.\n4. Run `cmake --build .` to build xdiffpp.\n5. Run `cmake --install .` to install xdiffpp.\n\n## Dependencies\n\nxdiffpp depends on the xdiff library. You can choose to use one of the following xdiff libraries:\n\n* git_xdiff\n* xdiff\n* libxdiff\n\nSelect the desired xdiff library when running CMake.\n\n```\n\n**include/xdiffpp.hpp**\n```\n#ifndef XDIFFPP_H\n#define XDIFFPP_H\n\n#include <xdiff.h>\n\nnamespace xdiffpp {\n\n// Forward declarations\nclass MemoryFile;\nclass Diff;\nclass Patch;\nclass Merge;\n\n// MemoryFile class\nclass MemoryFile {\npublic:\n    MemoryFile();\n    ~MemoryFile();\n\n    // Initialize the memory file\n    void init(long bsize, unsigned long flags);\n\n    // Free the memory file\n    void free();\n\n    // Check if the memory file is compact\n    bool isCompact() const;\n\n    // Get the size of the memory file\n    long size() const;\n\n    // Read from the memory file\n    long read(void* data, long size);\n\n    // Write to the memory file\n    long write(const void* data, long size);\n\n    // Add a user-specified block to the memory file\n    long addBlock(char* ptr, long size, unsigned long flags);\n\n    // Get the first block of the memory file\n    void* firstBlock(long* size);\n\n    // Get the next block of the memory file\n    void* nextBlock(long* size);\n\nprivate:\n    mmfile_t mmf_;\n};\n\n// Diff class\nclass Diff {\npublic:\n    Diff();\n    ~Diff();\n\n    // Create a diff between two memory files\n    int createDiff(MemoryFile& oldFile, MemoryFile& newFile, xpparam_t const* xpp, xdemitconf_t const* xecfg, xdemitcb_t* ecb);\n\nprivate:\n    xpparam_t xpp_;\n    xdemitconf_t xecfg_;\n    xdemitcb_t ecb_;\n};\n\n// Patch class\nclass Patch {\npublic:\n    Patch();\n    ~Patch();\n\n    // Apply a patch to a memory file\n    int applyPatch(MemoryFile& oldFile, MemoryFile& patchFile, int mode, xdemitcb_t* ecb, xdemitcb_t* rjecb);\n\nprivate:\n    xdemitcb_t ecb_;\n    xdemitcb_t rjecb_;\n};\n\n// Merge class\nclass Merge {\npublic:\n    Merge();\n    ~Merge();\n\n    // Merge three memory files\n    int merge(MemoryFile& origFile, MemoryFile& file1, MemoryFile& file2, xdemitcb_t* ecb, xdemitcb_t* rjecb);\n\nprivate:\n    xdemitcb_t ecb_;\n    xdemitcb_t rjecb_;\n};\n\n// Usage instructions\n// ==================\n//\n// To produce a diff:\n// 1. Create two MemoryFile objects, one for the old file and one for the new file.\n// 2. Initialize the MemoryFile objects using the init() method.\n// 3. Write the file contents to the MemoryFile objects using the write() method.\n// 4. Create a Diff object and call the createDiff() method, passing in the two MemoryFile objects and any desired diff options.\n// 5. The diff output will be emitted through the xdemitcb_t callback function.\n//\n// To apply a patch:\n// 1. Create a MemoryFile object for the old file and a MemoryFile object for the patch file.\n// 2. Initialize the MemoryFile objects using the init() method.\n// 3. Write the file contents to the MemoryFile objects using the write() method.\n// 4. Create a Patch object and call the applyPatch() method, passing in the two MemoryFile objects and any desired patch options.\n// 5. The patched output will be emitted through the xdemitcb_t callback function.\n//\n// To merge three files:\n// 1. Create three MemoryFile objects, one for the original file and two for the modified files.\n// 2. Initialize the MemoryFile objects using the init() method.\n// 3. Write the file contents to the MemoryFile objects using the write() method.\n// 4. Create a Merge object and call the merge() method, passing in the three MemoryFile objects and any desired merge options.\n// 5. The merged output will be emitted through the xdemitcb_t callback function.\n\n} // namespace xdiffpp\n\n#endif // XDIFFPP_H\n\n```\n\n**ref/git/xdiff/xdiff.h**\n```\n/*\n *  LibXDiff by Davide Libenzi ( File Differential Library )\n *  Copyright (C) 2003  Davide Libenzi\n *\n *  This library is free software; you can redistribute it and/or\n *  modify it under the terms of the GNU Lesser General Public\n *  License as published by the Free Software Foundation; either\n *  version 2.1 of the License, or (at your option) any later version.\n *\n *  This library is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n *  Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; if not, see\n *  <http://www.gnu.org/licenses/>.\n *\n *  Davide Libenzi <davidel@xmailserver.org>\n *\n */\n\n#if !defined(XDIFF_H)\n#define XDIFF_H\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif /* #ifdef __cplusplus */\n\n/* xpparm_t.flags */\n#define XDF_NEED_MINIMAL (1 << 0)\n\n#define XDF_IGNORE_WHITESPACE (1 << 1)\n#define XDF_IGNORE_WHITESPACE_CHANGE (1 << 2)\n#define XDF_IGNORE_WHITESPACE_AT_EOL (1 << 3)\n#define XDF_IGNORE_CR_AT_EOL (1 << 4)\n#define XDF_WHITESPACE_FLAGS (XDF_IGNORE_WHITESPACE | \\\n\t\t\t      XDF_IGNORE_WHITESPACE_CHANGE | \\\n\t\t\t      XDF_IGNORE_WHITESPACE_AT_EOL | \\\n\t\t\t      XDF_IGNORE_CR_AT_EOL)\n\n#define XDF_IGNORE_BLANK_LINES (1 << 7)\n\n#define XDF_PATIENCE_DIFF (1 << 14)\n#define XDF_HISTOGRAM_DIFF (1 << 15)\n#define XDF_DIFF_ALGORITHM_MASK (XDF_PATIENCE_DIFF | XDF_HISTOGRAM_DIFF)\n#define XDF_DIFF_ALG(x) ((x) & XDF_DIFF_ALGORITHM_MASK)\n\n#define XDF_INDENT_HEURISTIC (1 << 23)\n\n/* xdemitconf_t.flags */\n#define XDL_EMIT_FUNCNAMES (1 << 0)\n#define XDL_EMIT_NO_HUNK_HDR (1 << 1)\n#define XDL_EMIT_FUNCCONTEXT (1 << 2)\n\n/* merge simplification levels */\n#define XDL_MERGE_MINIMAL 0\n#define XDL_MERGE_EAGER 1\n#define XDL_MERGE_ZEALOUS 2\n#define XDL_MERGE_ZEALOUS_ALNUM 3\n\n/* merge favor modes */\n#define XDL_MERGE_FAVOR_OURS 1\n#define XDL_MERGE_FAVOR_THEIRS 2\n#define XDL_MERGE_FAVOR_UNION 3\n\n/* merge output styles */\n#define XDL_MERGE_DIFF3 1\n#define XDL_MERGE_ZEALOUS_DIFF3 2\n\ntypedef struct s_mmfile {\n\tchar *ptr;\n\tlong size;\n} mmfile_t;\n\ntypedef struct s_mmbuffer {\n\tchar *ptr;\n\tlong size;\n} mmbuffer_t;\n\ntypedef struct s_xpparam {\n\tunsigned long flags;\n\n\t/* -I<regex> */\n\tregex_t **ignore_regex;\n\tsize_t ignore_regex_nr;\n\n\t/* See Documentation/diff-options.txt. */\n\tchar **anchors;\n\tsize_t anchors_nr;\n} xpparam_t;\n\ntypedef struct s_xdemitcb {\n\tvoid *priv;\n\tint (*out_hunk)(void *,\n\t\t\tlong old_begin, long old_nr,\n\t\t\tlong new_begin, long new_nr,\n\t\t\tconst char *func, long funclen);\n\tint (*out_line)(void *, mmbuffer_t *, int);\n} xdemitcb_t;\n\ntypedef long (*find_func_t)(const char *line, long line_len, char *buffer, long buffer_size, void *priv);\n\ntypedef int (*xdl_emit_hunk_consume_func_t)(long start_a, long count_a,\n\t\t\t\t\t    long start_b, long count_b,\n\t\t\t\t\t    void *cb_data);\n\ntypedef struct s_xdemitconf {\n\tlong ctxlen;\n\tlong interhunkctxlen;\n\tunsigned long flags;\n\tfind_func_t find_func;\n\tvoid *find_func_priv;\n\txdl_emit_hunk_consume_func_t hunk_func;\n} xdemitconf_t;\n\ntypedef struct s_bdiffparam {\n\tlong bsize;\n} bdiffparam_t;\n\n\n#define xdl_malloc(x) xmalloc(x)\n#define xdl_calloc(n, sz) xcalloc(n, sz)\n#define xdl_free(ptr) free(ptr)\n#define xdl_realloc(ptr,x) xrealloc(ptr,x)\n\nvoid *xdl_mmfile_first(mmfile_t *mmf, long *size);\nlong xdl_mmfile_size(mmfile_t *mmf);\n\nint xdl_diff(mmfile_t *mf1, mmfile_t *mf2, xpparam_t const *xpp,\n\t     xdemitconf_t const *xecfg, xdemitcb_t *ecb);\n\ntypedef struct s_xmparam {\n\txpparam_t xpp;\n\tint marker_size;\n\tint level;\n\tint favor;\n\tint style;\n\tconst char *ancestor;\t/* label for orig */\n\tconst char *file1;\t/* label for mf1 */\n\tconst char *file2;\t/* label for mf2 */\n} xmparam_t;\n\n#define DEFAULT_CONFLICT_MARKER_SIZE 7\n\nint xdl_merge(mmfile_t *orig, mmfile_t *mf1, mmfile_t *mf2,\n\t\txmparam_t const *xmp, mmbuffer_t *result);\n\n#ifdef __cplusplus\n}\n#endif /* #ifdef __cplusplus */\n\n#endif /* #if !defined(XDIFF_H) */\n\n```\n\n**ref/libxdiff/man/xdiff.txt**\n```\nLibXDiff(3)                File Differential Library               LibXDiff(3)\n\n\n\nNAME\n       xdl_set_allocator, xdl_malloc, xdl_free, xdl_realloc, xdl_init_mmfile,\n       xdl_free_mmfile, xdl_mmfile_iscompact, xdl_seek_mmfile,\n       xdl_read_mmfile, xdl_write_mmfile, xdl_writem_mmfile,\n       xdl_mmfile_writeallocate, xdl_mmfile_ptradd, xdl_mmfile_first,\n       xdl_mmfile_next, xdl_mmfile_size, xdl_mmfile_cmp, xdl_mmfile_compact,\n       xdl_diff, xdl_patch, xdl_merge3, xdl_bdiff_mb, xdl_bdiff, xdl_rabd-\n       iff_mb, xdl_rabdiff, xdl_bdiff_tgsize, xdl_bpatch - File Differential\n       Library support functions\n\n\nSYNOPSIS\n       #include <xdiff.h>\n\n       int xdl_set_allocator(memallocator_t const *malt);\n       void *xdl_malloc(unsigned int size);\n       void xdl_free(void *ptr);\n       void *xdl_realloc(void *ptr, unsigned int nsize);\n       int xdl_init_mmfile(mmfile_t *mmf, long bsize, unsigned long flags);\n       void xdl_free_mmfile(mmfile_t *mmf);\n       int xdl_mmfile_iscompact(mmfile_t *mmf);\n       int xdl_seek_mmfile(mmfile_t *mmf, long off);\n       long xdl_read_mmfile(mmfile_t *mmf, void *data, long size);\n       long xdl_write_mmfile(mmfile_t *mmf, void const *data, long size);\n       long xdl_writem_mmfile(mmfile_t *mmf, mmbuffer_t *mb, int nbuf);\n       void *xdl_mmfile_writeallocate(mmfile_t *mmf, long size);\n       long xdl_mmfile_ptradd(mmfile_t *mmf, char *ptr, long size, unsigned long flags);\n       void *xdl_mmfile_first(mmfile_t *mmf, long *size);\n       void *xdl_mmfile_next(mmfile_t *mmf, long *size);\n       long xdl_mmfile_size(mmfile_t *mmf);\n       int xdl_mmfile_cmp(mmfile_t *mmf1, mmfile_t *mmf2);\n       int xdl_mmfile_compact(mmfile_t *mmfo, mmfile_t *mmfc, long bsize, unsigned long flags);\n       int xdl_diff(mmfile_t *mmf1, mmfile_t *mmf2, xpparam_t const *xpp, xdemitconf_t const *xecfg, xdemitcb_t *ecb);\n       int xdl_patch(mmfile_t *mmf, mmfile_t *mmfp, int mode, xdemitcb_t *ecb, xdemitcb_t *rjecb);\n       int xdl_merge3(mmfile_t *mmfo, mmfile_t *mmf1, mmfile_t *mmf2, xdemitcb_t *ecb, xdemitcb_t *rjecb);\n       int xdl_bdiff_mb(mmbuffer_t *mmb1, mmbuffer_t *mmb2, bdiffparam_t const *bdp, xdemitcb_t *ecb);\n       int xdl_bdiff(mmfile_t *mmf1, mmfile_t *mmf2, bdiffparam_t const *bdp, xdemitcb_t *ecb);\n       int xdl_rabdiff_mb(mmbuffer_t *mmb1, mmbuffer_t *mmb2, xdemitcb_t *ecb);\n       int xdl_rabdiff(mmfile_t *mmf1, mmfile_t *mmf2, xdemitcb_t *ecb);\n       long xdl_bdiff_tgsize(mmfile_t *mmfp);\n       int xdl_bpatch(mmfile_t *mmf, mmfile_t *mmfp, xdemitcb_t *ecb);\n\n\nDESCRIPTION\n       The LibXDiff library implements basic and yet complete functionalities\n       to create file differences/patches to both binary and text files. The\n       library uses memory files as file abstraction to achieve both perfor-\n       mance and portability. For binary files, LibXDiff implements both (with\n       some modification) the algorithm described in File System Support for\n       Delta Compression by Joshua P. MacDonald, and the method described in\n       Fingerprinting by Random Polynomials by Michael O. Rabin.  While for\n       text files it follows directives described in An O(ND) Difference Algo-\n       rithm and Its Variations by Eugene W. Myers.  Memory files used by the\n       library are basically a collection of buffers that store the file con-\n       tent. There are two different requirements for memory files when passed\n       to diff/patch functions. Text files for diff/patch functions require\n       that a single line do not have to spawn across two different memory\n       file blocks. Binary diff/patch functions require memory files to be\n       compact.  A compact memory files is a file whose content is stored\n       inside a single block.  Functionalities inside the library are avail-\n       able to satisfy these rules.  Using the XDL_MMF_ATOMIC memory file flag\n       it is possible to make writes to not split the written record across\n       different blocks, while the functions xdl_mmfile_iscompact() ,\n       xdl_mmfile_compact() and xdl_mmfile_writeallocate() are usefull to test\n       if the file is compact and to create a compacted version of the file\n       itself. The text file differential output uses the raw unified output\n       format, by omitting the file header since the result is always relative\n       to a single compare operation (between two files). The output format of\n       the binary patch file is proprietary (and binary) and it is basically a\n       collection of copy and insert commands, like described inside the Mac-\n       Donald paper.\n\n\n\n   Functions\n       The following functions are defined:\n\n       int xdl_set_allocator(memallocator_t const *malt);\n\n              The LibXDiff library enable the user to set its own memory allo-\n              cator, that will be used for all the following memory requests.\n              The allocator must be set before to start calling the LibXDiff\n              library with a call to xdl_set_allocator().  The memory alloca-\n              tor structure contains the following members:\n\n                   typedef struct s_memallocator {\n                        void *priv;\n                        void *(*malloc)(void *priv, unsigned int size);\n                        void (*free)(void *priv, void *ptr);\n                        void *(*realloc)(void *priv, void *ptr, unsigned int nsize);\n                   } memallocator_t;\n\n              The malloc() function pointer will be used by LibXDiff to\n              request a memory block of size bytes. The free() function\n              pointer will be called to free a previously allocated block ptr\n              , while the realloc() will be used to resize the ptr to a new\n              nsize size in bytes. The priv structure member will be passed to\n              the malloc(),free(),realloc() functions as first parameter. The\n              LibXDiff user must call xdl_set_allocator() before starting\n              using the library, otherwise LibXDiff functions will fail due to\n              the lack of memory allocation support.  A typical initialization\n              sequence for POSIX systems will use the standard malloc(3),\n              free(3), realloc(3) and will look like:\n\n                   void *wrap_malloc(void *priv, unsigned int size) {\n                        return malloc(size);\n                   }\n\n                   void wrap_free(void *priv, void *ptr) {\n                        free(ptr);\n                   }\n\n                   void *wrap_realloc(void *priv, void *ptr, unsigned int size) {\n                        return realloc(ptr, size);\n                   }\n\n                   void my_init_xdiff(void) {\n                        memallocator_t malt;\n\n                        malt.priv = NULL;\n                        malt.malloc = wrap_malloc;\n                        malt.free = wrap_free;\n                        malt.realloc = wrap_realloc;\n                        xdl_set_allocator(&malt);\n                   }\n\n\n\n       void *xdl_malloc(unsigned int size);\n\n              Allocates a memory block of size bytes using the LibXDiff memory\n              allocator. The user can specify its own allocator using the\n              xdl_set_allocator() function. The xdl_malloc() return a pointer\n              to the newly allocated block, or NULL in case of failure.\n\n\n       void xdl_free(void *ptr);\n\n              Free a previously allocated memory block pointed by ptr.  The\n              ptr block must has been allocated using either xdl_malloc() or\n              xdl_realloc().\n\n\n       void *xdl_realloc(void *ptr, unsigned int nsize);\n\n              Resizes the memory block pointed by ptr to a new size nsize.\n              Return the resized block if successful, or NULL in case the\n              reallocation fails. After a successful reallocation, the old ptr\n              block is to be considered no more valid.\n\n\n       int xdl_init_mmfile(mmfile_t *mmf, long bsize, unsigned long flags);\n\n              Initialize the memory file mmf by requiring an internal block\n              size of bsize.  The flags parameter is a combination of the fol-\n              lowing flags :\n\n              XDL_MMF_ATOMIC Writes on the memory file will be atomic. That\n              is, the data will not be split on two or more different blocks.\n\n              Once an xdl_init_mmfile() succeeded, a matching\n              xdl_free_mmfile() must be called when the user has done using\n              the memory file, otherwise serious memory leaks will happen.\n              The function return 0 if succeed or -1 if an error is encoun-\n              tered.\n\n\n       void xdl_free_mmfile(mmfile_t *mmf);\n\n              Free all the data associated with the mmf memory file.\n\n\n       int xdl_mmfile_iscompact(mmfile_t *mmf);\n\n              Returns an integer different from 0 if the mmf memory file is\n              compact, 0 otherwise. A compact memory file is one that have the\n              whole content stored inside a single block.\n\n\n       int xdl_seek_mmfile(mmfile_t *mmf, long off);\n\n              Set the current data pointer of the memory file mmf to the spec-\n              ified offset off from the beginning of the file itself. Returns\n              0 if successful or -1 if an error happened.\n\n\n       long xdl_read_mmfile(mmfile_t *mmf, void *data, long size);\n\n              Request to read size bytes from the memory file mmf by storing\n              the data inside the data buffer. Returns the number of bytes\n              read into the data buffer. The amount of data read can be lower\n              than the specified size.  The function returns -1 if an error\n              happened.\n\n\n       long xdl_write_mmfile(mmfile_t *mmf, void const *data, long size);\n\n              Request to write size bytes from the specified buffer data into\n              the memory file mmf.  If the memory file has been created using\n              the XDL_MMF_ATOMIC flag, the write request will not be split\n              across different blocks.  Note that all write operations done on\n              memory files do append data at the end the file, and writes in\n              the middle of it are allowed. This is because the library memory\n              file abstraction does not need this functionality to be avail-\n              able.  The function returns the number of bytes written or a\n              number lower than size if an error happened.\n\n\n       long xdl_writem_mmfile(mmfile_t *mmf, mmbuffer_t *mb, int nbuf);\n\n              Request to sequentially write nbuf memory buffers passed inside\n              the array mb into the memory file mmf.  The memory buffer struc-\n              ture is defined as :\n\n                   typedef struct s_mmbuffer {\n                        char *ptr;\n                        long size;\n                   } mmbuffer_t;\n\n              The ptr field is a pointer to the user data, whose size is spec-\n              ified inside the size structure field. The function returns the\n              total number of bytes written or a lower number if an error hap-\n              pened.\n\n\n       void *xdl_mmfile_writeallocate(mmfile_t *mmf, long size);\n\n              The function request to allocate a write buffer of size bytes in\n              the mmf memory file and returns the pointer to the allocated\n              buffer. The user will have the responsibility to store size\n              bytes (no more, no less) inside the memory region pointed to by\n              the returned pointer.  The files size will grow of size bytes as\n              a consequence of this operation. The function will return NULL\n              if an error happened.\n\n\n       long xdl_mmfile_ptradd(mmfile_t *mmf, char *ptr, long size, unsigned\n       long flags);\n\n              The function adds a user specified block to the end of the mem-\n              ory file mmf.  The block first byte is pointed to by ptr and its\n              length is size bytes. The flags parameter can be used to specify\n              attributes of the user memory block. Currently supported\n              attributes are:\n\n              XDL_MMB_READONLY Specify that the added memory block must be\n              treated as read-only, and every attempt to write on it should\n              result in a failure of the memory file writing functions.\n\n              The purpose of this function is basically to avoid copying mem-\n              ory around, by helping the library to not drain the CPU cache.\n              The function returns size in case of success, or -1 in case of\n              error.\n\n\n       void *xdl_mmfile_first(mmfile_t *mmf, long *size);\n\n              The function is used to return the first block of the mmf memory\n              file block chain. The size parameter will receive the size of\n              the block, while the function will return the pointer the the\n              first byte of the block itself. The function returns NULL if the\n              file is empty.\n\n\n       void *xdl_mmfile_next(mmfile_t *mmf, long *size);\n\n              The function is used to return the next block of the mmf memory\n              file block chain. The size parameter will receive the size of\n              the block, while the function will return the pointer the the\n              first byte of the block itself. The function returns NULL if the\n              current block is the last one of the chain.\n\n\n       long xdl_mmfile_size(mmfile_t *mmf);\n\n              The function returns the size of the specified memory file mmf.\n\n\n       int xdl_mmfile_cmp(mmfile_t *mmf1, mmfile_t *mmf2);\n\n              Request to compare two memory files mmf1 and mmf2 and returns 0\n              if files are identical, or a value different from 0 if files are\n              different.\n\n\n       int xdl_mmfile_compact(mmfile_t *mmfo, mmfile_t *mmfc, long bsize,\n       unsigned long flags);\n\n              Request to create a compact version of the memory file mmfo into\n              the (uninitialized) memory file mmfc.  The bsize parameter spec-\n              ify the requested block size and flags specify flags to be used\n              to create the new mmfc memory file (see xdl_init_mmfile() ). The\n              function returns 0 if succedded or -1 if an error happened.\n\n\n       int xdl_diff(mmfile_t *mmf1, mmfile_t *mmf2, xpparam_t const *xpp,\n       xdemitconf_t const *xecfg, xdemitcb_t *ecb);\n\n              Request to create the difference between the two text memory\n              files mmf1 and mmf2.  The mmf1 memory files is considered the\n              \"old\" file while mmf2 is considered the \"new\" file. So the func-\n              tion will create a patch file that once applied to mmf1 will\n              give mmf2 as result. Files mmf1 and mmf2 must be atomic from a\n              line point of view (or, as an extreme, compact), that means that\n              a single test line cannot spread among different memory file\n              blocks.  The xpp parameter is a pointer to a structure :\n\n                   typedef struct s_xpparam {\n                        unsigned long flags;\n                   } xpparam_t;\n\n              that is used to specify parameters to be used by the file dif-\n              ferential algorithm.  The flags field is a combination of the\n              following flags :\n\n\n              XDF_NEED_MINIMAL Requires the minimal edit script to be found by\n              the algorithm (may be slow).\n\n              The xecfg parameter point to a structure :\n\n                   typedef struct s_xdemitconf {\n                        long ctxlen;\n                   } xdemitconf_t;\n\n              that is used to configure the algorithm responsible of the\n              creation the the differential file from an edit script. The\n              ctxlen field is used to specify the amount of context to be\n              emitted inside the differential file (the value 3 is suggested\n              for normal operations).  The parameter ecb is a pointer to a\n              structure :\n\n                   typedef struct s_xdemitcb {\n                        void *priv;\n                        int (*outf)(void *, mmbuffer_t *, int);\n                   } xdemitcb_t;\n\n              that is used by the differential file creation algorithm to emit\n              the created data. The priv field is an opaque pointer to a user\n              specified data, while the outf field point to a callback func-\n              tion that is called internally to emit algorithm generated data\n              rappresenting the differential file. The first parameter of the\n              callback is the same priv field specified inside the xdemitcb_t\n              structure. The second parameter point to an array of mmbuffer_t\n              (see above for a definition of the structure) whose element\n              count is specified inside the last parameter of the callback\n              itself. The callback will always be called with entire records\n              (lines) and never a record (line) will be emitted using two dif-\n              ferent callback calls. This is important because if the called\n              will use another memory file to store the result, by creating\n              the target memory file with XDL_MMF_ATOMIC will guarantee the\n              \"atomicity\" of the memory file itself.  The function returns 0\n              if succeeded or -1 if an error occurred.\n\n\n       int xdl_patch(mmfile_t *mmf, mmfile_t *mmfp, int mode, xdemitcb_t *ecb,\n       xdemitcb_t *rjecb);\n\n              Request to patch the memory file mmf using the patch file stored\n              in mmfp.  The mmf memory file is not changed during the opera-\n              tion and can be considered as read only.  The mode parameter can\n              be one of the following values :\n\n              XDL_PATCH_NORMAL Perform standard patching like if the patch\n              memory file mmfp has been created using mmf as \"old\" file.\n\n              XDL_PATCH_REVERSE Apply the reverse patch. That means that the\n              mmf memory file has to be considered as if it was specified as\n              \"new\" file during the differential operation ( xdl_diff() ). The\n              result of the operation will then be the file content that was\n              used as \"old\" file during the differential operation.\n\n              The following flags can be specified (by or-ing them) to one of\n              the above:\n\n              XDL_PATCH_IGNOREBSPACE Ignore the whitespace at the beginning\n              and the end of the line.\n\n              The ecb will be used by the patch algorithm to create the result\n              file while the rjecb will be used to emit all differential\n              chunks that cannot be applied.  Like explained above, callbacks\n              are always called with entire records to guarantee atomicity of\n              the resulting output.  The function returns 0 if succeeded with-\n              out performing any fuzzy hunk detection, a positive value if it\n              secceeded with fuzzy hunk detection or -1 if an error occurred\n              during the patch operation.\n\n\n       int xdl_merge3(mmfile_t *mmfo, mmfile_t *mmf1, mmfile_t *mmf2,\n       xdemitcb_t *ecb, xdemitcb_t *rjecb);\n\n              Merges three files together. The mmfo file is the original one,\n              while mmf1 and mmf2 are two modified versions of mmfo.  The\n              function works by creating a differential between mmfo and mmf2\n              and by applying the resulting patch to mmf1.  Because of this\n              sequence, mmf1 changes will be privileged against the ones of\n              mmf2.  The ecb will be used by the patch algorithm to create the\n              result file while the rjecb will be used to emit all differen-\n              tial chunks that cannot be applied.  Like explained above, call-\n              backs are always called with entire records to guarantee atomic-\n              ity of the resulting output.  The function returns 0 if suc-\n              ceeded or -1 if an error occurred during the patch operation.\n\n\n       int xdl_bdiff(mmfile_t *mmf1, mmfile_t *mmf2, bdiffparam_t const *bdp,\n       xdemitcb_t *ecb);\n\n              Request to create the difference between the two text memory\n              files mmf1 and mmf2.  The mmf1 memory files is considered the\n              \"old\" file while mmf2 is considered the \"new\" file. So the func-\n              tion will create a patch file that once applied to mmf1 will\n              give mmf2 as result. Files mmf1 and mmf2 must be compact to make\n              it easy and faster to perform the difference operation.  Func-\n              tions are available to check for compactness ( xdl_mmfile_iscom-\n              pact() ) and to make compact a non-compact file (\n              xdl_mmfile_compact() ). An example of how to create a compact\n              memory file (described inside the test subdirectory) is :\n\n                   int xdlt_load_mmfile(char const *fname, mmfile_t *mf, int binmode) {\n                        char cc;\n                        int fd;\n                        long size, bsize;\n                        char *blk;\n\n                        if (xdl_init_mmfile(mf, XDLT_STD_BLKSIZE, XDL_MMF_ATOMIC) < 0)\n                             return -1;\n                        if ((fd = open(fname, O_RDONLY)) == -1) {\n                             perror(fname);\n                             xdl_free_mmfile(mf);\n                             return -1;\n                        }\n                        if ((size = bsize = lseek(fd, 0, SEEK_END)) > 0 && !binmode) {\n                             if (lseek(fd, -1, SEEK_END) != (off_t) -1 &&\n                                 read(fd, &cc, 1) && cc != '\\n')\n                                  bsize++;\n                        }\n                        lseek(fd, 0, SEEK_SET);\n                        if (!(blk = (char *) xdl_mmfile_writeallocate(mf, bsize))) {\n                             xdl_free_mmfile(mf);\n                             close(fd);\n                             return -1;\n                        }\n                        if (read(fd, blk, (size_t) size) != (size_t) size) {\n                             perror(fname);\n                             xdl_free_mmfile(mf);\n                             close(fd);\n                             return -1;\n                        }\n                        close(fd);\n                        if (bsize > size)\n                             blk[size] = '\\n';\n                        return 0;\n                   }\n\n              The bdp parameter points to a structure :\n\n                   typedef struct s_bdiffparam {\n                        long bsize;\n                   } bdiffparam_t;\n\n              that is used to pass information to the binary file differential\n              algorithm.  The bsize parameter specify the size of the block\n              that will be used to decompose mmf1 during the block classifica-\n              tion phase of the algorithm (see MacDonald paper).  Suggested\n              values go from 16 to 64, with a preferred power of two charac-\n              teristic.  The ecb parameter is used to pass the emission call-\n              back to the algorithm responsible of the output file creation.\n              The function returns 0 if succeede or -1 if an error is\n              occurred.\n\n\n       int xdl_bdiff_mb(mmbuffer_t *mmb1, mmbuffer_t *mmb2, bdiffparam_t const\n       *bdp, xdemitcb_t *ecb);\n\n              Same as xdl_bdiff() but it works on memory buffer directly. The\n              xdl_bdiff() is implemented internally with a xdl_bdiff_mb()\n              after having setup the two memory buffers from the passed memory\n              files (that must be compact, as described above). The memory\n              buffer structure is defined as :\n\n                   typedef struct s_mmbuffer {\n                        char *ptr;\n                        long size;\n                   } mmbuffer_t;\n\n              An empty memory buffer is specified by setting the ptr member as\n              NULL and the size member as zero. The reason of having this\n              function is to avoid the memory file preparation, that might\n              involve copying memory from other sources. Using the\n              xdl_bdiff_mb(), the caller can setup the two memory buffer by\n              using, for example, mmap(2), and hence avoiding unnecessary mem-\n              ory copies. The other parameters and the return value of the\n              function xdl_bdiff_mb() are the same as the ones already\n              described in xdl_bdiff().\n\n\n       int xdl_rabdiff(mmfile_t *mmf1, mmfile_t *mmf2, xdemitcb_t *ecb);\n\n              Request to create the difference between the two text memory\n              files mmf1 and mmf2 using the Rabin's polynomial fingerprinting\n              algorithm. This algorithm typically performs faster and produces\n              smaller deltas, when compared to the XDelta-like one.  The mmf1\n              memory files is considered the \"old\" file while mmf2 is consid-\n              ered the \"new\" file. So the function will create a patch file\n              that once applied to mmf1 will give mmf2 as result. Files mmf1\n              and mmf2 must be compact to make it easy and faster to perform\n              the difference operation.  Functions are available to check for\n              compactness ( xdl_mmfile_iscompact() ) and to make compact a\n              non-compact file ( xdl_mmfile_compact() ). The ecb parameter is\n              used to pass the emission callback to the algorithm responsible\n              of the output file creation.  The function returns 0 if succeede\n              or -1 if an error is occurred.\n\n\n       int xdl_rabdiff_mb(mmbuffer_t *mmb1, mmbuffer_t *mmb2, xdemitcb_t\n       *ecb);\n\n              Same as xdl_rabdiff() but it works on memory buffer directly.\n              The memory buffer structure is defined as :\n\n                   typedef struct s_mmbuffer {\n                        char *ptr;\n                        long size;\n                   } mmbuffer_t;\n\n              An empty memory buffer is specified by setting the ptr member as\n              NULL and the size member as zero. The reason of having this\n              function is to avoid the memory file preparation, that might\n              involve copying memory from other sources. Using the xdl_rabd-\n              iff_mb(), the caller can setup the two memory buffer by using,\n              for example, mmap(2), and hence avoiding unnecessary memory\n              copies. The other parameters and the return value of the func-\n              tion xdl_rabdiff_mb() are the same as the ones already described\n              in xdl_rabdiff().\n\n\n       long xdl_bdiff_tgsize(mmfile_t *mmfp);\n\n              Given a binary memory file patch, it returns the size that the\n              result file will have once the patch is applied to the target\n              file. It can be used to pre-allocate (or write-allocate) a mem-\n              ory block to store the patch result so that a compact file will\n              be available at the end of the operation. The function returns\n              the requested size, or -1 if an error occurred during the opera-\n              tion.\n\n\n       int xdl_bpatch(mmfile_t *mmf, mmfile_t *mmfp, xdemitcb_t *ecb);\n\n              Request to patch the binary memory file mmf using the binary\n              patch file stored in mmfp.  The mmf memory file is not changed\n              during the operation and can be considered as read only. The\n              binary patch algorithm has no notion of context, so the patch\n              operation cannot be partial (either success or failure). The ecb\n              parameter contain the callabck (see above for description) used\n              by the binary patch algorithm to emit the result file. The func-\n              tion returns 0 if succeeded or -1 if an error occurred during\n              the patch operation.\n\n\nSEE ALSO\n       Two papers drove the content of this library and these are :\n\n       o      File System Support for Delta Compression by Joshua P. MacDonald\n              http://www.xmailserver.org/xdfs.pdf\n\n       o      Fingerprinting by Random Polynomials by Michael O. Rabin\n              http://www.xmailserver.org/rabin.pdf\n\n       o      An O(ND) Difference Algorithm and Its Variations by Eugene W.\n              Myers http://www.xmailserver.org/diff2.pdf\n\n\n       Also usefull information can be looked up inside the diffutil GNU pack-\n       age :\n\n       http://www.gnu.org/software/diffutils/diffutils.html\n\n\nLICENSE\n       This library is free software; you can redistribute it and/or modify it\n       under the terms of the GNU Lesser General Public License as published\n       by the Free Software Foundation; either version 2.1 of the License, or\n       (at your option) any later version.  A copy of the license is available\n       at :\n\n       http://www.gnu.org/copyleft/lesser.html\n\n\nAUTHOR\n       Developed by Davide Libenzi <davidel@xmailserver.org>\n\n\nAVAILABILITY\n       The latest version of LibXDiff can be found at :\n\n       http://www.xmailserver.org/xdiff-lib.html\n\n\nBUGS\n       There are no known bugs.  Bug reports and comments to Davide Libenzi\n       <davidel@xmailserver.org>\n\n\n\n\nGNU                                  0.23                          LibXDiff(3)\n\n```\n\n**ref/git/xdiff/xdiffi.h**\n```\n/*\n *  LibXDiff by Davide Libenzi ( File Differential Library )\n *  Copyright (C) 2003  Davide Libenzi\n *\n *  This library is free software; you can redistribute it and/or\n *  modify it under the terms of the GNU Lesser General Public\n *  License as published by the Free Software Foundation; either\n *  version 2.1 of the License, or (at your option) any later version.\n *\n *  This library is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n *  Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; if not, see\n *  <http://www.gnu.org/licenses/>.\n *\n *  Davide Libenzi <davidel@xmailserver.org>\n *\n */\n\n#if !defined(XDIFFI_H)\n#define XDIFFI_H\n\n\ntypedef struct s_diffdata {\n\tlong nrec;\n\tunsigned long const *ha;\n\tlong *rindex;\n\tchar *rchg;\n} diffdata_t;\n\ntypedef struct s_xdalgoenv {\n\tlong mxcost;\n\tlong snake_cnt;\n\tlong heur_min;\n} xdalgoenv_t;\n\ntypedef struct s_xdchange {\n\tstruct s_xdchange *next;\n\tlong i1, i2;\n\tlong chg1, chg2;\n\tint ignore;\n} xdchange_t;\n\n\n\nint xdl_recs_cmp(diffdata_t *dd1, long off1, long lim1,\n\t\t diffdata_t *dd2, long off2, long lim2,\n\t\t long *kvdf, long *kvdb, int need_min, xdalgoenv_t *xenv);\nint xdl_do_diff(mmfile_t *mf1, mmfile_t *mf2, xpparam_t const *xpp,\n\t\txdfenv_t *xe);\nint xdl_change_compact(xdfile_t *xdf, xdfile_t *xdfo, long flags);\nint xdl_build_script(xdfenv_t *xe, xdchange_t **xscr);\nvoid xdl_free_script(xdchange_t *xscr);\nint xdl_emit_diff(xdfenv_t *xe, xdchange_t *xscr, xdemitcb_t *ecb,\n\t\t  xdemitconf_t const *xecfg);\nint xdl_do_patience_diff(xpparam_t const *xpp, xdfenv_t *env);\nint xdl_do_histogram_diff(xpparam_t const *xpp, xdfenv_t *env);\n\n#endif /* #if !defined(XDIFFI_H) */\n\n```\n\n**ref/git/xdiff/xdiffi.c**\n```\n/*\n *  LibXDiff by Davide Libenzi ( File Differential Library )\n *  Copyright (C) 2003\tDavide Libenzi\n *\n *  This library is free software; you can redistribute it and/or\n *  modify it under the terms of the GNU Lesser General Public\n *  License as published by the Free Software Foundation; either\n *  version 2.1 of the License, or (at your option) any later version.\n *\n *  This library is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n *  Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; if not, see\n *  <http://www.gnu.org/licenses/>.\n *\n *  Davide Libenzi <davidel@xmailserver.org>\n *\n */\n#define DISABLE_SIGN_COMPARE_WARNINGS\n\n#include \"xinclude.h\"\n\n#define XDL_MAX_COST_MIN 256\n#define XDL_HEUR_MIN_COST 256\n#define XDL_LINE_MAX (long)((1UL << (CHAR_BIT * sizeof(long) - 1)) - 1)\n#define XDL_SNAKE_CNT 20\n#define XDL_K_HEUR 4\n\ntypedef struct s_xdpsplit {\n\tlong i1, i2;\n\tint min_lo, min_hi;\n} xdpsplit_t;\n\n/*\n * See \"An O(ND) Difference Algorithm and its Variations\", by Eugene Myers.\n * Basically considers a \"box\" (off1, off2, lim1, lim2) and scan from both\n * the forward diagonal starting from (off1, off2) and the backward diagonal\n * starting from (lim1, lim2). If the K values on the same diagonal crosses\n * returns the furthest point of reach. We might encounter expensive edge cases\n * using this algorithm, so a little bit of heuristic is needed to cut the\n * search and to return a suboptimal point.\n */\nstatic long xdl_split(unsigned long const *ha1, long off1, long lim1,\n\t\t      unsigned long const *ha2, long off2, long lim2,\n\t\t      long *kvdf, long *kvdb, int need_min, xdpsplit_t *spl,\n\t\t      xdalgoenv_t *xenv) {\n\tlong dmin = off1 - lim2, dmax = lim1 - off2;\n\tlong fmid = off1 - off2, bmid = lim1 - lim2;\n\tlong odd = (fmid - bmid) & 1;\n\tlong fmin = fmid, fmax = fmid;\n\tlong bmin = bmid, bmax = bmid;\n\tlong ec, d, i1, i2, prev1, best, dd, v, k;\n\n\t/*\n\t * Set initial diagonal values for both forward and backward path.\n\t */\n\tkvdf[fmid] = off1;\n\tkvdb[bmid] = lim1;\n\n\tfor (ec = 1;; ec++) {\n\t\tint got_snake = 0;\n\n\t\t/*\n\t\t * We need to extend the diagonal \"domain\" by one. If the next\n\t\t * values exits the box boundaries we need to change it in the\n\t\t * opposite direction because (max - min) must be a power of\n\t\t * two.\n\t\t *\n\t\t * Also we initialize the external K value to -1 so that we can\n\t\t * avoid extra conditions in the check inside the core loop.\n\t\t */\n\t\tif (fmin > dmin)\n\t\t\tkvdf[--fmin - 1] = -1;\n\t\telse\n\t\t\t++fmin;\n\t\tif (fmax < dmax)\n\t\t\tkvdf[++fmax + 1] = -1;\n\t\telse\n\t\t\t--fmax;\n\n\t\tfor (d = fmax; d >= fmin; d -= 2) {\n\t\t\tif (kvdf[d - 1] >= kvdf[d + 1])\n\t\t\t\ti1 = kvdf[d - 1] + 1;\n\t\t\telse\n\t\t\t\ti1 = kvdf[d + 1];\n\t\t\tprev1 = i1;\n\t\t\ti2 = i1 - d;\n\t\t\tfor (; i1 < lim1 && i2 < lim2 && ha1[i1] == ha2[i2]; i1++, i2++);\n\t\t\tif (i1 - prev1 > xenv->snake_cnt)\n\t\t\t\tgot_snake = 1;\n\t\t\tkvdf[d] = i1;\n\t\t\tif (odd && bmin <= d && d <= bmax && kvdb[d] <= i1) {\n\t\t\t\tspl->i1 = i1;\n\t\t\t\tspl->i2 = i2;\n\t\t\t\tspl->min_lo = spl->min_hi = 1;\n\t\t\t\treturn ec;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * We need to extend the diagonal \"domain\" by one. If the next\n\t\t * values exits the box boundaries we need to change it in the\n\t\t * opposite direction because (max - min) must be a power of\n\t\t * two.\n\t\t *\n\t\t * Also we initialize the external K value to -1 so that we can\n\t\t * avoid extra conditions in the check inside the core loop.\n\t\t */\n\t\tif (bmin > dmin)\n\t\t\tkvdb[--bmin - 1] = XDL_LINE_MAX;\n\t\telse\n\t\t\t++bmin;\n\t\tif (bmax < dmax)\n\t\t\tkvdb[++bmax + 1] = XDL_LINE_MAX;\n\t\telse\n\t\t\t--bmax;\n\n\t\tfor (d = bmax; d >= bmin; d -= 2) {\n\t\t\tif (kvdb[d - 1] < kvdb[d + 1])\n\t\t\t\ti1 = kvdb[d - 1];\n\t\t\telse\n\t\t\t\ti1 = kvdb[d + 1] - 1;\n\t\t\tprev1 = i1;\n\t\t\ti2 = i1 - d;\n\t\t\tfor (; i1 > off1 && i2 > off2 && ha1[i1 - 1] == ha2[i2 - 1]; i1--, i2--);\n\t\t\tif (prev1 - i1 > xenv->snake_cnt)\n\t\t\t\tgot_snake = 1;\n\t\t\tkvdb[d] = i1;\n\t\t\tif (!odd && fmin <= d && d <= fmax && i1 <= kvdf[d]) {\n\t\t\t\tspl->i1 = i1;\n\t\t\t\tspl->i2 = i2;\n\t\t\t\tspl->min_lo = spl->min_hi = 1;\n\t\t\t\treturn ec;\n\t\t\t}\n\t\t}\n\n\t\tif (need_min)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * If the edit cost is above the heuristic trigger and if\n\t\t * we got a good snake, we sample current diagonals to see\n\t\t * if some of them have reached an \"interesting\" path. Our\n\t\t * measure is a function of the distance from the diagonal\n\t\t * corner (i1 + i2) penalized with the distance from the\n\t\t * mid diagonal itself. If this value is above the current\n\t\t * edit cost times a magic factor (XDL_K_HEUR) we consider\n\t\t * it interesting.\n\t\t */\n\t\tif (got_snake && ec > xenv->heur_min) {\n\t\t\tfor (best = 0, d = fmax; d >= fmin; d -= 2) {\n\t\t\t\tdd = d > fmid ? d - fmid: fmid - d;\n\t\t\t\ti1 = kvdf[d];\n\t\t\t\ti2 = i1 - d;\n\t\t\t\tv = (i1 - off1) + (i2 - off2) - dd;\n\n\t\t\t\tif (v > XDL_K_HEUR * ec && v > best &&\n\t\t\t\t    off1 + xenv->snake_cnt <= i1 && i1 < lim1 &&\n\t\t\t\t    off2 + xenv->snake_cnt <= i2 && i2 < lim2) {\n\t\t\t\t\tfor (k = 1; ha1[i1 - k] == ha2[i2 - k]; k++)\n\t\t\t\t\t\tif (k == xenv->snake_cnt) {\n\t\t\t\t\t\t\tbest = v;\n\t\t\t\t\t\t\tspl->i1 = i1;\n\t\t\t\t\t\t\tspl->i2 = i2;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (best > 0) {\n\t\t\t\tspl->min_lo = 1;\n\t\t\t\tspl->min_hi = 0;\n\t\t\t\treturn ec;\n\t\t\t}\n\n\t\t\tfor (best = 0, d = bmax; d >= bmin; d -= 2) {\n\t\t\t\tdd = d > bmid ? d - bmid: bmid - d;\n\t\t\t\ti1 = kvdb[d];\n\t\t\t\ti2 = i1 - d;\n\t\t\t\tv = (lim1 - i1) + (lim2 - i2) - dd;\n\n\t\t\t\tif (v > XDL_K_HEUR * ec && v > best &&\n\t\t\t\t    off1 < i1 && i1 <= lim1 - xenv->snake_cnt &&\n\t\t\t\t    off2 < i2 && i2 <= lim2 - xenv->snake_cnt) {\n\t\t\t\t\tfor (k = 0; ha1[i1 + k] == ha2[i2 + k]; k++)\n\t\t\t\t\t\tif (k == xenv->snake_cnt - 1) {\n\t\t\t\t\t\t\tbest = v;\n\t\t\t\t\t\t\tspl->i1 = i1;\n\t\t\t\t\t\t\tspl->i2 = i2;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (best > 0) {\n\t\t\t\tspl->min_lo = 0;\n\t\t\t\tspl->min_hi = 1;\n\t\t\t\treturn ec;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Enough is enough. We spent too much time here and now we\n\t\t * collect the furthest reaching path using the (i1 + i2)\n\t\t * measure.\n\t\t */\n\t\tif (ec >= xenv->mxcost) {\n\t\t\tlong fbest, fbest1, bbest, bbest1;\n\n\t\t\tfbest = fbest1 = -1;\n\t\t\tfor (d = fmax; d >= fmin; d -= 2) {\n\t\t\t\ti1 = XDL_MIN(kvdf[d], lim1);\n\t\t\t\ti2 = i1 - d;\n\t\t\t\tif (lim2 < i2)\n\t\t\t\t\ti1 = lim2 + d, i2 = lim2;\n\t\t\t\tif (fbest < i1 + i2) {\n\t\t\t\t\tfbest = i1 + i2;\n\t\t\t\t\tfbest1 = i1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbbest = bbest1 = XDL_LINE_MAX;\n\t\t\tfor (d = bmax; d >= bmin; d -= 2) {\n\t\t\t\ti1 = XDL_MAX(off1, kvdb[d]);\n\t\t\t\ti2 = i1 - d;\n\t\t\t\tif (i2 < off2)\n\t\t\t\t\ti1 = off2 + d, i2 = off2;\n\t\t\t\tif (i1 + i2 < bbest) {\n\t\t\t\t\tbbest = i1 + i2;\n\t\t\t\t\tbbest1 = i1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ((lim1 + lim2) - bbest < fbest - (off1 + off2)) {\n\t\t\t\tspl->i1 = fbest1;\n\t\t\t\tspl->i2 = fbest - fbest1;\n\t\t\t\tspl->min_lo = 1;\n\t\t\t\tspl->min_hi = 0;\n\t\t\t} else {\n\t\t\t\tspl->i1 = bbest1;\n\t\t\t\tspl->i2 = bbest - bbest1;\n\t\t\t\tspl->min_lo = 0;\n\t\t\t\tspl->min_hi = 1;\n\t\t\t}\n\t\t\treturn ec;\n\t\t}\n\t}\n}\n\n\n/*\n * Rule: \"Divide et Impera\" (divide & conquer). Recursively split the box in\n * sub-boxes by calling the box splitting function. Note that the real job\n * (marking changed lines) is done in the two boundary reaching checks.\n */\nint xdl_recs_cmp(diffdata_t *dd1, long off1, long lim1,\n\t\t diffdata_t *dd2, long off2, long lim2,\n\t\t long *kvdf, long *kvdb, int need_min, xdalgoenv_t *xenv) {\n\tunsigned long const *ha1 = dd1->ha, *ha2 = dd2->ha;\n\n\t/*\n\t * Shrink the box by walking through each diagonal snake (SW and NE).\n\t */\n\tfor (; off1 < lim1 && off2 < lim2 && ha1[off1] == ha2[off2]; off1++, off2++);\n\tfor (; off1 < lim1 && off2 < lim2 && ha1[lim1 - 1] == ha2[lim2 - 1]; lim1--, lim2--);\n\n\t/*\n\t * If one dimension is empty, then all records on the other one must\n\t * be obviously changed.\n\t */\n\tif (off1 == lim1) {\n\t\tchar *rchg2 = dd2->rchg;\n\t\tlong *rindex2 = dd2->rindex;\n\n\t\tfor (; off2 < lim2; off2++)\n\t\t\trchg2[rindex2[off2]] = 1;\n\t} else if (off2 == lim2) {\n\t\tchar *rchg1 = dd1->rchg;\n\t\tlong *rindex1 = dd1->rindex;\n\n\t\tfor (; off1 < lim1; off1++)\n\t\t\trchg1[rindex1[off1]] = 1;\n\t} else {\n\t\txdpsplit_t spl;\n\t\tspl.i1 = spl.i2 = 0;\n\n\t\t/*\n\t\t * Divide ...\n\t\t */\n\t\tif (xdl_split(ha1, off1, lim1, ha2, off2, lim2, kvdf, kvdb,\n\t\t\t      need_min, &spl, xenv) < 0) {\n\n\t\t\treturn -1;\n\t\t}\n\n\t\t/*\n\t\t * ... et Impera.\n\t\t */\n\t\tif (xdl_recs_cmp(dd1, off1, spl.i1, dd2, off2, spl.i2,\n\t\t\t\t kvdf, kvdb, spl.min_lo, xenv) < 0 ||\n\t\t    xdl_recs_cmp(dd1, spl.i1, lim1, dd2, spl.i2, lim2,\n\t\t\t\t kvdf, kvdb, spl.min_hi, xenv) < 0) {\n\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n\nint xdl_do_diff(mmfile_t *mf1, mmfile_t *mf2, xpparam_t const *xpp,\n\t\txdfenv_t *xe) {\n\tlong ndiags;\n\tlong *kvd, *kvdf, *kvdb;\n\txdalgoenv_t xenv;\n\tdiffdata_t dd1, dd2;\n\tint res;\n\n\tif (xdl_prepare_env(mf1, mf2, xpp, xe) < 0)\n\t\treturn -1;\n\n\tif (XDF_DIFF_ALG(xpp->flags) == XDF_PATIENCE_DIFF) {\n\t\tres = xdl_do_patience_diff(xpp, xe);\n\t\tgoto out;\n\t}\n\n\tif (XDF_DIFF_ALG(xpp->flags) == XDF_HISTOGRAM_DIFF) {\n\t\tres = xdl_do_histogram_diff(xpp, xe);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Allocate and setup K vectors to be used by the differential\n\t * algorithm.\n\t *\n\t * One is to store the forward path and one to store the backward path.\n\t */\n\tndiags = xe->xdf1.nreff + xe->xdf2.nreff + 3;\n\tif (!XDL_ALLOC_ARRAY(kvd, 2 * ndiags + 2)) {\n\n\t\txdl_free_env(xe);\n\t\treturn -1;\n\t}\n\tkvdf = kvd;\n\tkvdb = kvdf + ndiags;\n\tkvdf += xe->xdf2.nreff + 1;\n\tkvdb += xe->xdf2.nreff + 1;\n\n\txenv.mxcost = xdl_bogosqrt(ndiags);\n\tif (xenv.mxcost < XDL_MAX_COST_MIN)\n\t\txenv.mxcost = XDL_MAX_COST_MIN;\n\txenv.snake_cnt = XDL_SNAKE_CNT;\n\txenv.heur_min = XDL_HEUR_MIN_COST;\n\n\tdd1.nrec = xe->xdf1.nreff;\n\tdd1.ha = xe->xdf1.ha;\n\tdd1.rchg = xe->xdf1.rchg;\n\tdd1.rindex = xe->xdf1.rindex;\n\tdd2.nrec = xe->xdf2.nreff;\n\tdd2.ha = xe->xdf2.ha;\n\tdd2.rchg = xe->xdf2.rchg;\n\tdd2.rindex = xe->xdf2.rindex;\n\n\tres = xdl_recs_cmp(&dd1, 0, dd1.nrec, &dd2, 0, dd2.nrec,\n\t\t\t   kvdf, kvdb, (xpp->flags & XDF_NEED_MINIMAL) != 0,\n\t\t\t   &xenv);\n\txdl_free(kvd);\n out:\n\tif (res < 0)\n\t\txdl_free_env(xe);\n\n\treturn res;\n}\n\n\nstatic xdchange_t *xdl_add_change(xdchange_t *xscr, long i1, long i2, long chg1, long chg2) {\n\txdchange_t *xch;\n\n\tif (!(xch = (xdchange_t *) xdl_malloc(sizeof(xdchange_t))))\n\t\treturn NULL;\n\n\txch->next = xscr;\n\txch->i1 = i1;\n\txch->i2 = i2;\n\txch->chg1 = chg1;\n\txch->chg2 = chg2;\n\txch->ignore = 0;\n\n\treturn xch;\n}\n\n\nstatic int recs_match(xrecord_t *rec1, xrecord_t *rec2)\n{\n\treturn (rec1->ha == rec2->ha);\n}\n\n/*\n * If a line is indented more than this, get_indent() just returns this value.\n * This avoids having to do absurd amounts of work for data that are not\n * human-readable text, and also ensures that the output of get_indent fits\n * within an int.\n */\n#define MAX_INDENT 200\n\n/*\n * Return the amount of indentation of the specified line, treating TAB as 8\n * columns. Return -1 if line is empty or contains only whitespace. Clamp the\n * output value at MAX_INDENT.\n */\nstatic int get_indent(xrecord_t *rec)\n{\n\tlong i;\n\tint ret = 0;\n\n\tfor (i = 0; i < rec->size; i++) {\n\t\tchar c = rec->ptr[i];\n\n\t\tif (!XDL_ISSPACE(c))\n\t\t\treturn ret;\n\t\telse if (c == ' ')\n\t\t\tret += 1;\n\t\telse if (c == '\\t')\n\t\t\tret += 8 - ret % 8;\n\t\t/* ignore other whitespace characters */\n\n\t\tif (ret >= MAX_INDENT)\n\t\t\treturn MAX_INDENT;\n\t}\n\n\t/* The line contains only whitespace. */\n\treturn -1;\n}\n\n/*\n * If more than this number of consecutive blank rows are found, just return\n * this value. This avoids requiring O(N^2) work for pathological cases, and\n * also ensures that the output of score_split fits in an int.\n */\n#define MAX_BLANKS 20\n\n/* Characteristics measured about a hypothetical split position. */\nstruct split_measurement {\n\t/*\n\t * Is the split at the end of the file (aside from any blank lines)?\n\t */\n\tint end_of_file;\n\n\t/*\n\t * How much is the line immediately following the split indented (or -1\n\t * if the line is blank):\n\t */\n\tint indent;\n\n\t/*\n\t * How many consecutive lines above the split are blank?\n\t */\n\tint pre_blank;\n\n\t/*\n\t * How much is the nearest non-blank line above the split indented (or\n\t * -1 if there is no such line)?\n\t */\n\tint pre_indent;\n\n\t/*\n\t * How many lines after the line following the split are blank?\n\t */\n\tint post_blank;\n\n\t/*\n\t * How much is the nearest non-blank line after the line following the\n\t * split indented (or -1 if there is no such line)?\n\t */\n\tint post_indent;\n};\n\nstruct split_score {\n\t/* The effective indent of this split (smaller is preferred). */\n\tint effective_indent;\n\n\t/* Penalty for this split (smaller is preferred). */\n\tint penalty;\n};\n\n/*\n * Fill m with information about a hypothetical split of xdf above line split.\n */\nstatic void measure_split(const xdfile_t *xdf, long split,\n\t\t\t  struct split_measurement *m)\n{\n\tlong i;\n\n\tif (split >= xdf->nrec) {\n\t\tm->end_of_file = 1;\n\t\tm->indent = -1;\n\t} else {\n\t\tm->end_of_file = 0;\n\t\tm->indent = get_indent(xdf->recs[split]);\n\t}\n\n\tm->pre_blank = 0;\n\tm->pre_indent = -1;\n\tfor (i = split - 1; i >= 0; i--) {\n\t\tm->pre_indent = get_indent(xdf->recs[i]);\n\t\tif (m->pre_indent != -1)\n\t\t\tbreak;\n\t\tm->pre_blank += 1;\n\t\tif (m->pre_blank == MAX_BLANKS) {\n\t\t\tm->pre_indent = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tm->post_blank = 0;\n\tm->post_indent = -1;\n\tfor (i = split + 1; i < xdf->nrec; i++) {\n\t\tm->post_indent = get_indent(xdf->recs[i]);\n\t\tif (m->post_indent != -1)\n\t\t\tbreak;\n\t\tm->post_blank += 1;\n\t\tif (m->post_blank == MAX_BLANKS) {\n\t\t\tm->post_indent = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n/*\n * The empirically-determined weight factors used by score_split() below.\n * Larger values means that the position is a less favorable place to split.\n *\n * Note that scores are only ever compared against each other, so multiplying\n * all of these weight/penalty values by the same factor wouldn't change the\n * heuristic's behavior. Still, we need to set that arbitrary scale *somehow*.\n * In practice, these numbers are chosen to be large enough that they can be\n * adjusted relative to each other with sufficient precision despite using\n * integer math.\n */\n\n/* Penalty if there are no non-blank lines before the split */\n#define START_OF_FILE_PENALTY 1\n\n/* Penalty if there are no non-blank lines after the split */\n#define END_OF_FILE_PENALTY 21\n\n/* Multiplier for the number of blank lines around the split */\n#define TOTAL_BLANK_WEIGHT (-30)\n\n/* Multiplier for the number of blank lines after the split */\n#define POST_BLANK_WEIGHT 6\n\n/*\n * Penalties applied if the line is indented more than its predecessor\n */\n#define RELATIVE_INDENT_PENALTY (-4)\n#define RELATIVE_INDENT_WITH_BLANK_PENALTY 10\n\n/*\n * Penalties applied if the line is indented less than both its predecessor and\n * its successor\n */\n#define RELATIVE_OUTDENT_PENALTY 24\n#define RELATIVE_OUTDENT_WITH_BLANK_PENALTY 17\n\n/*\n * Penalties applied if the line is indented less than its predecessor but not\n * less than its successor\n */\n#define RELATIVE_DEDENT_PENALTY 23\n#define RELATIVE_DEDENT_WITH_BLANK_PENALTY 17\n\n/*\n * We only consider whether the sum of the effective indents for splits are\n * less than (-1), equal to (0), or greater than (+1) each other. The resulting\n * value is multiplied by the following weight and combined with the penalty to\n * determine the better of two scores.\n */\n#define INDENT_WEIGHT 60\n\n/*\n * How far do we slide a hunk at most?\n */\n#define INDENT_HEURISTIC_MAX_SLIDING 100\n\n/*\n * Compute a badness score for the hypothetical split whose measurements are\n * stored in m. The weight factors were determined empirically using the tools\n * and corpus described in\n *\n *     https://github.com/mhagger/diff-slider-tools\n *\n * Also see that project if you want to improve the weights based on, for\n * example, a larger or more diverse corpus.\n */\nstatic void score_add_split(const struct split_measurement *m, struct split_score *s)\n{\n\t/*\n\t * A place to accumulate penalty factors (positive makes this index more\n\t * favored):\n\t */\n\tint post_blank, total_blank, indent, any_blanks;\n\n\tif (m->pre_indent == -1 && m->pre_blank == 0)\n\t\ts->penalty += START_OF_FILE_PENALTY;\n\n\tif (m->end_of_file)\n\t\ts->penalty += END_OF_FILE_PENALTY;\n\n\t/*\n\t * Set post_blank to the number of blank lines following the split,\n\t * including the line immediately after the split:\n\t */\n\tpost_blank = (m->indent == -1) ? 1 + m->post_blank : 0;\n\ttotal_blank = m->pre_blank + post_blank;\n\n\t/* Penalties based on nearby blank lines: */\n\ts->penalty += TOTAL_BLANK_WEIGHT * total_blank;\n\ts->penalty += POST_BLANK_WEIGHT * post_blank;\n\n\tif (m->indent != -1)\n\t\tindent = m->indent;\n\telse\n\t\tindent = m->post_indent;\n\n\tany_blanks = (total_blank != 0);\n\n\t/* Note that the effective indent is -1 at the end of the file: */\n\ts->effective_indent += indent;\n\n\tif (indent == -1) {\n\t\t/* No additional adjustments needed. */\n\t} else if (m->pre_indent == -1) {\n\t\t/* No additional adjustments needed. */\n\t} else if (indent > m->pre_indent) {\n\t\t/*\n\t\t * The line is indented more than its predecessor.\n\t\t */\n\t\ts->penalty += any_blanks ?\n\t\t\tRELATIVE_INDENT_WITH_BLANK_PENALTY :\n\t\t\tRELATIVE_INDENT_PENALTY;\n\t} else if (indent == m->pre_indent) {\n\t\t/*\n\t\t * The line has the same indentation level as its predecessor.\n\t\t * No additional adjustments needed.\n\t\t */\n\t} else {\n\t\t/*\n\t\t * The line is indented less than its predecessor. It could be\n\t\t * the block terminator of the previous block, but it could\n\t\t * also be the start of a new block (e.g., an \"else\" block, or\n\t\t * maybe the previous block didn't have a block terminator).\n\t\t * Try to distinguish those cases based on what comes next:\n\t\t */\n\t\tif (m->post_indent != -1 && m->post_indent > indent) {\n\t\t\t/*\n\t\t\t * The following line is indented more. So it is likely\n\t\t\t * that this line is the start of a block.\n\t\t\t */\n\t\t\ts->penalty += any_blanks ?\n\t\t\t\tRELATIVE_OUTDENT_WITH_BLANK_PENALTY :\n\t\t\t\tRELATIVE_OUTDENT_PENALTY;\n\t\t} else {\n\t\t\t/*\n\t\t\t * That was probably the end of a block.\n\t\t\t */\n\t\t\ts->penalty += any_blanks ?\n\t\t\t\tRELATIVE_DEDENT_WITH_BLANK_PENALTY :\n\t\t\t\tRELATIVE_DEDENT_PENALTY;\n\t\t}\n\t}\n}\n\nstatic int score_cmp(struct split_score *s1, struct split_score *s2)\n{\n\t/* -1 if s1.effective_indent < s2->effective_indent, etc. */\n\tint cmp_indents = ((s1->effective_indent > s2->effective_indent) -\n\t\t\t   (s1->effective_indent < s2->effective_indent));\n\n\treturn INDENT_WEIGHT * cmp_indents + (s1->penalty - s2->penalty);\n}\n\n/*\n * Represent a group of changed lines in an xdfile_t (i.e., a contiguous group\n * of lines that was inserted or deleted from the corresponding version of the\n * file). We consider there to be such a group at the beginning of the file, at\n * the end of the file, and between any two unchanged lines, though most such\n * groups will usually be empty.\n *\n * If the first line in a group is equal to the line following the group, then\n * the group can be slid down. Similarly, if the last line in a group is equal\n * to the line preceding the group, then the group can be slid up. See\n * group_slide_down() and group_slide_up().\n *\n * Note that loops that are testing for changed lines in xdf->rchg do not need\n * index bounding since the array is prepared with a zero at position -1 and N.\n */\nstruct xdlgroup {\n\t/*\n\t * The index of the first changed line in the group, or the index of\n\t * the unchanged line above which the (empty) group is located.\n\t */\n\tlong start;\n\n\t/*\n\t * The index of the first unchanged line after the group. For an empty\n\t * group, end is equal to start.\n\t */\n\tlong end;\n};\n\n/*\n * Initialize g to point at the first group in xdf.\n */\nstatic void group_init(xdfile_t *xdf, struct xdlgroup *g)\n{\n\tg->start = g->end = 0;\n\twhile (xdf->rchg[g->end])\n\t\tg->end++;\n}\n\n/*\n * Move g to describe the next (possibly empty) group in xdf and return 0. If g\n * is already at the end of the file, do nothing and return -1.\n */\nstatic inline int group_next(xdfile_t *xdf, struct xdlgroup *g)\n{\n\tif (g->end == xdf->nrec)\n\t\treturn -1;\n\n\tg->start = g->end + 1;\n\tfor (g->end = g->start; xdf->rchg[g->end]; g->end++)\n\t\t;\n\n\treturn 0;\n}\n\n/*\n * Move g to describe the previous (possibly empty) group in xdf and return 0.\n * If g is already at the beginning of the file, do nothing and return -1.\n */\nstatic inline int group_previous(xdfile_t *xdf, struct xdlgroup *g)\n{\n\tif (g->start == 0)\n\t\treturn -1;\n\n\tg->end = g->start - 1;\n\tfor (g->start = g->end; xdf->rchg[g->start - 1]; g->start--)\n\t\t;\n\n\treturn 0;\n}\n\n/*\n * If g can be slid toward the end of the file, do so, and if it bumps into a\n * following group, expand this group to include it. Return 0 on success or -1\n * if g cannot be slid down.\n */\nstatic int group_slide_down(xdfile_t *xdf, struct xdlgroup *g)\n{\n\tif (g->end < xdf->nrec &&\n\t    recs_match(xdf->recs[g->start], xdf->recs[g->end])) {\n\t\txdf->rchg[g->start++] = 0;\n\t\txdf->rchg[g->end++] = 1;\n\n\t\twhile (xdf->rchg[g->end])\n\t\t\tg->end++;\n\n\t\treturn 0;\n\t} else {\n\t\treturn -1;\n\t}\n}\n\n/*\n * If g can be slid toward the beginning of the file, do so, and if it bumps\n * into a previous group, expand this group to include it. Return 0 on success\n * or -1 if g cannot be slid up.\n */\nstatic int group_slide_up(xdfile_t *xdf, struct xdlgroup *g)\n{\n\tif (g->start > 0 &&\n\t    recs_match(xdf->recs[g->start - 1], xdf->recs[g->end - 1])) {\n\t\txdf->rchg[--g->start] = 1;\n\t\txdf->rchg[--g->end] = 0;\n\n\t\twhile (xdf->rchg[g->start - 1])\n\t\t\tg->start--;\n\n\t\treturn 0;\n\t} else {\n\t\treturn -1;\n\t}\n}\n\n/*\n * Move back and forward change groups for a consistent and pretty diff output.\n * This also helps in finding joinable change groups and reducing the diff\n * size.\n */\nint xdl_change_compact(xdfile_t *xdf, xdfile_t *xdfo, long flags) {\n\tstruct xdlgroup g, go;\n\tlong earliest_end, end_matching_other;\n\tlong groupsize;\n\n\tgroup_init(xdf, &g);\n\tgroup_init(xdfo, &go);\n\n\twhile (1) {\n\t\t/*\n\t\t * If the group is empty in the to-be-compacted file, skip it:\n\t\t */\n\t\tif (g.end == g.start)\n\t\t\tgoto next;\n\n\t\t/*\n\t\t * Now shift the change up and then down as far as possible in\n\t\t * each direction. If it bumps into any other changes, merge\n\t\t * them.\n\t\t */\n\t\tdo {\n\t\t\tgroupsize = g.end - g.start;\n\n\t\t\t/*\n\t\t\t * Keep track of the last \"end\" index that causes this\n\t\t\t * group to align with a group of changed lines in the\n\t\t\t * other file. -1 indicates that we haven't found such\n\t\t\t * a match yet:\n\t\t\t */\n\t\t\tend_matching_other = -1;\n\n\t\t\t/* Shift the group backward as much as possible: */\n\t\t\twhile (!group_slide_up(xdf, &g))\n\t\t\t\tif (group_previous(xdfo, &go))\n\t\t\t\t\tBUG(\"group sync broken sliding up\");\n\n\t\t\t/*\n\t\t\t * This is this highest that this group can be shifted.\n\t\t\t * Record its end index:\n\t\t\t */\n\t\t\tearliest_end = g.end;\n\n\t\t\tif (go.end > go.start)\n\t\t\t\tend_matching_other = g.end;\n\n\t\t\t/* Now shift the group forward as far as possible: */\n\t\t\twhile (1) {\n\t\t\t\tif (group_slide_down(xdf, &g))\n\t\t\t\t\tbreak;\n\t\t\t\tif (group_next(xdfo, &go))\n\t\t\t\t\tBUG(\"group sync broken sliding down\");\n\n\t\t\t\tif (go.end > go.start)\n\t\t\t\t\tend_matching_other = g.end;\n\t\t\t}\n\t\t} while (groupsize != g.end - g.start);\n\n\t\t/*\n\t\t * If the group can be shifted, then we can possibly use this\n\t\t * freedom to produce a more intuitive diff.\n\t\t *\n\t\t * The group is currently shifted as far down as possible, so\n\t\t * the heuristics below only have to handle upwards shifts.\n\t\t */\n\n\t\tif (g.end == earliest_end) {\n\t\t\t/* no shifting was possible */\n\t\t} else if (end_matching_other != -1) {\n\t\t\t/*\n\t\t\t * Move the possibly merged group of changes back to\n\t\t\t * line up with the last group of changes from the\n\t\t\t * other file that it can align with.\n\t\t\t */\n\t\t\twhile (go.end == go.start) {\n\t\t\t\tif (group_slide_up(xdf, &g))\n\t\t\t\t\tBUG(\"match disappeared\");\n\t\t\t\tif (group_previous(xdfo, &go))\n\t\t\t\t\tBUG(\"group sync broken sliding to match\");\n\t\t\t}\n\t\t} else if (flags & XDF_INDENT_HEURISTIC) {\n\t\t\t/*\n\t\t\t * Indent heuristic: a group of pure add/delete lines\n\t\t\t * implies two splits, one between the end of the\n\t\t\t * \"before\" context and the start of the group, and\n\t\t\t * another between the end of the group and the\n\t\t\t * beginning of the \"after\" context. Some splits are\n\t\t\t * aesthetically better and some are worse. We compute\n\t\t\t * a badness \"score\" for each split, and add the scores\n\t\t\t * for the two splits to define a \"score\" for each\n\t\t\t * position that the group can be shifted to. Then we\n\t\t\t * pick the shift with the lowest score.\n\t\t\t */\n\t\t\tlong shift, best_shift = -1;\n\t\t\tstruct split_score best_score;\n\n\t\t\tshift = earliest_end;\n\t\t\tif (g.end - groupsize - 1 > shift)\n\t\t\t\tshift = g.end - groupsize - 1;\n\t\t\tif (g.end - INDENT_HEURISTIC_MAX_SLIDING > shift)\n\t\t\t\tshift = g.end - INDENT_HEURISTIC_MAX_SLIDING;\n\t\t\tfor (; shift <= g.end; shift++) {\n\t\t\t\tstruct split_measurement m;\n\t\t\t\tstruct split_score score = {0, 0};\n\n\t\t\t\tmeasure_split(xdf, shift, &m);\n\t\t\t\tscore_add_split(&m, &score);\n\t\t\t\tmeasure_split(xdf, shift - groupsize, &m);\n\t\t\t\tscore_add_split(&m, &score);\n\t\t\t\tif (best_shift == -1 ||\n\t\t\t\t    score_cmp(&score, &best_score) <= 0) {\n\t\t\t\t\tbest_score.effective_indent = score.effective_indent;\n\t\t\t\t\tbest_score.penalty = score.penalty;\n\t\t\t\t\tbest_shift = shift;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\twhile (g.end > best_shift) {\n\t\t\t\tif (group_slide_up(xdf, &g))\n\t\t\t\t\tBUG(\"best shift unreached\");\n\t\t\t\tif (group_previous(xdfo, &go))\n\t\t\t\t\tBUG(\"group sync broken sliding to blank line\");\n\t\t\t}\n\t\t}\n\n\tnext:\n\t\t/* Move past the just-processed group: */\n\t\tif (group_next(xdf, &g))\n\t\t\tbreak;\n\t\tif (group_next(xdfo, &go))\n\t\t\tBUG(\"group sync broken moving to next group\");\n\t}\n\n\tif (!group_next(xdfo, &go))\n\t\tBUG(\"group sync broken at end of file\");\n\n\treturn 0;\n}\n\n\nint xdl_build_script(xdfenv_t *xe, xdchange_t **xscr) {\n\txdchange_t *cscr = NULL, *xch;\n\tchar *rchg1 = xe->xdf1.rchg, *rchg2 = xe->xdf2.rchg;\n\tlong i1, i2, l1, l2;\n\n\t/*\n\t * Trivial. Collects \"groups\" of changes and creates an edit script.\n\t */\n\tfor (i1 = xe->xdf1.nrec, i2 = xe->xdf2.nrec; i1 >= 0 || i2 >= 0; i1--, i2--)\n\t\tif (rchg1[i1 - 1] || rchg2[i2 - 1]) {\n\t\t\tfor (l1 = i1; rchg1[i1 - 1]; i1--);\n\t\t\tfor (l2 = i2; rchg2[i2 - 1]; i2--);\n\n\t\t\tif (!(xch = xdl_add_change(cscr, i1, i2, l1 - i1, l2 - i2))) {\n\t\t\t\txdl_free_script(cscr);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tcscr = xch;\n\t\t}\n\n\t*xscr = cscr;\n\n\treturn 0;\n}\n\n\nvoid xdl_free_script(xdchange_t *xscr) {\n\txdchange_t *xch;\n\n\twhile ((xch = xscr) != NULL) {\n\t\txscr = xscr->next;\n\t\txdl_free(xch);\n\t}\n}\n\nstatic int xdl_call_hunk_func(xdfenv_t *xe UNUSED, xdchange_t *xscr, xdemitcb_t *ecb,\n\t\t\t      xdemitconf_t const *xecfg)\n{\n\txdchange_t *xch, *xche;\n\n\tfor (xch = xscr; xch; xch = xche->next) {\n\t\txche = xdl_get_hunk(&xch, xecfg);\n\t\tif (!xch)\n\t\t\tbreak;\n\t\tif (xecfg->hunk_func(xch->i1, xche->i1 + xche->chg1 - xch->i1,\n\t\t\t\t     xch->i2, xche->i2 + xche->chg2 - xch->i2,\n\t\t\t\t     ecb->priv) < 0)\n\t\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic void xdl_mark_ignorable_lines(xdchange_t *xscr, xdfenv_t *xe, long flags)\n{\n\txdchange_t *xch;\n\n\tfor (xch = xscr; xch; xch = xch->next) {\n\t\tint ignore = 1;\n\t\txrecord_t **rec;\n\t\tlong i;\n\n\t\trec = &xe->xdf1.recs[xch->i1];\n\t\tfor (i = 0; i < xch->chg1 && ignore; i++)\n\t\t\tignore = xdl_blankline(rec[i]->ptr, rec[i]->size, flags);\n\n\t\trec = &xe->xdf2.recs[xch->i2];\n\t\tfor (i = 0; i < xch->chg2 && ignore; i++)\n\t\t\tignore = xdl_blankline(rec[i]->ptr, rec[i]->size, flags);\n\n\t\txch->ignore = ignore;\n\t}\n}\n\nstatic int record_matches_regex(xrecord_t *rec, xpparam_t const *xpp) {\n\tregmatch_t regmatch;\n\tint i;\n\n\tfor (i = 0; i < xpp->ignore_regex_nr; i++)\n\t\tif (!regexec_buf(xpp->ignore_regex[i], rec->ptr, rec->size, 1,\n\t\t\t\t &regmatch, 0))\n\t\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic void xdl_mark_ignorable_regex(xdchange_t *xscr, const xdfenv_t *xe,\n\t\t\t\t     xpparam_t const *xpp)\n{\n\txdchange_t *xch;\n\n\tfor (xch = xscr; xch; xch = xch->next) {\n\t\txrecord_t **rec;\n\t\tint ignore = 1;\n\t\tlong i;\n\n\t\t/*\n\t\t * Do not override --ignore-blank-lines.\n\t\t */\n\t\tif (xch->ignore)\n\t\t\tcontinue;\n\n\t\trec = &xe->xdf1.recs[xch->i1];\n\t\tfor (i = 0; i < xch->chg1 && ignore; i++)\n\t\t\tignore = record_matches_regex(rec[i], xpp);\n\n\t\trec = &xe->xdf2.recs[xch->i2];\n\t\tfor (i = 0; i < xch->chg2 && ignore; i++)\n\t\t\tignore = record_matches_regex(rec[i], xpp);\n\n\t\txch->ignore = ignore;\n\t}\n}\n\nint xdl_diff(mmfile_t *mf1, mmfile_t *mf2, xpparam_t const *xpp,\n\t     xdemitconf_t const *xecfg, xdemitcb_t *ecb) {\n\txdchange_t *xscr;\n\txdfenv_t xe;\n\temit_func_t ef = xecfg->hunk_func ? xdl_call_hunk_func : xdl_emit_diff;\n\n\tif (xdl_do_diff(mf1, mf2, xpp, &xe) < 0) {\n\n\t\treturn -1;\n\t}\n\tif (xdl_change_compact(&xe.xdf1, &xe.xdf2, xpp->flags) < 0 ||\n\t    xdl_change_compact(&xe.xdf2, &xe.xdf1, xpp->flags) < 0 ||\n\t    xdl_build_script(&xe, &xscr) < 0) {\n\n\t\txdl_free_env(&xe);\n\t\treturn -1;\n\t}\n\tif (xscr) {\n\t\tif (xpp->flags & XDF_IGNORE_BLANK_LINES)\n\t\t\txdl_mark_ignorable_lines(xscr, &xe, xpp->flags);\n\n\t\tif (xpp->ignore_regex)\n\t\t\txdl_mark_ignorable_regex(xscr, &xe, xpp);\n\n\t\tif (ef(&xe, xscr, ecb, xecfg) < 0) {\n\n\t\t\txdl_free_script(xscr);\n\t\t\txdl_free_env(&xe);\n\t\t\treturn -1;\n\t\t}\n\t\txdl_free_script(xscr);\n\t}\n\txdl_free_env(&xe);\n\n\treturn 0;\n}\n\n```\n\n**ref/git/xdiff/xinclude.h**\n```\n/*\n *  LibXDiff by Davide Libenzi ( File Differential Library )\n *  Copyright (C) 2003  Davide Libenzi\n *\n *  This library is free software; you can redistribute it and/or\n *  modify it under the terms of the GNU Lesser General Public\n *  License as published by the Free Software Foundation; either\n *  version 2.1 of the License, or (at your option) any later version.\n *\n *  This library is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n *  Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; if not, see\n *  <http://www.gnu.org/licenses/>.\n *\n *  Davide Libenzi <davidel@xmailserver.org>\n *\n */\n\n#if !defined(XINCLUDE_H)\n#define XINCLUDE_H\n\n#define DISABLE_SIGN_COMPARE_WARNINGS\n\n#include \"git-compat-util.h\"\n#include \"xmacros.h\"\n#include \"xdiff.h\"\n#include \"xtypes.h\"\n#include \"xutils.h\"\n#include \"xprepare.h\"\n#include \"xdiffi.h\"\n#include \"xemit.h\"\n\n\n#endif /* #if !defined(XINCLUDE_H) */\n\n```\n\n**ref/git/xdiff/xtypes.h**\n```\n/*\n *  LibXDiff by Davide Libenzi ( File Differential Library )\n *  Copyright (C) 2003  Davide Libenzi\n *\n *  This library is free software; you can redistribute it and/or\n *  modify it under the terms of the GNU Lesser General Public\n *  License as published by the Free Software Foundation; either\n *  version 2.1 of the License, or (at your option) any later version.\n *\n *  This library is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n *  Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; if not, see\n *  <http://www.gnu.org/licenses/>.\n *\n *  Davide Libenzi <davidel@xmailserver.org>\n *\n */\n\n#if !defined(XTYPES_H)\n#define XTYPES_H\n\n\n\ntypedef struct s_chanode {\n\tstruct s_chanode *next;\n\tlong icurr;\n} chanode_t;\n\ntypedef struct s_chastore {\n\tchanode_t *head, *tail;\n\tlong isize, nsize;\n\tchanode_t *ancur;\n\tchanode_t *sncur;\n\tlong scurr;\n} chastore_t;\n\ntypedef struct s_xrecord {\n\tstruct s_xrecord *next;\n\tchar const *ptr;\n\tlong size;\n\tunsigned long ha;\n} xrecord_t;\n\ntypedef struct s_xdfile {\n\tchastore_t rcha;\n\tlong nrec;\n\tunsigned int hbits;\n\txrecord_t **rhash;\n\tlong dstart, dend;\n\txrecord_t **recs;\n\tchar *rchg;\n\tlong *rindex;\n\tlong nreff;\n\tunsigned long *ha;\n} xdfile_t;\n\ntypedef struct s_xdfenv {\n\txdfile_t xdf1, xdf2;\n} xdfenv_t;\n\n\n\n#endif /* #if !defined(XTYPES_H) */\n\n```<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\n","ts":1.738869337514E9}
