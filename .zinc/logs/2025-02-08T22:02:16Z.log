{"role":"user","content":"[1] [2] I'm working on understanding xdf_clean_mmatch. Can you tell what minimal parameters would make it return true?\n\n1: **third_party/xdiff/xprepare.c**\n```\n/*\n *  LibXDiff by Davide Libenzi ( File Differential Library )\n *  Copyright (C) 2003  Davide Libenzi\n *\n *  This library is free software; you can redistribute it and/or\n *  modify it under the terms of the GNU Lesser General Public\n *  License as published by the Free Software Foundation; either\n *  version 2.1 of the License, or (at your option) any later version.\n *\n *  This library is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n *  Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; if not, see\n *  <http://www.gnu.org/licenses/>.\n *\n *  Davide Libenzi <davidel@xmailserver.org>\n *\n */\n\n#include \"xinclude.h\"\n\n\n#define XDL_KPDIS_RUN 4\n#define XDL_MAX_EQLIMIT 1024\n#define XDL_SIMSCAN_WINDOW 100\n#define XDL_GUESS_NLINES1 256\n#define XDL_GUESS_NLINES2 20\n\n\ntypedef struct s_xdlclass {\n\tstruct s_xdlclass *next;\n\tunsigned long ha;\n\tchar const *line;\n\tlong size;\n\tlong idx;\n\tlong len1, len2;\n} xdlclass_t;\n\ntypedef struct s_xdlclassifier {\n\tunsigned int hbits;\n\tlong hsize;\n\txdlclass_t **rchash;\n\tchastore_t ncha;\n\txdlclass_t **rcrecs;\n\tlong alloc;\n\tlong count;\n\tlong flags;\n} xdlclassifier_t;\n\n\n\n\nstatic int xdl_init_classifier(xdlclassifier_t *cf, long size, long flags);\nstatic void xdl_free_classifier(xdlclassifier_t *cf);\nstatic int xdl_classify_record(unsigned int pass, xdlclassifier_t *cf, xrecord_t **rhash,\n\t\t\t       unsigned int hbits, xrecord_t *rec);\nstatic int xdl_prepare_ctx(unsigned int pass, mmfile_t *mf, long narec, xpparam_t const *xpp,\n\t\t\t   xdlclassifier_t *cf, xdfile_t *xdf);\nstatic void xdl_free_ctx(xdfile_t *xdf);\nstatic int xdl_clean_mmatch(char const *dis, long i, long s, long e);\nstatic int xdl_cleanup_records(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);\nstatic int xdl_trim_ends(xdfile_t *xdf1, xdfile_t *xdf2);\nstatic int xdl_optimize_ctxs(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);\n\n\n\n\nstatic int xdl_init_classifier(xdlclassifier_t *cf, long size, long flags) {\n\tcf->flags = flags;\n\n\tcf->hbits = xdl_hashbits((unsigned int) size);\n\tcf->hsize = 1 << cf->hbits;\n\n\tif (xdl_cha_init(&cf->ncha, sizeof(xdlclass_t), size / 4 + 1) < 0) {\n\n\t\treturn -1;\n\t}\n\tif (!XDL_CALLOC_ARRAY(cf->rchash, cf->hsize)) {\n\n\t\txdl_cha_free(&cf->ncha);\n\t\treturn -1;\n\t}\n\n\tcf->alloc = size;\n\tif (!XDL_ALLOC_ARRAY(cf->rcrecs, cf->alloc)) {\n\n\t\txdl_free(cf->rchash);\n\t\txdl_cha_free(&cf->ncha);\n\t\treturn -1;\n\t}\n\n\tcf->count = 0;\n\n\treturn 0;\n}\n\n\nstatic void xdl_free_classifier(xdlclassifier_t *cf) {\n\n\txdl_free(cf->rcrecs);\n\txdl_free(cf->rchash);\n\txdl_cha_free(&cf->ncha);\n}\n\n\nstatic int xdl_classify_record(unsigned int pass, xdlclassifier_t *cf, xrecord_t **rhash,\n\t\t\t       unsigned int hbits, xrecord_t *rec) {\n\tlong hi;\n\tchar const *line;\n\txdlclass_t *rcrec;\n\n\tline = rec->ptr;\n\thi = (long) XDL_HASHLONG(rec->ha, cf->hbits);\n\tfor (rcrec = cf->rchash[hi]; rcrec; rcrec = rcrec->next)\n\t\tif (rcrec->ha == rec->ha &&\n\t\t\t\txdl_recmatch(rcrec->line, rcrec->size,\n\t\t\t\t\trec->ptr, rec->size, cf->flags))\n\t\t\tbreak;\n\n\tif (!rcrec) {\n\t\tif (!(rcrec = xdl_cha_alloc(&cf->ncha))) {\n\n\t\t\treturn -1;\n\t\t}\n\t\trcrec->idx = cf->count++;\n\t\tif (XDL_ALLOC_GROW(cf->rcrecs, cf->count, cf->alloc))\n\t\t\t\treturn -1;\n\t\tcf->rcrecs[rcrec->idx] = rcrec;\n\t\trcrec->line = line;\n\t\trcrec->size = rec->size;\n\t\trcrec->ha = rec->ha;\n\t\trcrec->len1 = rcrec->len2 = 0;\n\t\trcrec->next = cf->rchash[hi];\n\t\tcf->rchash[hi] = rcrec;\n\t}\n\n\t(pass == 1) ? rcrec->len1++ : rcrec->len2++;\n\n\trec->ha = (unsigned long) rcrec->idx;\n\n\thi = (long) XDL_HASHLONG(rec->ha, hbits);\n\trec->next = rhash[hi];\n\trhash[hi] = rec;\n\n\treturn 0;\n}\n\n\nstatic int xdl_prepare_ctx(unsigned int pass, mmfile_t *mf, long narec, xpparam_t const *xpp,\n\t\t\t   xdlclassifier_t *cf, xdfile_t *xdf) {\n\tunsigned int hbits;\n\tlong nrec, hsize, bsize;\n\tunsigned long hav;\n\tchar const *blk, *cur, *top, *prev;\n\txrecord_t *crec;\n\txrecord_t **recs;\n\txrecord_t **rhash;\n\tunsigned long *ha;\n\tchar *rchg;\n\tlong *rindex;\n\n\tha = NULL;\n\trindex = NULL;\n\trchg = NULL;\n\trhash = NULL;\n\trecs = NULL;\n\n\tif (xdl_cha_init(&xdf->rcha, sizeof(xrecord_t), narec / 4 + 1) < 0)\n\t\tgoto abort;\n\tif (!XDL_ALLOC_ARRAY(recs, narec))\n\t\tgoto abort;\n\n\thbits = xdl_hashbits((unsigned int) narec);\n\thsize = 1 << hbits;\n\tif (!XDL_CALLOC_ARRAY(rhash, hsize))\n\t\tgoto abort;\n\n\tnrec = 0;\n\tif ((cur = blk = xdl_mmfile_first(mf, &bsize))) {\n\t\tfor (top = blk + bsize; cur < top; ) {\n\t\t\tprev = cur;\n\t\t\thav = xdl_hash_record(&cur, top, xpp->flags);\n\t\t\tif (XDL_ALLOC_GROW(recs, nrec + 1, narec))\n\t\t\t\tgoto abort;\n\t\t\tif (!(crec = xdl_cha_alloc(&xdf->rcha)))\n\t\t\t\tgoto abort;\n\t\t\tcrec->ptr = prev;\n\t\t\tcrec->size = (long) (cur - prev);\n\t\t\tcrec->ha = hav;\n\t\t\trecs[nrec++] = crec;\n\t\t\tif (xdl_classify_record(pass, cf, rhash, hbits, crec) < 0)\n\t\t\t\tgoto abort;\n\t\t}\n\t}\n\n\tif (!XDL_CALLOC_ARRAY(rchg, nrec + 2))\n\t\tgoto abort;\n\n\tif ((XDF_DIFF_ALG(xpp->flags) != XDF_PATIENCE_DIFF) &&\n\t    (XDF_DIFF_ALG(xpp->flags) != XDF_HISTOGRAM_DIFF)) {\n\t\tif (!XDL_ALLOC_ARRAY(rindex, nrec + 1))\n\t\t\tgoto abort;\n\t\tif (!XDL_ALLOC_ARRAY(ha, nrec + 1))\n\t\t\tgoto abort;\n\t}\n\n\txdf->nrec = nrec;\n\txdf->recs = recs;\n\txdf->hbits = hbits;\n\txdf->rhash = rhash;\n\txdf->rchg = rchg + 1;\n\txdf->rindex = rindex;\n\txdf->nreff = 0;\n\txdf->ha = ha;\n\txdf->dstart = 0;\n\txdf->dend = nrec - 1;\n\n\treturn 0;\n\nabort:\n\txdl_free(ha);\n\txdl_free(rindex);\n\txdl_free(rchg);\n\txdl_free(rhash);\n\txdl_free(recs);\n\txdl_cha_free(&xdf->rcha);\n\treturn -1;\n}\n\n\nstatic void xdl_free_ctx(xdfile_t *xdf) {\n\n\txdl_free(xdf->rhash);\n\txdl_free(xdf->rindex);\n\txdl_free(xdf->rchg - 1);\n\txdl_free(xdf->ha);\n\txdl_free(xdf->recs);\n\txdl_cha_free(&xdf->rcha);\n}\n\n\nint xdl_prepare_env(mmfile_t *mf1, mmfile_t *mf2, xpparam_t const *xpp,\n\t\t    xdfenv_t *xe) {\n\tlong enl1, enl2, sample;\n\txdlclassifier_t cf;\n\n\tmemset(&cf, 0, sizeof(cf));\n\n\t/*\n\t * For histogram diff, we can afford a smaller sample size and\n\t * thus a poorer estimate of the number of lines, as the hash\n\t * table (rhash) won't be filled up/grown. The number of lines\n\t * (nrecs) will be updated correctly anyway by\n\t * xdl_prepare_ctx().\n\t */\n\tsample = (XDF_DIFF_ALG(xpp->flags) == XDF_HISTOGRAM_DIFF\n\t\t  ? XDL_GUESS_NLINES2 : XDL_GUESS_NLINES1);\n\n\tenl1 = xdl_guess_lines(mf1, sample) + 1;\n\tenl2 = xdl_guess_lines(mf2, sample) + 1;\n\n\tif (xdl_init_classifier(&cf, enl1 + enl2 + 1, xpp->flags) < 0)\n\t\treturn -1;\n\n\tif (xdl_prepare_ctx(1, mf1, enl1, xpp, &cf, &xe->xdf1) < 0) {\n\n\t\txdl_free_classifier(&cf);\n\t\treturn -1;\n\t}\n\tif (xdl_prepare_ctx(2, mf2, enl2, xpp, &cf, &xe->xdf2) < 0) {\n\n\t\txdl_free_ctx(&xe->xdf1);\n\t\txdl_free_classifier(&cf);\n\t\treturn -1;\n\t}\n\n\tif ((XDF_DIFF_ALG(xpp->flags) != XDF_PATIENCE_DIFF) &&\n\t    (XDF_DIFF_ALG(xpp->flags) != XDF_HISTOGRAM_DIFF) &&\n\t    xdl_optimize_ctxs(&cf, &xe->xdf1, &xe->xdf2) < 0) {\n\n\t\txdl_free_ctx(&xe->xdf2);\n\t\txdl_free_ctx(&xe->xdf1);\n\t\txdl_free_classifier(&cf);\n\t\treturn -1;\n\t}\n\n\txdl_free_classifier(&cf);\n\n\treturn 0;\n}\n\n\nvoid xdl_free_env(xdfenv_t *xe) {\n\n\txdl_free_ctx(&xe->xdf2);\n\txdl_free_ctx(&xe->xdf1);\n}\n\n\nstatic int xdl_clean_mmatch(char const *dis, long i, long s, long e) {\n\tlong r, rdis0, rpdis0, rdis1, rpdis1;\n\n\t/*\n\t * Limits the window the is examined during the similar-lines\n\t * scan. The loops below stops when dis[i - r] == 1 (line that\n\t * has no match), but there are corner cases where the loop\n\t * proceed all the way to the extremities by causing huge\n\t * performance penalties in case of big files.\n\t */\n\tif (i - s > XDL_SIMSCAN_WINDOW)\n\t\ts = i - XDL_SIMSCAN_WINDOW;\n\tif (e - i > XDL_SIMSCAN_WINDOW)\n\t\te = i + XDL_SIMSCAN_WINDOW;\n\n\t/*\n\t * Scans the lines before 'i' to find a run of lines that either\n\t * have no match (dis[j] == 0) or have multiple matches (dis[j] > 1).\n\t * Note that we always call this function with dis[i] > 1, so the\n\t * current line (i) is already a multimatch line.\n\t */\n\tfor (r = 1, rdis0 = 0, rpdis0 = 1; (i - r) >= s; r++) {\n\t\tif (!dis[i - r])\n\t\t\trdis0++;\n\t\telse if (dis[i - r] == 2)\n\t\t\trpdis0++;\n\t\telse\n\t\t\tbreak;\n\t}\n\t/*\n\t * If the run before the line 'i' found only multimatch lines, we\n\t * return 0 and hence we don't make the current line (i) discarded.\n\t * We want to discard multimatch lines only when they appear in the\n\t * middle of runs with nomatch lines (dis[j] == 0).\n\t */\n\tif (rdis0 == 0)\n\t\treturn 0;\n\tfor (r = 1, rdis1 = 0, rpdis1 = 1; (i + r) <= e; r++) {\n\t\tif (!dis[i + r])\n\t\t\trdis1++;\n\t\telse if (dis[i + r] == 2)\n\t\t\trpdis1++;\n\t\telse\n\t\t\tbreak;\n\t}\n\t/*\n\t * If the run after the line 'i' found only multimatch lines, we\n\t * return 0 and hence we don't make the current line (i) discarded.\n\t */\n\tif (rdis1 == 0)\n\t\treturn 0;\n\trdis1 += rdis0;\n\trpdis1 += rpdis0;\n\n\treturn rpdis1 * XDL_KPDIS_RUN < (rpdis1 + rdis1);\n}\n\n\n/*\n * Try to reduce the problem complexity, discard records that have no\n * matches on the other file. Also, lines that have multiple matches\n * might be potentially discarded if they happear in a run of discardable.\n */\nstatic int xdl_cleanup_records(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2) {\n\tlong i, nm, nreff, mlim;\n\txrecord_t **recs;\n\txdlclass_t *rcrec;\n\tchar *dis, *dis1, *dis2;\n\n\tif (!XDL_CALLOC_ARRAY(dis, xdf1->nrec + xdf2->nrec + 2))\n\t\treturn -1;\n\tdis1 = dis;\n\tdis2 = dis1 + xdf1->nrec + 1;\n\n\tif ((mlim = xdl_bogosqrt(xdf1->nrec)) > XDL_MAX_EQLIMIT)\n\t\tmlim = XDL_MAX_EQLIMIT;\n\tfor (i = xdf1->dstart, recs = &xdf1->recs[xdf1->dstart]; i <= xdf1->dend; i++, recs++) {\n\t\trcrec = cf->rcrecs[(*recs)->ha];\n\t\tnm = rcrec ? rcrec->len2 : 0;\n\t\tdis1[i] = (nm == 0) ? 0: (nm >= mlim) ? 2: 1;\n\t}\n\n\tif ((mlim = xdl_bogosqrt(xdf2->nrec)) > XDL_MAX_EQLIMIT)\n\t\tmlim = XDL_MAX_EQLIMIT;\n\tfor (i = xdf2->dstart, recs = &xdf2->recs[xdf2->dstart]; i <= xdf2->dend; i++, recs++) {\n\t\trcrec = cf->rcrecs[(*recs)->ha];\n\t\tnm = rcrec ? rcrec->len1 : 0;\n\t\tdis2[i] = (nm == 0) ? 0: (nm >= mlim) ? 2: 1;\n\t}\n\n\tfor (nreff = 0, i = xdf1->dstart, recs = &xdf1->recs[xdf1->dstart];\n\t     i <= xdf1->dend; i++, recs++) {\n\t\tif (dis1[i] == 1 ||\n\t\t    (dis1[i] == 2 && !xdl_clean_mmatch(dis1, i, xdf1->dstart, xdf1->dend))) {\n\t\t\txdf1->rindex[nreff] = i;\n\t\t\txdf1->ha[nreff] = (*recs)->ha;\n\t\t\tnreff++;\n\t\t} else\n\t\t\txdf1->rchg[i] = 1;\n\t}\n\txdf1->nreff = nreff;\n\n\tfor (nreff = 0, i = xdf2->dstart, recs = &xdf2->recs[xdf2->dstart];\n\t     i <= xdf2->dend; i++, recs++) {\n\t\tif (dis2[i] == 1 ||\n\t\t    (dis2[i] == 2 && !xdl_clean_mmatch(dis2, i, xdf2->dstart, xdf2->dend))) {\n\t\t\txdf2->rindex[nreff] = i;\n\t\t\txdf2->ha[nreff] = (*recs)->ha;\n\t\t\tnreff++;\n\t\t} else\n\t\t\txdf2->rchg[i] = 1;\n\t}\n\txdf2->nreff = nreff;\n\n\txdl_free(dis);\n\n\treturn 0;\n}\n\n\n/*\n * Early trim initial and terminal matching records.\n */\nstatic int xdl_trim_ends(xdfile_t *xdf1, xdfile_t *xdf2) {\n\tlong i, lim;\n\txrecord_t **recs1, **recs2;\n\n\trecs1 = xdf1->recs;\n\trecs2 = xdf2->recs;\n\tfor (i = 0, lim = XDL_MIN(xdf1->nrec, xdf2->nrec); i < lim;\n\t     i++, recs1++, recs2++)\n\t\tif ((*recs1)->ha != (*recs2)->ha)\n\t\t\tbreak;\n\n\txdf1->dstart = xdf2->dstart = i;\n\n\trecs1 = xdf1->recs + xdf1->nrec - 1;\n\trecs2 = xdf2->recs + xdf2->nrec - 1;\n\tfor (lim -= i, i = 0; i < lim; i++, recs1--, recs2--)\n\t\tif ((*recs1)->ha != (*recs2)->ha)\n\t\t\tbreak;\n\n\txdf1->dend = xdf1->nrec - i - 1;\n\txdf2->dend = xdf2->nrec - i - 1;\n\n\treturn 0;\n}\n\n\nstatic int xdl_optimize_ctxs(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2) {\n\n\tif (xdl_trim_ends(xdf1, xdf2) < 0 ||\n\t    xdl_cleanup_records(cf, xdf1, xdf2) < 0) {\n\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n```\n\n2: **src/diff_xdiff.cpp**\n```\n#include <cstdlib>\n#include <stdlib.h>\n\n\nextern \"C\" {\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wsign-conversion\"\n#pragma GCC diagnostic ignored \"-Wconversion\"\n#include <xdiff/xinclude.h>\n\n// add casts in order to navigate -fpermissive void* warnings\n} struct AnyPtr { template <class T>\n    operator T*() { return (T*) ptr; } void *ptr;\n}; extern \"C\" {\n#undef NULL\n#define NULL AnyPtr(nullptr)\n\n#undef xdl_malloc\n#define xdl_malloc(x) AnyPtr(malloc(x))\n#undef xdl_calloc\n#define xdl_calloc(n, sz) AnyPtr(calloc(n, sz))\n#undef xdl_free\n#define xdl_free(ptr) free(ptr)\n#undef xdl_realloc\n#define xdl_realloc(ptr, x) (decltype(ptr))realloc(ptr, x)\n\n#define xdl_mmfile_first(mmf,size) AnyPtr(xdl_mmfile_first(mmf,size))\n#define xdl_cha_alloc(cha) AnyPtr(xdl_cha_alloc(cha))\n#define xdl_alloc_grow_helper(p,nr,alloc,size) AnyPtr(xdl_alloc_grow_helper(p,nr,alloc,size))\n// done adding casts\n\n#include <xdiff/xprepare.c>\n\n#undef calloc\n#undef malloc\n#pragma GCC diagnostic pop\n}\n\n#include <cassert>\n#include <span>\n#include <stdexcept>\n#include <string_view>\n#include <valarray>\n#include <vector>\n\n#include <boost/container/devector.hpp>\n\nunsigned long enum XDFLAGS {\n    NEED_MINIMAL = (1 << 0),\n\n    IGNORE_WHITESPACE = (1 << 1),\n    IGNORE_WHITESPACE_CHANGE = (1 << 2),\n    IGNORE_WHITESPACE_AT_EOL = (1 << 3),\n    IGNORE_CR_AT_EOL = (1 << 4),\n    WHITESPACE_FLAGS = (IGNORE_WHITESPACE |\n\t    \t\t        IGNORE_WHITESPACE_CHANGE |\n\t    \t\t        IGNORE_WHITESPACE_AT_EOL |\n\t    \t\t        IGNORE_CR_AT_EOL),\n\n    IGNORE_BLANK_LINES = (1 << 7),\n\n    PATIENCE_DIFF = (1 << 14),\n    HISTOGRAM_DIFF = (1 << 15),\n    DIFF_ALGORITHM_MASK = (PATIENCE_DIFF | HISTOGRAM_DIFF),\n\n    INDENT_HEURISTIC = (1 << 23)\n};\n\nnamespace {\n\ntemplate <typename T>\nmmfile_t to_mmfile(T data)\n{\n\treturn {\n\t\t.ptr = (char*)data.data(),\n\t\t.size = (long)data.size()\n\t};\n};\n\nstd::string_view xdfile_line(xdfile_t & xdf, size_t idx)\n{\n    auto & rec = *xdf.recs[idx];\n\tstd::string_view result{\n\t\trec.ptr, static_cast<size_t>(rec.size)\n\t};\n\tif (result.back() == '\\n') {\n\t\tresult = result.substr(0, result.size()-1);\n\t}\n\treturn result;\n}\n\n#define mustbe0(call) _0(0 == (call), \"failed: \" #call)\n#define cantbe0(call) _0(0 != (call), \"failed: \" #call)\ninline void _0(bool success, char const * msg)\n{ if (!success) { throw std::runtime_error(msg); } }\n\n}\n\nenum DiffType { EQUAL, INSERT, DELETE };\nstruct Diff {\n    DiffType type;\n    std::string_view text;\n\n    Diff(DiffType type, std::string_view text)\n    : type(type), text(text) {}\n    Diff(DiffType type, xdfile_t & xdf, size_t line = 0)\n    : type(type), text(xdfile_line(xdf, line)) {}\n    bool operator==(Diff const&) const = default;\n};\n\nclass ChaStore\n{\n    // a chastore is a linked list of chanodes\n    // .head, .tail -> node pointers\n    // .isize -> size of each user item allocated in a node\n    // .nsize -> size of each node memory region (minus chanode size)\n    // .ancur -> pointer to active node being filled\n    // a chanode is a header to an allocated memory region, \n    //      .next -> pointer to next node\n    //      .icurr -> offset within this node to next use\n\n    // questions: it looks to me like always ancur == tail. true/false?\n\n    // so basically a chanode is a dynamic array similar to a deque\n    // it does not appear to manage user offsets within its storage\n};\n\nclass DynamicXDFile\n{\npublic:\n    DynamicXDFile(unsigned int pass, xdfile_t * xdf, xdlclassifier_t * cf, unsigned int line_estimate)\n    : xdf(xdf), cf(cf), pass(pass)\n    {\n        /* xdl_prepare_ctx */\n\t    mustbe0(xdl_cha_init(&xdf->rcha, sizeof(xrecord_t), line_estimate / 4 + 1));\n\n        hbits = xdl_hashbits((unsigned int) line_estimate);\n        rhash.resize(1 << hbits);\n\n        xdf->nrec = 0;\n        xdf->nreff = 0;\n        xdf->dstart = 0;\n\n        /* xdl_cleanup_records */\n        if ((mlim = xdl_bogosqrt(line_estimate)) > XDL_MAX_EQLIMIT)\n            mlim = XDL_MAX_EQLIMIT;\n    }\n    unsigned int line_estimate() {\n        return xdf->rcha.nsize / xdf->rcha.isize;\n    }\n    long size() {\n        return xdf->nrec;\n    }\n    std::string_view operator[](long line) {\n        auto & rec = *recs[line];\n        return {rec.ptr, (size_t)rec.size};\n    }\n    void extend_pre(xpparam_t * xpp, long line_estimate, std::span<char> data, bool compare_nreff = false)\n    {\n        /* xdl_prepare_ctx */\n    \tlong nrec, hsize, bsize;\n    \tunsigned long hav;\n    \tchar const *blk, *cur, *top, *prev;\n        xrecord_t *crec;\n\n        unsigned int narec = recs.size() + line_estimate;\n\n        if (narec >= rhash.size()) {\n            // this block always asserts to detect situations\n            // where this happens frequently or readily.\n            // it's better to estimate more lines at the start, because\n            // growing the hash table means reseating everything\n            assert(narec < rhash.size() && \"line estimate was too low by a factor of at least 2\");\n            hbits = xdl_hashbits((unsigned int) narec);\n            rhash.clear();\n            rhash.resize(1 << hbits);\n            for (auto rec : recs) {\n                auto hi = (long) XDL_HASHLONG(rec->ha, hbits);\n                rhash[hi] = rec;\n            }\n        }\n\n        recs.resize(narec);\n\n        nrec = xdf->nrec;\n        for (cur = &*data.begin(), top = &*data.end(); cur < top; ) {\n            prev = cur;\n            hav = xdl_hash_record(&cur, top, xpp->flags);\n            recs.resize(narec = nrec + 1);\n            cantbe0(crec = xdl_cha_alloc(&xdf->rcha));\n            crec->ptr = prev;\n            crec->size = (long) (cur - prev);\n            crec->ha = hav;\n            recs[nrec++] = crec;\n            mustbe0(xdl_classify_record(pass, cf, rhash.data(), hbits, crec));\n        }\n\n        rchg.resize(nrec + 2);\n\t    if ((XDF_DIFF_ALG(xpp->flags) != XDF_PATIENCE_DIFF) &&\n    \t    (XDF_DIFF_ALG(xpp->flags) != XDF_HISTOGRAM_DIFF)) {\n            rindex.resize(nrec + 1);\n            ha.resize(nrec + 1);\n    \t}\n\n        xdf->nrec = nrec;\n        xdf->recs = recs.begin();\n        xdf->hbits = hbits;\n        xdf->rhash = rhash.data();\n        xdf->rchg = rchg.begin() + 1;\n        xdf->rindex = &rindex[0];\n        xdf->ha = ha.begin();\n        xdf->dend = nrec - 1;\n    }\n    void extend_post(unsigned int end, bool compare_nreff)\n    {\n        /* ~~ xld_optimize_ctxs */\n        unsigned int start = xdf->nreff ? xdf->rindex[xdf->nreff - 1] : 0;\n\n        /* xdl_cleanup_records */\n        long i, nm, nreff;\n        xrecord_t **recs;\n        xdlclass_t *rcrec;\n\n\n        if (!compare_nreff) {\n            for (nreff = xdf->nreff, i = start, recs = &xdf->recs[start];\n                i <= end; i++, recs++, nreff++) {\n    \t\t\txdf->rindex[nreff] = i;\n    \t\t\txdf->ha[nreff] = (*recs)->ha;\n            }\n        } else {\n\n            dis.resize(end - start + 1);\n\n            for (i = start, recs = &xdf->recs[start]; i < end; i++, recs++) {\n                rcrec = cf->rcrecs[(*recs)->ha];\n                nm = rcrec ? (pass == 1 ? rcrec->len2 : rcrec->len1) : 0;\n                dis[i] = (nm == 0) ? 0: (nm >= mlim) ? 2: 1;\n            }\n\n            for (nreff = xdf->nreff, i = start, recs = &xdf->recs[start];\n                 i <= end; i++, recs++) {\n    \t\t    if (dis[i] == 1 ||\n                        there is a bug here in that xdl_clean_mmatch i believe treats dis as referencing the entire file\n        \t\t    (dis[i] == 2 && !xdl_clean_mmatch(dis.data(), i, xdf->dstart, xdf->dend))) {\n        \t\t\txdf->rindex[nreff] = i;\n        \t\t\txdf->ha[nreff] = (*recs)->ha;\n        \t\t\tnreff++;\n        \t\t} else\n        \t\t\txdf1->rchg[i] = 1;\n            }\n        }\n        xdf->nreff = nreff;\n    }\n    void consume(long lines = 1)\n    {\n        /* xdl_trim_ends */\n        xdf->dstart += lines;\n\n        /* ... */\n        cha_consume_(lines);\n        if (lines < xdf->dstart) {\n            xdf->dstart -= lines;\n        } else {\n            xdf->dstart = 0;\n        }\n        xdf->dend -= lines;\n        for (size_t i = 0 ; i < lines; ++ i) {\n            classifier_consume_(recs[i]);\n        }\n        recs.erase(recs.begin(), recs.begin() + lines);\n        xdf->recs = recs.begin();\n        rchg.erase(rchg.begin(), rchg.begin() + lines);\n        xdf->rchg = rchg.begin() + 1;\n        xdf->nrec -= lines;\n\n        /* xdl_cleanup_records */\n        long nreff = xdf->nreff, nreff_off;\n        for (nreff_off = 0; nreff_eff < nreff; ++ nreff_off) {\n            if (rindex[nreff_off] >= lines) {\n                break;\n            }\n        }\n        nreff -= nreff_off;\n        rindex[std::slice(0, nreff, 1)] =\n            rindex[std::slice(nreff_off, nreff, 1)] - lines;\n        ha.erase(ha.begin(), ha.begin() + nreff_off);\n        xdf->ha = ha.begin();\n        xdf->nref = nreff;\n    }\n    ~DynamicXDFile()\n    {\n        /* xdl_free_ctx */\n        xdl_cha_free(xdf->rcha);\n    }\n\nprivate:\n    void cha_consume_(chastore_t * cha, size_t items)\n    {\n        /* xdl_cha_alloc */\n        cha->scurr += items * cha->isize;\n        while (cha->scurr > cha->head->icurr) {\n            auto consumed = cha->head;\n            cha->head = consumed->next;\n            if (cha->tail == consumed) {\n                cha->tail = cha->head;\n            }\n            if (cha->ancur == consumed) {\n                cha->ancur = cha->head;\n            }\n            cha->scurr -= consumed->icurr;\n            xdl_free(consumed);\n        }\n    }\n    void classifier_consume_(xdlclassifier_t * cf, xrecord_t * rec)\n    {\n        /* xdl_classify_record */\n        // look up record\n        auto* rcrec = cf->rcrecs[rec->ha];\n\n        // update line count\n        (pass == 1) ? rcrec->len1-- : rcrec->len2--;\n        \n        // remove from rhash\n        long rhash_hi = (long) XDL_HASHLONG(rec->ha, xdf->hbits);\n        auto rhash_it = rhash[rhash_hi];\n        if (rhash_it == rec) {\n            rhash[rhash_hi] = rec->next;\n        } else {\n            while (rhash_it->next != rec) {\n                assert(rhash_it->next);\n                rhash_it = rhash_it->next;\n            }\n            rhash_it->next = rec->next;\n        }\n\n        // the rcrec is not consumed if unused at this time.\n        // another line may still hash to its value.\n    }\n    xdfile_t * xdf;\n    xdlclassifier_t * cf;\n    unsigned int pass;\n    unsigned int hbits;\n    std::vector<xrecord_t*> rhash; // reverse hash lookup, constant size\n    boost::container::devector<xrecord_t*> recs; // canonical line list, points into xdf->rcha\n    boost::container::devector<char> rchg; // canonical line change list\n    std::valarray<long> rindex;\n    boost::container::devector<unsigned long> ha;\n\n    long mlim;\n    std::vector<char> dis;\n};\n\nclass AsymmetricStreamingXDiff\n{\npublic:\n    AsymmetricStreamingXDiff(\n        std::string_view old_file,\n        unsigned long xdflags = NEED_MINIMAL | IGNORE_CR_AT_EOL /*| HISTOGRAM_DIFF*/ | INDENT_HEURISTIC\n    ) : xp{\n          .flags = xdflags,\n          .ignore_regex = nullptr, .ignore_regex_nr = 0,\n          .anchors = nullptr,\n          .anchors_nr = 0,\n        },\n        dynxdfs{\n            {\n                1,\n                &xe.xdf1,\n                &cf,\n                /* xdl_prepare_env */\n                xdl_guess_lines(\n                        to_mmfile(data_old),\n                        (XDF_DIFF_ALG(flags) == XDF_HISTOGRAM_DIFF\n                         ? XDL_GUESS_NLINES2 : XDL_GUESS_NLINES1)\n                )\n            }, {\n                2,\n                &xe.xdf2,\n                &cf,\n                dynxdfs[0].line_estimate() * 2\n            }\n        };\n    {\n        auto line_estimate = dynxdfs[0].line_estimate();\n\n        /* xdl_prepare_env */\n        memset(cf, 0, sizeof(*cf));\n\n        mustbe0(xdl_init_classifier(&cf, line_estimate * 2 + 1, xp.flags));\n\n        /* ... */\n        dynxdfs[0].extend_pre(&xp, line_estimate, old_file);\n        dynxdfs[0].extend_post(dynxdfs[0].size(), false);\n    }\n    zinc::generator<Diff> diff(zinc::generator<std::string_view> against, ssize_t window_size = -1)\n    {\n        if (window_size == -1) {\n            window_size = std::max(\n                    std::sqrt(dynxdfs[0].size()) + 1,\n                    std::sqrt(line_estimate()) + 1,\n                    7\n            );\n        }\n        long l1 = 0, l2 = 0;\n        for (auto && new_line : against) {\n            extend_env(new_line);\n            if (dynxdfs[1].size() >= window_size) {\n                do_diff();                \n                for (auto && diff : generate_diffs_for(l1, l2)) {\n                    co_yield diff;\n                }\n                // if l1 or l2 overflows this likely means that file 1 was exhausted while there were still matching values in file 2 for some reason. maybe they weren't passed through nreff?\n                while (l1) {\n                    dynxdfs[0].consume();\n                    -- l1;\n                }\n                while (l2) {\n                    dynxdfs[1].consume();\n                    -- l2;\n                }\n            }\n        }\n        do_diff();\n\n        while (l1 < dynxdfs[0].size() || l2 < dynxdfs[1].size()) {\n            for (auto && diff : generate_diffs_for(l1, l2)) {\n                co_yield diff;\n            }\n        }\n    }\n    ~AsymmetricStreamingXDiff()\n    {\n        xdl_free_classifier(&cf);\n        xdl_free_env(&xe);\n    }\nprivate:\n    zinc::generator<Diff> generate_diffs_for(long & l1, long & l2)\n    {\n        bool c1 = (l1 < dynxdfs[0].size()) ? dynxdfs[0].rchg[l1] : 0;\n        bool c2 = (l2 < dynxdfs[1].size()) ? dynxdfs[1].rchg[l2] : 0;\n        switch (std::pair<bool>(c1, c2)) {\n        case {true, true}:\n            co_yield Diff(DELETE, xe.xdf1);\n            ++ l1;\n            co_yield Diff(INSERT, xe.xdf2);\n            ++ l2;\n            break;\n        case {true, false}:\n            co_yield Diff(DELETE, xe.xdf1);\n            ++ l1;\n            break;\n        case {false, true}:\n            co_yield Diff(INSERT, xe.xdf2);\n            ++ l2;\n            break;\n        case {false, false}:\n            assert(xdfile_line(xe.xdf1,0) == xdfile_line(xe.xdf2,0));\n            co_yield Diff(EQUAL, xe.xdf1);\n            ++ l1;\n            ++ l2;\n            break;\n        }\n    }\n    //void extend_env(unsigned int lines_estimate, std::span<char> data)\n    //{\n    //    dynxdfs[1].extend(lines_estimate, data);\n    //    // lets update nreff\n    //}\n    size_t extend_env(std::string_view line) {\n        size_t mark_b = window.size();\n        size_t mark_l = dynxdfs[1].size();\n        \n        assert(line.find('\\n') == line.end());\n        window.insert(window.end(), line.begin(), line.end());\n        window.push_back('\\n');\n\n        dynxdfs[1].extend_pre(\n                &xp,\n                1,//lines.size(),\n                {\n                    window.begin() + mark_b, \n                    window.end()\n                }\n        );\n        dynxdfs[1].extend_post(\n                dynxdfs[1].size(),\n                true\n        );\n        return dynxdfs[1].size();\n    }\n    void do_diff()\n    {\n        switch (XDF_DIGG_ALG(xp.flags)) {\n        case XDF_PATIENCE_DIFF:\n            mustbe0(xdl_do_patience_diff(&xp, xe));\n            break;\n        case XDF_HISTOGRAM_DIFF:\n            mustbe0(xdl_do_histogram_diff(&xp, xe));\n            break;\n        default: {\n            /* from xdiff/xdiffi.c . feel free to consolidate. */\n        \tlong ndiags;\n        \tlong *kvdf, *kvdb;\n        \txdalgoenv_t xenv;\n        \tdiffdata_t dd1, dd2;\n\n        \t/*\n        \t * Allocate and setup K vectors to be used by the differential\n        \t * algorithm.\n        \t *\n        \t * One is to store the forward path and one to store the backward path.\n        \t */\n        \tndiags = xe->xdf1.nreff + xe->xdf2.nreff + 3;\n            kvd.resize(2 * ndiags + 2);\n        \tkvdf = kvd.data();\n        \tkvdb = kvdf + ndiags;\n        \tkvdf += xe->xdf2.nreff + 1;\n        \tkvdb += xe->xdf2.nreff + 1;\n\n        \txenv.mxcost = xdl_bogosqrt(ndiags);\n        \tif (xenv.mxcost < XDL_MAX_COST_MIN)\n        \t\txenv.mxcost = XDL_MAX_COST_MIN;\n        \txenv.snake_cnt = XDL_SNAKE_CNT;\n        \txenv.heur_min = XDL_HEUR_MIN_COST;\n\n        \tdd1.nrec = xe->xdf1.nreff;\n        \tdd1.ha = xe->xdf1.ha;\n        \tdd1.rchg = xe->xdf1.rchg;\n        \tdd1.rindex = xe->xdf1.rindex;\n        \tdd2.nrec = xe->xdf2.nreff;\n        \tdd2.ha = xe->xdf2.ha;\n        \tdd2.rchg = xe->xdf2.rchg;\n        \tdd2.rindex = xe->xdf2.rindex;\n\n        \tmustbe0(xdl_recs_cmp(&dd1, 0, dd1.nrec, &dd2, 0, dd2.nrec,\n        \t\t    kvdf, kvdb, (xp.flags & XDF_NEED_MINIMAL) != 0,\n        \t\t    &xenv));\n        }   break;\n        }\n    }\n    xpparam_t xp;\n    xdfenv_t xe;\n    boost::container::devector window;\n    std::vector<long> kvd; /* stores path vectors in default algorithm */\n    DynamicXDFile dynxdf[2];\n\n    xdlclassifier_t cf;\n    std::vector<xdlclass_t*> cf_rchash;\n    std::vector<xdlclass_t*> cf_rcrecs;\n    std::vector<xrecord_t*> xdf2_rhash;\n    std::vector<xrecord_t*> xdf2_recs;\n    std::vector<char> xdf2_rchg;\n    std::vector<long> xdf2_rindex;\n    std::vector<long> xdf2_ha;\n};\n\nclass XDiff\n{\npublic:\n    template <typename T>\n    XDiff(\n        T data_old,\n        T data_new,\n        unsigned long xdflags = NEED_MINIMAL | HISTOGRAM_DIFF | INDENT_HEURISTIC\n    ) : xp{\n        .flags = xdflags,\n        .ignore_regex = nullptr,\n        .ignore_regex_nr = 0,\n        .anchors = nullptr,\n        .anchors_nr = 0,\n    }\n    {\n        mmfile_t o = to_mmfile(data_old), n = to_mmfile(data_new);\n        mustbe0(xdl_do_diff(&o, &n, &xp, &xe));\n    }\n    \n    std::vector<Diff> & edits(std::vector<Diff> & result)\n    {\n        size_t l1 = 0, l2 = 0;\n    \tauto* cp1 = xe.xdf1.rchg,* cp2 = xe.xdf2.rchg;\n    \tssize_t s1 = xe.xdf1.nrec, s2 = xe.xdf2.nrec;\n    \twhile ((ssize_t)l1 < s1 || (ssize_t)l2 < s2) {\n    \t\tauto c1 = ((ssize_t)l1 < s1 ? (cp1[l1]?1:0) : 0);\n    \t\tauto c2 = ((ssize_t)l2 < s2 ? (cp2[l2]?1:0) : 0);\n    \t\tswitch ((c1 << 2) | c2) {\n    \t\tcase (1 << 2) | 1:\n    \t\t\t// remove and add\n                result.push_back(Diff(DELETE, xe.xdf1, l1));\n                ++ l1;\n                result.push_back(Diff(INSERT, xe.xdf2, l2));\n                ++ l2;\n    \t\t\tbreak;\n    \t\tcase (1 << 2) | 0:\n    \t\t\t// remove only\n                result.push_back(Diff(DELETE, xe.xdf1, l1));\n                ++ l1;\n    \t\t\tbreak;\n    \t\tcase 0 | 1:\n    \t\t\t// add only\n                result.push_back(Diff(INSERT, xe.xdf2, l2));\n                ++ l2;\n    \t\t\tbreak;\n    \t\tcase 0:\n    \t\t\t// same\n    \t\t\tassert(xdfile_line(xe.xdf1,l1)==xdfile_line(xe.xdf2,l2));\n                result.push_back(Diff(EQUAL, xe.xdf1, l1));\n                ++ l1;\n                ++ l2;\n    \t\t\tbreak;\n    \t\t}\n    \t}\n        return result;\n    }\n    ~XDiff()\n    {\n        xdl_free_env(&xe);\n    }\nprivate:\n    xpparam_t xp;\n    xdfenv_t xe;\n};\n\n\n#include <iostream>\nnamespace {\n\nclass XDiffAdapter {\npublic:\n    XDiffAdapter() {}\n\n    std::vector<Diff> diff_main(std::string a_, std::string b_, bool)\n    {\n        std::string a, b;\n        for (auto [in,out] : {std::pair(a_,&a),{b_,&b}}) {\n            for (auto & ch : in) {\n                out->push_back(ch);\n                out->push_back('\\n');\n            }\n        }\n        std::vector<Diff> result;\n        return std::move(XDiff(a, b).edits(result));\n    }\n};\n\nclass AsymmetricStreamingXDiffAdapter {\npublic:\n    AsymmetricStreamingXDiffAdapter() {}\n\n    std::vector<Diff> diff_main(std::string a_, std::string b_, bool)\n    {\n        std::string a;\n        for (auto ch : a_) {\n            a.push_back(ch);\n            a.push_back('\\n')l\n        }\n        std::vector<Diff> result;\n        AsymmetricStreamingXDiff xdiff(a);\n        auto b = []()->zinc::generator<std::string_view> {\n            std::string b;\n            b.resize(2);\n            b[1] = '\\n';\n            for (auto & ch : b_) {\n                b[0] = ch;\n                co_yield b;\n            }\n        };\n        for (auto && diff : xdiff.diff(b(), b_.size())) {\n            result.emplace_back(std::move(diff));\n        }\n        return result;\n    }\n};\n\nvoid assertEquals(char const*desc, std::vector<Diff>&expected, std::vector<Diff>const&actual)\n{\n    std::cerr << desc << std::endl;\n    assert(std::equal(expected.begin(),expected.end(),actual.begin(),actual.end()));\n}\ntemplate <typename... T>\nstd::vector<Diff> diffList(T... diffs)\n{\n    return {diffs...};\n}\n\n}\n\nvoid test_diff_xdiff()\n{\n  AsymmetricStreamingXDiffAdapter dmp;\n  std::vector<Diff> diffs;\n\n  assertEquals(\"diff_main: Null case.\", diffs, dmp.diff_main(\"\", \"\", false));\n\n  diffs = diffList(Diff(EQUAL, \"abc\"));\n  assertEquals(\"diff_main: Equality.\", diffs, dmp.diff_main(\"abc\", \"abc\", false));\n\n  diffs = diffList(Diff(EQUAL, \"ab\"), Diff(INSERT, \"123\"), Diff(EQUAL, \"c\"));\n  assertEquals(\"diff_main: Simple insertion.\", diffs, dmp.diff_main(\"abc\", \"ab123c\", false));\n\n  diffs = diffList(Diff(EQUAL, \"a\"), Diff(DELETE, \"123\"), Diff(EQUAL, \"bc\"));\n  assertEquals(\"diff_main: Simple deletion.\", diffs, dmp.diff_main(\"a123bc\", \"abc\", false));\n\n  diffs = diffList(Diff(EQUAL, \"a\"), Diff(INSERT, \"123\"), Diff(EQUAL, \"b\"), Diff(INSERT, \"456\"), Diff(EQUAL, \"c\"));\n  assertEquals(\"diff_main: Two insertions.\", diffs, dmp.diff_main(\"abc\", \"a123b456c\", false));\n\n  diffs = diffList(Diff(EQUAL, \"a\"), Diff(DELETE, \"123\"), Diff(EQUAL, \"b\"), Diff(DELETE, \"456\"), Diff(EQUAL, \"c\"));\n  assertEquals(\"diff_main: Two deletions.\", diffs, dmp.diff_main(\"a123b456c\", \"abc\", false));\n\n  diffs = diffList(Diff(DELETE, \"a\"), Diff(INSERT, \"b\"));\n  assertEquals(\"diff_main: Simple case #1.\", diffs, dmp.diff_main(\"a\", \"b\", false));\n\n  diffs = diffList(Diff(DELETE, \"Apple\"), Diff(INSERT, \"Banana\"), Diff(EQUAL, \"s are a\"), Diff(INSERT, \"lso\"), Diff(EQUAL, \" fruit.\"));\n  assertEquals(\"diff_main: Simple case #2.\", diffs, dmp.diff_main(\"Apples are a fruit.\", \"Bananas are also fruit.\", false));\n\n  //diffs = diffList(Diff(DELETE, \"a\"), Diff(INSERT, QString::fromWCharArray((const wchar_t*) L\"\\u0680\", 1)), Diff(EQUAL, \"x\"), Diff(DELETE, \"\\t\"), Diff(INSERT, QString::fromWCharArray((const wchar_t*) L\"\\000\", 1)));\n  //assertEquals(\"diff_main: Simple case #3.\", diffs, dmp.diff_main(\"ax\\t\", QString::fromWCharArray((const wchar_t*) L\"\\u0680x\\000\", 3), false));\n\n  diffs = diffList(Diff(DELETE, \"1\"), Diff(EQUAL, \"a\"), Diff(DELETE, \"y\"), Diff(EQUAL, \"b\"), Diff(DELETE, \"2\"), Diff(INSERT, \"xab\"));\n  assertEquals(\"diff_main: Overlap #1.\", diffs, dmp.diff_main(\"1ayb2\", \"abxab\", false));\n\n  diffs = diffList(Diff(INSERT, \"xaxcx\"), Diff(EQUAL, \"abc\"), Diff(DELETE, \"y\"));\n  assertEquals(\"diff_main: Overlap #2.\", diffs, dmp.diff_main(\"abcy\", \"xaxcxabc\", false));\n\n  diffs = diffList(Diff(DELETE, \"ABCD\"), Diff(EQUAL, \"a\"), Diff(DELETE, \"=\"), Diff(INSERT, \"-\"), Diff(EQUAL, \"bcd\"), Diff(DELETE, \"=\"), Diff(INSERT, \"-\"), Diff(EQUAL, \"efghijklmnopqrs\"), Diff(DELETE, \"EFGHIJKLMNOefg\"));\n  assertEquals(\"diff_main: Overlap #3.\", diffs, dmp.diff_main(\"ABCDa=bcd=efghijklmnopqrsEFGHIJKLMNOefg\", \"a-bcd-efghijklmnopqrs\", false));\n\n  diffs = diffList(Diff(INSERT, \" \"), Diff(EQUAL, \"a\"), Diff(INSERT, \"nd\"), Diff(EQUAL, \" [[Pennsylvania]]\"), Diff(DELETE, \" and [[New\"));\n  assertEquals(\"diff_main: Large equality.\", diffs, dmp.diff_main(\"a [[Pennsylvania]] and [[New\", \" and [[Pennsylvania]]\", false));\n}\n\nint main() {\n    test_diff_xdiff();\n}\n//*/\n\n```\n","ts":1.739070150772E9}
