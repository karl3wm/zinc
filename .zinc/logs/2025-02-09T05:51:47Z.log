{"role":"user","content":"Write a boost::json parser that tracks the range of characters in the passed string represented by each value.","ts":1.739098343115E9}
{"role":"assistant","content":"Below is an example of a `boost::json` parser that tracks the range of characters in the passed string represented by each value.\n\n```cpp\n#include <boost/json.hpp>\n#include <iostream>\n#include <string>\n\n// Custom value type that includes the range of characters in the input string\nstruct ranged_value {\n    boost::json::value value;\n    size_t start;\n    size_t end;\n};\n\n// Custom parser that tracks the range of characters in the input string\nclass ranged_parser {\npublic:\n    ranged_parser() : parser_(), start_(0) {}\n\n    // Parse a JSON string and return a ranged_value\n    ranged_value parse(const std::string& str) {\n        boost::json::error_code ec;\n        boost::json::value value = parser_.write(str, ec);\n        if (ec) {\n            throw boost::json::system_error(ec);\n        }\n        return {value, start_, start_ + str.size()};\n    }\n\n    // Parse a JSON string and return a ranged_value, with the range of each child value tracked\n    ranged_value parse_with_ranges(const std::string& str) {\n        boost::json::error_code ec;\n        boost::json::value value = parser_.write(str, ec);\n        if (ec) {\n            throw boost::json::system_error(ec);\n        }\n        return parse_with_ranges_recursive(value, str, start_);\n    }\n\nprivate:\n    // Recursively parse a JSON value and track the range of each child value\n    ranged_value parse_with_ranges_recursive(const boost::json::value& value, const std::string& str, size_t start) {\n        ranged_value result;\n        result.value = value;\n        result.start = start;\n        result.end = start;\n\n        switch (value.kind()) {\n            case boost::json::kind::object: {\n                result.end = start;\n                for (const auto& [key, val] : value.as_object()) {\n                    size_t key_start = str.find(key, result.end);\n                    size_t key_end = key_start + key.size();\n                    size_t val_start = key_end + 1; // +1 for the colon\n                    ranged_value val_result = parse_with_ranges_recursive(val, str, val_start);\n                    result.end = val_result.end;\n                }\n                result.end += 1; // +1 for the closing brace\n                break;\n            }\n            case boost::json::kind::array: {\n                result.end = start;\n                for (const auto& val : value.as_array()) {\n                    ranged_value val_result = parse_with_ranges_recursive(val, str, result.end);\n                    result.end = val_result.end;\n                }\n                result.end += 1; // +1 for the closing bracket\n                break;\n            }\n            case boost::json::kind::string: {\n                size_t str_start = str.find(value.as_string(), start);\n                result.start = str_start;\n                result.end = str_start + value.as_string().size() + 2; // +2 for the quotes\n                break;\n            }\n            case boost::json::kind::int64: {\n                size_t int_start = str.find(std::to_string(value.as_int64()), start);\n                result.start = int_start;\n                result.end = int_start + std::to_string(value.as_int64()).size();\n                break;\n            }\n            case boost::json::kind::uint64: {\n                size_t uint_start = str.find(std::to_string(value.as_uint64()), start);\n                result.start = uint_start;\n                result.end = uint_start + std::to_string(value.as_uint64()).size();\n                break;\n            }\n            case boost::json::kind::double_: {\n                size_t double_start = str.find(std::to_string(value.as_double()), start);\n                result.start = double_start;\n                result.end = double_start + std::to_string(value.as_double()).size();\n                break;\n            }\n            case boost::json::kind::bool_: {\n                size_t bool_start = str.find(value.as_bool() ? \"true\" : \"false\", start);\n                result.start = bool_start;\n                result.end = bool_start + (value.as_bool() ? 4 : 5);\n                break;\n            }\n            case boost::json::kind::null: {\n                size_t null_start = str.find(\"null\", start);\n                result.start = null_start;\n                result.end = null_start + 4;\n                break;\n            }\n        }\n\n        return result;\n    }\n\n    boost::json::parser parser_;\n    size_t start_;\n};\n\nint main() {\n    ranged_parser parser;\n    std::string json_str = \"{\\\"key\\\":\\\"value\\\",\\\"array\\\":[1,2,3],\\\"object\\\":{\\\"nested\\\":\\\"value\\\"}}\";\n    ranged_value value = parser.parse_with_ranges(json_str);\n\n    // Print the parsed JSON value and its range\n    std::cout << \"Parsed JSON value: \" << value.value << std::endl;\n    std::cout << \"Range: [\" << value.start << \", \" << value.end << \")\" << std::endl;\n\n    return 0;\n}\n```\n\nThis code defines a custom `ranged_parser` class that uses the `boost::json::parser` to parse a JSON string and track the range of characters in the input string represented by each value. The `parse_with_ranges` function recursively parses the JSON value and tracks the range of each child value.\n\nNote that this implementation assumes that the input JSON string is well-formed and does not contain any escaped characters. If the input JSON string may contain escaped characters, additional handling will be required to correctly track the range of each value.\n\nAlso, this implementation only tracks the range of each value and does not provide any additional information about the parsed JSON value. If additional information is required, such as the type of each value or the nesting level of each value, additional modifications will be required to the `ranged_value` struct and the `parse_with_ranges_recursive` function.","ts":1.739098352244E9}
