{"prompt":"<|begin_of_text|><|start_header_id|>user<|end_header_id|>\n\nThe test for nested structures here needs to validate all the content, not just check the type. Make any similar fixes elsewhere. Output the entire new file content with file name.\n\n**tests/test_json.cpp**\n```\n#define BOOST_TEST_MODULE JSONTest\n#include <boost/test/unit_test.hpp>\n#include <zinc/json.hpp>\n#include <string_view>\n#include <span>\n\nusing namespace zinc;\n\nBOOST_AUTO_TEST_CASE(test_decode_encode_simple_object) {\n    const std::string_view input = R\"({\"key\":\"value\"})\";\n    JSON::Doc doc = JSON::decode(input);\n    JSON& root = *doc;\n    BOOST_CHECK_EQUAL(root.encode(), input);\n}\n\nBOOST_AUTO_TEST_CASE(test_access_object_element) {\n    const std::string_view input = R\"({\"key\":42})\";\n    JSON::Doc doc = JSON::decode(input);\n    JSON& root = *doc;\n    \n    const JSON& value = root[\"key\"];\n    BOOST_REQUIRE(std::holds_alternative<long>(value));\n    BOOST_CHECK_EQUAL(std::get<long>(value), 42);\n}\n\nBOOST_AUTO_TEST_CASE(test_null_type) {\n    JSON::Doc doc = JSON::decode(\"null\");\n    JSON& root = *doc;\n    BOOST_CHECK(std::holds_alternative<std::nullptr_t>(root));\n    BOOST_CHECK_EQUAL(root.encode(), \"null\");\n}\n\nBOOST_AUTO_TEST_CASE(test_boolean_types) {\n    {\n        JSON::Doc doc = JSON::decode(\"true\");\n        JSON& root = *doc;\n        BOOST_CHECK(std::holds_alternative<bool>(root));\n        BOOST_CHECK_EQUAL(std::get<bool>(root), true);\n    }\n    {\n        JSON::Doc doc = JSON::decode(\"false\");\n        JSON& root = *doc;\n        BOOST_CHECK(std::holds_alternative<bool>(root));\n        BOOST_CHECK_EQUAL(std::get<bool>(root), false);\n    }\n}\n\nBOOST_AUTO_TEST_CASE(test_number_types) {\n    {\n        JSON::Doc doc = JSON::decode(\"12345\");\n        JSON& root = *doc;\n        BOOST_CHECK(std::holds_alternative<long>(root));\n        BOOST_CHECK_EQUAL(std::get<long>(root), 12345);\n    }\n    {\n        JSON::Doc doc = JSON::decode(\"123.45\");\n        JSON& root = *doc;\n        BOOST_CHECK(std::holds_alternative<double>(root));\n        BOOST_CHECK_CLOSE(std::get<double>(root), 123.45, 1e-6);\n    }\n}\n\nBOOST_AUTO_TEST_CASE(test_string_type) {\n    const std::string_view input = R\"(\"hello\\u0020world\")\";\n    JSON::Doc doc = JSON::decode(input);\n    JSON& root = *doc;\n    BOOST_CHECK(std::holds_alternative<std::string_view>(root));\n    BOOST_CHECK_EQUAL(std::get<std::string_view>(root), \"hello world\");\n}\n\nBOOST_AUTO_TEST_CASE(test_array_type) {\n    const std::string_view input = R\"([1,\"two\",3.0])\";\n    JSON::Doc doc = JSON::decode(input);\n    JSON& root = *doc;\n    \n    const auto& arr = root.array();\n    BOOST_REQUIRE_EQUAL(arr.size(), 3);\n    BOOST_CHECK(std::holds_alternative<long>(arr[0]));\n    BOOST_CHECK(std::holds_alternative<std::string_view>(arr[1]));\n    BOOST_CHECK(std::holds_alternative<double>(arr[2]));\n}\n\nBOOST_AUTO_TEST_CASE(test_object_type) {\n    const std::string_view input = R\"({\"a\":1,\"b\":\"two\"})\";\n    JSON::Doc doc = JSON::decode(input);\n    JSON& root = *doc;\n    \n    const auto& obj = root.object();\n    BOOST_REQUIRE_EQUAL(obj.size(), 2);\n    BOOST_CHECK((obj[0].first == \"a\" && std::get<long>(obj[0].second) == 1) ||\n                (obj[1].first == \"a\" && std::get<long>(obj[1].second) == 1));\n}\n\nBOOST_AUTO_TEST_CASE(test_comparison_operators) {\n    JSON::Doc doc1 = JSON::decode(\"42\");\n    JSON::Doc doc2 = JSON::decode(\"42\");\n    JSON::Doc doc3 = JSON::decode(\"43\");\n    \n    BOOST_CHECK(*doc1 == *doc2);\n    BOOST_CHECK((*doc1 <=> *doc3) == std::partial_ordering::less);\n}\n\nBOOST_AUTO_TEST_CASE(test_nested_structures) {\n    const std::string_view input = R\"({\"arr\":[1,{\"nested\":true}],\"obj\":{}})\";\n    JSON::Doc doc = JSON::decode(input);\n    JSON& root = *doc;\n    \n    const JSON& arr = root[\"arr\"];\n    const auto& elements = arr.array();\n    BOOST_REQUIRE_EQUAL(elements.size(), 2);\n    BOOST_CHECK(std::holds_alternative<std::span<KeyJSONPair>>(elements[1]));\n}\n\nBOOST_AUTO_TEST_CASE(test_edge_cases) {\n    {\n        JSON::Doc doc = JSON::decode(\"[]\");\n        BOOST_CHECK_EQUAL((*doc).encode(), \"[]\");\n    }\n    {\n        JSON::Doc doc = JSON::decode(\"{}\");\n        BOOST_CHECK_EQUAL((*doc).encode(), \"{}\");\n    }\n}\n\n```\n\n**include/zinc/json.hpp**\n```\n#pragma once\n\n#include <span>\n#include <string_view>\n#include <variant>\n\nnamespace zinc {\nclass JSON;\nusing KeyJSONPair = std::pair<std::string_view, JSON>;\nusing _JSON_variant = std::variant<\n    std::nullptr_t,\n    bool, long, double, std::string_view,\n    std::span<JSON>, std::span<KeyJSONPair>\n>;\n\n/*\n * The lifetime of parsed JSON objects is managed by the\n * returned JSON::Doc object.  Keep the JSON::Doc object around\n * until the storage for the entire tree can be reused.\n */\nclass JSON : public _JSON_variant {\npublic:\n    using _JSON_variant::variant;\n\n    enum Index {\n        /*NULL = 0,*/\n        BOOLEAN = 1,\n        INTEGER = 2,\n        NUMBER = 3,\n        STRING = 4,\n        ARRAY = 5,\n        OBJECT = 6,\n    };\n\n    //std::string_view raw;\n\n    std::partial_ordering operator<=>(JSON const&json) const;\n    bool operator==(JSON const&json) const { return 0==(*this<=>json); }\n\n    JSON const& operator[](std::string_view key) const;\n    JSON const& operator[](size_t idx) const;\n\n    auto& string() const\n    { return std::get<std::string_view>(*this); }\n    auto& array() const\n    { return std::get<std::span<JSON>>(*this); }\n    auto& object() const\n    { return std::get<std::span<KeyJSONPair>>(*this); }\n\n    class Doc {\n    public:\n        // this could instead be a JSON object with a flag\n        // or a smart pointer (or both)\n        Doc(Doc&&);\n\n        JSON& operator*() { return *root_; }\n\n        ~Doc();\n\n    private:\n        friend class JSON;\n        Doc(JSON*);\n        JSON* root_;\n    };\n\n    static Doc decode(std::string_view doc);\n    std::string_view encode() const;\n};\n\n}\n\n```<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\n","ts":1.739315978876E9}
