{"role":"user","content":"i want to figure out what parameter to pass to vllm's openai endpoint to configure the tokenizer to include special tokens in the response. what do i pass?\n","ts":1.739555821796E9}
{"role":"assistant","content":"To configure the tokenizer in the `vLLM` OpenAI endpoint to include special tokens in the response, you typically need to adjust the tokenization behavior via the API parameters. However, the OpenAI API (and `vLLM` when used with OpenAI-like endpoints) doesn't expose direct control over the tokenizer's inclusion of special tokens in the response by default.\n\nIf you want to include special tokens in the response, hereâ€™s what you can do:\n\n### 1. **Understand the Tokenizer Behavior**\nThe tokenizer used by models like GPT (e.g., GPT-2, GPT-3) usually adds special tokens like `<|endoftext|>` or BOS/EOS (beginning/end of sequence) tokens during tokenization. These tokens are often stripped out in the final response unless explicitly included.\n\n### 2. **Use `logprobs` or `token_logprobs` (if supported)**\nIf you want to inspect the tokens returned by the API, you can use the `logprobs` or `token_logprobs` parameter to get detailed token-level information. This won't directly include special tokens in the text response but will allow you to see the full tokenization process.\n\nExample:\n```python\nresponse = openai.Completion.create(\n    engine=\"your-vllm-model\",\n    prompt=\"Your prompt here\",\n    max_tokens=50,\n    logprobs=5  # Include token probabilities\n)\n```\n\n### 3. **Manual Post-Processing**\nIf you need special tokens in the response, you may need to manually add them after receiving the response. For example, if you know the EOS token is `<|endoftext|>`, you can append it to the generated text.\n\n### 4. **Custom Tokenizer Configuration (Advanced)**\nIf you have control over the `vLLM` server or model configuration, you can modify the tokenizer settings to include special tokens. This typically involves:\n   - Editing the model's tokenizer configuration (e.g., modifying the Hugging Face `tokenizer.json` or `tokenizer_config.json`).\n   - Ensuring the `add_special_tokens` parameter is set to `True` when tokenizing.\n\n### 5. **Check `vLLM` Documentation or Source Code**\nSince `vLLM` is a custom implementation, its behavior might differ slightly from the standard OpenAI API. Refer to the `vLLM` documentation or source code to see if","finish_reason":"\"length\"","ts":1.739555842331E9}
{"role":"assistant","content":" thereâ€™s an explicit parameter or configuration option for handling special tokens.\n\nIf youâ€™re using a custom model or tokenizer with `vLLM`, you may need to adjust the tokenizer settings directly in the model's configuration.\n\nLet me know if you need further clarification! ðŸš€\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"`\"","finish_reason":"runtime_error SIGINT","ts":1.739555855414E9}
{"role":"user","content":"Looks like I can pass skip_special_tokens=False from [1]. Now I want to figure out how to make it do greedy sampling. Transformers has a greedy sampling mode that is only entered when certain combinations of sampling parameters are passed. Do you know the combination, or where I would look in their code?\n\n1: /home/karl3/clones/vllm/vllm/entrypoints/openai/protocol.py\n\n**/home/karl3/clones/vllm/vllm/entrypoints/openai/protocol.py**\n```\n# SPDX-License-Identifier: Apache-2.0\n\n# Adapted from\n# https://github.com/lm-sys/FastChat/blob/168ccc29d3f7edc50823016105c024fe2282732a/fastchat/protocol/openai_api_protocol.py\nimport re\nimport time\nfrom argparse import Namespace\nfrom typing import Any, ClassVar, Dict, List, Literal, Optional, Set, Union\n\nimport torch\nfrom fastapi import UploadFile\nfrom pydantic import (BaseModel, ConfigDict, Field, TypeAdapter,\n                      ValidationInfo, field_validator, model_validator)\nfrom typing_extensions import Annotated, TypeAlias\n\nfrom vllm.entrypoints.chat_utils import ChatCompletionMessageParam\nfrom vllm.logger import init_logger\nfrom vllm.pooling_params import PoolingParams\nfrom vllm.sampling_params import (BeamSearchParams, GuidedDecodingParams,\n                                  RequestOutputKind, SamplingParams)\nfrom vllm.sequence import Logprob\nfrom vllm.utils import random_uuid, resolve_obj_by_qualname\n\nlogger = init_logger(__name__)\n\n# torch is mocked during docs generation,\n# so we have to provide the values as literals\n_MOCK_LONG_INFO = Namespace(min=-9223372036854775808, max=9223372036854775807)\n_LONG_INFO: Union[\"torch.iinfo\", Namespace]\n\ntry:\n    from sphinx.ext.autodoc.mock import _MockModule\n\n    if isinstance(torch, _MockModule):\n        _LONG_INFO = _MOCK_LONG_INFO\n    else:\n        _LONG_INFO = torch.iinfo(torch.long)\nexcept ModuleNotFoundError:\n    _LONG_INFO = torch.iinfo(torch.long)\n\nassert _LONG_INFO.min == _MOCK_LONG_INFO.min\nassert _LONG_INFO.max == _MOCK_LONG_INFO.max\n\n\nclass OpenAIBaseModel(BaseModel):\n    # OpenAI API does allow extra fields\n    model_config = ConfigDict(extra=\"allow\")\n\n    # Cache class field names\n    field_names: ClassVar[Optional[Set[str]]] = None\n\n    @model_validator(mode=\"wrap\")\n    @classmethod\n    def __log_extra_fields__(cls, data, handler):\n        result = handler(data)\n        if not isinstance(data, dict):\n            return result\n        field_names = cls.field_names\n        if field_names is None:\n            # Get all class field names and their potential aliases\n            field_names = set()\n            for field_name, field in cls.model_fields.items():\n                field_names.add(field_name)\n                if alias := getattr(field, 'alias', None):\n                    field_names.add(alias)\n            cls.field_names = field_names\n\n        # Compare against both field names and aliases\n        if any(k not in field_names for k in data):\n            logger.warning(\n                \"The following fields were present in the request \"\n                \"but ignored: %s\",\n                data.keys() - field_names)\n        return result\n\n\nclass ErrorResponse(OpenAIBaseModel):\n    object: str = \"error\"\n    message: str\n    type: str\n    param: Optional[str] = None\n    code: int\n\n\nclass ModelPermission(OpenAIBaseModel):\n    id: str = Field(default_factory=lambda: f\"modelperm-{random_uuid()}\")\n    object: str = \"model_permission\"\n    created: int = Field(default_factory=lambda: int(time.time()))\n    allow_create_engine: bool = False\n    allow_sampling: bool = True\n    allow_logprobs: bool = True\n    allow_search_indices: bool = False\n    allow_view: bool = True\n    allow_fine_tuning: bool = False\n    organization: str = \"*\"\n    group: Optional[str] = None\n    is_blocking: bool = False\n\n\nclass ModelCard(OpenAIBaseModel):\n    id: str\n    object: str = \"model\"\n    created: int = Field(default_factory=lambda: int(time.time()))\n    owned_by: str = \"vllm\"\n    root: Optional[str] = None\n    parent: Optional[str] = None\n    max_model_len: Optional[int] = None\n    permission: List[ModelPermission] = Field(default_factory=list)\n\n\nclass ModelList(OpenAIBaseModel):\n    object: str = \"list\"\n    data: List[ModelCard] = Field(default_factory=list)\n\n\nclass PromptTokenUsageInfo(OpenAIBaseModel):\n    cached_tokens: Optional[int] = None\n\n\nclass UsageInfo(OpenAIBaseModel):\n    prompt_tokens: int = 0\n    total_tokens: int = 0\n    completion_tokens: Optional[int] = 0\n    prompt_tokens_details: Optional[PromptTokenUsageInfo] = None\n\n\nclass RequestResponseMetadata(BaseModel):\n    request_id: str\n    final_usage_info: Optional[UsageInfo] = None\n\n\nclass JsonSchemaResponseFormat(OpenAIBaseModel):\n    name: str\n    description: Optional[str] = None\n    # schema is the field in openai but that causes conflicts with pydantic so\n    # instead use json_schema with an alias\n    json_schema: Optional[Dict[str, Any]] = Field(default=None, alias='schema')\n    strict: Optional[bool] = None\n\n\nclass ResponseFormat(OpenAIBaseModel):\n    # type must be \"json_schema\", \"json_object\" or \"text\"\n    type: Literal[\"text\", \"json_object\", \"json_schema\"]\n    json_schema: Optional[JsonSchemaResponseFormat] = None\n\n\nclass StreamOptions(OpenAIBaseModel):\n    include_usage: Optional[bool] = True\n    continuous_usage_stats: Optional[bool] = False\n\n\nclass FunctionDefinition(OpenAIBaseModel):\n    name: str\n    description: Optional[str] = None\n    parameters: Optional[Dict[str, Any]] = None\n\n\nclass ChatCompletionToolsParam(OpenAIBaseModel):\n    type: Literal[\"function\"] = \"function\"\n    function: FunctionDefinition\n\n\nclass ChatCompletionNamedFunction(OpenAIBaseModel):\n    name: str\n\n\nclass ChatCompletionNamedToolChoiceParam(OpenAIBaseModel):\n    function: ChatCompletionNamedFunction\n    type: Literal[\"function\"] = \"function\"\n\n\nclass LogitsProcessorConstructor(BaseModel):\n    qualname: str\n    args: Optional[List[Any]] = None\n    kwargs: Optional[Dict[str, Any]] = None\n\n\nLogitsProcessors = List[Union[str, LogitsProcessorConstructor]]\n\n\ndef get_logits_processors(processors: Optional[LogitsProcessors],\n                          pattern: Optional[str]) -> Optional[List[Any]]:\n    if processors and pattern:\n        logits_processors = []\n        for processor in processors:\n            qualname = processor if isinstance(processor,\n                                               str) else processor.qualname\n            if not re.match(pattern, qualname):\n                raise ValueError(\n                    f\"Logits processor '{qualname}' is not allowed by this \"\n                    \"server. See --logits-processor-pattern engine argument \"\n                    \"for more information.\")\n            try:\n                logits_processor = resolve_obj_by_qualname(qualname)\n            except Exception as e:\n                raise ValueError(\n                    f\"Logits processor '{qualname}' could not be resolved: {e}\"\n                ) from e\n            if isinstance(processor, LogitsProcessorConstructor):\n                logits_processor = logits_processor(*processor.args or [],\n                                                    **processor.kwargs or {})\n            logits_processors.append(logits_processor)\n        return logits_processors\n    elif processors:\n        raise ValueError(\n            \"The `logits_processors` argument is not supported by this \"\n            \"server. See --logits-processor-pattern engine argugment \"\n            \"for more information.\")\n    return None\n\n\nclass ChatCompletionRequest(OpenAIBaseModel):\n    # Ordered by official OpenAI API documentation\n    # https://platform.openai.com/docs/api-reference/chat/create\n    messages: List[ChatCompletionMessageParam]\n    model: str\n    frequency_penalty: Optional[float] = 0.0\n    logit_bias: Optional[Dict[str, float]] = None\n    logprobs: Optional[bool] = False\n    top_logprobs: Optional[int] = 0\n    # TODO(#9845): remove max_tokens when field is removed from OpenAI API\n    max_tokens: Optional[int] = Field(\n        default=None,\n        deprecated=\n        'max_tokens is deprecated in favor of the max_completion_tokens field')\n    max_completion_tokens: Optional[int] = None\n    n: Optional[int] = 1\n    presence_penalty: Optional[float] = 0.0\n    response_format: Optional[ResponseFormat] = None\n    seed: Optional[int] = Field(None, ge=_LONG_INFO.min, le=_LONG_INFO.max)\n    stop: Optional[Union[str, List[str]]] = Field(default_factory=list)\n    stream: Optional[bool] = False\n    stream_options: Optional[StreamOptions] = None\n    temperature: Optional[float] = None\n    top_p: Optional[float] = None\n    tools: Optional[List[ChatCompletionToolsParam]] = None\n    tool_choice: Optional[Union[Literal[\"none\"], Literal[\"auto\"],\n                                ChatCompletionNamedToolChoiceParam]] = \"none\"\n\n    # NOTE this will be ignored by VLLM -- the model determines the behavior\n    parallel_tool_calls: Optional[bool] = False\n    user: Optional[str] = None\n\n    # doc: begin-chat-completion-sampling-params\n    best_of: Optional[int] = None\n    use_beam_search: bool = False\n    top_k: Optional[int] = None\n    min_p: Optional[float] = None\n    repetition_penalty: Optional[float] = None\n    length_penalty: float = 1.0\n    stop_token_ids: Optional[List[int]] = Field(default_factory=list)\n    include_stop_str_in_output: bool = False\n    ignore_eos: bool = False\n    min_tokens: int = 0\n    skip_special_tokens: bool = True\n    spaces_between_special_tokens: bool = True\n    truncate_prompt_tokens: Optional[Annotated[int, Field(ge=1)]] = None\n    prompt_logprobs: Optional[int] = None\n    # doc: end-chat-completion-sampling-params\n\n    # doc: begin-chat-completion-extra-params\n    echo: bool = Field(\n        default=False,\n        description=(\n            \"If true, the new message will be prepended with the last message \"\n            \"if they belong to the same role.\"),\n    )\n    add_generation_prompt: bool = Field(\n        default=True,\n        description=\n        (\"If true, the generation prompt will be added to the chat template. \"\n         \"This is a parameter used by chat template in tokenizer config of the \"\n         \"model.\"),\n    )\n    continue_final_message: bool = Field(\n        default=False,\n        description=\n        (\"If this is set, the chat will be formatted so that the final \"\n         \"message in the chat is open-ended, without any EOS tokens. The \"\n         \"model will continue this message rather than starting a new one. \"\n         \"This allows you to \\\"prefill\\\" part of the model's response for it. \"\n         \"Cannot be used at the same time as `add_generation_prompt`.\"),\n    )\n    add_special_tokens: bool = Field(\n        default=False,\n        description=(\n            \"If true, special tokens (e.g. BOS) will be added to the prompt \"\n            \"on top of what is added by the chat template. \"\n            \"For most models, the chat template takes care of adding the \"\n            \"special tokens so this should be set to false (as is the \"\n            \"default).\"),\n    )\n    documents: Optional[List[Dict[str, str]]] = Field(\n        default=None,\n        description=\n        (\"A list of dicts representing documents that will be accessible to \"\n         \"the model if it is performing RAG (retrieval-augmented generation).\"\n         \" If the template does not support RAG, this argument will have no \"\n         \"effect. We recommend that each document should be a dict containing \"\n         \"\\\"title\\\" and \\\"text\\\" keys.\"),\n    )\n    chat_template: Optional[str] = Field(\n        default=None,\n        description=(\n            \"A Jinja template to use for this conversion. \"\n            \"As of transformers v4.44, default chat template is no longer \"\n            \"allowed, so you must provide a chat template if the tokenizer \"\n            \"does not define one.\"),\n    )\n    chat_template_kwargs: Optional[Dict[str, Any]] = Field(\n        default=None,\n        description=(\"Additional kwargs to pass to the template renderer. \"\n                     \"Will be accessible by the chat template.\"),\n    )\n    guided_json: Optional[Union[str, dict, BaseModel]] = Field(\n        default=None,\n        description=(\"If specified, the output will follow the JSON schema.\"),\n    )\n    guided_regex: Optional[str] = Field(\n        default=None,\n        description=(\n            \"If specified, the output will follow the regex pattern.\"),\n    )\n    guided_choice: Optional[List[str]] = Field(\n        default=None,\n        description=(\n            \"If specified, the output will be exactly one of the choices.\"),\n    )\n    guided_grammar: Optional[str] = Field(\n        default=None,\n        description=(\n            \"If specified, the output will follow the context free grammar.\"),\n    )\n    guided_decoding_backend: Optional[str] = Field(\n        default=None,\n        description=(\n            \"If specified, will override the default guided decoding backend \"\n            \"of the server for this specific request. If set, must be either \"\n            \"'outlines' / 'lm-format-enforcer'\"))\n    guided_whitespace_pattern: Optional[str] = Field(\n        default=None,\n        description=(\n            \"If specified, will override the default whitespace pattern \"\n            \"for guided json decoding.\"))\n    priority: int = Field(\n        default=0,\n        description=(\n            \"The priority of the request (lower means earlier handling; \"\n            \"default: 0). Any priority other than 0 will raise an error \"\n            \"if the served model does not use priority scheduling.\"))\n    request_id: str = Field(\n        default_factory=lambda: f\"{random_uuid()}\",\n        description=(\n            \"The request_id related to this request. If the caller does \"\n            \"not set it, a random_uuid will be generated. This id is used \"\n            \"through out the inference process and return in response.\"))\n    logits_processors: Optional[LogitsProcessors] = Field(\n        default=None,\n        description=(\n            \"A list of either qualified names of logits processors, or \"\n            \"constructor objects, to apply when sampling. A constructor is \"\n            \"a JSON object with a required 'qualname' field specifying the \"\n            \"qualified name of the processor class/factory, and optional \"\n            \"'args' and 'kwargs' fields containing positional and keyword \"\n            \"arguments. For example: {'qualname': \"\n            \"'my_module.MyLogitsProcessor', 'args': [1, 2], 'kwargs': \"\n            \"{'param': 'value'}}.\"))\n\n    # doc: end-chat-completion-extra-params\n\n    # Default sampling parameters for chat completion requests\n    _DEFAULT_SAMPLING_PARAMS: dict = {\n        \"repetition_penalty\": 1.0,\n        \"temperature\": 1.0,\n        \"top_p\": 1.0,\n        \"top_k\": -1,\n        \"min_p\": 0.0,\n    }\n\n    def to_beam_search_params(\n            self,\n            default_max_tokens: int,\n            default_sampling_params: Optional[dict] = None\n    ) -> BeamSearchParams:\n        # TODO(#9845): remove max_tokens when field is removed from OpenAI API\n        max_tokens = self.max_completion_tokens or self.max_tokens\n\n        if default_sampling_params is None:\n            default_sampling_params = {}\n        n = self.n if self.n is not None else 1\n\n        # Use minimum of context window, user request & server limit.\n        max_tokens = min(\n            val for val in (default_max_tokens, max_tokens,\n                            default_sampling_params.get(\"max_tokens\", None))\n            if val is not None)\n\n        if (temperature := self.temperature) is None:\n            temperature = default_sampling_params.get(\n                \"temperature\", self._DEFAULT_SAMPLING_PARAMS[\"temperature\"])\n\n        return BeamSearchParams(\n            beam_width=n,\n            max_tokens=max_tokens,\n            ignore_eos=self.ignore_eos,\n            temperature=temperature,\n            length_penalty=self.length_penalty,\n            include_stop_str_in_output=self.include_stop_str_in_output)\n\n    def to_sampling_params(\n            self,\n            default_max_tokens: int,\n            logits_processor_pattern: Optional[str],\n            default_sampling_params: Optional[dict] = None) -> SamplingParams:\n        # TODO(#9845): remove max_tokens when field is removed from OpenAI API\n        max_tokens = self.max_completion_tokens or self.max_tokens\n\n        if default_sampling_params is None:\n            default_sampling_params = {}\n\n        # Use minimum of context window, user request & server limit.\n        max_tokens = min(\n            val for val in (default_max_tokens, max_tokens,\n                            default_sampling_params.get(\"max_tokens\", None))\n            if val is not None)\n\n        # Default parameters\n        if (repetition_penalty := self.repetition_penalty) is None:\n            repetition_penalty = default_sampling_params.get(\n                \"repetition_penalty\",\n                self._DEFAULT_SAMPLING_PARAMS[\"repetition_penalty\"],\n            )\n        if (temperature := self.temperature) is None:\n            temperature = default_sampling_params.get(\n                \"temperature\", self._DEFAULT_SAMPLING_PARAMS[\"temperature\"])\n        if (top_p := self.top_p) is None:\n            top_p = default_sampling_params.get(\n                \"top_p\", self._DEFAULT_SAMPLING_PARAMS[\"top_p\"])\n        if (top_k := self.top_k) is None:\n            top_k = default_sampling_params.get(\n                \"top_k\", self._DEFAULT_SAMPLING_PARAMS[\"top_k\"])\n        if (min_p := self.min_p) is None:\n            min_p = default_sampling_params.get(\n                \"min_p\", self._DEFAULT_SAMPLING_PARAMS[\"min_p\"])\n\n        prompt_logprobs = self.prompt_logprobs\n        if prompt_logprobs is None and self.echo:\n            prompt_logprobs = self.top_logprobs\n\n        guided_json_object = None\n        if self.response_format is not None:\n            if self.response_format.type == \"json_object\":\n                guided_json_object = True\n            elif self.response_format.type == \"json_schema\":\n                json_schema = self.response_format.json_schema\n                assert json_schema is not None\n                self.guided_json = json_schema.json_schema\n                if self.guided_decoding_backend is None:\n                    self.guided_decoding_backend = \"xgrammar\"\n\n        guided_decoding = GuidedDecodingParams.from_optional(\n            json=self._get_guided_json_from_tool() or self.guided_json,\n            regex=self.guided_regex,\n            choice=self.guided_choice,\n            grammar=self.guided_grammar,\n            json_object=guided_json_object,\n            backend=self.guided_decoding_backend,\n            whitespace_pattern=self.guided_whitespace_pattern)\n\n        return SamplingParams.from_optional(\n            n=self.n,\n            best_of=self.best_of,\n            presence_penalty=self.presence_penalty,\n            frequency_penalty=self.frequency_penalty,\n            repetition_penalty=repetition_penalty,\n            temperature=temperature,\n            top_p=top_p,\n            top_k=top_k,\n            min_p=min_p,\n            seed=self.seed,\n            stop=self.stop,\n            stop_token_ids=self.stop_token_ids,\n            logprobs=self.top_logprobs if self.logprobs else None,\n            prompt_logprobs=prompt_logprobs,\n            ignore_eos=self.ignore_eos,\n            max_tokens=max_tokens,\n            min_tokens=self.min_tokens,\n            skip_special_tokens=self.skip_special_tokens,\n            spaces_between_special_tokens=self.spaces_between_special_tokens,\n            logits_processors=get_logits_processors(self.logits_processors,\n                                                    logits_processor_pattern),\n            include_stop_str_in_output=self.include_stop_str_in_output,\n            truncate_prompt_tokens=self.truncate_prompt_tokens,\n            output_kind=RequestOutputKind.DELTA if self.stream \\\n                else RequestOutputKind.FINAL_ONLY,\n            guided_decoding=guided_decoding,\n            logit_bias=self.logit_bias)\n\n    def _get_guided_json_from_tool(\n            self) -> Optional[Union[str, dict, BaseModel]]:\n        # user has chosen to not use any tool\n        if self.tool_choice == \"none\" or self.tools is None:\n            return None\n\n        # user has chosen to use a named tool\n        if type(self.tool_choice) is ChatCompletionNamedToolChoiceParam:\n            tool_name = self.tool_choice.function.name\n            tools = {tool.function.name: tool.function for tool in self.tools}\n            if tool_name not in tools:\n                raise ValueError(\n                    f\"Tool '{tool_name}' has not been passed in `tools`.\")\n            tool = tools[tool_name]\n            return tool.parameters\n\n        return None\n\n    @model_validator(mode=\"before\")\n    @classmethod\n    def validate_stream_options(cls, data):\n        if data.get(\"stream_options\") and not data.get(\"stream\"):\n            raise ValueError(\n                \"Stream options can only be defined when `stream=True`.\")\n\n        return data\n\n    @model_validator(mode=\"before\")\n    @classmethod\n    def check_logprobs(cls, data):\n        if (prompt_logprobs := data.get(\"prompt_logprobs\")) is not None:\n            if data.get(\"stream\") and prompt_logprobs > 0:\n                raise ValueError(\n                    \"`prompt_logprobs` are not available when `stream=True`.\")\n\n            if prompt_logprobs < 0:\n                raise ValueError(\"`prompt_logprobs` must be a positive value.\")\n\n        if (top_logprobs := data.get(\"top_logprobs\")) is not None:\n            if top_logprobs < 0:\n                raise ValueError(\"`top_logprobs` must be a positive value.\")\n\n            if not data.get(\"logprobs\"):\n                raise ValueError(\n                    \"when using `top_logprobs`, `logprobs` must be set to true.\"\n                )\n\n        return data\n\n    @model_validator(mode=\"before\")\n    @classmethod\n    def check_guided_decoding_count(cls, data):\n        if isinstance(data, ValueError):\n            raise data\n\n        guide_count = sum([\n            \"guided_json\" in data and data[\"guided_json\"] is not None,\n            \"guided_regex\" in data and data[\"guided_regex\"] is not None,\n            \"guided_choice\" in data and data[\"guided_choice\"] is not None\n        ])\n        # you can only use one kind of guided decoding\n        if guide_count > 1:\n            raise ValueError(\n                \"You can only use one kind of guided decoding \"\n                \"('guided_json', 'guided_regex' or 'guided_choice').\")\n        # you can only either use guided decoding or tools, not both\n        if guide_count > 1 and data.get(\"tool_choice\",\n                                        \"none\") not in (\"none\", \"auto\"):\n            raise ValueError(\n                \"You can only either use guided decoding or tools, not both.\")\n        return data\n\n    @model_validator(mode=\"before\")\n    @classmethod\n    def check_tool_usage(cls, data):\n\n        # if \"tool_choice\" is not specified but tools are provided,\n        # default to \"auto\" tool_choice\n        if \"tool_choice\" not in data and data.get(\"tools\"):\n            data[\"tool_choice\"] = \"auto\"\n\n        # if \"tool_choice\" is \"none\" -- ignore tools if present\n        if \"tool_choice\" in data and data[\"tool_choice\"] == \"none\":\n            # ensure that no tools are present\n            data.pop(\"tools\", None)\n            return data\n\n        # if \"tool_choice\" is specified -- validation\n        if \"tool_choice\" in data:\n\n            # ensure that if \"tool choice\" is specified, tools are present\n            if \"tools\" not in data or data[\"tools\"] is None:\n                raise ValueError(\n                    \"When using `tool_choice`, `tools` must be set.\")\n\n            # make sure that tool choice is either a named tool\n            # OR that it's set to \"auto\"\n            if data[\"tool_choice\"] != \"auto\" and not isinstance(\n                    data[\"tool_choice\"], dict):\n                raise ValueError(\n                    \"`tool_choice` must either be a named tool, \\\"auto\\\", \"\n                    \"or \\\"none\\\".\")\n\n            # ensure that if \"tool_choice\" is specified as an object,\n            # it matches a valid tool\n            if isinstance(data[\"tool_choice\"], dict):\n                valid_tool = False\n                specified_function = data[\"tool_choice\"].get(\"function\")\n                if not specified_function:\n                    raise ValueError(\n                        \"Expected field `function` in `tool_choice`.\"\n                        \" Correct usage: `{\\\"type\\\": \\\"function\\\",\"\n                        \" \\\"function\\\": {\\\"name\\\": \\\"my_function\\\"}}`\")\n                specified_function_name = specified_function.get(\"name\")\n                if not specified_function_name:\n                    raise ValueError(\n                        \"Expected field `name` in `function` in `tool_choice`.\"\n                        \"Correct usage: `{\\\"type\\\": \\\"function\\\", \"\n                        \"\\\"function\\\": {\\\"name\\\": \\\"my_function\\\"}}`\")\n                for tool in data[\"tools\"]:\n                    if tool[\"function\"][\"name\"] == specified_function_name:\n                        valid_tool = True\n                        break\n                if not valid_tool:\n                    raise ValueError(\n                        \"The tool specified in `tool_choice` does not match any\"\n                        \" of the specified `tools`\")\n        return data\n\n    @model_validator(mode=\"before\")\n    @classmethod\n    def check_generation_prompt(cls, data):\n        if data.get(\"continue_final_message\") and data.get(\n                \"add_generation_prompt\"):\n            raise ValueError(\"Cannot set both `continue_final_message` and \"\n                             \"`add_generation_prompt` to True.\")\n        return data\n\n\nclass CompletionRequest(OpenAIBaseModel):\n    # Ordered by official OpenAI API documentation\n    # https://platform.openai.com/docs/api-reference/completions/create\n    model: str\n    prompt: Union[List[int], List[List[int]], str, List[str]]\n    best_of: Optional[int] = None\n    echo: Optional[bool] = False\n    frequency_penalty: Optional[float] = 0.0\n    logit_bias: Optional[Dict[str, float]] = None\n    logprobs: Optional[int] = None\n    max_tokens: Optional[int] = 16\n    n: int = 1\n    presence_penalty: Optional[float] = 0.0\n    seed: Optional[int] = Field(None, ge=_LONG_INFO.min, le=_LONG_INFO.max)\n    stop: Optional[Union[str, List[str]]] = Field(default_factory=list)\n    stream: Optional[bool] = False\n    stream_options: Optional[StreamOptions] = None\n    suffix: Optional[str] = None\n    temperature: Optional[float] = None\n    top_p: Optional[float] = None\n    user: Optional[str] = None\n\n    # doc: begin-completion-sampling-params\n    use_beam_search: bool = False\n    top_k: Optional[int] = None\n    min_p: Optional[float] = None\n    repetition_penalty: Optional[float] = None\n    length_penalty: float = 1.0\n    stop_token_ids: Optional[List[int]] = Field(default_factory=list)\n    include_stop_str_in_output: bool = False\n    ignore_eos: bool = False\n    min_tokens: int = 0\n    skip_special_tokens: bool = True\n    spaces_between_special_tokens: bool = True\n    truncate_prompt_tokens: Optional[Annotated[int, Field(ge=1)]] = None\n    allowed_token_ids: Optional[List[int]] = None\n    prompt_logprobs: Optional[int] = None\n    # doc: end-completion-sampling-params\n\n    # doc: begin-completion-extra-params\n    add_special_tokens: bool = Field(\n        default=True,\n        description=(\n            \"If true (the default), special tokens (e.g. BOS) will be added to \"\n            \"the prompt.\"),\n    )\n    response_format: Optional[ResponseFormat] = Field(\n        default=None,\n        description=\n        (\"Similar to chat completion, this parameter specifies the format of \"\n         \"output. Only {'type': 'json_object'}, {'type': 'json_schema'} or \"\n         \"{'type': 'text' } is supported.\"),\n    )\n    guided_json: Optional[Union[str, dict, BaseModel]] = Field(\n        default=None,\n        description=\"If specified, the output will follow the JSON schema.\",\n    )\n    guided_regex: Optional[str] = Field(\n        default=None,\n        description=(\n            \"If specified, the output will follow the regex pattern.\"),\n    )\n    guided_choice: Optional[List[str]] = Field(\n        default=None,\n        description=(\n            \"If specified, the output will be exactly one of the choices.\"),\n    )\n    guided_grammar: Optional[str] = Field(\n        default=None,\n        description=(\n            \"If specified, the output will follow the context free grammar.\"),\n    )\n    guided_decoding_backend: Optional[str] = Field(\n        default=None,\n        description=(\n            \"If specified, will override the default guided decoding backend \"\n            \"of the server for this specific request. If set, must be one of \"\n            \"'outlines' / 'lm-format-enforcer'\"))\n    guided_whitespace_pattern: Optional[str] = Field(\n        default=None,\n        description=(\n            \"If specified, will override the default whitespace pattern \"\n            \"for guided json decoding.\"))\n    priority: int = Field(\n        default=0,\n        description=(\n            \"The priority of the request (lower means earlier handling; \"\n            \"default: 0). Any priority other than 0 will raise an error \"\n            \"if the served model does not use priority scheduling.\"))\n    logits_processors: Optional[LogitsProcessors] = Field(\n        default=None,\n        description=(\n            \"A list of either qualified names of logits processors, or \"\n            \"constructor objects, to apply when sampling. A constructor is \"\n            \"a JSON object with a required 'qualname' field specifying the \"\n            \"qualified name of the processor class/factory, and optional \"\n            \"'args' and 'kwargs' fields containing positional and keyword \"\n            \"arguments. For example: {'qualname': \"\n            \"'my_module.MyLogitsProcessor', 'args': [1, 2], 'kwargs': \"\n            \"{'param': 'value'}}.\"))\n\n    # doc: end-completion-extra-params\n\n    # Default sampling parameters for completion requests\n    _DEFAULT_SAMPLING_PARAMS: dict = {\n        \"repetition_penalty\": 1.0,\n        \"temperature\": 1.0,\n        \"top_p\": 1.0,\n        \"top_k\": -1,\n        \"min_p\": 0.0,\n    }\n\n    def to_beam_search_params(\n            self,\n            default_max_tokens: int,\n            default_sampling_params: Optional[dict] = None\n    ) -> BeamSearchParams:\n        max_tokens = self.max_tokens\n\n        if default_sampling_params is None:\n            default_sampling_params = {}\n        n = self.n if self.n is not None else 1\n\n        # Use minimum of context window, user request & server limit.\n        max_tokens = min(\n            val for val in (default_max_tokens, max_tokens,\n                            default_sampling_params.get(\"max_tokens\", None))\n            if val is not None)\n\n        if (temperature := self.temperature) is None:\n            temperature = default_sampling_params.get(\"temperature\", 1.0)\n\n        return BeamSearchParams(\n            beam_width=n,\n            max_tokens=max_tokens,\n            ignore_eos=self.ignore_eos,\n            temperature=temperature,\n            length_penalty=self.length_penalty,\n            include_stop_str_in_output=self.include_stop_str_in_output)\n\n    def to_sampling_params(\n            self,\n            default_max_tokens: int,\n            logits_processor_pattern: Optional[str],\n            default_sampling_params: Optional[dict] = None) -> SamplingParams:\n        max_tokens = self.max_tokens\n\n        if default_sampling_params is None:\n            default_sampling_params = {}\n\n        # Use minimum of context window, user request & server limit.\n        max_tokens = min(\n            val for val in (default_max_tokens, max_tokens,\n                            default_sampling_params.get(\"max_tokens\", None))\n            if val is not None)\n\n        # Default parameters\n        if (repetition_penalty := self.repetition_penalty) is None:\n            repetition_penalty = default_sampling_params.get(\n                \"repetition_penalty\",\n                self._DEFAULT_SAMPLING_PARAMS[\"repetition_penalty\"],\n            )\n        if (temperature := self.temperature) is None:\n            temperature = default_sampling_params.get(\n                \"temperature\", self._DEFAULT_SAMPLING_PARAMS[\"temperature\"])\n        if (top_p := self.top_p) is None:\n            top_p = default_sampling_params.get(\n                \"top_p\", self._DEFAULT_SAMPLING_PARAMS[\"top_p\"])\n        if (top_k := self.top_k) is None:\n            top_k = default_sampling_params.get(\n                \"top_k\", self._DEFAULT_SAMPLING_PARAMS[\"top_k\"])\n        if (min_p := self.min_p) is None:\n            min_p = default_sampling_params.get(\n                \"min_p\", self._DEFAULT_SAMPLING_PARAMS[\"min_p\"])\n\n        prompt_logprobs = self.prompt_logprobs\n        if prompt_logprobs is None and self.echo:\n            prompt_logprobs = self.logprobs\n\n        echo_without_generation = self.echo and self.max_tokens == 0\n\n        guided_json_object = None\n        if (self.response_format is not None\n                and self.response_format.type == \"json_object\"):\n            guided_json_object = True\n\n        guided_decoding = GuidedDecodingParams.from_optional(\n            json=self.guided_json,\n            regex=self.guided_regex,\n            choice=self.guided_choice,\n            grammar=self.guided_grammar,\n            json_object=guided_json_object,\n            backend=self.guided_decoding_backend,\n            whitespace_pattern=self.guided_whitespace_pattern)\n\n        return SamplingParams.from_optional(\n            n=self.n,\n            best_of=self.best_of,\n            presence_penalty=self.presence_penalty,\n            frequency_penalty=self.frequency_penalty,\n            repetition_penalty=repetition_penalty,\n            temperature=temperature,\n            top_p=top_p,\n            top_k=top_k,\n            min_p=min_p,\n            seed=self.seed,\n            stop=self.stop,\n            stop_token_ids=self.stop_token_ids,\n            logprobs=self.logprobs,\n            ignore_eos=self.ignore_eos,\n            max_tokens=max_tokens if not echo_without_generation else 1,\n            min_tokens=self.min_tokens,\n            prompt_logprobs=prompt_logprobs,\n            skip_special_tokens=self.skip_special_tokens,\n            spaces_between_special_tokens=self.spaces_between_special_tokens,\n            include_stop_str_in_output=self.include_stop_str_in_output,\n            logits_processors=get_logits_processors(self.logits_processors,\n                                                    logits_processor_pattern),\n            truncate_prompt_tokens=self.truncate_prompt_tokens,\n            output_kind=RequestOutputKind.DELTA if self.stream \\\n                else RequestOutputKind.FINAL_ONLY,\n            guided_decoding=guided_decoding,\n            logit_bias=self.logit_bias,\n            allowed_token_ids=self.allowed_token_ids)\n\n    @model_validator(mode=\"before\")\n    @classmethod\n    def check_guided_decoding_count(cls, data):\n        guide_count = sum([\n            \"guided_json\" in data and data[\"guided_json\"] is not None,\n            \"guided_regex\" in data and data[\"guided_regex\"] is not None,\n            \"guided_choice\" in data and data[\"guided_choice\"] is not None\n        ])\n        if guide_count > 1:\n            raise ValueError(\n                \"You can only use one kind of guided decoding \"\n                \"('guided_json', 'guided_regex' or 'guided_choice').\")\n        return data\n\n    @model_validator(mode=\"before\")\n    @classmethod\n    def check_logprobs(cls, data):\n        if (prompt_logprobs := data.get(\"prompt_logprobs\")) is not None:\n            if data.get(\"stream\") and prompt_logprobs > 0:\n                raise ValueError(\n                    \"`prompt_logprobs` are not available when `stream=True`.\")\n\n            if prompt_logprobs < 0:\n                raise ValueError(\"`prompt_logprobs` must be a positive value.\")\n\n        if (logprobs := data.get(\"logprobs\")) is not None and logprobs < 0:\n            raise ValueError(\"`logprobs` must be a positive value.\")\n\n        return data\n\n    @model_validator(mode=\"before\")\n    @classmethod\n    def validate_stream_options(cls, data):\n        if data.get(\"stream_options\") and not data.get(\"stream\"):\n            raise ValueError(\n                \"Stream options can only be defined when `stream=True`.\")\n\n        return data\n\n\nclass EmbeddingCompletionRequest(OpenAIBaseModel):\n    # Ordered by official OpenAI API documentation\n    # https://platform.openai.com/docs/api-reference/embeddings\n    model: str\n    input: Union[List[int], List[List[int]], str, List[str]]\n    encoding_format: Literal[\"float\", \"base64\"] = \"float\"\n    dimensions: Optional[int] = None\n    user: Optional[str] = None\n    truncate_prompt_tokens: Optional[Annotated[int, Field(ge=1)]] = None\n\n    # doc: begin-embedding-pooling-params\n    additional_data: Optional[Any] = None\n    # doc: end-embedding-pooling-params\n\n    # doc: begin-embedding-extra-params\n    add_special_tokens: bool = Field(\n        default=True,\n        description=(\n            \"If true (the default), special tokens (e.g. BOS) will be added to \"\n            \"the prompt.\"),\n    )\n    priority: int = Field(\n        default=0,\n        description=(\n            \"The priority of the request (lower means earlier handling; \"\n            \"default: 0). Any priority other than 0 will raise an error \"\n            \"if the served model does not use priority scheduling.\"))\n\n    # doc: end-embedding-extra-params\n\n    def to_pooling_params(self):\n        return PoolingParams(additional_data=self.additional_data)\n\n\nclass EmbeddingChatRequest(OpenAIBaseModel):\n    model: str\n    messages: List[ChatCompletionMessageParam]\n\n    encoding_format: Literal[\"float\", \"base64\"] = \"float\"\n    dimensions: Optional[int] = None\n    user: Optional[str] = None\n    truncate_prompt_tokens: Optional[Annotated[int, Field(ge=1)]] = None\n\n    # doc: begin-chat-embedding-pooling-params\n    additional_data: Optional[Any] = None\n    # doc: end-chat-embedding-pooling-params\n\n    # doc: begin-chat-embedding-extra-params\n    add_special_tokens: bool = Field(\n        default=False,\n        description=(\n            \"If true, special tokens (e.g. BOS) will be added to the prompt \"\n            \"on top of what is added by the chat template. \"\n            \"For most models, the chat template takes care of adding the \"\n            \"special tokens so this should be set to false (as is the \"\n            \"default).\"),\n    )\n    chat_template: Optional[str] = Field(\n        default=None,\n        description=(\n            \"A Jinja template to use for this conversion. \"\n            \"As of transformers v4.44, default chat template is no longer \"\n            \"allowed, so you must provide a chat template if the tokenizer \"\n            \"does not define one.\"),\n    )\n    chat_template_kwargs: Optional[Dict[str, Any]] = Field(\n        default=None,\n        description=(\"Additional kwargs to pass to the template renderer. \"\n                     \"Will be accessible by the chat template.\"),\n    )\n    priority: int = Field(\n        default=0,\n        description=(\n            \"The priority of the request (lower means earlier handling; \"\n            \"default: 0). Any priority other than 0 will raise an error \"\n            \"if the served model does not use priority scheduling.\"))\n    # doc: end-chat-embedding-extra-params\n\n    @model_validator(mode=\"before\")\n    @classmethod\n    def check_generation_prompt(cls, data):\n        if data.get(\"continue_final_message\") and data.get(\n                \"add_generation_prompt\"):\n            raise ValueError(\"Cannot set both `continue_final_message` and \"\n                             \"`add_generation_prompt` to True.\")\n        return data\n\n    def to_pooling_params(self):\n        return PoolingParams(additional_data=self.additional_data)\n\n\nEmbeddingRequest = Union[EmbeddingCompletionRequest, EmbeddingChatRequest]\n\nPoolingCompletionRequest = EmbeddingCompletionRequest\nPoolingChatRequest = EmbeddingChatRequest\nPoolingRequest = Union[PoolingCompletionRequest, PoolingChatRequest]\n\n\nclass ScoreRequest(OpenAIBaseModel):\n    model: str\n    text_1: Union[List[str], str]\n    text_2: Union[List[str], str]\n    truncate_prompt_tokens: Optional[Annotated[int, Field(ge=1)]] = None\n\n    # doc: begin-score-pooling-params\n    additional_data: Optional[Any] = None\n    # doc: end-score-pooling-params\n\n    # doc: begin-score-extra-params\n    priority: int = Field(\n        default=0,\n        description=(\n            \"The priority of the request (lower means earlier handling; \"\n            \"default: 0). Any priority other than 0 will raise an error \"\n            \"if the served model does not use priority scheduling.\"))\n\n    # doc: end-score-extra-params\n\n    def to_pooling_params(self):\n        return PoolingParams(additional_data=self.additional_data)\n\n\nclass RerankRequest(OpenAIBaseModel):\n    model: str\n    query: str\n    documents: List[str]\n    top_n: int = Field(default_factory=lambda: 0)\n    truncate_prompt_tokens: Optional[Annotated[int, Field(ge=1)]] = None\n\n    # doc: begin-rerank-pooling-params\n    additional_data: Optional[Any] = None\n    # doc: end-rerank-pooling-params\n\n    # doc: begin-rerank-extra-params\n    priority: int = Field(\n        default=0,\n        description=(\n            \"The priority of the request (lower means earlier handling; \"\n            \"default: 0). Any priority other than 0 will raise an error \"\n            \"if the served model does not use priority scheduling.\"))\n\n    # doc: end-rerank-extra-params\n\n    def to_pooling_params(self):\n        return PoolingParams(additional_data=self.additional_data)\n\n\nclass RerankDocument(BaseModel):\n    text: str\n\n\nclass RerankResult(BaseModel):\n    index: int\n    document: RerankDocument\n    relevance_score: float\n\n\nclass RerankUsage(BaseModel):\n    total_tokens: int\n\n\nclass RerankResponse(OpenAIBaseModel):\n    id: str\n    model: str\n    usage: RerankUsage\n    results: List[RerankResult]\n\n\nclass CompletionLogProbs(OpenAIBaseModel):\n    text_offset: List[int] = Field(default_factory=list)\n    token_logprobs: List[Optional[float]] = Field(default_factory=list)\n    tokens: List[str] = Field(default_factory=list)\n    top_logprobs: List[Optional[Dict[str,\n                                     float]]] = Field(default_factory=list)\n\n\nclass CompletionResponseChoice(OpenAIBaseModel):\n    index: int\n    text: str\n    logprobs: Optional[CompletionLogProbs] = None\n    finish_reason: Optional[str] = None\n    stop_reason: Optional[Union[int, str]] = Field(\n        default=None,\n        description=(\n            \"The stop string or token id that caused the completion \"\n            \"to stop, None if the completion finished for some other reason \"\n            \"including encountering the EOS token\"),\n    )\n    prompt_logprobs: Optional[List[Optional[Dict[int, Logprob]]]] = None\n\n\nclass CompletionResponse(OpenAIBaseModel):\n    id: str = Field(default_factory=lambda: f\"cmpl-{random_uuid()}\")\n    object: str = \"text_completion\"\n    created: int = Field(default_factory=lambda: int(time.time()))\n    model: str\n    choices: List[CompletionResponseChoice]\n    usage: UsageInfo\n\n\nclass CompletionResponseStreamChoice(OpenAIBaseModel):\n    index: int\n    text: str\n    logprobs: Optional[CompletionLogProbs] = None\n    finish_reason: Optional[str] = None\n    stop_reason: Optional[Union[int, str]] = Field(\n        default=None,\n        description=(\n            \"The stop string or token id that caused the completion \"\n            \"to stop, None if the completion finished for some other reason \"\n            \"including encountering the EOS token\"),\n    )\n\n\nclass CompletionStreamResponse(OpenAIBaseModel):\n    id: str = Field(default_factory=lambda: f\"cmpl-{random_uuid()}\")\n    object: str = \"text_completion\"\n    created: int = Field(default_factory=lambda: int(time.time()))\n    model: str\n    choices: List[CompletionResponseStreamChoice]\n    usage: Optional[UsageInfo] = Field(default=None)\n\n\nclass EmbeddingResponseData(OpenAIBaseModel):\n    index: int\n    object: str = \"embedding\"\n    embedding: Union[List[float], str]\n\n\nclass EmbeddingResponse(OpenAIBaseModel):\n    id: str = Field(default_factory=lambda: f\"embd-{random_uuid()}\")\n    object: str = \"list\"\n    created: int = Field(default_factory=lambda: int(time.time()))\n    model: str\n    data: List[EmbeddingResponseData]\n    usage: UsageInfo\n\n\nclass PoolingResponseData(OpenAIBaseModel):\n    index: int\n    object: str = \"pooling\"\n    data: Union[List[List[float]], List[float], str]\n\n\nclass PoolingResponse(OpenAIBaseModel):\n    id: str = Field(default_factory=lambda: f\"pool-{random_uuid()}\")\n    object: str = \"list\"\n    created: int = Field(default_factory=lambda: int(time.time()))\n    model: str\n    data: List[PoolingResponseData]\n    usage: UsageInfo\n\n\nclass ScoreResponseData(OpenAIBaseModel):\n    index: int\n    object: str = \"score\"\n    score: float\n\n\nclass ScoreResponse(OpenAIBaseModel):\n    id: str = Field(default_factory=lambda: f\"embd-{random_uuid()}\")\n    object: str = \"list\"\n    created: int = Field(default_factory=lambda: int(time.time()))\n    model: str\n    data: List[ScoreResponseData]\n    usage: UsageInfo\n\n\nclass FunctionCall(OpenAIBaseModel):\n    name: str\n    arguments: str\n\n\nclass ToolCall(OpenAIBaseModel):\n    id: str = Field(default_factory=lambda: f\"chatcmpl-tool-{random_uuid()}\")\n    type: Literal[\"function\"] = \"function\"\n    function: FunctionCall\n\n\nclass DeltaFunctionCall(BaseModel):\n    name: Optional[str] = None\n    arguments: Optional[str] = None\n\n\n# a tool call delta where everything is optional\nclass DeltaToolCall(OpenAIBaseModel):\n    id: str = Field(default_factory=lambda: f\"chatcmpl-tool-{random_uuid()}\")\n    type: Literal[\"function\"] = \"function\"\n    index: int\n    function: Optional[DeltaFunctionCall] = None\n\n\nclass ExtractedToolCallInformation(BaseModel):\n    # indicate if tools were called\n    tools_called: bool\n\n    # extracted tool calls\n    tool_calls: List[ToolCall]\n\n    # content - per OpenAI spec, content AND tool calls can be returned rarely\n    # But some models will do this intentionally\n    content: Optional[str] = None\n\n\nclass ChatMessage(OpenAIBaseModel):\n    role: str\n    reasoning_content: Optional[str] = None\n    content: Optional[str] = None\n    tool_calls: List[ToolCall] = Field(default_factory=list)\n\n\nclass ChatCompletionLogProb(OpenAIBaseModel):\n    token: str\n    logprob: float = -9999.0\n    bytes: Optional[List[int]] = None\n\n\nclass ChatCompletionLogProbsContent(ChatCompletionLogProb):\n    top_logprobs: List[ChatCompletionLogProb] = Field(default_factory=list)\n\n\nclass ChatCompletionLogProbs(OpenAIBaseModel):\n    content: Optional[List[ChatCompletionLogProbsContent]] = None\n\n\nclass ChatCompletionResponseChoice(OpenAIBaseModel):\n    index: int\n    message: ChatMessage\n    logprobs: Optional[ChatCompletionLogProbs] = None\n    # per OpenAI spec this is the default\n    finish_reason: Optional[str] = \"stop\"\n    # not part of the OpenAI spec but included in vLLM for legacy reasons\n    stop_reason: Optional[Union[int, str]] = None\n\n\nclass ChatCompletionResponse(OpenAIBaseModel):\n    id: str = Field(default_factory=lambda: f\"chatcmpl-{random_uuid()}\")\n    object: Literal[\"chat.completion\"] = \"chat.completion\"\n    created: int = Field(default_factory=lambda: int(time.time()))\n    model: str\n    choices: List[ChatCompletionResponseChoice]\n    usage: UsageInfo\n    prompt_logprobs: Optional[List[Optional[Dict[int, Logprob]]]] = None\n\n\nclass DeltaMessage(OpenAIBaseModel):\n    role: Optional[str] = None\n    content: Optional[str] = None\n    reasoning_content: Optional[str] = None\n    tool_calls: List[DeltaToolCall] = Field(default_factory=list)\n\n\nclass ChatCompletionResponseStreamChoice(OpenAIBaseModel):\n    index: int\n    delta: DeltaMessage\n    logprobs: Optional[ChatCompletionLogProbs] = None\n    finish_reason: Optional[str] = None\n    stop_reason: Optional[Union[int, str]] = None\n\n\nclass ChatCompletionStreamResponse(OpenAIBaseModel):\n    id: str = Field(default_factory=lambda: f\"chatcmpl-{random_uuid()}\")\n    object: Literal[\"chat.completion.chunk\"] = \"chat.completion.chunk\"\n    created: int = Field(default_factory=lambda: int(time.time()))\n    model: str\n    choices: List[ChatCompletionResponseStreamChoice]\n    usage: Optional[UsageInfo] = Field(default=None)\n\n\nclass BatchRequestInput(OpenAIBaseModel):\n    \"\"\"\n    The per-line object of the batch input file.\n\n    NOTE: Currently only the `/v1/chat/completions` endpoint is supported.\n    \"\"\"\n\n    # A developer-provided per-request id that will be used to match outputs to\n    # inputs. Must be unique for each request in a batch.\n    custom_id: str\n\n    # The HTTP method to be used for the request. Currently only POST is\n    # supported.\n    method: str\n\n    # The OpenAI API relative URL to be used for the request. Currently\n    # /v1/chat/completions is supported.\n    url: str\n\n    # The parameters of the request.\n    body: Union[ChatCompletionRequest, EmbeddingRequest, ScoreRequest]\n\n    @field_validator('body', mode='plain')\n    @classmethod\n    def check_type_for_url(cls, value: Any, info: ValidationInfo):\n        # Use url to disambiguate models\n        url = info.data['url']\n        if url == \"/v1/chat/completions\":\n            return ChatCompletionRequest.model_validate(value)\n        if url == \"/v1/embeddings\":\n            return TypeAdapter(EmbeddingRequest).validate_python(value)\n        if url == \"/v1/score\":\n            return ScoreRequest.model_validate(value)\n        return TypeAdapter(Union[ChatCompletionRequest, EmbeddingRequest,\n                                 ScoreRequest]).validate_python(value)\n\n\nclass BatchResponseData(OpenAIBaseModel):\n    # HTTP status code of the response.\n    status_code: int = 200\n\n    # An unique identifier for the API request.\n    request_id: str\n\n    # The body of the response.\n    body: Optional[Union[ChatCompletionResponse, EmbeddingResponse,\n                         ScoreResponse]] = None\n\n\nclass BatchRequestOutput(OpenAIBaseModel):\n    \"\"\"\n    The per-line object of the batch output and error files\n    \"\"\"\n\n    id: str\n\n    # A developer-provided per-request id that will be used to match outputs to\n    # inputs.\n    custom_id: str\n\n    response: Optional[BatchResponseData]\n\n    # For requests that failed with a non-HTTP error, this will contain more\n    # information on the cause of the failure.\n    error: Optional[Any]\n\n\nclass TokenizeCompletionRequest(OpenAIBaseModel):\n    model: str\n    prompt: str\n\n    add_special_tokens: bool = Field(\n        default=True,\n        description=(\n            \"If true (the default), special tokens (e.g. BOS) will be added to \"\n            \"the prompt.\"),\n    )\n\n\nclass TokenizeChatRequest(OpenAIBaseModel):\n    model: str\n    messages: List[ChatCompletionMessageParam]\n\n    add_generation_prompt: bool = Field(\n        default=True,\n        description=\n        (\"If true, the generation prompt will be added to the chat template. \"\n         \"This is a parameter used by chat template in tokenizer config of the \"\n         \"model.\"),\n    )\n    continue_final_message: bool = Field(\n        default=False,\n        description=\n        (\"If this is set, the chat will be formatted so that the final \"\n         \"message in the chat is open-ended, without any EOS tokens. The \"\n         \"model will continue this message rather than starting a new one. \"\n         \"This allows you to \\\"prefill\\\" part of the model's response for it. \"\n         \"Cannot be used at the same time as `add_generation_prompt`.\"),\n    )\n    add_special_tokens: bool = Field(\n        default=False,\n        description=(\n            \"If true, special tokens (e.g. BOS) will be added to the prompt \"\n            \"on top of what is added by the chat template. \"\n            \"For most models, the chat template takes care of adding the \"\n            \"special tokens so this should be set to false (as is the \"\n            \"default).\"),\n    )\n    chat_template: Optional[str] = Field(\n        default=None,\n        description=(\n            \"A Jinja template to use for this conversion. \"\n            \"As of transformers v4.44, default chat template is no longer \"\n            \"allowed, so you must provide a chat template if the tokenizer \"\n            \"does not define one.\"),\n    )\n    chat_template_kwargs: Optional[Dict[str, Any]] = Field(\n        default=None,\n        description=(\"Additional kwargs to pass to the template renderer. \"\n                     \"Will be accessible by the chat template.\"),\n    )\n\n    @model_validator(mode=\"before\")\n    @classmethod\n    def check_generation_prompt(cls, data):\n        if data.get(\"continue_final_message\") and data.get(\n                \"add_generation_prompt\"):\n            raise ValueError(\"Cannot set both `continue_final_message` and \"\n                             \"`add_generation_prompt` to True.\")\n        return data\n\n\nTokenizeRequest = Union[TokenizeCompletionRequest, TokenizeChatRequest]\n\n\nclass TokenizeResponse(OpenAIBaseModel):\n    count: int\n    max_model_len: int\n    tokens: List[int]\n\n\nclass DetokenizeRequest(OpenAIBaseModel):\n    model: str\n    tokens: List[int]\n\n\nclass DetokenizeResponse(OpenAIBaseModel):\n    prompt: str\n\n\nclass LoadLoraAdapterRequest(BaseModel):\n    lora_name: str\n    lora_path: str\n\n\nclass UnloadLoraAdapterRequest(BaseModel):\n    lora_name: str\n    lora_int_id: Optional[int] = Field(default=None)\n\n\n## Protocols for Audio\nAudioResponseFormat: TypeAlias = Literal[\"json\", \"text\", \"srt\", \"verbose_json\",\n                                         \"vtt\"]\n\n\nclass TranscriptionRequest(OpenAIBaseModel):\n    # Ordered by official OpenAI API documentation\n    #https://platform.openai.com/docs/api-reference/audio/createTranscription\n\n    file: UploadFile\n    \"\"\"\n    The audio file object (not file name) to transcribe, in one of these\n    formats: flac, mp3, mp4, mpeg, mpga, m4a, ogg, wav, or webm.\n    \"\"\"\n\n    model: str\n    \"\"\"ID of the model to use.\n    \"\"\"\n\n    language: Optional[str] = None\n    \"\"\"The language of the input audio.\n\n    Supplying the input language in\n    [ISO-639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) format\n    will improve accuracy and latency.\n    \"\"\"\n\n    prompt: str = Field(default=\"\")\n    \"\"\"An optional text to guide the model's style or continue a previous audio\n    segment.\n\n    The [prompt](https://platform.openai.com/docs/guides/speech-to-text#prompting)\n    should match the audio language.\n    \"\"\"\n\n    response_format: AudioResponseFormat = Field(default=\"json\")\n    \"\"\"\n    The format of the output, in one of these options: `json`, `text`, `srt`,\n    `verbose_json`, or `vtt`.\n    \"\"\"\n\n    ## TODO (varun) : Support if set to 0, certain thresholds are met !!\n    temperature: float = Field(default=0.0)\n    \"\"\"The sampling temperature, between 0 and 1.\n\n    Higher values like 0.8 will make the output more random, while lower values\n    like 0.2 will make it more focused / deterministic. If set to 0, the model\n    will use [log probability](https://en.wikipedia.org/wiki/Log_probability)\n    to automatically increase the temperature until certain thresholds are hit.\n    \"\"\"\n\n    timestamp_granularities: List[Literal[\"word\", \"segment\"]] = Field(\n        alias=\"timestamp_granularities[]\", default=[])\n    \"\"\"The timestamp granularities to populate for this transcription.\n\n    `response_format` must be set `verbose_json` to use timestamp granularities.\n    Either or both of these options are supported: `word`, or `segment`. Note:\n    There is no additional latency for segment timestamps, but generating word\n    timestamps incurs additional latency.\n    \"\"\"\n\n    # Default sampling parameters for transcription requests.\n    _DEFAULT_SAMPLING_PARAMS: dict = {\n        \"temperature\": 0,\n    }\n\n    def to_sampling_params(\n            self,\n            default_max_tokens: int,\n            default_sampling_params: Optional[dict] = None) -> SamplingParams:\n        # TODO(#9845): remove max_tokens when field is removed from OpenAI API\n        max_tokens = default_max_tokens\n\n        if default_sampling_params is None:\n            default_sampling_params = {}\n        # Default parameters\n        if (temperature := self.temperature) is None:\n            temperature = default_sampling_params.get(\n                \"temperature\", self._DEFAULT_SAMPLING_PARAMS[\"temperature\"])\n\n        return SamplingParams.from_optional(temperature=temperature,\n                                            max_tokens=max_tokens)\n\n\n# Transcription response objects\nclass TranscriptionResponse(OpenAIBaseModel):\n    text: str\n    \"\"\"The transcribed text.\"\"\"\n\n\nclass TranscriptionWord(OpenAIBaseModel):\n    end: float\n    \"\"\"End time of the word in seconds.\"\"\"\n\n    start: float\n    \"\"\"Start time of the word in seconds.\"\"\"\n\n    word: str\n    \"\"\"The text content of the word.\"\"\"\n\n\nclass TranscriptionSegment(OpenAIBaseModel):\n    id: int\n    \"\"\"Unique identifier of the segment.\"\"\"\n\n    avg_logprob: float\n    \"\"\"Average logprob of the segment.\n\n    If the value is lower than -1, consider the logprobs failed.\n    \"\"\"\n\n    compression_ratio: float\n    \"\"\"Compression ratio of the segment.\n\n    If the value is greater than 2.4, consider the compression failed.\n    \"\"\"\n\n    end: float\n    \"\"\"End time of the segment in seconds.\"\"\"\n\n    no_speech_prob: float\n    \"\"\"Probability of no speech in the segment.\n\n    If the value is higher than 1.0 and the `avg_logprob` is below -1, consider\n    this segment silent.\n    \"\"\"\n\n    seek: int\n    \"\"\"Seek offset of the segment.\"\"\"\n\n    start: float\n    \"\"\"Start time of the segment in seconds.\"\"\"\n\n    temperature: float\n    \"\"\"Temperature parameter used for generating the segment.\"\"\"\n\n    text: str\n    \"\"\"Text content of the segment.\"\"\"\n\n    tokens: List[int]\n    \"\"\"Array of token IDs for the text content.\"\"\"\n\n\nclass TranscriptionResponseVerbose(OpenAIBaseModel):\n    duration: str\n    \"\"\"The duration of the input audio.\"\"\"\n\n    language: str\n    \"\"\"The language of the input audio.\"\"\"\n\n    text: str\n    \"\"\"The transcribed text.\"\"\"\n\n    segments: Optional[List[TranscriptionSegment]] = None\n    \"\"\"Segments of the transcribed text and their corresponding details.\"\"\"\n\n    words: Optional[List[TranscriptionWord]] = None\n    \"\"\"Extracted words and their corresponding timestamps.\"\"\"\n\n```\n","ts":1.739556054339E9}
{"role":"assistant","content":"To enable **greedy sampling** in the `vLLM` OpenAI endpoint, you need to configure the sampling parameters in a specific way. Greedy sampling is achieved when the model always selects the token with the highest probability at each step, without any randomness or exploration.\n\nIn the context of `vLLM` and the code you provided, greedy sampling is triggered when:\n\n1. **`temperature` is set to `0`**:\n   - Temperature controls the randomness of the sampling. A value of `0` makes the sampling deterministic, forcing the model to always choose the highest-probability token.\n\n2. **`top_p` is set to `1`**:\n   - `top_p` (nucleus sampling) controls the cumulative probability threshold for token selection. A value of `1` includes all tokens, which means no filtering is applied.\n\n3. **`top_k` is set to `1`**:\n   - `top_k` restricts sampling to the top `k` tokens. A value of `1` ensures that only the highest-probability token is selected.\n\n### Parameters to Pass for Greedy Sampling\nTo enable greedy sampling in the `vLLM` OpenAI endpoint, you should pass the following parameters in your request:\n\n```python\n{\n    \"temperature\": 0,      # Makes sampling deterministic\n    \"top_p\": 1,            # Includes all tokens (no filtering)\n    \"top_k\": 1             # Selects only the highest-probability token\n}\n```\n\n### Where to Look in the Code\nIn the provided code, the `SamplingParams` class (used in `ChatCompletionRequest` and `CompletionRequest`) handles these parameters. Specifically:\n\n- The `temperature`, `top_p`, and `top_k` parameters are defined in the request classes (e.g., `ChatCompletionRequest` and `CompletionRequest`).\n- In the `to_sampling_params` method of these classes, these parameters are used to initialize the `SamplingParams` object, which determines the sampling behavior.\n\nFor example, in the `ChatCompletionRequest` class:\n\n```python\ndef to_sampling_params(self, default_max_tokens: int, ...) -> SamplingParams:\n    ...\n    if (temperature := self.temperature) is None:\n        temperature = default_sampling_params.get(\n            \"temperature\", self._DEFAULT_SAMPLING_PARAMS[\"temperature\"])\n    if (top_p := self.top_p) is","finish_reason":"\"length\"","ts":1.739556119613E9}
{"role":"assistant","content":" None:\n        top_p = default_sampling_params.get(\n            \"top_p\", self._DEFAULT_SAMPLING_PARAMS[\"top_p\"])\n    if (top_k := self.top_k) is None:\n        top_k = default_sampling_params.get(\n            \"top_k\", self._DEFAULT_SAMPLING_PARAMS[\"top_k\"])\n    ...\n```\n\nHere, `temperature`, `top_p`, and `top_k` are used to construct the `SamplingParams` object, which governs the sampling strategy.\n\n### Summary\nTo enable greedy sampling in `vLLM`'s OpenAI endpoint, set the following parameters in your request:\n\n```python\n{\n    \"temperature\": 0,\n    \"top_p\": 1,\n    \"top_k\": 1\n}\n```\n\nThis ensures that the model always selects the highest-probability token at each step, resulting in deterministic and greedy sampling.","finish_reason":"{\"text\":\"\",\"logprobs\":{\"token_logprobs\":[-8.289691992104053E-3],\"tokens\":[\"token_id:1\"]},\"token_ids\":[1]}","ts":1.739556146027E9}
{"role":"assistant","content":"","finish_reason":"{\"text\":\"\",\"logprobs\":{\"token_logprobs\":[-2.445216476917267E-2],\"tokens\":[\"token_id:1\"]},\"token_ids\":[1]}","ts":1.739556148585E9}
{"role":"assistant","content":"","finish_reason":"{\"text\":\"\",\"logprobs\":{\"token_logprobs\":[-2.01082993298769E-2],\"tokens\":[\"token_id:1\"]},\"token_ids\":[1]}","ts":1.73955615026E9}
{"role":"assistant","content":" Let me know if you need further clarification! ðŸš€","finish_reason":"{\"text\":\"\",\"logprobs\":{\"token_logprobs\":[-3.753998083993793E-3],\"tokens\":[\"token_id:1\"]},\"token_ids\":[1]}","ts":1.739556156152E9}
{"role":"assistant","content":"","finish_reason":"{\"text\":\"\",\"logprobs\":{\"token_logprobs\":[-6.010078825056553E-3],\"tokens\":[\"token_id:1\"]},\"token_ids\":[1]}","ts":1.739556158576E9}
{"role":"assistant","content":"","finish_reason":"{\"text\":\"\",\"logprobs\":{\"token_logprobs\":[-2.9785337392240763E-3],\"tokens\":[\"token_id:1\"]},\"token_ids\":[1]}","ts":1.739556162234E9}
{"role":"assistant","content":"","finish_reason":"\"stop\"","ts":1.73955617016E9}
{"role":"assistant","content":"","finish_reason":"\"stop\"","ts":1.739556177947E9}
{"role":"assistant","content":"","finish_reason":"{\"text\":\"\",\"logprobs\":{\"token_logprobs\":[-2.9785337392240763E-3],\"tokens\":[\"token_id:1\"]},\"token_ids\":[1]}","ts":1.739556180352E9}
{"role":"assistant","content":"","finish_reason":"{\"text\":\"\",\"logprobs\":{\"token_logprobs\":[-7.479402702301741E-3],\"tokens\":[\"token_id:1\"]},\"token_ids\":[1]}","ts":1.739556184331E9}
{"role":"assistant","content":"","finish_reason":"\"stop\"","ts":1.739556190829E9}
{"role":"assistant","content":"","finish_reason":"\"stop\"","ts":1.739556197818E9}
{"role":"assistant","content":"","finish_reason":"\"stop\"","ts":1.739556203813E9}
{"role":"assistant","content":"","finish_reason":"\"stop\"","ts":1.739556210053E9}
{"role":"assistant","content":"","finish_reason":"\"stop\"","ts":1.739556216452E9}
{"role":"assistant","content":"","finish_reason":"\"stop\"","ts":1.739556222839E9}
{"role":"assistant","content":"","finish_reason":"{\"text\":\"\",\"logprobs\":{\"token_logprobs\":[-4.669357556849718E-3],\"tokens\":[\"token_id:1\"]},\"token_ids\":[1]}","ts":1.739556225248E9}
{"role":"assistant","content":"","finish_reason":"{\"text\":\"\",\"logprobs\":{\"token_logprobs\":[-2.996124094352126E-3],\"tokens\":[\"token_id:1\"]},\"token_ids\":[1]}","ts":1.739556227588E9}
{"role":"assistant","content":"","finish_reason":"{\"text\":\"\",\"logprobs\":{\"token_logprobs\":[-3.8466285914182663E-3],\"tokens\":[\"token_id:1\"]},\"token_ids\":[1]}","ts":1.739556229255E9}
{"role":"assistant","content":"","finish_reason":"\"stop\"","ts":1.739556236346E9}
{"role":"assistant","content":"","finish_reason":"\"stop\"","ts":1.739556242734E9}
{"role":"assistant","content":"","finish_reason":"\"stop\"","ts":1.739556248938E9}
{"role":"assistant","content":"","finish_reason":"runtime_error SIGINT","ts":1.739556251129E9}
