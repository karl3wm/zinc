{"role":"user","content":"[1] [2]\n\n1: **../build/2025-02-09T21:11-05:00.log**\n```\nThe following will be replaced:\n- $(<pathname) will read a file\n- $(commands) will capture output from commands\n- `commands` is the same as $(commands)\n- http://url will fetch a url\n- https://url will also fetch a url\nPresently no escaping is processed, so be careful not to end commands early.\n\n\nuser: \nassistant: =================================================================\n==62850==ERROR: AddressSanitizer: heap-use-after-free on address 0x513000012230 at pc 0x7f66b731feb7 bp 0x7ffccc0098b0 sp 0x7ffccc0098a8\nREAD of size 1 at 0x513000012230 thread T0\n    #0 0x7f66b731feb6 in std::variant<decltype(nullptr), bool, long, double, std::basic_string_view<char, std::char_traits<char> >, std::span<zinc::JSON, 18446744073709551615ul>, std::span<std::pair<std::basic_string_view<char, std::char_traits<char> >, zinc::JSON>, 18446744073709551615ul> >::index() const /usr/include/c++/12/variant:1598\n    #1 0x7f66b7320fc3 in std::variant_alternative<6ul, std::variant<decltype(nullptr), bool, long, double, std::basic_string_view<char, std::char_traits<char> >, std::span<zinc::JSON, 18446744073709551615ul>, std::span<std::pair<std::basic_string_view<char, std::char_traits<char> >, zinc::JSON>, 18446744073709551615ul> > >::type const& std::get<6ul, decltype(nullptr), bool, long, double, std::basic_string_view<char, std::char_traits<char> >, std::span<zinc::JSON, 18446744073709551615ul>, std::span<std::pair<std::basic_string_view<char, std::char_traits<char> >, zinc::JSON>, 18446744073709551615ul> >(std::variant<decltype(nullptr), bool, long, double, std::basic_string_view<char, std::char_traits<char> >, std::span<zinc::JSON, 18446744073709551615ul>, std::span<std::pair<std::basic_string_view<char, std::char_traits<char> >, zinc::JSON>, 18446744073709551615ul> > const&) /usr/include/c++/12/variant:1710\n    #2 0x7f66b730f508 in std::span<std::pair<std::basic_string_view<char, std::char_traits<char> >, zinc::JSON>, 18446744073709551615ul> const& std::get<std::span<std::pair<std::basic_string_view<char, std::char_traits<char> >, zinc::JSON>, 18446744073709551615ul>, decltype(nullptr), bool, long, double, std::basic_string_view<char, std::char_traits<char> >, std::span<zinc::JSON, 18446744073709551615ul>, std::span<std::pair<std::basic_string_view<char, std::char_traits<char> >, zinc::JSON>, 18446744073709551615ul> >(std::variant<decltype(nullptr), bool, long, double, std::basic_string_view<char, std::char_traits<char> >, std::span<zinc::JSON, 18446744073709551615ul>, std::span<std::pair<std::basic_string_view<char, std::char_traits<char> >, zinc::JSON>, 18446744073709551615ul> > const&) /usr/include/c++/12/variant:1149\n    #3 0x7f66b72f9e0a in zinc::JSON::object() const /home/karl3/projects/zinc/include/zinc/json.hpp:47\n    #4 0x7f66b73754d6 in process_response_lines /home/karl3/projects/zinc/src/openai.cpp:57\n    #5 0x7f66b73738e8 in process_response_lines /home/karl3/projects/zinc/src/openai.cpp:35\n    #6 0x7f66b7383f79 in chat /home/karl3/projects/zinc/src/openai.cpp:242\n    #7 0x7f66b737fe84 in zinc::OpenAI::chat(std::span<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > const, 18446744073709551615ul>, std::span<std::pair<std::basic_string_view<char, std::char_traits<char> >, zinc::JSON> const, 18446744073709551615ul>) const /home/karl3/projects/zinc/src/openai.cpp:201\n    #8 0x5623e811f381 in main /home/karl3/projects/zinc/cli/chatabout.cpp:176\n    #9 0x7f66b5833d67 in __libc_start_call_main ../sysdeps/nptl/libc_start_call_main.h:58\n    #10 0x7f66b5833e24 in __libc_start_main_impl ../csu/libc-start.c:360\n    #11 0x5623e81195b0 in _start (/home/karl3/projects/zinc/build/chatabout+0x2f5b0) (BuildId: 04c1ada76bb2d534d422370b3e0d14cd0ef02566)\n\n0x513000012230 is located 304 bytes inside of 336-byte region [0x513000012100,0x513000012250)\nfreed by thread T0 here:\n    #0 0x7f66b7ef6698 in operator delete(void*, unsigned long) ../../../../src/libsanitizer/asan/asan_new_delete.cpp:164\n    #1 0x7f66b7351b1a in boost::container::new_allocator<char>::deallocate(char*, unsigned long) /usr/include/boost/container/new_allocator.hpp:169\n    #2 0x7f66b7338213 in boost::container::allocator_traits<boost::container::new_allocator<char> >::deallocate(boost::container::new_allocator<char>&, char*, unsigned long) /usr/include/boost/container/allocator_traits.hpp:308\n    #3 0x7f66b7338213 in boost::container::devector<char, void, void>::deallocate_buffer() /usr/include/boost/container/devector.hpp:2231\n    #4 0x7f66b7328ada in boost::container::devector<char, void, void>::reallocate_at(unsigned long, unsigned long) (/home/karl3/projects/zinc/build/libzinc.so+0xd28ada) (BuildId: 05874bfb02054646796ecaeaf30086bd62b3cf97)\n    #5 0x7f66b7292d32 in boost::container::devector<char, void, void>::reserve_back(unsigned long) /usr/include/boost/container/devector.hpp:1264\n    #6 0x7f66b7292d32 in reserve /home/karl3/projects/zinc/src/json_boost.cpp:143\n    #7 0x7f66b7297d52 in on_object_end /home/karl3/projects/zinc/src/json_boost.cpp:242\n    #8 0x7f66b72ccf5c in parse_object<true, false> /usr/include/boost/json/basic_parser_impl.hpp:1854\n    #9 0x7f66b72aecc3 in parse_value<true, false> /usr/include/boost/json/basic_parser_impl.hpp:609\n    #10 0x7f66b72a9c7e in parse_document<true> /usr/include/boost/json/basic_parser_impl.hpp:520\n    #11 0x7f66b72a6b2d in write_some /usr/include/boost/json/basic_parser_impl.hpp:2728\n    #12 0x7f66b72a17fe in write_some /usr/include/boost/json/basic_parser_impl.hpp:2784\n    #13 0x7f66b729ad17 in zinc::JSON::decode(std::basic_string_view<char, std::char_traits<char> >) /home/karl3/projects/zinc/src/json_boost.cpp:609\n    #14 0x7f66b7374e4b in process_response_lines /home/karl3/projects/zinc/src/openai.cpp:49\n    #15 0x7f66b73738e8 in process_response_lines /home/karl3/projects/zinc/src/openai.cpp:35\n    #16 0x7f66b7383f79 in chat /home/karl3/projects/zinc/src/openai.cpp:242\n    #17 0x7f66b737fe84 in zinc::OpenAI::chat(std::span<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > const, 18446744073709551615ul>, std::span<std::pair<std::basic_string_view<char, std::char_traits<char> >, zinc::JSON> const, 18446744073709551615ul>) const /home/karl3/projects/zinc/src/openai.cpp:201\n    #18 0x5623e811f381 in main /home/karl3/projects/zinc/cli/chatabout.cpp:176\n    #19 0x7f66b5833d67 in __libc_start_call_main ../sysdeps/nptl/libc_start_call_main.h:58\n\npreviously allocated by thread T0 here:\n    #0 0x7f66b7ef5798 in operator new(unsigned long) ../../../../src/libsanitizer/asan/asan_new_delete.cpp:95\n    #1 0x7f66b735f031 in boost::container::new_allocator<char>::allocate(unsigned long) /usr/include/boost/container/new_allocator.hpp:160\n    #2 0x7f66b7345cb1 in boost::container::allocator_traits<boost::container::new_allocator<char> >::allocate(boost::container::new_allocator<char>&, unsigned long) /usr/include/boost/container/allocator_traits.hpp:302\n    #3 0x7f66b7345cb1 in boost::container::devector<char, void, void>::impl::do_allocate(boost::container::new_allocator<char>&, unsigned long) /usr/include/boost/container/devector.hpp:2818\n    #4 0x7f66b7337a60 in boost::container::devector<char, void, void>::allocate(unsigned long) /usr/include/boost/container/devector.hpp:2212\n    #5 0x7f66b73280e2 in boost::container::devector<char, void, void>::reallocate_at(unsigned long, unsigned long) (/home/karl3/projects/zinc/build/libzinc.so+0xd280e2) (BuildId: 05874bfb02054646796ecaeaf30086bd62b3cf97)\n    #6 0x7f66b7292d32 in boost::container::devector<char, void, void>::reserve_back(unsigned long) /usr/include/boost/container/devector.hpp:1264\n    #7 0x7f66b7292d32 in reserve /home/karl3/projects/zinc/src/json_boost.cpp:143\n    #8 0x7f66b7297d52 in on_object_end /home/karl3/projects/zinc/src/json_boost.cpp:242\n    #9 0x7f66b72ccf5c in parse_object<true, false> /usr/include/boost/json/basic_parser_impl.hpp:1854\n    #10 0x7f66b72aecc3 in parse_value<true, false> /usr/include/boost/json/basic_parser_impl.hpp:609\n    #11 0x7f66b72caba8 in parse_array<true, false> /usr/include/boost/json/basic_parser_impl.hpp:1936\n    #12 0x7f66b72aec6c in parse_value<true, false> /usr/include/boost/json/basic_parser_impl.hpp:607\n    #13 0x7f66b72cc6ac in parse_object<true, false> /usr/include/boost/json/basic_parser_impl.hpp:1805\n    #14 0x7f66b72aecc3 in parse_value<true, false> /usr/include/boost/json/basic_parser_impl.hpp:609\n    #15 0x7f66b72a9c7e in parse_document<true> /usr/include/boost/json/basic_parser_impl.hpp:520\n    #16 0x7f66b72a6b2d in write_some /usr/include/boost/json/basic_parser_impl.hpp:2728\n    #17 0x7f66b72a17fe in write_some /usr/include/boost/json/basic_parser_impl.hpp:2784\n    #18 0x7f66b729ad17 in zinc::JSON::decode(std::basic_string_view<char, std::char_traits<char> >) /home/karl3/projects/zinc/src/json_boost.cpp:609\n    #19 0x7f66b7374e4b in process_response_lines /home/karl3/projects/zinc/src/openai.cpp:49\n    #20 0x7f66b73738e8 in process_response_lines /home/karl3/projects/zinc/src/openai.cpp:35\n    #21 0x7f66b7383f79 in chat /home/karl3/projects/zinc/src/openai.cpp:242\n    #22 0x7f66b737fe84 in zinc::OpenAI::chat(std::span<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > const, 18446744073709551615ul>, std::span<std::pair<std::basic_string_view<char, std::char_traits<char> >, zinc::JSON> const, 18446744073709551615ul>) const /home/karl3/projects/zinc/src/openai.cpp:201\n    #23 0x5623e811f381 in main /home/karl3/projects/zinc/cli/chatabout.cpp:176\n    #24 0x7f66b5833d67 in __libc_start_call_main ../sysdeps/nptl/libc_start_call_main.h:58\n\nSUMMARY: AddressSanitizer: heap-use-after-free /usr/include/c++/12/variant:1598 in std::variant<decltype(nullptr), bool, long, double, std::basic_string_view<char, std::char_traits<char> >, std::span<zinc::JSON, 18446744073709551615ul>, std::span<std::pair<std::basic_string_view<char, std::char_traits<char> >, zinc::JSON>, 18446744073709551615ul> >::index() const\nShadow bytes around the buggy address:\n  0x513000011f80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x513000012000: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x513000012080: 00 00 00 00 00 00 00 00 fa fa fa fa fa fa fa fa\n  0x513000012100: fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd\n  0x513000012180: fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd\n=>0x513000012200: fd fd fd fd fd fd[fd]fd fd fd fa fa fa fa fa fa\n  0x513000012280: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x513000012300: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x513000012380: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x513000012400: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x513000012480: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n==62850==ABORTING\n\n```\n\n2:\n```\n$ nl -ba ../src/json_boost.cpp\n     1\t#include <zinc/json.hpp>\n     2\t\n     3\t#include <boost/container/devector.hpp>\n     4\t#include <boost/json/basic_parser_impl.hpp>\n     5\t#define enum public: enum // make serializer public in boost 1.81.0\n     6\t#include <boost/json/serializer.hpp>\n     7\t#undef enum\n     8\t#include <boost/json/impl/serializer.ipp>\n     9\t\n    10\t#include <map>\n    11\t\n    12\tusing namespace boost::json;\n    13\t\n    14\tnamespace zinc {\n    15\t\n    16\tnamespace {\n    17\t\n    18\tstruct ParseHandler\n    19\t{\n    20\t    static constexpr std::size_t max_object_size = (size_t)-1;\n    21\t    static constexpr std::size_t max_array_size = (size_t)-1;\n    22\t    static constexpr std::size_t max_key_size = (size_t)-1;\n    23\t    static constexpr std::size_t max_string_size = (size_t)-1;\n    24\t\n    25\t    struct DocImpl : public zinc::JSON {\n    26\t        DocImpl(\n    27\t            JSON root, ParseHandler* handler,\n    28\t            char* store_start, char* store_end,\n    29\t            JSON** ptrs_start, JSON** ptrs_end\n    30\t        ) : JSON(root), handler(handler),\n    31\t            store_start(store_start), store_end(store_end),\n    32\t            ptrs_start(ptrs_start), ptrs_end(ptrs_end)\n    33\t        { }\n    34\t        ParseHandler * handler;\n    35\t        char* store_start;\n    36\t        char* store_end;\n    37\t        JSON** ptrs_start;\n    38\t        JSON** ptrs_end;\n    39\t    };\n    40\t    DocImpl* docimpl;\n    41\t\n    42\t    std::vector<JSON> stack;\n    43\t    boost::container::devector<char> store;\n    44\t    boost::container::devector<JSON*> ptr_jsons;\n    45\t    boost::container::devector<DocImpl*> docs;\n    46\t\n    47\t    JSON* get() {\n    48\t        auto ptr = docimpl;\n    49\t        docimpl = nullptr;\n    50\t        return ptr;\n    51\t    }\n    52\t    void abort() {\n    53\t        assert(docs.back() == docimpl);\n    54\t        store.erase(docimpl->store_start, store.end());\n    55\t        ptr_jsons.erase(docimpl->ptrs_start, ptr_jsons.end());\n    56\t        docs.pop_back();\n    57\t        docimpl = nullptr;\n    58\t    }\n    59\t    void del(DocImpl& doc) {\n    60\t        assert((store.end() == doc.store_end || store.begin() == doc.store_start) && \"deallocate jsons in forward or reverse order\");\n    61\t        assert((ptr_jsons.end() == doc.ptrs_end || ptr_jsons.begin() == doc.ptrs_start) && \"deallocate jsons in forward or reverse order\");\n    62\t        decltype(docs)::iterator doc_it;\n    63\t        if (docs.back() == &doc) {\n    64\t            doc_it = docs.end() - 1;\n    65\t        } else if (docs.front() == &doc) {\n    66\t            doc_it = docs.begin();\n    67\t        } else {\n    68\t            assert(!\"deallocate jsons in forward or reverse order\");\n    69\t        }\n    70\t        assert(doc.store_start >= store.begin() && doc.store_end <= store.end());\n    71\t        assert(doc.store_start <= doc.store_end);\n    72\t        assert(doc.ptrs_start >= ptr_jsons.begin() && doc.ptrs_end <= ptr_jsons.end());\n    73\t        assert(doc.ptrs_start <= doc.ptrs_end);\n    74\t        store.erase(doc.store_start, doc.store_end);\n    75\t        ptr_jsons.erase(doc.ptrs_start, doc.ptrs_end);\n    76\t        docs.erase(doc_it);\n    77\t    }\n    78\t    static void del(JSON* doc_) {\n    79\t        DocImpl & doc = *(DocImpl*)doc_;\n    80\t        doc.handler->del(doc);\n    81\t    }\n    82\t\n    83\t    inline void adjust_store_pointers(ptrdiff_t store_offset)\n    84\t    {\n    85\t        if (!store_offset) {\n    86\t            return;\n    87\t        }\n    88\t        for (JSON *& json : ptr_jsons) {\n    89\t            json = (JSON*)((char*)json + store_offset);\n    90\t            if (auto span = std::get_if<std::span<JSON>>(json)) {\n    91\t                *span = {\n    92\t                    (JSON*)((char*)span->data() + store_offset),\n    93\t                    span->size()\n    94\t                };\n    95\t            } else if (auto span = std::get_if<std::span<KeyJSONPair>>(json)) {\n    96\t                *span = {\n    97\t                    (KeyJSONPair*)((char*)span->data() + store_offset),\n    98\t                    span->size()\n    99\t                };\n   100\t            } else if (auto sv = std::get_if<std::string_view>(json)) {\n   101\t                *sv = {\n   102\t                    sv->data() + store_offset,\n   103\t                    sv->size()\n   104\t                };\n   105\t            } else {\n   106\t                throw std::logic_error(\"non-pointer json in ptr_jsons\");\n   107\t            }\n   108\t        }   \n   109\t        for (DocImpl*& doc : docs) {\n   110\t            doc = (DocImpl*)((char*)doc + store_offset);\n   111\t            assert(doc->handler == this);\n   112\t            doc->store_start += store_offset;\n   113\t            doc->store_end += store_offset;\n   114\t            assert(doc->store_start >= store.begin() && doc->store_end <= store.end());\n   115\t            assert(doc->store_start <= doc->store_end);\n   116\t        }\n   117\t        if (docimpl != nullptr) {\n   118\t            docimpl = (DocImpl*)((char*)docimpl + store_offset);\n   119\t        }\n   120\t    }\n   121\t\n   122\t    inline void adjust_ptr_pointers(ptrdiff_t ptrs_offset)\n   123\t    {\n   124\t        if (!ptrs_offset) {\n   125\t            return;\n   126\t        }\n   127\t        for (DocImpl*& doc : docs) {\n   128\t            assert(doc->handler == this);\n   129\t            doc->ptrs_start = (JSON**)((char*)doc->ptrs_start + ptrs_offset);\n   130\t            doc->ptrs_end = (JSON**)((char*)doc->ptrs_end + ptrs_offset);\n   131\t            assert(doc->ptrs_start >= ptr_jsons.begin() && doc->ptrs_end <= ptr_jsons.end());\n   132\t            assert(doc->ptrs_start <= doc->ptrs_end);\n   133\t        }\n   134\t    }\n   135\t\n   136\t    inline char* reserve(size_t n) {\n   137\t        if (store.back_free_capacity() < n) {\n   138\t            size_t new_capacity = std::max(store.size(), 64ul);\n   139\t            while (new_capacity < store.size() + n) {\n   140\t                new_capacity *= 2;\n   141\t            }\n   142\t            char* old = store.data();\n   143\t            store.reserve_back(new_capacity);\n   144\t            adjust_store_pointers(store.data() - old);\n   145\t        }\n   146\t        return store.end();\n   147\t    }\n   148\t    inline char* store_chars(std::string_view chars)\n   149\t    {\n   150\t        reserve(chars.size());\n   151\t        store.insert(store.end(), chars.begin(), chars.end());\n   152\t        return store.end();\n   153\t    }\n   154\t    inline char* store_key(std::string_view key)\n   155\t    {\n   156\t        //auto seat = (std::string_view*)reserve(sizeof(key));\n   157\t        store.insert(reserve(sizeof(key)), (char*)&key, (char*)(&key+1));\n   158\t        //store.resize_back(store.size() + sizeof(key));\n   159\t        //new (seat) std::string_view(key);\n   160\t        return store.end();\n   161\t    }\n   162\t    bool json_is_ptr(JSON const & json) {\n   163\t        if (\n   164\t            std::holds_alternative<std::span<JSON>>(json) ||\n   165\t            std::holds_alternative<std::span<KeyJSONPair>>(json)\n   166\t        ) {\n   167\t            return true;\n   168\t        } else if (std::string_view const * sv = std::get_if<std::string_view>(&json)) {\n   169\t            if (sv->data() >= store.data()\n   170\t             && sv->data() < &*store.end()) {\n   171\t                return true;\n   172\t            }\n   173\t        }\n   174\t        return false;\n   175\t    }\n   176\t    void add_ptr_json(JSON* json)\n   177\t    {\n   178\t        char* old = (char*)ptr_jsons.data();\n   179\t        ptr_jsons.push_back(json);\n   180\t        if ((char*)ptr_jsons.data() != old) {\n   181\t            adjust_ptr_pointers((char*)ptr_jsons.data() - old);\n   182\t        }\n   183\t    }\n   184\t    inline char* store_json(JSON const & json)\n   185\t    {\n   186\t        bool is_ptr = json_is_ptr(json);\n   187\t\n   188\t        auto seat = (JSON*)reserve(sizeof(JSON));\n   189\t        store.insert(store.end(), (char*)&json, (char*)(&json + 1));\n   190\t        //store.resize_back(store.size() + sizeof(json));\n   191\t        //new (seat) JSON(json);\n   192\t\n   193\t        if (is_ptr) {\n   194\t            add_ptr_json(seat);\n   195\t        }\n   196\t\n   197\t        return store.end();\n   198\t    }\n   199\t\n   200\t    inline char* store_doc()\n   201\t    {\n   202\t        assert(nullptr == docimpl);\n   203\t        char* storeptr = reserve(sizeof(DocImpl));\n   204\t        JSON** ptrsptr = ptr_jsons.end();\n   205\t        docimpl = (DocImpl*)storeptr;\n   206\t        docs.push_back(docimpl);\n   207\t        store.resize_back(store.size() + sizeof(DocImpl));\n   208\t        new (docimpl) DocImpl(\n   209\t            nullptr, this,\n   210\t            storeptr, storeptr,\n   211\t            ptrsptr, ptrsptr\n   212\t        );\n   213\t        return store.end();\n   214\t    }\n   215\t\n   216\t    //inline void set_raw(std::string_view raw) {\n   217\t    //    JSON & json = stack.back();\n   218\t    //    assert(json.raw.empty());\n   219\t    //    json.raw = raw;\n   220\t    //}\n   221\t\n   222\t    inline bool on_document_begin(error_code&) {\n   223\t        store_doc();\n   224\t        return true;\n   225\t    }\n   226\t    inline bool on_document_end(error_code&) {\n   227\t        assert(1 == stack.size());\n   228\t        assert(docimpl->handler == this);\n   229\t        *(JSON*)docimpl = stack.back();\n   230\t        stack.clear();\n   231\t        if (json_is_ptr(*docimpl)) {\n   232\t            add_ptr_json(docimpl);\n   233\t        }\n   234\t        docimpl->store_end = store.end();\n   235\t        docimpl->ptrs_end = ptr_jsons.end();\n   236\t        return true;\n   237\t    }\n   238\t    inline bool on_object_begin(error_code&) {\n   239\t        return true;\n   240\t    }\n   241\t    inline bool on_object_end(std::size_t n, error_code&) {\n   242\t        auto bot_start = (KeyJSONPair*)reserve(sizeof(KeyJSONPair) * n + sizeof(JSON));\n   243\t        auto top_end = stack.end(), top_start = top_end - (ssize_t)n * 2;\n   244\t        for (auto json = top_start; json != top_end;) {\n   245\t            store_key(std::get<std::string_view>(*json));\n   246\t            ++ json;\n   247\t            store_json(*json);\n   248\t            ++ json;\n   249\t        }\n   250\t        auto bot_end = (KeyJSONPair*)&*store.end();\n   251\t        stack.erase(top_start, top_end);\n   252\t        stack.emplace_back(std::span<KeyJSONPair>(bot_start, bot_end));\n   253\t        return true;\n   254\t    }\n   255\t    inline bool on_array_begin(error_code&)\n   256\t    {\n   257\t        return true;\n   258\t    }\n   259\t    inline bool on_array_end(std::size_t n, error_code&)\n   260\t    {\n   261\t        auto bot_start = (JSON*)reserve(sizeof(JSON) * n + sizeof(JSON));\n   262\t        auto top_end = stack.end(), top_start = top_end - (ssize_t)n;\n   263\t        for (auto json = top_start; json != top_end; ++ json) {\n   264\t            store_json(*json);\n   265\t        }\n   266\t        auto bot_end = (JSON*)&*store.end();\n   267\t        stack.erase(top_start, top_end);\n   268\t        stack.emplace_back(std::span<JSON>(bot_start, bot_end));\n   269\t        return true;\n   270\t    }\n   271\t    inline bool on_key_part(string_view s, std::size_t, error_code&) {\n   272\t        store_chars(s);\n   273\t        return true;\n   274\t    }\n   275\t    inline bool on_key(string_view s, std::size_t n, error_code&) {\n   276\t        if (s.size() < n) {\n   277\t            store_chars(s);\n   278\t            auto end = store.end(), start = end - n;\n   279\t            stack.emplace_back(std::string_view{start, end});\n   280\t        } else {\n   281\t            stack.emplace_back(s);\n   282\t        }\n   283\t        return true;\n   284\t    }\n   285\t    inline bool on_string_part(string_view s, std::size_t, error_code&) {\n   286\t        store_chars(s);\n   287\t        return true;\n   288\t    }\n   289\t    inline bool on_string(string_view s, std::size_t n, error_code&) {\n   290\t        if (s.size() < n) {\n   291\t            store_chars(s);\n   292\t            auto end = store.end(), start = end - n;\n   293\t            stack.emplace_back(std::string_view{start, end});\n   294\t        } else {\n   295\t            stack.emplace_back(s);\n   296\t        }\n   297\t        return true;\n   298\t    }\n   299\t    inline bool on_number_part(string_view, error_code&)\n   300\t    {\n   301\t        return true;\n   302\t    }\n   303\t    inline bool on_int64(std::int64_t i, string_view, error_code&)\n   304\t    {\n   305\t        stack.emplace_back((long)i);\n   306\t        return true;\n   307\t    }\n   308\t    inline bool on_uint64(std::uint64_t u, string_view, error_code&)\n   309\t    {\n   310\t        stack.emplace_back((long)u);\n   311\t        return true;\n   312\t    }\n   313\t    inline bool on_double(double d, string_view, error_code&)\n   314\t    {\n   315\t        stack.emplace_back(d);\n   316\t        return true;\n   317\t    }\n   318\t    inline bool on_bool(bool b, error_code&)\n   319\t    {\n   320\t        stack.emplace_back(b);\n   321\t        return true;\n   322\t    }\n   323\t    inline bool on_null(error_code&)\n   324\t    {\n   325\t        stack.emplace_back(nullptr);\n   326\t        return true;\n   327\t    }\n   328\t    inline bool on_comment_part(string_view, error_code&)\n   329\t    {\n   330\t        return true;\n   331\t    }\n   332\t    inline bool on_comment(string_view, error_code&)\n   333\t    {\n   334\t        return true;\n   335\t    }\n   336\t};\n   337\t\n   338\tclass Serializer : public boost::json::serializer\n   339\t{\n   340\t    union\n   341\t    {\n   342\t        JSON const* pj_;\n   343\t        std::span<KeyJSONPair const> const* po_;\n   344\t        std::span<JSON const> const* pa_;\n   345\t    };\n   346\t    JSON const* jj_ = nullptr;\n   347\t    boost::json::value boost_value;\n   348\tpublic:\n   349\t\n   350\t    bool suspend(\n   351\t        state st,\n   352\t        std::span<JSON const>::iterator it,\n   353\t        std::span<JSON const> const* pa)\n   354\t    {\n   355\t        st_.push(pa);\n   356\t        st_.push(it);\n   357\t        st_.push(st);\n   358\t        return false;\n   359\t    }\n   360\t\n   361\t    bool suspend(\n   362\t        state st,\n   363\t        std::span<KeyJSONPair const>::iterator it,\n   364\t        std::span<KeyJSONPair const> const* po)\n   365\t    {\n   366\t        st_.push(po);\n   367\t        st_.push(it);\n   368\t        st_.push(st);\n   369\t        return false;\n   370\t    }\n   371\t\n   372\t    void reset(JSON const* j) noexcept\n   373\t    {\n   374\t        //pv_ = j;\n   375\t        pj_ = j;\n   376\t        fn0_ = (fn_t)&Serializer::write_value<true>;\n   377\t        fn1_ = (fn_t)&Serializer::write_value<false>;\n   378\t\n   379\t        jj_ = j;\n   380\t        st_.clear();\n   381\t        done_ = false;\n   382\t    }\n   383\t\n   384\t    template<bool StackEmpty>\n   385\t    bool write_array(stream& ss0)\n   386\t    {\n   387\t        std::span<JSON const> const* pa;\n   388\t        local_stream ss(ss0);\n   389\t        std::span<JSON const>::iterator it, end;\n   390\t        if(StackEmpty || st_.empty())\n   391\t        {\n   392\t            pa = pa_;\n   393\t            it = pa->begin();\n   394\t            end = pa->end();\n   395\t        } else {\n   396\t            state st;\n   397\t            st_.pop(st);\n   398\t            st_.pop(it);\n   399\t            st_.pop(pa);\n   400\t            end = pa->end();\n   401\t            switch(st)\n   402\t            {\n   403\t            default:\n   404\t            case state::arr1: goto do_arr1;\n   405\t            case state::arr2: goto do_arr2;\n   406\t            case state::arr3: goto do_arr3;\n   407\t            case state::arr4: goto do_arr4;\n   408\t                break;\n   409\t            }\n   410\t        }\n   411\tdo_arr1:\n   412\t        if(BOOST_JSON_LIKELY(ss))\n   413\t            ss.append('[');\n   414\t        else\n   415\t            return suspend(\n   416\t                state::arr1, it, pa);\n   417\t        if(it == end)\n   418\t            goto do_arr4;\n   419\t        for(;;)\n   420\t        {\n   421\tdo_arr2:\n   422\t            jj_ = &*it;\n   423\t            if(! write_value<StackEmpty>(ss))\n   424\t                return suspend(\n   425\t                    state::arr2, it, pa);\n   426\t            if(BOOST_JSON_UNLIKELY(\n   427\t                ++it == end))\n   428\t                break;\n   429\tdo_arr3:\n   430\t            if(BOOST_JSON_LIKELY(ss))\n   431\t                ss.append(',');\n   432\t            else\n   433\t                return suspend(\n   434\t                    state::arr3, it, pa);\n   435\t        }\n   436\tdo_arr4:\n   437\t        if(BOOST_JSON_LIKELY(ss))\n   438\t            ss.append(']');\n   439\t        else\n   440\t            return suspend(\n   441\t                state::arr4, it, pa);\n   442\t        return true;\n   443\t    }\n   444\t\n   445\t    template<bool StackEmpty>\n   446\t    bool write_object(stream& ss0)\n   447\t    {\n   448\t        std::span<KeyJSONPair const> const* po;\n   449\t        local_stream ss(ss0);\n   450\t        std::span<KeyJSONPair const>::iterator it, end;\n   451\t        if(StackEmpty || st_.empty())\n   452\t        {\n   453\t            po = po_;\n   454\t            it = po->begin();\n   455\t            end = po->end();\n   456\t        } else {\n   457\t            state st;\n   458\t            st_.pop(st);\n   459\t            st_.pop(it);\n   460\t            st_.pop(po);\n   461\t            end = po->end();\n   462\t            switch(st)\n   463\t            {\n   464\t            default:\n   465\t            case state::obj1: goto do_obj1;\n   466\t            case state::obj2: goto do_obj2;\n   467\t            case state::obj3: goto do_obj3;\n   468\t            case state::obj4: goto do_obj4;\n   469\t            case state::obj5: goto do_obj5;\n   470\t            case state::obj6: goto do_obj6;\n   471\t                break;\n   472\t            }\n   473\t        }\n   474\tdo_obj1:\n   475\t        if(BOOST_JSON_LIKELY(ss))\n   476\t            ss.append('{');\n   477\t        else\n   478\t            return suspend(\n   479\t                state::obj1, it, po);\n   480\t        if(BOOST_JSON_UNLIKELY(\n   481\t            it == end))\n   482\t            goto do_obj6;\n   483\t        for(;;)\n   484\t        {\n   485\t            cs0_ = {\n   486\t                it->first.data(),\n   487\t                it->first.size() };\n   488\tdo_obj2:\n   489\t            if(BOOST_JSON_UNLIKELY(\n   490\t                ! write_string<StackEmpty>(ss)))\n   491\t                return suspend(\n   492\t                    state::obj2, it, po);\n   493\tdo_obj3:\n   494\t            if(BOOST_JSON_LIKELY(ss))\n   495\t                ss.append(':');\n   496\t            else\n   497\t                return suspend(\n   498\t                    state::obj3, it, po);\n   499\tdo_obj4:\n   500\t            jj_ = &it->second;\n   501\t            if(BOOST_JSON_UNLIKELY(\n   502\t                ! write_value<StackEmpty>(ss)))\n   503\t                return suspend(\n   504\t                    state::obj4, it, po);\n   505\t            ++it;\n   506\t            if(BOOST_JSON_UNLIKELY(it == end))\n   507\t                break;\n   508\tdo_obj5:\n   509\t            if(BOOST_JSON_UNLIKELY(ss))\n   510\t                ss.append(',');\n   511\t            else\n   512\t                return suspend(\n   513\t                    state::obj5, it, po);\n   514\t        }\n   515\tdo_obj6:\n   516\t        if(BOOST_JSON_LIKELY(ss))\n   517\t        {\n   518\t            ss.append('}');\n   519\t            return true;\n   520\t        }\n   521\t        return suspend(\n   522\t            state::obj6, it, po);\n   523\t    }\n   524\t\n   525\t    template<bool StackEmpty>\n   526\t    bool write_value(stream& ss)\n   527\t    {\n   528\t        auto const& jj(*jj_);\n   529\t        if (StackEmpty || st_.empty()) {\n   530\t            switch(jj.index()) {\n   531\t            default:\n   532\t            case JSON::OBJECT:\n   533\t                po_ = (std::span<KeyJSONPair const>const*)&jj.object();\n   534\t                return write_object<true>(ss);\n   535\t            case JSON::ARRAY:\n   536\t                pa_ = (std::span<JSON const>const*)&jj.array();\n   537\t                return write_array<true>(ss);\n   538\t            case JSON::STRING:\n   539\t            {\n   540\t                auto const& js = std::get<std::string_view>(jj);\n   541\t                cs0_ = { js.data(), js.size() };\n   542\t                return write_string<true>(ss);\n   543\t            }\n   544\t            case JSON::INTEGER:\n   545\t                boost_value = std::get<long>(jj);\n   546\t                jv_ = &boost_value;\n   547\t                return write_number<true>(ss);\n   548\t            case JSON::NUMBER:\n   549\t                boost_value = std::get<double>(jj);\n   550\t                jv_ = &boost_value;\n   551\t                return write_number<true>(ss);\n   552\t            case JSON::BOOLEAN:\n   553\t                if (std::get<bool>(jj)) {\n   554\t                    if(BOOST_JSON_LIKELY(\n   555\t                        ss.remain() >= 4))\n   556\t                    {\n   557\t                        ss.append(\"true\", 4);\n   558\t                        return true;\n   559\t                    }\n   560\t                    return write_true<true>(ss);\n   561\t                } else {\n   562\t                    if(BOOST_JSON_LIKELY(\n   563\t                        ss.remain() >= 5))\n   564\t                    {\n   565\t                        ss.append(\"false\", 5);\n   566\t                        return true;\n   567\t                    }\n   568\t                    return write_false<true>(ss);\n   569\t                }\n   570\t            case (JSON::Index)NULL:\n   571\t                if(BOOST_JSON_LIKELY(\n   572\t                    ss.remain() >= 4))\n   573\t                {\n   574\t                    ss.append(\"null\", 4);\n   575\t                    return true;\n   576\t                }\n   577\t                return write_null<true>(ss);\n   578\t            }\n   579\t        } else {\n   580\t            state st;\n   581\t            st_.peek(st);\n   582\t            switch(st)\n   583\t            {\n   584\t            default:\n   585\t                return serializer::write_value<StackEmpty>(ss);\n   586\t\n   587\t            case state::arr1: case state::arr2:\n   588\t            case state::arr3: case state::arr4:\n   589\t                return write_array<StackEmpty>(ss);\n   590\t\n   591\t            case state::obj1: case state::obj2:\n   592\t            case state::obj3: case state::obj4:\n   593\t            case state::obj5: case state::obj6:\n   594\t                return write_object<StackEmpty>(ss);\n   595\t            }\n   596\t        }\n   597\t    }\n   598\t};\n   599\t\n   600\tthread_local boost::json::basic_parser<ParseHandler> parser({});\n   601\t\n   602\t}\n   603\t\n   604\tJSON::Doc JSON::decode(std::string_view text)\n   605\t{\n   606\t    std::error_code ec;\n   607\t    parser.reset();\n   608\t    try {\n   609\t        /*size_t parsed_size = */parser.write_some(false, text.data(), text.size(), ec);\n   610\t        if (ec) { throw std::system_error(ec); }\n   611\t    } catch(...) {\n   612\t        parser.handler().abort();\n   613\t        throw;\n   614\t    }\n   615\t    return parser.handler().get();\n   616\t}\n   617\t\n   618\tstd::string_view JSON::encode() const\n   619\t{\n   620\t    static thread_local Serializer serializer;\n   621\t    static thread_local std::string storage;\n   622\t    serializer.reset(this);\n   623\t    storage.clear();\n   624\t    while (!serializer.done()) {\n   625\t        if (storage.capacity() == storage.size()) {\n   626\t            storage.reserve(storage.size() * 2);\n   627\t        }\n   628\t        storage += serializer.read(&*storage.end(), storage.capacity() - storage.size());\n   629\t    }\n   630\t    return storage;\n   631\t}\n   632\t\n   633\tstd::partial_ordering JSON::operator<=>(JSON const& json) const\n   634\t{\n   635\t    if (index() != json.index()) {\n   636\t        return std::partial_ordering::unordered;\n   637\t    }\n   638\t    if (auto sv = std::get_if<std::string_view>(this)) {\n   639\t        return *sv <=> std::get<std::string_view>(json);\n   640\t    } else if (auto d = std::get_if<double>(this)) {\n   641\t        return *d <=> std::get<double>(json);\n   642\t    } else if (auto l = std::get_if<long>(this)) {\n   643\t        return *l <=> std::get<long>(json);\n   644\t    } else if (auto b = std::get_if<bool>(this)) {\n   645\t        return *b <=> std::get<bool>(json);\n   646\t    } else if (auto span = std::get_if<std::span<JSON>>(this)) {\n   647\t        auto &lhs = *span;\n   648\t        auto &rhs = std::get<std::span<JSON>>(json);\n   649\t        std::partial_ordering cmp = std::partial_ordering::equivalent;\n   650\t        for (size_t idx = 0; 0 == cmp && lhs.size() > idx; ++ idx) {\n   651\t            cmp = lhs[idx] <=> rhs[idx];\n   652\t        }\n   653\t        return cmp;\n   654\t    } else if (auto span = std::get_if<std::span<KeyJSONPair>>(this)) {\n   655\t        static thread_local std::map<KeyJSONPair::first_type,KeyJSONPair::second_type> lhs, rhs;\n   656\t        auto & rhs_ =std::get<std::span<KeyJSONPair>>(json);\n   657\t        lhs.clear(); lhs.insert(span->begin(), span->end());\n   658\t        rhs.clear(); rhs.insert(rhs_.begin(), rhs_.end());\n   659\t        if (lhs.size() != rhs.size()) {\n   660\t            return lhs.size() <=> rhs.size();\n   661\t        }\n   662\t        std::partial_ordering cmp = std::partial_ordering::equivalent;\n   663\t        for (auto lit = lhs.begin(), rit = rhs.begin(); lit != lhs.end() && rit != rhs.end(); ++ lit, ++ rit) {\n   664\t            auto & [lk, lv] = *lit;\n   665\t            auto & [rk, rv] = *rit;\n   666\t            cmp = lk <=> rk; if (cmp != 0) break;\n   667\t            cmp = lv <=> rv; if (cmp != 0) break;\n   668\t        }\n   669\t        return cmp;\n   670\t    } else {\n   671\t        return std::partial_ordering::equivalent;\n   672\t    }\n   673\t}\n   674\t\n   675\tJSON const& JSON::operator[](std::string_view key) const\n   676\t{\n   677\t    auto & span = std::get<std::span<KeyJSONPair>>(*this);\n   678\t    JSON * result = nullptr;\n   679\t    for (auto & [k, json] : span) {\n   680\t        if (k == key) {\n   681\t            if (result != nullptr) {\n   682\t                throw std::out_of_range(\"multiple entries\");\n   683\t            }\n   684\t            result = &json;\n   685\t        }\n   686\t    }\n   687\t    if (result == nullptr) {\n   688\t        throw std::out_of_range(\"not found\");\n   689\t    }\n   690\t    return *result;\n   691\t}\n   692\t\n   693\tJSON::Doc::Doc(JSON*root)\n   694\t: root_(root)\n   695\t{ }\n   696\t\n   697\tJSON::Doc::Doc(Doc&&doc)\n   698\t: root_(doc.root_)\n   699\t{\n   700\t    doc.root_ = nullptr;\n   701\t}\n   702\t\n   703\tJSON::Doc::~Doc()\n   704\t{\n   705\t    if (root_) {\n   706\t        ParseHandler::del(root_);\n   707\t    }\n   708\t}\n   709\t\n   710\t}\n\n```\n","ts":1.739155118122E9}
{"role":"assistant","content":"<think>\nOkay, I need to figure out what's causing the heap-use-after-free error in the provided code. Let me start by looking at the error message and the code.\n\nThe error occurs when accessing a JSON object's data after it's been freed. The stack trace shows the crash in the `JSON::object()` method, which retrieves the object span. So, the problem is likely that the JSON object's underlying data was already deallocated when it's accessed.\n\nLooking at the code in `json_boost.cpp`, the `ParseHandler` class manages memory using `boost::container::devector` for the `store` and `ptr_jsons`. The `store` is used to allocate memory for JSON data. When parsing, it seems that `store` is dynamically adjusted, and when a document is parsed, a `DocImpl` is created which tracks the allocated memory ranges in `store_start`, `store_end`, `ptrs_start`, and `ptrs_end`.\n\nIn the `del` method of `ParseHandler`, when a document is deleted, the code erases the corresponding sections from `store` and `ptr_jsons`. However, this might be causing issues if the JSON object is still being referenced after it's been deleted. The error's stack trace shows that `process_response_lines` in `openai.cpp` is accessing the JSON object after it's been freed. This suggests that the JSON object (probably part of a `Doc`) was destroyed, but the pointer is still being used.\n\nLooking at how `Doc` objects are managed: `JSON::Doc` is supposed to own the root JSON object. When `Doc` is destroyed, it calls `ParseHandler::del(root_)`, which deallocates the memory from `store` and `ptr_jsons`. However, if a `Doc` is moved (like in the move constructor) and the original `Doc` is destroyed, but perhaps the `DocImpl` references in `docs` aren't properly updated. Or if there's an issue with how the `store` memory is managed when multiple documents are parsed.\n\nAnother angle: The `JSON::encode` function uses a static thread-local `Serializer` and a static `storage` string. This might be problematic if multiple threads are involved or if `storage` gets overwritten while encoding. However, the error is about a use-after-free, which points more to memory management in `ParseHandler`.\n\nLet me look closer at how `DocImpl` handles its memory. When a document is parsed (`decode`), it's stored in `store`, and a `DocImpl` is created. The `decode` function returns a `Doc`, which is a wrapper owning the `root_` pointer. When the `Doc` is destroyed, `ParseHandler::del` is called, which deletes the associated memory. However, if a reference to the JSON data inside a `Doc` is kept after the `Doc` is destroyed, accessing it would lead to a use-after-free.","ts":1.739155238615E9}
{"role":"user","content":"The problem appears to relate to pointer adjustment code. The memory violation occurs prior to deletion of the first document, which is never moved after return. There is only one thread. Here's the header file to clarify the larger structure[3], but the problem is a logic error in the parsing, which happens all within the handler and the parser in one go. Here is the basic parser code if you need it [4].\n\n3: **../include/zinc/json.hpp**\n```\n#pragma once\n\n#include <span>\n#include <string_view>\n#include <variant>\n\nnamespace zinc {\nclass JSON;\nusing KeyJSONPair = std::pair<std::string_view, JSON>;\nusing _JSON_variant = std::variant<\n    std::nullptr_t,\n    bool, long, double, std::string_view,\n    std::span<JSON>, std::span<KeyJSONPair>\n>;\n\n/*\n * The lifetime of parsed JSON objects is managed by the\n * returned JSON::Doc object.  Keep the JSON::Doc object around\n * until the storage for the entire tree can be reused.\n */\nclass JSON : public _JSON_variant {\npublic:\n    using _JSON_variant::variant;\n\n    enum Index {\n        /*NULL = 0,*/\n        BOOLEAN = 1,\n        INTEGER = 2,\n        NUMBER = 3,\n        STRING = 4,\n        ARRAY = 5,\n        OBJECT = 6,\n    };\n\n    //std::string_view raw;\n\n    std::partial_ordering operator<=>(JSON const&json) const;\n    bool operator==(JSON const&json) const { return 0==(*this<=>json); }\n\n    JSON const& operator[](std::string_view key) const;\n\n    auto& string() const\n    { return std::get<std::string_view>(*this); }\n    auto& array() const\n    { return std::get<std::span<JSON>>(*this); }\n    auto& object() const\n    { return std::get<std::span<KeyJSONPair>>(*this); }\n\n    class Doc {\n    public:\n        // this could instead be a JSON object with a flag\n        // or a smart pointer (or both)\n        Doc(Doc&&);\n\n        JSON& operator*() { return *root_; }\n\n        ~Doc();\n\n    private:\n        friend class JSON;\n        Doc(JSON*);\n        JSON* root_;\n    };\n\n    static Doc decode(std::string_view doc);\n    std::string_view encode() const;\n};\n\n}\n\n```\n\n4: **/usr/include/boost/json/basic_parser_impl.hpp**\n```\n//\n// Copyright (c) 2019 Vinnie Falco (vinnie.falco@gmail.com)\n// Copyright (c) 2020 Krystian Stasiowski (sdkrystian@gmail.com)\n//\n// Distributed under the Boost Software License, Version 1.0. (See accompanying\n// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n//\n// Official repository: https://github.com/boostorg/json\n//\n\n#ifndef BOOST_JSON_BASIC_PARSER_IMPL_HPP\n#define BOOST_JSON_BASIC_PARSER_IMPL_HPP\n\n#include <boost/json/detail/config.hpp>\n#include <boost/json/basic_parser.hpp>\n#include <boost/json/error.hpp>\n#include <boost/json/detail/buffer.hpp>\n#include <boost/json/detail/sse2.hpp>\n#include <cmath>\n#include <limits>\n#include <cstring>\n\n#ifdef _MSC_VER\n#pragma warning(push)\n#pragma warning(disable: 4702) // unreachable code\n#pragma warning(disable: 4127) // conditional expression is constant\n#endif\n\n/*  This file must be manually included to get the\n    function template definitions for basic_parser.\n*/\n\n/*  Reference:\n\n    https://www.json.org/\n\n    RFC 7159: The JavaScript Object Notation (JSON) Data Interchange Format\n    https://tools.ietf.org/html/rfc7159\n\n    https://ampl.com/netlib/fp/dtoa.c\n*/\n\n#ifndef BOOST_JSON_DOCS\n\nBOOST_JSON_NS_BEGIN\nnamespace detail {\n\ninline\ndouble\npow10(int exp) noexcept\n{\n    static double const tab[618] = {\n                        1e-308, 1e-307, 1e-306, 1e-305, 1e-304, 1e-303, 1e-302, 1e-301,\n\n        1e-300, 1e-299, 1e-298, 1e-297, 1e-296, 1e-295, 1e-294, 1e-293, 1e-292, 1e-291,\n        1e-290, 1e-289, 1e-288, 1e-287, 1e-286, 1e-285, 1e-284, 1e-283, 1e-282, 1e-281,\n        1e-280, 1e-279, 1e-278, 1e-277, 1e-276, 1e-275, 1e-274, 1e-273, 1e-272, 1e-271,\n        1e-270, 1e-269, 1e-268, 1e-267, 1e-266, 1e-265, 1e-264, 1e-263, 1e-262, 1e-261,\n        1e-260, 1e-259, 1e-258, 1e-257, 1e-256, 1e-255, 1e-254, 1e-253, 1e-252, 1e-251,\n        1e-250, 1e-249, 1e-248, 1e-247, 1e-246, 1e-245, 1e-244, 1e-243, 1e-242, 1e-241,\n        1e-240, 1e-239, 1e-238, 1e-237, 1e-236, 1e-235, 1e-234, 1e-233, 1e-232, 1e-231,\n        1e-230, 1e-229, 1e-228, 1e-227, 1e-226, 1e-225, 1e-224, 1e-223, 1e-222, 1e-221,\n        1e-220, 1e-219, 1e-218, 1e-217, 1e-216, 1e-215, 1e-214, 1e-213, 1e-212, 1e-211,\n        1e-210, 1e-209, 1e-208, 1e-207, 1e-206, 1e-205, 1e-204, 1e-203, 1e-202, 1e-201,\n\n        1e-200, 1e-199, 1e-198, 1e-197, 1e-196, 1e-195, 1e-194, 1e-193, 1e-192, 1e-191,\n        1e-190, 1e-189, 1e-188, 1e-187, 1e-186, 1e-185, 1e-184, 1e-183, 1e-182, 1e-181,\n        1e-180, 1e-179, 1e-178, 1e-177, 1e-176, 1e-175, 1e-174, 1e-173, 1e-172, 1e-171,\n        1e-170, 1e-169, 1e-168, 1e-167, 1e-166, 1e-165, 1e-164, 1e-163, 1e-162, 1e-161,\n        1e-160, 1e-159, 1e-158, 1e-157, 1e-156, 1e-155, 1e-154, 1e-153, 1e-152, 1e-151,\n        1e-150, 1e-149, 1e-148, 1e-147, 1e-146, 1e-145, 1e-144, 1e-143, 1e-142, 1e-141,\n        1e-140, 1e-139, 1e-138, 1e-137, 1e-136, 1e-135, 1e-134, 1e-133, 1e-132, 1e-131,\n        1e-130, 1e-129, 1e-128, 1e-127, 1e-126, 1e-125, 1e-124, 1e-123, 1e-122, 1e-121,\n        1e-120, 1e-119, 1e-118, 1e-117, 1e-116, 1e-115, 1e-114, 1e-113, 1e-112, 1e-111,\n        1e-110, 1e-109, 1e-108, 1e-107, 1e-106, 1e-105, 1e-104, 1e-103, 1e-102, 1e-101,\n\n        1e-100, 1e-099, 1e-098, 1e-097, 1e-096, 1e-095, 1e-094, 1e-093, 1e-092, 1e-091,\n        1e-090, 1e-089, 1e-088, 1e-087, 1e-086, 1e-085, 1e-084, 1e-083, 1e-082, 1e-081,\n        1e-080, 1e-079, 1e-078, 1e-077, 1e-076, 1e-075, 1e-074, 1e-073, 1e-072, 1e-071,\n        1e-070, 1e-069, 1e-068, 1e-067, 1e-066, 1e-065, 1e-064, 1e-063, 1e-062, 1e-061,\n        1e-060, 1e-059, 1e-058, 1e-057, 1e-056, 1e-055, 1e-054, 1e-053, 1e-052, 1e-051,\n        1e-050, 1e-049, 1e-048, 1e-047, 1e-046, 1e-045, 1e-044, 1e-043, 1e-042, 1e-041,\n        1e-040, 1e-039, 1e-038, 1e-037, 1e-036, 1e-035, 1e-034, 1e-033, 1e-032, 1e-031,\n        1e-030, 1e-029, 1e-028, 1e-027, 1e-026, 1e-025, 1e-024, 1e-023, 1e-022, 1e-021,\n        1e-020, 1e-019, 1e-018, 1e-017, 1e-016, 1e-015, 1e-014, 1e-013, 1e-012, 1e-011,\n        1e-010, 1e-009, 1e-008, 1e-007, 1e-006, 1e-005, 1e-004, 1e-003, 1e-002, 1e-001,\n\n        1e+000, 1e+001, 1e+002, 1e+003, 1e+004, 1e+005, 1e+006, 1e+007, 1e+008, 1e+009,\n        1e+010, 1e+011, 1e+012, 1e+013, 1e+014, 1e+015, 1e+016, 1e+017, 1e+018, 1e+019,\n        1e+020, 1e+021, 1e+022, 1e+023, 1e+024, 1e+025, 1e+026, 1e+027, 1e+028, 1e+029,\n        1e+030, 1e+031, 1e+032, 1e+033, 1e+034, 1e+035, 1e+036, 1e+037, 1e+038, 1e+039,\n        1e+040, 1e+041, 1e+042, 1e+043, 1e+044, 1e+045, 1e+046, 1e+047, 1e+048, 1e+049,\n        1e+050, 1e+051, 1e+052, 1e+053, 1e+054, 1e+055, 1e+056, 1e+057, 1e+058, 1e+059,\n        1e+060, 1e+061, 1e+062, 1e+063, 1e+064, 1e+065, 1e+066, 1e+067, 1e+068, 1e+069,\n        1e+070, 1e+071, 1e+072, 1e+073, 1e+074, 1e+075, 1e+076, 1e+077, 1e+078, 1e+079,\n        1e+080, 1e+081, 1e+082, 1e+083, 1e+084, 1e+085, 1e+086, 1e+087, 1e+088, 1e+089,\n        1e+090, 1e+091, 1e+092, 1e+093, 1e+094, 1e+095, 1e+096, 1e+097, 1e+098, 1e+099,\n\n        1e+100, 1e+101, 1e+102, 1e+103, 1e+104, 1e+105, 1e+106, 1e+107, 1e+108, 1e+109,\n        1e+110, 1e+111, 1e+112, 1e+113, 1e+114, 1e+115, 1e+116, 1e+117, 1e+118, 1e+119,\n        1e+120, 1e+121, 1e+122, 1e+123, 1e+124, 1e+125, 1e+126, 1e+127, 1e+128, 1e+129,\n        1e+130, 1e+131, 1e+132, 1e+133, 1e+134, 1e+135, 1e+136, 1e+137, 1e+138, 1e+139,\n        1e+140, 1e+141, 1e+142, 1e+143, 1e+144, 1e+145, 1e+146, 1e+147, 1e+148, 1e+149,\n        1e+150, 1e+151, 1e+152, 1e+153, 1e+154, 1e+155, 1e+156, 1e+157, 1e+158, 1e+159,\n        1e+160, 1e+161, 1e+162, 1e+163, 1e+164, 1e+165, 1e+166, 1e+167, 1e+168, 1e+169,\n        1e+170, 1e+171, 1e+172, 1e+173, 1e+174, 1e+175, 1e+176, 1e+177, 1e+178, 1e+179,\n        1e+180, 1e+181, 1e+182, 1e+183, 1e+184, 1e+185, 1e+186, 1e+187, 1e+188, 1e+189,\n        1e+190, 1e+191, 1e+192, 1e+193, 1e+194, 1e+195, 1e+196, 1e+197, 1e+198, 1e+199,\n\n        1e+200, 1e+201, 1e+202, 1e+203, 1e+204, 1e+205, 1e+206, 1e+207, 1e+208, 1e+209,\n        1e+210, 1e+211, 1e+212, 1e+213, 1e+214, 1e+215, 1e+216, 1e+217, 1e+218, 1e+219,\n        1e+220, 1e+221, 1e+222, 1e+223, 1e+224, 1e+225, 1e+226, 1e+227, 1e+228, 1e+229,\n        1e+230, 1e+231, 1e+232, 1e+233, 1e+234, 1e+235, 1e+236, 1e+237, 1e+238, 1e+239,\n        1e+240, 1e+241, 1e+242, 1e+243, 1e+244, 1e+245, 1e+246, 1e+247, 1e+248, 1e+249,\n        1e+250, 1e+251, 1e+252, 1e+253, 1e+254, 1e+255, 1e+256, 1e+257, 1e+258, 1e+259,\n        1e+260, 1e+261, 1e+262, 1e+263, 1e+264, 1e+265, 1e+266, 1e+267, 1e+268, 1e+269,\n        1e+270, 1e+271, 1e+272, 1e+273, 1e+274, 1e+275, 1e+276, 1e+277, 1e+278, 1e+279,\n        1e+280, 1e+281, 1e+282, 1e+283, 1e+284, 1e+285, 1e+286, 1e+287, 1e+288, 1e+289,\n        1e+290, 1e+291, 1e+292, 1e+293, 1e+294, 1e+295, 1e+296, 1e+297, 1e+298, 1e+299,\n\n        1e+300, 1e+301, 1e+302, 1e+303, 1e+304, 1e+305, 1e+306, 1e+307, 1e+308 };\n\n    if( exp > 308 )\n    {\n        return std::numeric_limits<double>::infinity();\n    }\n    else if( exp < -308 )\n    {\n        // due to the way pow10 is used by dec_to_float,\n        // we can afford to return 0.0 here\n        return 0.0;\n    }\n    else\n    {\n        exp += 308;\n        BOOST_ASSERT(exp >= 0 && exp < 618);\n        return tab[exp];\n    }\n}\n\ninline\ndouble\ndec_to_float(\n    std::uint64_t m,\n    std::int32_t e,\n    bool neg) noexcept\n{\n    // convert to double explicitly to silence warnings\n    double x = static_cast<double>(m);\n    if(neg)\n        x = -x;\n\n    if(e < -305)\n    {\n        x *= 1e-305 ;\n        e += 305;\n    }\n\n    if(e >= -22 && e < 0)\n        return x / pow10(-e);\n\n    return x * pow10(e);\n}\n\ninline\nbool\nis_control(char c) noexcept\n{\n    return static_cast<unsigned char>(c) < 32;\n}\n\ninline\nint\nhex_digit(unsigned char c) noexcept\n{\n    // by Peter Dimov\n    if( c >= '0' && c <= '9' )\n        return c - '0';\n    c &= ~0x20;\n    if( c >= 'A' && c <= 'F' )\n        return 10 + c - 'A';\n    return -1;\n}\n\n} // detail\n\n//----------------------------------------------------------\n\ntemplate<class Handler>\nvoid\nbasic_parser<Handler>::\nreserve()\n{\n    if(BOOST_JSON_LIKELY(\n        ! st_.empty()))\n        return;\n    // Reserve the largest stack we need,\n    // to avoid reallocation during suspend.\n    st_.reserve(\n        sizeof(state) + // document parsing state\n        (sizeof(state) +\n            sizeof(std::size_t)) * depth() + // array and object state + size\n        sizeof(state) + // value parsing state\n        sizeof(std::size_t) + // string size\n        sizeof(state)); // comment state\n}\n\n//----------------------------------------------------------\n//\n// The sentinel value is returned by parse functions\n// to indicate that the parser failed, or suspended.\n// this is used as it is distinct from all valid values\n// for data in write\n\ntemplate<class Handler>\nconst char*\nbasic_parser<Handler>::\nsentinel()\n{\n    return reinterpret_cast<\n        const char*>(this);\n}\n\ntemplate<class Handler>\nbool\nbasic_parser<Handler>::\nincomplete(\n    const detail::const_stream_wrapper& cs)\n{\n    return cs.begin() == sentinel();\n}\n\n//----------------------------------------------------------\n//\n// These functions are declared with the BOOST_NOINLINE\n// attribute to avoid polluting the parsers hot-path.\n// They return the canary value to indicate suspension\n// or failure.\n\ntemplate<class Handler>\nconst char*\nbasic_parser<Handler>::\nsuspend_or_fail(state st)\n{\n    if(BOOST_JSON_LIKELY(\n        ! ec_ && more_))\n    {\n        // suspend\n        reserve();\n        st_.push_unchecked(st);\n    }\n    return sentinel();\n}\n\ntemplate<class Handler>\nconst char*\nbasic_parser<Handler>::\nsuspend_or_fail(\n    state st,\n    std::size_t n)\n{\n    if(BOOST_JSON_LIKELY(\n        ! ec_ && more_))\n    {\n        // suspend\n        reserve();\n        st_.push_unchecked(n);\n        st_.push_unchecked(st);\n    }\n    return sentinel();\n}\n\n\ntemplate<class Handler>\nconst char*\nbasic_parser<Handler>::\nfail(const char* p) noexcept\n{\n    end_ = p;\n    return sentinel();\n}\n\ntemplate<class Handler>\nconst char*\nbasic_parser<Handler>::\nfail(\n    const char* p,\n    error ev,\n    source_location const* loc) noexcept\n{\n    end_ = p;\n    ec_.assign(ev, loc);\n    return sentinel();\n}\n\ntemplate<class Handler>\nconst char*\nbasic_parser<Handler>::\nmaybe_suspend(\n    const char* p,\n    state st)\n{\n    end_ = p;\n    if(BOOST_JSON_LIKELY(more_))\n    {\n        // suspend\n        reserve();\n        st_.push_unchecked(st);\n    }\n    return sentinel();\n}\n\ntemplate<class Handler>\nconst char*\nbasic_parser<Handler>::\nmaybe_suspend(\n    const char* p,\n    state st,\n    std::size_t n)\n{\n    end_ = p;\n    if(BOOST_JSON_LIKELY(more_))\n    {\n        // suspend\n        reserve();\n        st_.push_unchecked(n);\n        st_.push_unchecked(st);\n    }\n    return sentinel();\n}\n\ntemplate<class Handler>\nconst char*\nbasic_parser<Handler>::\nmaybe_suspend(\n    const char* p,\n    state st,\n    const number& num)\n{\n    end_ = p;\n    if(BOOST_JSON_LIKELY(more_))\n    {\n        // suspend\n        num_ = num;\n        reserve();\n        st_.push_unchecked(st);;\n    }\n    return sentinel();\n}\n\ntemplate<class Handler>\nconst char*\nbasic_parser<Handler>::\nsuspend(\n    const char* p,\n    state st)\n{\n    end_ = p;\n    // suspend\n    reserve();\n    st_.push_unchecked(st);\n    return sentinel();\n}\n\ntemplate<class Handler>\nconst char*\nbasic_parser<Handler>::\nsuspend(\n    const char* p,\n    state st,\n    const number& num)\n{\n    end_ = p;\n    // suspend\n    num_ = num;\n    reserve();\n    st_.push_unchecked(st);\n    return sentinel();\n}\n\ntemplate<class Handler>\ntemplate<\n    bool StackEmpty_/*,\n    bool Terminal_*/>\nconst char*\nbasic_parser<Handler>::\nparse_comment(const char* p,\n    std::integral_constant<bool, StackEmpty_> stack_empty,\n    /*std::integral_constant<bool, Terminal_>*/ bool terminal)\n{\n    detail::const_stream_wrapper cs(p, end_);\n    const char* start = cs.begin();\n    std::size_t remain;\n    if(! stack_empty && ! st_.empty())\n    {\n        state st;\n        st_.pop(st);\n        switch(st)\n        {\n            default: BOOST_JSON_UNREACHABLE();\n            case state::com1: goto do_com1;\n            case state::com2: goto do_com2;\n            case state::com3: goto do_com3;\n            case state::com4: goto do_com4;\n        }\n    }\n    BOOST_ASSERT(*cs == '/');\n    ++cs;\ndo_com1:\n    if(BOOST_JSON_UNLIKELY(! cs))\n        return maybe_suspend(cs.begin(), state::com1);\n    switch(*cs)\n    {\n    default:\n        {\n            BOOST_STATIC_CONSTEXPR source_location loc\n                = BOOST_CURRENT_LOCATION;\n            return fail(cs.begin(), error::syntax, &loc);\n        }\n    case '/':\n        ++cs;\ndo_com2:\n        // KRYSTIAN TODO: this is a mess, we have to fix this\n        remain = cs.remain();\n        cs = remain ? static_cast<const char*>(\n            std::memchr(cs.begin(), '\\n', remain)) : sentinel();\n        if(! cs.begin())\n            cs = sentinel();\n        if(BOOST_JSON_UNLIKELY(incomplete(cs)))\n        {\n            // if the doc does not terminate\n            // with a newline, treat it as the\n            // end of the comment\n            if(terminal && ! more_)\n            {\n                if(BOOST_JSON_UNLIKELY(! h_.on_comment(\n                    {start, cs.remain(start)}, ec_)))\n                    return fail(cs.end());\n                return cs.end();\n            }\n            if(BOOST_JSON_UNLIKELY(! h_.on_comment_part(\n                {start, cs.remain(start)}, ec_)))\n                return fail(cs.end());\n            if(terminal)\n                return suspend(cs.end(), state::com2);\n            return maybe_suspend(cs.end(), state::com2);\n        }\n        break;\n    case '*':\n        do\n        {\n            ++cs;\ndo_com3:\n            // KRYSTIAN TODO: this is a mess, we have to fix this\n            remain = cs.remain();\n            cs = remain ? static_cast<const char*>(\n                std::memchr(cs.begin(), '*', remain)) : sentinel();\n            if(! cs.begin())\n                cs = sentinel();\n            // stopped inside a c comment\n            if(BOOST_JSON_UNLIKELY(incomplete(cs)))\n            {\n                if(BOOST_JSON_UNLIKELY(! h_.on_comment_part(\n                    {start, cs.remain(start)}, ec_)))\n                    return fail(cs.end());\n                return maybe_suspend(cs.end(), state::com3);\n            }\n            // found a asterisk, check if the next char is a slash\n            ++cs;\ndo_com4:\n            if(BOOST_JSON_UNLIKELY(! cs))\n            {\n                if(BOOST_JSON_UNLIKELY(! h_.on_comment_part(\n                    {start, cs.used(start)}, ec_)))\n                    return fail(cs.begin());\n                return maybe_suspend(cs.begin(), state::com4);\n            }\n        }\n        while(*cs != '/');\n    }\n    ++cs;\n    if(BOOST_JSON_UNLIKELY(! h_.on_comment(\n        {start, cs.used(start)}, ec_)))\n        return fail(cs.begin());\n    return cs.begin();\n}\n\ntemplate<class Handler>\ntemplate<bool StackEmpty_>\nconst char*\nbasic_parser<Handler>::\nparse_document(const char* p,\n    std::integral_constant<bool, StackEmpty_> stack_empty)\n{\n    detail::const_stream_wrapper cs(p, end_);\n    if(! stack_empty && ! st_.empty())\n    {\n        state st;\n        st_.pop(st);\n        switch(st)\n        {\n        default: BOOST_JSON_UNREACHABLE();\n        case state::doc1: goto do_doc1;\n        case state::doc2: goto do_doc2;\n        case state::doc3: goto do_doc3;\n        case state::doc4: goto do_doc4;\n        }\n    }\ndo_doc1:\n    cs = detail::count_whitespace(cs.begin(), cs.end());\n    if(BOOST_JSON_UNLIKELY(! cs))\n        return maybe_suspend(cs.begin(), state::doc1);\ndo_doc2:\n    switch(+opt_.allow_comments |\n        (opt_.allow_trailing_commas << 1) |\n        (opt_.allow_invalid_utf8 << 2))\n    {\n    // no extensions\n    default:\n        cs = parse_value(cs.begin(), stack_empty, std::false_type(), std::false_type(), std::false_type());\n        break;\n    // comments\n    case 1:\n        cs = parse_value(cs.begin(), stack_empty, std::true_type(), std::false_type(), std::false_type());\n        break;\n    // trailing\n    case 2:\n        cs = parse_value(cs.begin(), stack_empty, std::false_type(), std::true_type(), std::false_type());\n        break;\n    // comments & trailing\n    case 3:\n        cs = parse_value(cs.begin(), stack_empty, std::true_type(), std::true_type(), std::false_type());\n        break;\n    // skip validation\n    case 4:\n        cs = parse_value(cs.begin(), stack_empty, std::false_type(), std::false_type(), std::true_type());\n        break;\n    // comments & skip validation\n    case 5:\n        cs = parse_value(cs.begin(), stack_empty, std::true_type(), std::false_type(), std::true_type());\n        break;\n    // trailing & skip validation\n    case 6:\n        cs = parse_value(cs.begin(), stack_empty, std::false_type(), std::true_type(), std::true_type());\n        break;\n    // comments & trailing & skip validation\n    case 7:\n        cs = parse_value(cs.begin(), stack_empty, std::true_type(), std::true_type(), std::true_type());\n        break;\n    }\n    if(BOOST_JSON_UNLIKELY(incomplete(cs)))\n        return suspend_or_fail(state::doc2);\ndo_doc3:\n    cs = detail::count_whitespace(cs.begin(), cs.end());\n    if(BOOST_JSON_UNLIKELY(! cs))\n    {\n        if(more_)\n            return suspend(cs.begin(), state::doc3);\n    }\n    else if(opt_.allow_comments && *cs == '/')\n    {\ndo_doc4:\n        cs = parse_comment(cs.begin(), stack_empty, std::true_type());\n        if(BOOST_JSON_UNLIKELY(incomplete(cs)))\n            return suspend_or_fail(state::doc4);\n        goto do_doc3;\n    }\n    return cs.begin();\n}\n\ntemplate<class Handler>\ntemplate<\n    bool StackEmpty_,\n    bool AllowComments_/*,\n    bool AllowTrailing_,\n    bool AllowBadUTF8_*/>\nconst char*\nbasic_parser<Handler>::\nparse_value(const char* p,\n    std::integral_constant<bool, StackEmpty_> stack_empty,\n    std::integral_constant<bool, AllowComments_> allow_comments,\n    /*std::integral_constant<bool, AllowTrailing_>*/ bool allow_trailing,\n    /*std::integral_constant<bool, AllowBadUTF8_>*/ bool allow_bad_utf8)\n{\n    if(stack_empty || st_.empty())\n    {\nloop:\n        switch(*p)\n        {\n        case '0':\n            return parse_number(p, std::true_type(), std::integral_constant<char, '0'>());\n        case '-':\n            return parse_number(p, std::true_type(), std::integral_constant<char, '-'>());\n        case '1': case '2': case '3':\n        case '4': case '5': case '6':\n        case '7': case '8': case '9':\n            return parse_number(p, std::true_type(), std::integral_constant<char, '+'>());\n        case 't':\n            return parse_true(p, std::true_type());\n        case 'f':\n            return parse_false(p, std::true_type());\n        case 'n':\n            return parse_null(p, std::true_type());\n        case '\"':\n            return parse_unescaped(p, std::true_type(), std::false_type(), allow_bad_utf8);\n        case '[':\n            return parse_array(p, std::true_type(), allow_comments, allow_trailing, allow_bad_utf8);\n        case '{':\n            return parse_object(p, std::true_type(), allow_comments, allow_trailing, allow_bad_utf8);\n        case '/':\n            if(! allow_comments)\n            {\n                BOOST_STATIC_CONSTEXPR source_location loc\n                    = BOOST_CURRENT_LOCATION;\n                return fail(p, error::syntax, &loc);\n            }\n            p = parse_comment(p, stack_empty, std::false_type());\n            // KRYSTIAN NOTE: incomplete takes const_stream, we either\n            // can add an overload, change the existing one to take a pointer,\n            // or just leave it as is\n            if(BOOST_JSON_UNLIKELY(p == sentinel()))\n                return maybe_suspend(p, state::val2);\n            // intentional fallthrough\n        case ' ':\n        case '\\t':\n        case '\\n':\n        case '\\r':\n            p = detail::count_whitespace(p, end_);\n            if(BOOST_JSON_UNLIKELY(p == end_))\n                return maybe_suspend(p, state::val1);\n            goto loop;\n        default:\n            {\n                BOOST_STATIC_CONSTEXPR source_location loc\n                    = BOOST_CURRENT_LOCATION;\n                return fail(p, error::syntax, &loc);\n            }\n        }\n    }\n    return resume_value(p, stack_empty, allow_comments, allow_trailing, allow_bad_utf8);\n}\n\ntemplate<class Handler>\ntemplate<\n    bool StackEmpty_,\n    bool AllowComments_/*,\n    bool AllowTrailing_,\n    bool AllowBadUTF8_*/>\nconst char*\nbasic_parser<Handler>::\nresume_value(const char* p,\n    std::integral_constant<bool, StackEmpty_> stack_empty,\n    std::integral_constant<bool, AllowComments_> allow_comments,\n    /*std::integral_constant<bool, AllowTrailing_>*/ bool allow_trailing,\n    /*std::integral_constant<bool, AllowBadUTF8_>*/ bool allow_bad_utf8)\n{\n    state st;\n    st_.peek(st);\n    switch(st)\n    {\n    default: BOOST_JSON_UNREACHABLE();\n    case state::nul1: case state::nul2:\n    case state::nul3:\n        return parse_null(p, stack_empty);\n\n    case state::tru1: case state::tru2:\n    case state::tru3:\n        return parse_true(p, stack_empty);\n\n    case state::fal1: case state::fal2:\n    case state::fal3: case state::fal4:\n        return parse_false(p, stack_empty);\n\n    case state::str1:\n        return parse_unescaped(p, stack_empty, std::false_type(), allow_bad_utf8);\n\n    case state::str2: case state::str3:\n    case state::str4: case state::str5:\n    case state::str6: case state::str7:\n    case state::str8:\n    case state::sur1: case state::sur2:\n    case state::sur3: case state::sur4:\n    case state::sur5: case state::sur6:\n        return parse_escaped(p, 0, stack_empty, std::false_type(), allow_bad_utf8);\n\n    case state::arr1: case state::arr2:\n    case state::arr3: case state::arr4:\n    case state::arr5: case state::arr6:\n        return parse_array(p, stack_empty, allow_comments, allow_trailing, allow_bad_utf8);\n\n    case state::obj1: case state::obj2:\n    case state::obj3: case state::obj4:\n    case state::obj5: case state::obj6:\n    case state::obj7: case state::obj8:\n    case state::obj9: case state::obj10:\n    case state::obj11:\n        return parse_object(p, stack_empty, allow_comments, allow_trailing, allow_bad_utf8);\n\n    case state::num1: case state::num2:\n    case state::num3: case state::num4:\n    case state::num5: case state::num6:\n    case state::num7: case state::num8:\n    case state::exp1: case state::exp2:\n    case state::exp3:\n        return parse_number(p, stack_empty, std::integral_constant<char, 0>());\n\n    case state::com1: case state::com2:\n    case state::com3: case state::com4:\n        return parse_comment(p, stack_empty, std::false_type());\n\n    // KRYSTIAN NOTE: these are special cases\n    case state::val1:\n    {\n        st_.pop(st);\n        BOOST_ASSERT(st_.empty());\n        p = detail::count_whitespace(p, end_);\n        if(BOOST_JSON_UNLIKELY(p == end_))\n            return maybe_suspend(p, state::val1);\n        return parse_value(p, std::true_type(), allow_comments, allow_trailing, allow_bad_utf8);\n    }\n\n    case state::val2:\n    {\n        st_.pop(st);\n        p = parse_comment(p, stack_empty, std::false_type());\n        if(BOOST_JSON_UNLIKELY(p == sentinel()))\n            return maybe_suspend(p, state::val2);\n        BOOST_ASSERT(st_.empty());\n        return parse_value(p, std::true_type(), std::true_type(), allow_trailing, allow_bad_utf8);\n    }\n    }\n}\n\ntemplate<class Handler>\ntemplate<bool StackEmpty_>\nconst char*\nbasic_parser<Handler>::\nparse_null(const char* p,\n    std::integral_constant<bool, StackEmpty_> stack_empty)\n{\n    detail::const_stream_wrapper cs(p, end_);\n    if(stack_empty || st_.empty())\n    {\n        if(BOOST_JSON_LIKELY(cs.remain() >= 4))\n        {\n            if(BOOST_JSON_UNLIKELY(\n                std::memcmp(cs.begin(), \"null\", 4) != 0))\n            {\n                BOOST_STATIC_CONSTEXPR source_location loc\n                    = BOOST_CURRENT_LOCATION;\n                return fail(cs.begin(), error::syntax, &loc);\n            }\n            if(BOOST_JSON_UNLIKELY(\n                ! h_.on_null(ec_)))\n                return fail(cs.begin());\n            cs += 4;\n            return cs.begin();\n        }\n    }\n    else\n    {\n        state st;\n        st_.pop(st);\n        switch(st)\n        {\n        default: BOOST_JSON_UNREACHABLE();\n        case state::nul1: goto do_nul1;\n        case state::nul2: goto do_nul2;\n        case state::nul3: goto do_nul3;\n        }\n    }\n    ++cs;\ndo_nul1:\n    if(BOOST_JSON_UNLIKELY(! cs))\n        return maybe_suspend(cs.begin(), state::nul1);\n    if(BOOST_JSON_UNLIKELY(*cs != 'u'))\n    {\n        BOOST_STATIC_CONSTEXPR source_location loc = BOOST_CURRENT_LOCATION;\n        return fail(cs.begin(), error::syntax, &loc);\n    }\n    ++cs;\ndo_nul2:\n    if(BOOST_JSON_UNLIKELY(! cs))\n        return maybe_suspend(cs.begin(), state::nul2);\n    if(BOOST_JSON_UNLIKELY(*cs != 'l'))\n    {\n        BOOST_STATIC_CONSTEXPR source_location loc = BOOST_CURRENT_LOCATION;\n        return fail(cs.begin(), error::syntax, &loc);\n    }\n    ++cs;\ndo_nul3:\n    if(BOOST_JSON_UNLIKELY(! cs))\n        return maybe_suspend(cs.begin(), state::nul3);\n    if(BOOST_JSON_UNLIKELY(*cs != 'l'))\n    {\n        BOOST_STATIC_CONSTEXPR source_location loc = BOOST_CURRENT_LOCATION;\n        return fail(cs.begin(), error::syntax, &loc);\n    }\n    if(BOOST_JSON_UNLIKELY(\n        ! h_.on_null(ec_)))\n        return fail(cs.begin());\n    ++cs;\n    return cs.begin();\n}\n\ntemplate<class Handler>\ntemplate<bool StackEmpty_>\nconst char*\nbasic_parser<Handler>::\nparse_true(const char* p,\n    std::integral_constant<bool, StackEmpty_> stack_empty)\n{\n    detail::const_stream_wrapper cs(p, end_);\n    if(stack_empty || st_.empty())\n    {\n        if(BOOST_JSON_LIKELY(cs.remain() >= 4))\n        {\n            if(BOOST_JSON_UNLIKELY(\n                std::memcmp(cs.begin(), \"true\", 4) != 0))\n            {\n                BOOST_STATIC_CONSTEXPR source_location loc\n                    = BOOST_CURRENT_LOCATION;\n                return fail(cs.begin(), error::syntax, &loc);\n            }\n            if(BOOST_JSON_UNLIKELY(\n                ! h_.on_bool(true, ec_)))\n                return fail(cs.begin());\n            cs += 4;\n            return cs.begin();\n        }\n    }\n    else\n    {\n        state st;\n        st_.pop(st);\n        switch(st)\n        {\n        default: BOOST_JSON_UNREACHABLE();\n        case state::tru1: goto do_tru1;\n        case state::tru2: goto do_tru2;\n        case state::tru3: goto do_tru3;\n        }\n    }\n    ++cs;\ndo_tru1:\n    if(BOOST_JSON_UNLIKELY(! cs))\n        return maybe_suspend(cs.begin(), state::tru1);\n    if(BOOST_JSON_UNLIKELY(*cs != 'r'))\n    {\n        BOOST_STATIC_CONSTEXPR source_location loc = BOOST_CURRENT_LOCATION;\n        return fail(cs.begin(), error::syntax, &loc);\n    }\n    ++cs;\ndo_tru2:\n    if(BOOST_JSON_UNLIKELY(! cs))\n        return maybe_suspend(cs.begin(), state::tru2);\n    if(BOOST_JSON_UNLIKELY(*cs != 'u'))\n    {\n        BOOST_STATIC_CONSTEXPR source_location loc = BOOST_CURRENT_LOCATION;\n        return fail(cs.begin(), error::syntax, &loc);\n    }\n    ++cs;\ndo_tru3:\n    if(BOOST_JSON_UNLIKELY(! cs))\n        return maybe_suspend(cs.begin(), state::tru3);\n    if(BOOST_JSON_UNLIKELY(*cs != 'e'))\n    {\n        BOOST_STATIC_CONSTEXPR source_location loc = BOOST_CURRENT_LOCATION;\n        return fail(cs.begin(), error::syntax, &loc);\n    }\n    if(BOOST_JSON_UNLIKELY(\n        ! h_.on_bool(true, ec_)))\n        return fail(cs.begin());\n    ++cs;\n    return cs.begin();\n}\n\ntemplate<class Handler>\ntemplate<bool StackEmpty_>\nconst char*\nbasic_parser<Handler>::\nparse_false(const char* p,\n    std::integral_constant<bool, StackEmpty_> stack_empty)\n{\n    detail::const_stream_wrapper cs(p, end_);\n    if(stack_empty || st_.empty())\n    {\n        if(BOOST_JSON_LIKELY(cs.remain() >= 5))\n        {\n            if(BOOST_JSON_UNLIKELY(\n                std::memcmp(cs.begin() + 1, \"alse\", 4) != 0))\n            {\n                BOOST_STATIC_CONSTEXPR source_location loc\n                    = BOOST_CURRENT_LOCATION;\n                return fail(cs.begin(), error::syntax, &loc);\n            }\n            if(BOOST_JSON_UNLIKELY(\n                ! h_.on_bool(false, ec_)))\n                return fail(cs.begin());\n            cs += 5;\n            return cs.begin();\n        }\n    }\n    else\n    {\n        state st;\n        st_.pop(st);\n        switch(st)\n        {\n        default: BOOST_JSON_UNREACHABLE();\n        case state::fal1: goto do_fal1;\n        case state::fal2: goto do_fal2;\n        case state::fal3: goto do_fal3;\n        case state::fal4: goto do_fal4;\n        }\n    }\n    ++cs;\ndo_fal1:\n    if(BOOST_JSON_UNLIKELY(! cs))\n        return maybe_suspend(cs.begin(), state::fal1);\n    if(BOOST_JSON_UNLIKELY(*cs != 'a'))\n    {\n        BOOST_STATIC_CONSTEXPR source_location loc = BOOST_CURRENT_LOCATION;\n        return fail(cs.begin(), error::syntax, &loc);\n    }\n    ++cs;\ndo_fal2:\n    if(BOOST_JSON_UNLIKELY(! cs))\n        return maybe_suspend(cs.begin(), state::fal2);\n    if(BOOST_JSON_UNLIKELY(*cs != 'l'))\n    {\n        BOOST_STATIC_CONSTEXPR source_location loc = BOOST_CURRENT_LOCATION;\n        return fail(cs.begin(), error::syntax, &loc);\n    }\n    ++cs;\ndo_fal3:\n    if(BOOST_JSON_UNLIKELY(! cs))\n        return maybe_suspend(cs.begin(), state::fal3);\n    if(BOOST_JSON_UNLIKELY(*cs != 's'))\n    {\n        BOOST_STATIC_CONSTEXPR source_location loc = BOOST_CURRENT_LOCATION;\n        return fail(cs.begin(), error::syntax, &loc);\n    }\n    ++cs;\ndo_fal4:\n    if(BOOST_JSON_UNLIKELY(! cs))\n        return maybe_suspend(cs.begin(), state::fal4);\n    if(BOOST_JSON_UNLIKELY(*cs != 'e'))\n    {\n        BOOST_STATIC_CONSTEXPR source_location loc = BOOST_CURRENT_LOCATION;\n        return fail(cs.begin(), error::syntax, &loc);\n    }\n    if(BOOST_JSON_UNLIKELY(\n        ! h_.on_bool(false, ec_)))\n        return fail(cs.begin());\n    ++cs;\n    return cs.begin();\n}\n\n//----------------------------------------------------------\n\ntemplate<class Handler>\ntemplate<\n    bool StackEmpty_,\n    bool IsKey_/*,\n    bool AllowBadUTF8_*/>\nconst char*\nbasic_parser<Handler>::\nparse_string(const char* p,\n    std::integral_constant<bool, StackEmpty_> stack_empty,\n    std::integral_constant<bool, IsKey_> is_key,\n    /*std::integral_constant<bool, AllowBadUTF8_>*/ bool allow_bad_utf8)\n{\n    if(! stack_empty && ! st_.empty())\n    {\n        state st;\n        st_.peek(st);\n        switch(st)\n        {\n        default: BOOST_JSON_UNREACHABLE();\n        case state::str1:\n            return parse_unescaped(p, stack_empty, is_key, allow_bad_utf8);\n\n        case state::str2: case state::str3:\n        case state::str4: case state::str5:\n        case state::str6: case state::str7:\n        case state::str8:\n        case state::sur1: case state::sur2:\n        case state::sur3: case state::sur4:\n        case state::sur5: case state::sur6:\n            return parse_escaped(p, 0, stack_empty, is_key, allow_bad_utf8);\n        }\n    }\n\n    return parse_unescaped(p, std::true_type(), is_key, allow_bad_utf8);\n}\n\ntemplate<class Handler>\ntemplate<\n    bool StackEmpty_,\n    bool IsKey_/*,\n    bool AllowBadUTF8_*/>\nconst char*\nbasic_parser<Handler>::\nparse_unescaped(const char* p,\n    std::integral_constant<bool, StackEmpty_> stack_empty,\n    std::integral_constant<bool, IsKey_> is_key,\n    /*std::integral_constant<bool, AllowBadUTF8_>*/ bool allow_bad_utf8)\n{\n    detail::const_stream_wrapper cs(p, end_);\n    std::size_t total;\n    if(stack_empty || st_.empty())\n    {\n        BOOST_ASSERT(*cs == '\\x22'); // '\"'\n        ++cs;\n        total = 0;\n    }\n    else\n    {\n        state st;\n        st_.pop(st);\n        st_.pop(total);\n    }\n    char const* start = cs.begin();\n    cs = allow_bad_utf8?\n        detail::count_valid<true>(cs.begin(), cs.end()):\n        detail::count_valid<false>(cs.begin(), cs.end());\n    std::size_t size = cs.used(start);\n    if(is_key)\n    {\n        BOOST_ASSERT(total <= Handler::max_key_size);\n        if(BOOST_JSON_UNLIKELY(size >\n            Handler::max_key_size - total))\n        {\n            BOOST_STATIC_CONSTEXPR source_location loc\n                = BOOST_CURRENT_LOCATION;\n            return fail(cs.begin(), error::key_too_large, &loc);\n        }\n    }\n    else\n    {\n        BOOST_ASSERT(total <= Handler::max_string_size);\n        if(BOOST_JSON_UNLIKELY(size >\n            Handler::max_string_size - total))\n        {\n            BOOST_STATIC_CONSTEXPR source_location loc\n                = BOOST_CURRENT_LOCATION;\n            return fail(cs.begin(), error::string_too_large, &loc);\n        }\n    }\n    total += size;\n    if(BOOST_JSON_UNLIKELY(! cs))\n    {\n        // call handler if the string isn't empty\n        if(BOOST_JSON_LIKELY(size))\n        {\n            {\n                bool r = is_key?\n                    h_.on_key_part( {start, size}, total, ec_ ):\n                    h_.on_string_part( {start, size}, total, ec_ );\n\n                if(BOOST_JSON_UNLIKELY(!r))\n                {\n                    return fail(cs.begin());\n                }\n            }\n        }\n        return maybe_suspend(cs.begin(), state::str1, total);\n    }\n    // at this point all valid characters have been skipped, so any remaining\n    // if there are any more characters, they are either escaped, or incomplete\n    // utf8, or invalid utf8\n    if(BOOST_JSON_UNLIKELY(*cs != '\\x22')) // '\"'\n    {\n        // sequence is invalid or incomplete\n        if((*cs & 0x80) && !allow_bad_utf8)\n        {\n            seq_.save(cs.begin(), cs.remain());\n            if(BOOST_JSON_UNLIKELY(seq_.complete()))\n            {\n                BOOST_STATIC_CONSTEXPR source_location loc\n                    = BOOST_CURRENT_LOCATION;\n                return fail(cs.begin(), error::syntax, &loc);\n            }\n            if(BOOST_JSON_LIKELY(size))\n            {\n                {\n                    bool r = is_key?\n                        h_.on_key_part( {start, size}, total, ec_ ):\n                        h_.on_string_part( {start, size}, total, ec_ );\n\n                    if(BOOST_JSON_UNLIKELY(!r))\n                    {\n                        return fail(cs.begin());\n                    }\n                }\n            }\n            return maybe_suspend(cs.end(), state::str8, total);\n        }\n        else if(BOOST_JSON_LIKELY(*cs == '\\\\'))\n        {\n            // flush unescaped run from input\n            if(BOOST_JSON_LIKELY(size))\n            {\n                {\n                    bool r = is_key?\n                        h_.on_key_part( {start, size}, total, ec_ ):\n                        h_.on_string_part( {start, size}, total, ec_ );\n\n                    if(BOOST_JSON_UNLIKELY(!r))\n                    {\n                        return fail(cs.begin());\n                    }\n                }\n            }\n            return parse_escaped(cs.begin(), total, stack_empty, is_key, allow_bad_utf8);\n        }\n        // illegal control\n        BOOST_STATIC_CONSTEXPR source_location loc = BOOST_CURRENT_LOCATION;\n        return fail(cs.begin(), error::syntax, &loc);\n    }\n\n    {\n        bool r = is_key?\n            h_.on_key( {start, size}, total, ec_ ):\n            h_.on_string( {start, size}, total, ec_ );\n\n        if(BOOST_JSON_UNLIKELY(!r))\n        {\n            return fail(cs.begin());\n        }\n    }\n\n    ++cs;\n    return cs.begin();\n}\n\ntemplate<class Handler>\ntemplate<\n    bool StackEmpty_/*,\n    bool IsKey_,\n    bool AllowBadUTF8_*/>\nconst char*\nbasic_parser<Handler>::\nparse_escaped(\n    const char* p,\n    std::size_t total,\n    std::integral_constant<bool, StackEmpty_> stack_empty,\n    /*std::integral_constant<bool, IsKey_>*/ bool is_key,\n    /*std::integral_constant<bool, AllowBadUTF8_>*/ bool allow_bad_utf8)\n{\n    //---------------------------------------------------------------\n    //\n    // To handle escapes, a local temporary buffer accumulates\n    // the unescaped result. The algorithm attempts to fill the\n    // buffer to capacity before invoking the handler.\n    // In some cases the temporary buffer needs to be flushed\n    // before it is full:\n    // * When the closing double quote is seen\n    // * When there in no more input (and more is expected later)\n    // A goal of the algorithm is to call the handler as few times\n    // as possible. Thus, when the first escape is encountered,\n    // the algorithm attempts to fill the temporary buffer first.\n    //\n    auto const ev_too_large = is_key?\n        error::key_too_large : error::string_too_large;\n    auto const max_size = is_key?\n        Handler::max_key_size : Handler::max_string_size;\n    detail::clipped_const_stream cs(p, end_);\n    detail::buffer<BOOST_JSON_STACK_BUFFER_SIZE> temp;\n    int digit;\n    char c;\n    cs.clip(temp.max_size());\n    if(! stack_empty && ! st_.empty())\n    {\n        state st;\n        st_.pop(st);\n        st_.pop(total);\n        switch(st)\n        {\n        default: BOOST_JSON_UNREACHABLE();\n        case state::str2: goto do_str2;\n        case state::str3: goto do_str3;\n        case state::str4: goto do_str4;\n        case state::str5: goto do_str5;\n        case state::str6: goto do_str6;\n        case state::str7: goto do_str7;\n        case state::str8: goto do_str8;\n        case state::sur1: goto do_sur1;\n        case state::sur2: goto do_sur2;\n        case state::sur3: goto do_sur3;\n        case state::sur4: goto do_sur4;\n        case state::sur5: goto do_sur5;\n        case state::sur6: goto do_sur6;\n        }\n    }\n    // Unescaped JSON is never larger than its escaped version.\n    // To efficiently process only what will fit in the temporary buffer,\n    // the size of the input stream is temporarily \"clipped\" to the size\n    // of the temporary buffer.\n    // handle escaped character\n    BOOST_ASSERT(*cs == '\\\\');\n    ++cs;\ndo_str3:\n    if(BOOST_JSON_UNLIKELY(! cs))\n    {\n        if(BOOST_JSON_LIKELY(! temp.empty()))\n        {\n            BOOST_ASSERT(total <= max_size);\n            if(BOOST_JSON_UNLIKELY(\n                temp.size() > max_size - total))\n            {\n                BOOST_STATIC_CONSTEXPR source_location loc\n                    = BOOST_CURRENT_LOCATION;\n                return fail(cs.begin(), ev_too_large, &loc);\n            }\n            total += temp.size();\n            {\n                bool r = is_key\n                    ? h_.on_key_part(temp.get(), total, ec_)\n                    : h_.on_string_part(temp.get(), total, ec_);\n\n                if(BOOST_JSON_UNLIKELY(!r))\n                {\n                    return fail(cs.begin());\n                }\n            }\n            temp.clear();\n        }\n        cs.clip(temp.max_size());\n        if(BOOST_JSON_UNLIKELY(! cs))\n            return maybe_suspend(cs.begin(), state::str3, total);\n    }\n    switch(*cs)\n    {\n    default:\n        {\n            BOOST_STATIC_CONSTEXPR source_location loc\n                = BOOST_CURRENT_LOCATION;\n            return fail(cs.begin(), error::syntax, &loc);\n        }\n    case '\\x22': // '\"'\n        temp.push_back('\\x22');\n        ++cs;\n        break;\n    case '\\\\':\n        temp.push_back('\\\\');\n        ++cs;\n        break;\n    case '/':\n        temp.push_back('/');\n        ++cs;\n        break;\n    case 'b':\n        temp.push_back('\\x08');\n        ++cs;\n        break;\n    case 'f':\n        temp.push_back('\\x0c');\n        ++cs;\n        break;\n    case 'n':\n        temp.push_back('\\x0a');\n        ++cs;\n        break;\n    case 'r':\n        temp.push_back('\\x0d');\n        ++cs;\n        break;\n    case 't':\n        temp.push_back('\\x09');\n        ++cs;\n        break;\n    case 'u':\n        // utf16 escape\n        //\n        // fast path only when the buffer\n        // is large enough for 2 surrogates\n        if(BOOST_JSON_LIKELY(cs.remain() > 10))\n        {\n            // KRYSTIAN TODO: this could be done\n            // with fewer instructions\n            digit = detail::load_little_endian<4>(\n                cs.begin() + 1);\n            int d4 = detail::hex_digit(static_cast<\n                unsigned char>(digit >> 24));\n            int d3 = detail::hex_digit(static_cast<\n                unsigned char>(digit >> 16));\n            int d2 = detail::hex_digit(static_cast<\n                unsigned char>(digit >> 8));\n            int d1 = detail::hex_digit(static_cast<\n                unsigned char>(digit));\n            if(BOOST_JSON_UNLIKELY(\n                (d1 | d2 | d3 | d4) == -1))\n            {\n                if(d1 != -1)\n                    ++cs;\n                if(d2 != -1)\n                    ++cs;\n                if(d3 != -1)\n                    ++cs;\n                BOOST_STATIC_CONSTEXPR source_location loc\n                    = BOOST_CURRENT_LOCATION;\n                return fail(cs.begin(), error::expected_hex_digit, &loc);\n            }\n            // 32 bit unicode scalar value\n            unsigned const u1 =\n                (d1 << 12) + (d2 << 8) +\n                (d3 << 4) + d4;\n            // valid unicode scalar values are\n            // [0, D7FF] and [E000, 10FFFF]\n            // values within this range are valid utf-8\n            // code points and invalid leading surrogates.\n            if(BOOST_JSON_LIKELY(\n                u1 < 0xd800 || u1 > 0xdfff))\n            {\n                cs += 5;\n                temp.append_utf8(u1);\n                break;\n            }\n            if(BOOST_JSON_UNLIKELY(u1 > 0xdbff))\n            {\n                BOOST_STATIC_CONSTEXPR source_location loc\n                    = BOOST_CURRENT_LOCATION;\n                return fail(cs.begin(), error::illegal_leading_surrogate,\n                    &loc);\n            }\n            cs += 5;\n            // KRYSTIAN TODO: this can be a two byte load\n            // and a single comparison. We lose error information,\n            // but it's faster.\n            if(BOOST_JSON_UNLIKELY(*cs != '\\\\'))\n            {\n                BOOST_STATIC_CONSTEXPR source_location loc\n                    = BOOST_CURRENT_LOCATION;\n                return fail(cs.begin(), error::syntax, &loc);\n            }\n            ++cs;\n            if(BOOST_JSON_UNLIKELY(*cs != 'u'))\n            {\n                BOOST_STATIC_CONSTEXPR source_location loc\n                    = BOOST_CURRENT_LOCATION;\n                return fail(cs.begin(), error::syntax, &loc);\n            }\n            ++cs;\n            digit = detail::load_little_endian<4>(cs.begin());\n            d4 = detail::hex_digit(static_cast<\n                unsigned char>(digit >> 24));\n            d3 = detail::hex_digit(static_cast<\n                unsigned char>(digit >> 16));\n            d2 = detail::hex_digit(static_cast<\n                unsigned char>(digit >> 8));\n            d1 = detail::hex_digit(static_cast<\n                unsigned char>(digit));\n            if(BOOST_JSON_UNLIKELY(\n                (d1 | d2 | d3 | d4) == -1))\n            {\n                if(d1 != -1)\n                    ++cs;\n                if(d2 != -1)\n                    ++cs;\n                if(d3 != -1)\n                    ++cs;\n                BOOST_STATIC_CONSTEXPR source_location loc\n                    = BOOST_CURRENT_LOCATION;\n                return fail(cs.begin(), error::expected_hex_digit, &loc);\n            }\n            unsigned const u2 =\n                (d1 << 12) + (d2 << 8) +\n                (d3 << 4) + d4;\n            // valid trailing surrogates are [DC00, DFFF]\n            if(BOOST_JSON_UNLIKELY(\n                u2 < 0xdc00 || u2 > 0xdfff))\n            {\n                BOOST_STATIC_CONSTEXPR source_location loc\n                    = BOOST_CURRENT_LOCATION;\n                return fail(cs.begin(), error::illegal_trailing_surrogate,\n                    &loc);\n            }\n            cs += 4;\n            unsigned cp =\n                ((u1 - 0xd800) << 10) +\n                ((u2 - 0xdc00)) +\n                    0x10000;\n            // utf-16 surrogate pair\n            temp.append_utf8(cp);\n            break;\n        }\n        // flush\n        if(BOOST_JSON_LIKELY(! temp.empty()))\n        {\n            BOOST_ASSERT(total <= max_size);\n            if(BOOST_JSON_UNLIKELY(\n                temp.size() > max_size - total))\n            {\n                BOOST_STATIC_CONSTEXPR source_location loc\n                    = BOOST_CURRENT_LOCATION;\n                return fail(cs.begin(), ev_too_large, &loc);\n            }\n            total += temp.size();\n            {\n                bool r = is_key\n                    ? h_.on_key_part(temp.get(), total, ec_)\n                    : h_.on_string_part(temp.get(), total, ec_);\n\n                if(BOOST_JSON_UNLIKELY(!r))\n                {\n                    return fail(cs.begin());\n                }\n            }\n            temp.clear();\n            cs.clip(temp.max_size());\n        }\n        ++cs;\n        // utf-16 escape\ndo_str4:\n        if(BOOST_JSON_UNLIKELY(! cs))\n            return maybe_suspend(cs.begin(), state::str4, total);\n        digit = detail::hex_digit(*cs);\n        if(BOOST_JSON_UNLIKELY(digit == -1))\n        {\n            BOOST_STATIC_CONSTEXPR source_location loc\n                = BOOST_CURRENT_LOCATION;\n            return fail(cs.begin(), error::expected_hex_digit, &loc);\n        }\n        ++cs;\n        u1_ = digit << 12;\ndo_str5:\n        if(BOOST_JSON_UNLIKELY(! cs))\n            return maybe_suspend(cs.begin(), state::str5, total);\n        digit = detail::hex_digit(*cs);\n        if(BOOST_JSON_UNLIKELY(digit == -1))\n        {\n            BOOST_STATIC_CONSTEXPR source_location loc\n                = BOOST_CURRENT_LOCATION;\n            return fail(cs.begin(), error::expected_hex_digit, &loc);\n        }\n        ++cs;\n        u1_ += digit << 8;\ndo_str6:\n        if(BOOST_JSON_UNLIKELY(! cs))\n            return maybe_suspend(cs.begin(), state::str6, total);\n        digit = detail::hex_digit(*cs);\n        if(BOOST_JSON_UNLIKELY(digit == -1))\n        {\n            BOOST_STATIC_CONSTEXPR source_location loc\n                = BOOST_CURRENT_LOCATION;\n            return fail(cs.begin(), error::expected_hex_digit, &loc);\n        }\n        ++cs;\n        u1_ += digit << 4;\ndo_str7:\n        if(BOOST_JSON_UNLIKELY(! cs))\n            return maybe_suspend(cs.begin(), state::str7, total);\n        digit = detail::hex_digit(*cs);\n        if(BOOST_JSON_UNLIKELY(digit == -1))\n        {\n            BOOST_STATIC_CONSTEXPR source_location loc\n                = BOOST_CURRENT_LOCATION;\n            return fail(cs.begin(), error::expected_hex_digit, &loc);\n        }\n        ++cs;\n        u1_ += digit;\n        if(BOOST_JSON_LIKELY(\n            u1_ < 0xd800 || u1_ > 0xdfff))\n        {\n            BOOST_ASSERT(temp.empty());\n            // utf-8 codepoint\n            temp.append_utf8(u1_);\n            break;\n        }\n        if(BOOST_JSON_UNLIKELY(u1_ > 0xdbff))\n        {\n            BOOST_STATIC_CONSTEXPR source_location loc\n                = BOOST_CURRENT_LOCATION;\n            return fail(cs.begin(), error::illegal_trailing_surrogate, &loc);\n        }\ndo_sur1:\n        if(BOOST_JSON_UNLIKELY(! cs))\n            return maybe_suspend(cs.begin(), state::sur1, total);\n        if(BOOST_JSON_UNLIKELY(*cs != '\\\\'))\n        {\n            BOOST_STATIC_CONSTEXPR source_location loc\n                = BOOST_CURRENT_LOCATION;\n            return fail(cs.begin(), error::syntax, &loc);\n        }\n        ++cs;\ndo_sur2:\n        if(BOOST_JSON_UNLIKELY(! cs))\n            return maybe_suspend(cs.begin(), state::sur2, total);\n        if(BOOST_JSON_UNLIKELY(*cs != 'u'))\n        {\n            BOOST_STATIC_CONSTEXPR source_location loc\n                = BOOST_CURRENT_LOCATION;\n            return fail(cs.begin(), error::syntax, &loc);\n        }\n        ++cs;\ndo_sur3:\n        if(BOOST_JSON_UNLIKELY(! cs))\n            return maybe_suspend(cs.begin(), state::sur3, total);\n        digit = detail::hex_digit(*cs);\n        if(BOOST_JSON_UNLIKELY(digit == -1))\n        {\n            BOOST_STATIC_CONSTEXPR source_location loc\n                = BOOST_CURRENT_LOCATION;\n            return fail(cs.begin(), error::expected_hex_digit, &loc);\n        }\n        ++cs;\n        u2_ = digit << 12;\ndo_sur4:\n        if(BOOST_JSON_UNLIKELY(! cs))\n            return maybe_suspend(cs.begin(), state::sur4, total);\n        digit = detail::hex_digit(*cs);\n        if(BOOST_JSON_UNLIKELY(digit == -1))\n        {\n            BOOST_STATIC_CONSTEXPR source_location loc\n                = BOOST_CURRENT_LOCATION;\n            return fail(cs.begin(), error::expected_hex_digit, &loc);\n        }\n        ++cs;\n        u2_ += digit << 8;\ndo_sur5:\n        if(BOOST_JSON_UNLIKELY(! cs))\n            return maybe_suspend(cs.begin(), state::sur5, total);\n        digit = detail::hex_digit(*cs);\n        if(BOOST_JSON_UNLIKELY(digit == -1))\n        {\n            BOOST_STATIC_CONSTEXPR source_location loc\n                = BOOST_CURRENT_LOCATION;\n            return fail(cs.begin(), error::expected_hex_digit, &loc);\n        }\n        ++cs;\n        u2_ += digit << 4;\ndo_sur6:\n        if(BOOST_JSON_UNLIKELY(! cs))\n            return maybe_suspend(cs.begin(), state::sur6, total);\n        digit = detail::hex_digit(*cs);\n        if(BOOST_JSON_UNLIKELY(digit == -1))\n        {\n            BOOST_STATIC_CONSTEXPR source_location loc\n                = BOOST_CURRENT_LOCATION;\n            return fail(cs.begin(), error::expected_hex_digit, &loc);\n        }\n        ++cs;\n        u2_ += digit;\n        if(BOOST_JSON_UNLIKELY(\n            u2_ < 0xdc00 || u2_ > 0xdfff))\n        {\n            BOOST_STATIC_CONSTEXPR source_location loc\n                = BOOST_CURRENT_LOCATION;\n            return fail(cs.begin(), error::expected_hex_digit, &loc);\n        }\n        unsigned cp =\n            ((u1_ - 0xd800) << 10) +\n            ((u2_ - 0xdc00)) +\n                0x10000;\n        BOOST_ASSERT(temp.empty());\n        // utf-16 surrogate pair\n        temp.append_utf8(cp);\n    }\ndo_str2:\n    // KRYSTIAN TODO: we can append the characters\n    // all at once instead of one at a time\n    for(;;)\n    {\n        if(BOOST_JSON_UNLIKELY(! cs))\n        {\n            // flush\n            if(BOOST_JSON_LIKELY(! temp.empty()))\n            {\n                BOOST_ASSERT(total <= max_size);\n                if(BOOST_JSON_UNLIKELY(\n                    temp.size() > max_size - total))\n                {\n                    BOOST_STATIC_CONSTEXPR source_location loc\n                        = BOOST_CURRENT_LOCATION;\n                    return fail(cs.begin(), ev_too_large, &loc);\n                }\n                total += temp.size();\n                {\n                    bool r = is_key\n                        ? h_.on_key_part(temp.get(), total, ec_)\n                        : h_.on_string_part(temp.get(), total, ec_);\n\n                    if(BOOST_JSON_UNLIKELY(!r))\n                    {\n                        return fail(cs.begin());\n                    }\n                }\n                temp.clear();\n            }\n            cs.clip(temp.max_size());\n            if(BOOST_JSON_UNLIKELY(! cs))\n                return maybe_suspend(cs.begin(), state::str2, total);\n        }\n        c = *cs;\n        if(BOOST_JSON_LIKELY(c == '\\x22')) // '\"'\n        {\n            BOOST_ASSERT(total <= max_size);\n            if(BOOST_JSON_UNLIKELY(\n                temp.size() > max_size - total))\n            {\n                BOOST_STATIC_CONSTEXPR source_location loc\n                    = BOOST_CURRENT_LOCATION;\n                return fail(cs.begin(), ev_too_large, &loc);\n            }\n            total += temp.size();\n            {\n                bool r = is_key\n                    ? h_.on_key(temp.get(), total, ec_)\n                    : h_.on_string(temp.get(), total, ec_);\n\n                if(BOOST_JSON_UNLIKELY(!r))\n                {\n                    return fail(cs.begin());\n                }\n            }\n            ++cs;\n            return cs.begin();\n        }\n        else if((c & 0x80) && !allow_bad_utf8)\n        {\n            seq_.save(cs.begin(), cs.remain());\n            if(BOOST_JSON_UNLIKELY(! seq_.complete()))\n            {\n                if(BOOST_JSON_LIKELY(! temp.empty()))\n                {\n                    BOOST_ASSERT(total <= max_size);\n                    if(BOOST_JSON_UNLIKELY(\n                        temp.size() > max_size - total))\n                    {\n                        BOOST_STATIC_CONSTEXPR source_location loc\n                            = BOOST_CURRENT_LOCATION;\n                        return fail(cs.begin(), ev_too_large, &loc);\n                    }\n                    total += temp.size();\n                    {\n                        bool r = is_key\n                            ? h_.on_key_part(temp.get(), total, ec_)\n                            : h_.on_string_part(temp.get(), total, ec_);\n\n                        if(BOOST_JSON_UNLIKELY(!r))\n                        {\n                            return fail(cs.begin());\n                        }\n                    }\n                    temp.clear();\n                }\n                cs = cs.end();\n                // ensure there is room for the saved byte sequence\n                cs.clip(temp.max_size() - seq_.length());\n                goto do_str8;\n            }\n            if(BOOST_JSON_UNLIKELY(! seq_.valid()))\n            {\n                BOOST_STATIC_CONSTEXPR source_location loc\n                    = BOOST_CURRENT_LOCATION;\n                return fail(cs.begin(), error::syntax, &loc);\n            }\n            temp.append(seq_.data(), seq_.length());\n            cs += seq_.length();\n            continue;\n        }\n        else if(BOOST_JSON_LIKELY(c == '\\\\'))\n        {\n            ++cs;\n            goto do_str3;\n        }\n        else if(BOOST_JSON_UNLIKELY(\n            detail::is_control(c)))\n        {\n            BOOST_STATIC_CONSTEXPR source_location loc\n                = BOOST_CURRENT_LOCATION;\n            return fail(cs.begin(), error::syntax, &loc);\n        }\n        temp.push_back(c);\n        ++cs;\n    }\ndo_str8:\n    uint8_t needed = seq_.needed();\n    if(BOOST_JSON_UNLIKELY(\n        ! seq_.append(cs.begin(), cs.remain())))\n        return maybe_suspend(cs.end(), state::str8, total);\n    if(BOOST_JSON_UNLIKELY(! seq_.valid()))\n    {\n        BOOST_STATIC_CONSTEXPR source_location loc = BOOST_CURRENT_LOCATION;\n        return fail(cs.begin(), error::syntax, &loc);\n    }\n    temp.append(seq_.data(), seq_.length());\n    cs += needed;\n    goto do_str2;\n}\n\n//----------------------------------------------------------\n\ntemplate<class Handler>\ntemplate<\n    bool StackEmpty_,\n    bool AllowComments_/*,\n    bool AllowTrailing_,\n    bool AllowBadUTF8_*/>\nconst char*\nbasic_parser<Handler>::\nparse_object(const char* p,\n    std::integral_constant<bool, StackEmpty_> stack_empty,\n    std::integral_constant<bool, AllowComments_> allow_comments,\n    /*std::integral_constant<bool, AllowTrailing_>*/ bool allow_trailing,\n    /*std::integral_constant<bool, AllowBadUTF8_>*/ bool allow_bad_utf8)\n{\n    detail::const_stream_wrapper cs(p, end_);\n    std::size_t size;\n    if(! stack_empty && ! st_.empty())\n    {\n        // resume\n        state st;\n        st_.pop(st);\n        st_.pop(size);\n        switch(st)\n        {\n        default: BOOST_JSON_UNREACHABLE();\n        case state::obj1: goto do_obj1;\n        case state::obj2: goto do_obj2;\n        case state::obj3: goto do_obj3;\n        case state::obj4: goto do_obj4;\n        case state::obj5: goto do_obj5;\n        case state::obj6: goto do_obj6;\n        case state::obj7: goto do_obj7;\n        case state::obj8: goto do_obj8;\n        case state::obj9: goto do_obj9;\n        case state::obj10: goto do_obj10;\n        case state::obj11: goto do_obj11;\n        }\n    }\n    BOOST_ASSERT(*cs == '{');\n    size = 0;\n    if(BOOST_JSON_UNLIKELY(! depth_))\n    {\n        BOOST_STATIC_CONSTEXPR source_location loc = BOOST_CURRENT_LOCATION;\n        return fail(cs.begin(), error::too_deep, &loc);\n    }\n    --depth_;\n    if(BOOST_JSON_UNLIKELY(\n        ! h_.on_object_begin(ec_)))\n        return fail(cs.begin());\n    ++cs;\n    // object:\n    //     '{' *ws '}'\n    //     '{' *ws string *ws ':' *ws value *ws *[ ',' *ws string *ws ':' *ws value *ws ] '}'\ndo_obj1:\n    cs = detail::count_whitespace(cs.begin(), cs.end());\n    if(BOOST_JSON_UNLIKELY(! cs))\n        return maybe_suspend(cs.begin(), state::obj1, size);\n    if(BOOST_JSON_LIKELY(*cs != '}'))\n    {\n        if(BOOST_JSON_UNLIKELY(*cs != '\\x22'))\n        {\n            if(allow_comments && *cs == '/')\n            {\ndo_obj2:\n                cs = parse_comment(cs.begin(), stack_empty, std::false_type());\n                if(BOOST_JSON_UNLIKELY(incomplete(cs)))\n                    return suspend_or_fail(state::obj2, size);\n                goto do_obj1;\n            }\n            BOOST_STATIC_CONSTEXPR source_location loc\n                = BOOST_CURRENT_LOCATION;\n            return fail(cs.begin(), error::syntax, &loc);\n        }\nloop:\n        if(BOOST_JSON_UNLIKELY(++size >\n            Handler::max_object_size))\n        {\n            BOOST_STATIC_CONSTEXPR source_location loc\n                = BOOST_CURRENT_LOCATION;\n            return fail(cs.begin(), error::object_too_large, &loc);\n        }\ndo_obj3:\n        cs = parse_string(cs.begin(), stack_empty, std::true_type(), allow_bad_utf8);\n        if(BOOST_JSON_UNLIKELY(incomplete(cs)))\n            return suspend_or_fail(state::obj3, size);\ndo_obj4:\n        cs = detail::count_whitespace(cs.begin(), cs.end());\n        if(BOOST_JSON_UNLIKELY(! cs))\n            return maybe_suspend(cs.begin(), state::obj4, size);\n        if(BOOST_JSON_UNLIKELY(*cs != ':'))\n        {\n            if(allow_comments && *cs == '/')\n            {\ndo_obj5:\n                cs = parse_comment(cs.begin(), stack_empty, std::false_type());\n                if(BOOST_JSON_UNLIKELY(incomplete(cs)))\n                    return suspend_or_fail(state::obj5, size);\n                goto do_obj4;\n            }\n            BOOST_STATIC_CONSTEXPR source_location loc\n                = BOOST_CURRENT_LOCATION;\n            return fail(cs.begin(), error::syntax, &loc);\n        }\n        ++cs;\ndo_obj6:\n        cs = detail::count_whitespace(cs.begin(), cs.end());\n        if(BOOST_JSON_UNLIKELY(! cs))\n            return maybe_suspend(cs.begin(), state::obj6, size);\ndo_obj7:\n        cs = parse_value(cs.begin(), stack_empty, allow_comments, allow_trailing, allow_bad_utf8);\n        if(BOOST_JSON_UNLIKELY(incomplete(cs)))\n            return suspend_or_fail(state::obj7, size);\ndo_obj8:\n        cs = detail::count_whitespace(cs.begin(), cs.end());\n        if(BOOST_JSON_UNLIKELY(! cs))\n            return maybe_suspend(cs.begin(), state::obj8, size);\n        if(BOOST_JSON_LIKELY(*cs == ','))\n        {\n            ++cs;\ndo_obj9:\n            cs = detail::count_whitespace(cs.begin(), cs.end());\n            if(BOOST_JSON_UNLIKELY(! cs))\n                return maybe_suspend(cs.begin(), state::obj9, size);\n\n            // loop for next element\n            if(BOOST_JSON_LIKELY(*cs == '\\x22'))\n                goto loop;\n            if(! allow_trailing || *cs != '}')\n            {\n                if(allow_comments && *cs == '/')\n                {\ndo_obj10:\n                    cs = parse_comment(cs.begin(), stack_empty, std::false_type());\n                    if(BOOST_JSON_UNLIKELY(incomplete(cs)))\n                        return suspend_or_fail(state::obj10, size);\n                    goto do_obj9;\n                }\n                BOOST_STATIC_CONSTEXPR source_location loc\n                    = BOOST_CURRENT_LOCATION;\n                return fail(cs.begin(), error::syntax, &loc);\n            }\n        }\n        else if(BOOST_JSON_UNLIKELY(*cs != '}'))\n        {\n            if(allow_comments && *cs == '/')\n            {\ndo_obj11:\n                cs = parse_comment(cs.begin(), stack_empty, std::false_type());\n                if(BOOST_JSON_UNLIKELY(incomplete(cs)))\n                    return suspend_or_fail(state::obj11, size);\n                goto do_obj8;\n            }\n            BOOST_STATIC_CONSTEXPR source_location loc\n                = BOOST_CURRENT_LOCATION;\n            return fail(cs.begin(), error::syntax, &loc);\n        }\n        // got closing brace, fall through\n    }\n    if(BOOST_JSON_UNLIKELY(\n        ! h_.on_object_end(size, ec_)))\n        return fail(cs.begin());\n    ++depth_;\n    ++cs;\n    return cs.begin();\n}\n\n//----------------------------------------------------------\n\ntemplate<class Handler>\ntemplate<\n    bool StackEmpty_,\n    bool AllowComments_/*,\n    bool AllowTrailing_,\n    bool AllowBadUTF8_*/>\nconst char*\nbasic_parser<Handler>::\nparse_array(const char* p,\n    std::integral_constant<bool, StackEmpty_> stack_empty,\n    std::integral_constant<bool, AllowComments_> allow_comments,\n    /*std::integral_constant<bool, AllowTrailing_>*/ bool allow_trailing,\n    /*std::integral_constant<bool, AllowBadUTF8_>*/ bool allow_bad_utf8)\n{\n    detail::const_stream_wrapper cs(p, end_);\n    std::size_t size;\n    if(! stack_empty && ! st_.empty())\n    {\n        // resume\n        state st;\n        st_.pop(st);\n        st_.pop(size);\n        switch(st)\n        {\n        default: BOOST_JSON_UNREACHABLE();\n        case state::arr1: goto do_arr1;\n        case state::arr2: goto do_arr2;\n        case state::arr3: goto do_arr3;\n        case state::arr4: goto do_arr4;\n        case state::arr5: goto do_arr5;\n        case state::arr6: goto do_arr6;\n        }\n    }\n    BOOST_ASSERT(*cs == '[');\n    size = 0;\n    if(BOOST_JSON_UNLIKELY(! depth_))\n    {\n        BOOST_STATIC_CONSTEXPR source_location loc = BOOST_CURRENT_LOCATION;\n        return fail(cs.begin(), error::too_deep, &loc);\n    }\n    --depth_;\n    if(BOOST_JSON_UNLIKELY(\n        ! h_.on_array_begin(ec_)))\n        return fail(cs.begin());\n    ++cs;\n    // array:\n    //     '[' *ws ']'\n    //     '[' *ws value *ws *[ ',' *ws value *ws ] ']'\ndo_arr1:\n    cs = detail::count_whitespace(cs.begin(), cs.end());\n    if(BOOST_JSON_UNLIKELY(! cs))\n        return maybe_suspend(cs.begin(), state::arr1, size);\n    if(BOOST_JSON_LIKELY(*cs != ']'))\n    {\nloop:\n        if(allow_comments && *cs == '/')\n        {\ndo_arr2:\n            cs = parse_comment(cs.begin(), stack_empty, std::false_type());\n            if(BOOST_JSON_UNLIKELY(incomplete(cs)))\n                return suspend_or_fail(state::arr2, size);\n            goto do_arr1;\n        }\n        if(BOOST_JSON_UNLIKELY(++size >\n            Handler::max_array_size))\n        {\n            BOOST_STATIC_CONSTEXPR source_location loc\n                = BOOST_CURRENT_LOCATION;\n            return fail(cs.begin(), error::array_too_large, &loc);\n        }\ndo_arr3:\n        // array is not empty, value required\n        cs = parse_value(cs.begin(), stack_empty, allow_comments, allow_trailing, allow_bad_utf8);\n        if(BOOST_JSON_UNLIKELY(incomplete(cs)))\n            return suspend_or_fail(state::arr3, size);\ndo_arr4:\n        cs = detail::count_whitespace(cs.begin(), cs.end());\n        if(BOOST_JSON_UNLIKELY(! cs))\n            return maybe_suspend(cs.begin(), state::arr4, size);\n        if(BOOST_JSON_LIKELY(*cs == ','))\n        {\n            ++cs;\ndo_arr5:\n            cs = detail::count_whitespace(cs.begin(), cs.end());\n            if(BOOST_JSON_UNLIKELY(! cs))\n                return maybe_suspend(cs.begin(), state::arr5, size);\n            // loop for next element\n            if(! allow_trailing || *cs != ']')\n                goto loop;\n        }\n        else if(BOOST_JSON_UNLIKELY(*cs != ']'))\n        {\n            if(allow_comments && *cs == '/')\n            {\ndo_arr6:\n                cs = parse_comment(cs.begin(), stack_empty, std::false_type());\n                if(BOOST_JSON_UNLIKELY(incomplete(cs)))\n                    return suspend_or_fail(state::arr6, size);\n                goto do_arr4;\n            }\n            BOOST_STATIC_CONSTEXPR source_location loc\n                = BOOST_CURRENT_LOCATION;\n            return fail(cs.begin(), error::syntax, &loc);\n        }\n        // got closing bracket; fall through\n    }\n    if(BOOST_JSON_UNLIKELY(\n        ! h_.on_array_end(size, ec_)))\n        return fail(cs.begin());\n    ++depth_;\n    ++cs;\n    return cs.begin();\n}\n\n//----------------------------------------------------------\n\ntemplate<class Handler>\ntemplate<bool StackEmpty_, char First_>\nconst char*\nbasic_parser<Handler>::\nparse_number(const char* p,\n    std::integral_constant<bool, StackEmpty_> stack_empty,\n    std::integral_constant<char, First_> first)\n{\n    // only one of these will be true if we are not resuming\n    // if negative then !zero_first && !nonzero_first\n    // if zero_first then !nonzero_first && !negative\n    // if nonzero_first then !zero_first && !negative\n    bool const negative = first == '-';\n    bool const zero_first = first == '0';\n    bool const nonzero_first = first == '+';\n    detail::const_stream_wrapper cs(p, end_);\n    number num;\n    const char* begin = cs.begin();\n    if(stack_empty || st_.empty())\n    {\n        num.bias = 0;\n        num.exp = 0;\n        num.frac = false;\n\n        //----------------------------------\n        //\n        // '-'\n        // leading minus sign\n        //\n        BOOST_ASSERT(cs);\n        if(negative)\n            ++cs;\n\n        num.neg = negative;\n        num.frac = false;\n        num.exp = 0;\n        num.bias = 0;\n\n        // fast path\n        if( cs.remain() >= 16 + 1 + 16 ) // digits . digits\n        {\n            int n1;\n\n            if( nonzero_first ||\n                (negative && *cs != '0') )\n            {\n                n1 = detail::count_digits( cs.begin() );\n                BOOST_ASSERT(n1 >= 0 && n1 <= 16);\n\n                if( ! nonzero_first && n1 == 0 )\n                {\n                    // digit required\n                    BOOST_STATIC_CONSTEXPR source_location loc\n                        = BOOST_CURRENT_LOCATION;\n                    return fail(cs.begin(), error::syntax, &loc);\n                }\n\n                num.mant = detail::parse_unsigned( 0, cs.begin(), n1 );\n\n                cs += n1;\n\n                // integer or floating-point with\n                // >= 16 leading digits\n                if( n1 == 16 )\n                {\n                    goto do_num2;\n                }\n            }\n            else\n            {\n                // 0. floating-point or 0e integer\n                num.mant = 0;\n                n1 = 0;\n                ++cs;\n            }\n\n            {\n                const char c = *cs;\n                if(c != '.')\n                {\n                    if((c | 32) == 'e')\n                    {\n                        ++cs;\n                        goto do_exp1;\n                    }\n                    if(negative)\n                        num.mant = ~num.mant + 1;\n                    goto finish_signed;\n                }\n            }\n\n            // floating-point number\n\n            ++cs;\n\n            int n2 = detail::count_digits( cs.begin() );\n            BOOST_ASSERT(n2 >= 0 && n2 <= 16);\n\n            if( n2 == 0 )\n            {\n                // digit required\n                BOOST_STATIC_CONSTEXPR source_location loc\n                    = BOOST_CURRENT_LOCATION;\n                return fail(cs.begin(), error::syntax, &loc);\n            }\n\n            // floating-point mantissa overflow\n            if( n1 + n2 >= 19 )\n            {\n                goto do_num7;\n            }\n\n            num.mant = detail::parse_unsigned( num.mant, cs.begin(), n2 );\n\n            BOOST_ASSERT(num.bias == 0);\n\n            num.bias -= n2;\n\n            cs += n2;\n\n            char ch = *cs;\n\n            if( (ch | 32) == 'e' )\n            {\n                ++cs;\n                goto do_exp1;\n            }\n            else if( ch >= '0' && ch <= '9' )\n            {\n                goto do_num8;\n            }\n\n            goto finish_dub;\n        }\n    }\n    else\n    {\n        num = num_;\n        state st;\n        st_.pop(st);\n        switch(st)\n        {\n        default: BOOST_JSON_UNREACHABLE();\n        case state::num1: goto do_num1;\n        case state::num2: goto do_num2;\n        case state::num3: goto do_num3;\n        case state::num4: goto do_num4;\n        case state::num5: goto do_num5;\n        case state::num6: goto do_num6;\n        case state::num7: goto do_num7;\n        case state::num8: goto do_num8;\n        case state::exp1: goto do_exp1;\n        case state::exp2: goto do_exp2;\n        case state::exp3: goto do_exp3;\n        }\n    }\n\n    //----------------------------------\n    //\n    // DIGIT\n    // first digit\n    //\ndo_num1:\n    if(zero_first || nonzero_first ||\n        BOOST_JSON_LIKELY(cs))\n    {\n        char const c = *cs;\n        if(zero_first)\n        {\n            ++cs;\n            num.mant = 0;\n            goto do_num6;\n        }\n        else if(nonzero_first || BOOST_JSON_LIKELY(\n            c >= '1' && c <= '9'))\n        {\n            ++cs;\n            num.mant = c - '0';\n        }\n        else if(BOOST_JSON_UNLIKELY(\n            c == '0'))\n        {\n            ++cs;\n            num.mant = 0;\n            goto do_num6;\n        }\n        else\n        {\n            BOOST_STATIC_CONSTEXPR source_location loc\n                = BOOST_CURRENT_LOCATION;\n            return fail(cs.begin(), error::syntax, &loc);\n        }\n    }\n    else\n    {\n        if(BOOST_JSON_UNLIKELY(\n            ! h_.on_number_part(\n                {begin, cs.used(begin)}, ec_)))\n            return fail(cs.begin());\n        return maybe_suspend(\n            cs.begin(), state::num1, num);\n    }\n\n    //----------------------------------\n    //\n    // 1*DIGIT\n    // significant digits left of decimal\n    //\ndo_num2:\n    if(negative || (!stack_empty && num.neg))\n    {\n        for(;;)\n        {\n            if(BOOST_JSON_UNLIKELY(! cs))\n            {\n                if(BOOST_JSON_UNLIKELY(more_))\n                {\n                    if(BOOST_JSON_UNLIKELY(\n                        ! h_.on_number_part(\n                            {begin, cs.used(begin)}, ec_)))\n                        return fail(cs.begin());\n                    return suspend(cs.begin(), state::num2, num);\n                }\n                goto finish_int;\n            }\n            char const c = *cs;\n            if(BOOST_JSON_LIKELY(\n                c >= '0' && c <= '9'))\n            {\n                ++cs;\n                //              9223372036854775808 INT64_MIN\n                if( num.mant  > 922337203685477580 || (\n                    num.mant == 922337203685477580 && c > '8'))\n                    break;\n                num.mant = 10 * num.mant + ( c - '0' );\n                continue;\n            }\n            goto do_num6; // [.eE]\n        }\n    }\n    else\n    {\n        for(;;)\n        {\n            if(BOOST_JSON_UNLIKELY(! cs))\n            {\n                if(BOOST_JSON_UNLIKELY(more_))\n                {\n                    if(BOOST_JSON_UNLIKELY(\n                        ! h_.on_number_part(\n                            {begin, cs.used(begin)}, ec_)))\n                        return fail(cs.begin());\n                    return suspend(cs.begin(), state::num2, num);\n                }\n                goto finish_int;\n            }\n            char const c = *cs;\n            if(BOOST_JSON_LIKELY(\n                c >= '0' && c <= '9'))\n            {\n                ++cs;\n                //              18446744073709551615 UINT64_MAX\n                if( num.mant  > 1844674407370955161 || (\n                    num.mant == 1844674407370955161 && c > '5'))\n                    break;\n                num.mant = 10 * num.mant + ( c - '0' );\n            }\n            else\n            {\n                goto do_num6; // [.eE]\n            }\n        }\n    }\n    ++num.bias;\n\n    //----------------------------------\n    //\n    // 1*DIGIT\n    // non-significant digits left of decimal\n    //\ndo_num3:\n    for(;;)\n    {\n        if(BOOST_JSON_UNLIKELY(! cs))\n        {\n            if(BOOST_JSON_UNLIKELY(more_))\n            {\n                if(BOOST_JSON_UNLIKELY(\n                    ! h_.on_number_part(\n                        {begin, cs.used(begin)}, ec_)))\n                    return fail(cs.begin());\n                return suspend(cs.begin(), state::num3, num);\n            }\n            goto finish_dub;\n        }\n        char const c = *cs;\n        if(BOOST_JSON_UNLIKELY(\n            c >= '0' && c <= '9'))\n        {\n            ++cs;\n            // VFALCO check overflow\n            ++num.bias;\n        }\n        else if(BOOST_JSON_LIKELY(\n            c == '.'))\n        {\n            ++cs;\n            break;\n        }\n        else if((c | 32) == 'e')\n        {\n            ++cs;\n            goto do_exp1;\n        }\n        else\n        {\n            goto finish_dub;\n        }\n    }\n\n    //----------------------------------\n    //\n    // DIGIT\n    // first non-significant digit\n    // to the right of decimal\n    //\ndo_num4:\n    {\n        if(BOOST_JSON_UNLIKELY(! cs))\n        {\n            if(BOOST_JSON_UNLIKELY(\n                ! h_.on_number_part(\n                    {begin, cs.used(begin)}, ec_)))\n                return fail(cs.begin());\n            return maybe_suspend(\n                cs.begin(), state::num4, num);\n        }\n        char const c = *cs;\n        if(BOOST_JSON_LIKELY(\n            //static_cast<unsigned char>(c - '0') < 10))\n            c >= '0' && c <= '9'))\n        {\n            ++cs;\n        }\n        else\n        {\n            // digit required\n            BOOST_STATIC_CONSTEXPR source_location loc\n                = BOOST_CURRENT_LOCATION;\n            return fail(cs.begin(), error::syntax, &loc);\n        }\n    }\n\n    //----------------------------------\n    //\n    // 1*DIGIT\n    // non-significant digits\n    // to the right of decimal\n    //\ndo_num5:\n    for(;;)\n    {\n        if(BOOST_JSON_UNLIKELY(! cs))\n        {\n            if(BOOST_JSON_UNLIKELY(more_))\n            {\n                if(BOOST_JSON_UNLIKELY(\n                    ! h_.on_number_part(\n                        {begin, cs.used(begin)}, ec_)))\n                    return fail(cs.begin());\n                return suspend(cs.begin(), state::num5, num);\n            }\n            goto finish_dub;\n        }\n        char const c = *cs;\n        if(BOOST_JSON_LIKELY(\n            c >= '0' && c <= '9'))\n        {\n            ++cs;\n        }\n        else if((c | 32) == 'e')\n        {\n            ++cs;\n            goto do_exp1;\n        }\n        else\n        {\n            goto finish_dub;\n        }\n    }\n\n    //----------------------------------\n    //\n    // [.eE]\n    //\ndo_num6:\n    {\n        if(BOOST_JSON_UNLIKELY(! cs))\n        {\n            if(BOOST_JSON_UNLIKELY(more_))\n            {\n                if(BOOST_JSON_UNLIKELY(\n                    ! h_.on_number_part(\n                        {begin, cs.used(begin)}, ec_)))\n                    return fail(cs.begin());\n                return suspend(cs.begin(), state::num6, num);\n            }\n            goto finish_int;\n        }\n        char const c = *cs;\n        if(BOOST_JSON_LIKELY(\n            c == '.'))\n        {\n            ++cs;\n        }\n        else if((c | 32) == 'e')\n        {\n            ++cs;\n            goto do_exp1;\n        }\n        else\n        {\n            goto finish_int;\n        }\n    }\n\n    //----------------------------------\n    //\n    // DIGIT\n    // first significant digit\n    // to the right of decimal\n    //\ndo_num7:\n    {\n        if(BOOST_JSON_UNLIKELY(! cs))\n        {\n            if(BOOST_JSON_UNLIKELY(more_))\n            {\n                if(BOOST_JSON_UNLIKELY(\n                    ! h_.on_number_part(\n                        {begin, cs.used(begin)}, ec_)))\n                    return fail(cs.begin());\n                return suspend(cs.begin(), state::num7, num);\n            }\n            // digit required\n            BOOST_STATIC_CONSTEXPR source_location loc\n                = BOOST_CURRENT_LOCATION;\n            return fail(cs.begin(), error::syntax, &loc);\n        }\n        char const c = *cs;\n        if(BOOST_JSON_UNLIKELY(\n            c < '0' || c > '9'))\n        {\n            // digit required\n            BOOST_STATIC_CONSTEXPR source_location loc\n                = BOOST_CURRENT_LOCATION;\n            return fail(cs.begin(), error::syntax, &loc);\n        }\n    }\n\n    //----------------------------------\n    //\n    // 1*DIGIT\n    // significant digits\n    // to the right of decimal\n    //\ndo_num8:\n    for(;;)\n    {\n        if(BOOST_JSON_UNLIKELY(! cs))\n        {\n            if(BOOST_JSON_UNLIKELY(more_))\n            {\n                if(BOOST_JSON_UNLIKELY(\n                    ! h_.on_number_part(\n                        {begin, cs.used(begin)}, ec_)))\n                    return fail(cs.begin());\n                return suspend(cs.begin(), state::num8, num);\n            }\n            goto finish_dub;\n        }\n        char const c = *cs;\n        if(BOOST_JSON_LIKELY(\n            c >= '0' && c <= '9'))\n        {\n            ++cs;\n            if(BOOST_JSON_LIKELY(\n                num.mant <= 9007199254740991)) // 2^53-1\n            {\n                --num.bias;\n                num.mant = 10 * num.mant + ( c - '0' );\n            }\n            else\n            {\n                goto do_num5;\n            }\n        }\n        else if((c | 32) == 'e')\n        {\n            ++cs;\n            goto do_exp1;\n        }\n        else\n        {\n            goto finish_dub;\n        }\n    }\n\n    //----------------------------------\n    //\n    // *[+-]\n    //\ndo_exp1:\n    if(BOOST_JSON_UNLIKELY(! cs))\n    {\n        if(BOOST_JSON_UNLIKELY(\n            ! h_.on_number_part(\n                {begin, cs.used(begin)}, ec_)))\n            return fail(cs.begin());\n        return maybe_suspend(\n            cs.begin(), state::exp1, num);\n    }\n    if(*cs == '+')\n    {\n        ++cs;\n    }\n    else if(*cs == '-')\n    {\n        ++cs;\n        num.frac = true;\n    }\n\n    //----------------------------------\n    //\n    // DIGIT\n    // first digit of the exponent\n    //\ndo_exp2:\n    {\n        if(BOOST_JSON_UNLIKELY(! cs))\n        {\n            if(BOOST_JSON_UNLIKELY(more_))\n            {\n                if(BOOST_JSON_UNLIKELY(\n                    ! h_.on_number_part(\n                        {begin, cs.used(begin)}, ec_)))\n                    return fail(cs.begin());\n                return suspend(cs.begin(), state::exp2, num);\n            }\n            // digit required\n            BOOST_STATIC_CONSTEXPR source_location loc\n                = BOOST_CURRENT_LOCATION;\n            return fail(cs.begin(), error::syntax, &loc);\n        }\n        char const c = *cs;\n        if(BOOST_JSON_UNLIKELY(\n            c < '0' || c > '9'))\n        {\n            // digit required\n            BOOST_STATIC_CONSTEXPR source_location loc\n                = BOOST_CURRENT_LOCATION;\n            return fail(cs.begin(), error::syntax, &loc);\n        }\n        ++cs;\n        num.exp = c - '0';\n    }\n\n    //----------------------------------\n    //\n    // 1*DIGIT\n    // subsequent digits in the exponent\n    //\ndo_exp3:\n    for(;;)\n    {\n        if(BOOST_JSON_UNLIKELY(! cs))\n        {\n            if(BOOST_JSON_UNLIKELY(more_))\n            {\n                if(BOOST_JSON_UNLIKELY(\n                    ! h_.on_number_part(\n                        {begin, cs.used(begin)}, ec_)))\n                    return fail(cs.begin());\n                return suspend(cs.begin(), state::exp3, num);\n            }\n        }\n        else\n        {\n            char const c = *cs;\n            if(BOOST_JSON_LIKELY(\n                c >= '0' && c <= '9'))\n            {\n                if(BOOST_JSON_UNLIKELY\n                //              2147483647 INT_MAX\n                    (num.exp  > 214748364 || (\n                        num.exp == 214748364 && c > '7')))\n                {\n                    BOOST_STATIC_CONSTEXPR source_location loc\n                        = BOOST_CURRENT_LOCATION;\n                    return fail(cs.begin(), error::exponent_overflow, &loc);\n                }\n                ++cs;\n                num.exp = 10 * num.exp + ( c - '0' );\n                continue;\n            }\n        }\n        BOOST_ASSERT(num.exp >= 0);\n        if ( num.frac )\n        {\n            if (BOOST_JSON_UNLIKELY( num.bias  < (INT_MIN + num.exp) ))\n            {\n                BOOST_STATIC_CONSTEXPR source_location loc\n                    = BOOST_CURRENT_LOCATION;\n                return fail(cs.begin(), error::exponent_overflow, &loc);\n            }\n        }\n        else\n        {\n            if (BOOST_JSON_UNLIKELY( num.bias > (INT_MAX - num.exp) ))\n            {\n                BOOST_STATIC_CONSTEXPR source_location loc\n                    = BOOST_CURRENT_LOCATION;\n                return fail(cs.begin(), error::exponent_overflow, &loc);\n            }\n        }\n        goto finish_dub;\n    }\n\nfinish_int:\n    if(negative || (!stack_empty && num.neg))\n    {\n        if(BOOST_JSON_UNLIKELY(\n            ! h_.on_int64(static_cast<\n                int64_t>(~num.mant + 1), {begin, cs.used(begin)}, ec_)))\n            return fail(cs.begin());\n        return cs.begin();\n    }\n    if(num.mant <= INT64_MAX)\n    {\nfinish_signed:\n        if(BOOST_JSON_UNLIKELY(\n            ! h_.on_int64(static_cast<\n                int64_t>(num.mant), {begin, cs.used(begin)}, ec_)))\n            return fail(cs.begin());\n        return cs.begin();\n    }\n    if(BOOST_JSON_UNLIKELY(\n        ! h_.on_uint64(num.mant, {begin, cs.used(begin)}, ec_)))\n        return fail(cs.begin());\n    return cs.begin();\nfinish_dub:\n    double const d = detail::dec_to_float(\n        num.mant,\n        num.bias + (num.frac ?\n            -num.exp : num.exp),\n        num.neg);\n    if(BOOST_JSON_UNLIKELY(\n        ! h_.on_double(d, {begin, cs.used(begin)}, ec_)))\n        return fail(cs.begin());\n    return cs.begin();\n}\n\n//----------------------------------------------------------\n\ntemplate<class Handler>\ntemplate<class... Args>\nbasic_parser<Handler>::\nbasic_parser(\n    parse_options const& opt,\n    Args&&... args)\n    : h_(std::forward<Args>(args)...)\n    , opt_(opt)\n{\n}\n\n//----------------------------------------------------------\n\ntemplate<class Handler>\nvoid\nbasic_parser<Handler>::\nreset() noexcept\n{\n    ec_ = {};\n    st_.clear();\n    more_ = true;\n    done_ = false;\n    clean_ = true;\n}\n\ntemplate<class Handler>\nvoid\nbasic_parser<Handler>::\nfail(error_code ec) noexcept\n{\n    if(! ec)\n    {\n        // assign an arbitrary\n        // error code to prevent UB\n        BOOST_JSON_FAIL(ec_, error::incomplete);\n    }\n    else\n    {\n        ec_ = ec;\n    }\n    done_ = false;\n}\n\n//----------------------------------------------------------\n\ntemplate<class Handler>\nstd::size_t\nbasic_parser<Handler>::\nwrite_some(\n    bool more,\n    char const* data,\n    std::size_t size,\n    error_code& ec)\n{\n    // see if we exited via exception\n    // on the last call to write_some\n    if(! clean_)\n    {\n        // prevent UB\n        if(! ec_)\n        {\n            BOOST_JSON_FAIL(ec_, error::exception);\n        }\n    }\n    if(ec_)\n    {\n        // error is sticky\n        ec = ec_;\n        return 0;\n    }\n    clean_ = false;\n    more_ = more;\n    end_ = data + size;\n    const char* p;\n    if(BOOST_JSON_LIKELY(st_.empty()))\n    {\n        // first time\n        depth_ = opt_.max_depth;\n        if(BOOST_JSON_UNLIKELY(\n            ! h_.on_document_begin(ec_)))\n        {\n            ec = ec_;\n            return 0;\n        }\n        p = parse_document(data, std::true_type());\n    }\n    else\n    {\n        p = parse_document(data, std::false_type());\n    }\n\n    if(BOOST_JSON_LIKELY(p != sentinel()))\n    {\n        BOOST_ASSERT(! ec_);\n        if(! done_)\n        {\n            done_ = true;\n            h_.on_document_end(ec_);\n        }\n    }\n    else\n    {\n        if(! ec_)\n        {\n            if(! more_)\n            {\n                BOOST_JSON_FAIL(ec_, error::incomplete);\n            }\n            else if(! st_.empty())\n            {\n                // consume as much trailing whitespace in\n                // the JSON document as possible, but still\n                // consider the parse complete\n                state st;\n                st_.peek(st);\n                if( st == state::doc3 &&\n                    ! done_)\n                {\n                    done_ = true;\n                    h_.on_document_end(ec_);\n                }\n            }\n        }\n        p = end_;\n    }\n    ec = ec_;\n    clean_ = true;\n    return p - data;\n}\n\ntemplate<class Handler>\nstd::size_t\nbasic_parser<Handler>::\nwrite_some(\n    bool more,\n    char const* data,\n    std::size_t size,\n    std::error_code& ec)\n{\n    error_code jec;\n    std::size_t const result = write_some(more, data, size, jec);\n    ec = jec;\n    return result;\n}\n\n#endif\n\nBOOST_JSON_NS_END\n\n#ifdef _MSC_VER\n#pragma warning(pop)\n#endif\n\n#endif\n\n```\n","ts":1.739155390725E9}
{"role":"assistant","content":"","ts":1.739155395874E9}
{"role":"user","content":"no reply?\n","ts":1.739155408416E9}
{"role":"assistant","content":"","ts":1.739155409699E9}
