{"role":"user","content":"I had set a better colorscheme in vim but I don't have it on reboot. Where is my vim history to find where it was set?\n","ts":1.739799932933E9}
{"role":"assistant","content":"When you set a colorscheme in Vim, itâ€™s typically done in one of Vimâ€™s configuration files. If the colorscheme doesnâ€™t persist after a reboot, it means the setting wasnâ€™t saved in a persistent configuration file. To locate where the colorscheme was set and ensure it persists, follow these steps:\n\n---\n\n### 1. **Check Vimâ€™s Configuration Files**\nVimâ€™s configuration is stored in specific files. Look for the colorscheme setting in these files:\n\n- **Global configuration file**: `/etc/vim/vimrc` (or `/etc/vimrc` on some systems)\n- **User-specific configuration file**: `~/.vimrc` (in your home directory)\n- **Local Vim configuration**: `~/.vim/vimrc` (if it exists)\n\nSearch for a line like this in these files:\n```vim\ncolorscheme <colorscheme_name>\n```\nReplace `<colorscheme_name>` with the name","finish_reason":"runtime_error SIGINT","ts":1.739799968741E9}
{"role":"user","content":"goodness. no it obviously wasn't in a configuration file since it didn't persist. it was on the commandline. where is my command history?\n","ts":1.739799986415E9}
{"role":"assistant","content":"Ah, I see! If you set the colorscheme via the Vim command line (e.g., using `:colorscheme <name>`), it won't persist unless saved to a configuration file. To find the command you previously used, you can check Vim's command history.\n\n---\n\n### **Access Vim Command History**\nVim keeps a history of commands youâ€™ve entered in the command line. To view it:\n\n1. Open Vim.\n2. In normal mode, type `:` to enter command mode.\n3. Press the **Up Arrow** or `Ctrl-P` to scroll through your command history.\n   - Look for a command like `colorscheme <name>`.\n4. Alternatively, use the `:history` command to list all recent commands:\n   ```vim\n   :history\n   ```\n   This will show a numbered list of commands. Look for the one where you set the colorscheme.\n\n---\n\n### **Persist the Colorscheme**\nOnce you find the command, add it to your Vim configuration file (`~/.vimrc`) to make it persistent. For example:\n```vim\ncolorscheme <name>\n```\nSave the file, and the colorscheme will apply every time you start Vim.\n\n---\n\nLet me know if you need further help! ðŸ˜Š","finish_reason":"stop","ts":1.739800022151E9}
{"role":"user","content":"is there a file containing these history lines for me to apply grep colorscheme | tail\n","ts":1.739800045876E9}
{"role":"assistant","content":"Yes! Vim stores its command history in a file, and you can indeed use `grep` to search through it. Hereâ€™s how:\n\n---\n\n### **Vim Command History File**\nVim keeps its command history in a file named `.viminfo` (or `.nviminfo` for Neovim) in your home directory. This file stores commands, search history, and other session data.\n\n---\n\n### **Steps to Search for the Colorscheme Command**\n1. Open a terminal.\n2. Use `grep` to search the `.viminfo` file for the `colorscheme` command:\n   ```bash\n   grep colorscheme ~/.viminfo\n   ```\n   This will show all lines in the history that contain the word `colorscheme`.\n\n3. To see the most recent occurrence, you can pipe the output to `tail`:\n   ```bash\n   grep colorscheme ~/.viminfo | tail\n   ```\n\n---\n\n### **Interpret the Results**\nThe `.viminfo` file stores commands in a specific format. Look for lines like:\n```\n:colorscheme <name>\n```\nThis is the command you used to set the colorscheme.\n\n---\n\n### **Persist the Colorscheme**\nOnce you find the command, add it to your `~/.vimrc` file to make it permanent:\n```vim\ncolorscheme <name>\n```\n\n---\n\n### **Neovim Users**\nIf youâ€™re using Neovim, the history file is `~/.local/share/nvim/shada/main.shada` (or `.nviminfo` in older versions). Use the same `grep` command on this file.\n\n---\n\nLet me know if you have any questions! ðŸ˜Š","finish_reason":"{\"text\":\"\",\"logprobs\":{\"token_logprobs\":[-1.4781842764932662E-5],\"tokens\":[\"token_id:1\"]},\"token_ids\":[1]}","ts":1.739800088781E9}
{"role":"assistant","content":"","finish_reason":"stop","ts":1.739800090037E9}
{"role":"user","content":"thank you for viminfo. viminfo appears newest-at-the-top? what kind of write policy or algorithm does vim use to keep their history file newest at the top? or am i seeing something wrong?\n","ts":1.739800110499E9}
{"role":"assistant","content":"Great question! The `.viminfo` file doesnâ€™t strictly store history in a \"newest-at-the-top\" order. Instead, it uses a specific **structured format** to store various types of information, including command history, search history, and more. Hereâ€™s how it works:\n\n---\n\n### **Viminfo File Structure**\nThe `.viminfo` file is a text file with sections marked by headers like `#Command Line History`, `#Search String History`, and `#Registers`, among others. Each section contains data in a specific format.\n\nFor **command line history**, the section looks like this:\n```\n#Command Line History\n|2,0,1699396320,150,1|:colorscheme mytheme\n|2,0,1699396315,150,1|:set number\n|2,0,1699396300,150,1|:set tabstop=4\n```\n- The `|2,0,...` format indicates metadata:\n  - `2` = type of entry (e.g., command line history).\n  - `0` = unused (reserved for future use).\n  - `1699396320` = Unix timestamp of when the command was executed.\n  - `150` = number of times this command was executed.\n  - `1` = marker for the latest execution.\n- The command itself follows, e.g., `:colorscheme mytheme`.\n\n---\n\n### **Order of Entries**\n- The `.viminfo` file doesnâ€™t reorder entries when itâ€™s written. New commands are **appended to the end** of the relevant section.\n- However, Vim **prepends newer entries** to its in-memory command history when you execute commands. This can make it seem like the file is \"newest-at-the-top\" when you view it in Vim (e.g., using `:history`).\n\n---\n\n### **Why It Might Seem Newest-at-the-Top**\nWhen you use `grep` or inspect the file manually:\n- If the `.viminfo` file was recently updated, newer commands will appear **near the end** of the file.\n- If the file has been truncated or rewritten (e.g., due to size limits), older entries may be removed, leaving newer ones at the top.\n\n---\n\n### **Practical Implications**\n- Use `grep` to search for `colorscheme`:\n  ```bash\n  grep colorsche","finish_reason":"length","ts":1.739800163373E9}
{"role":"assistant","content":"me ~/.viminfo\n  ```\n  This will show all occurrences, and you can use `tail` to see the most recent ones.\n\n---\n\n### **How Vim Updates `.viminfo`**\n- Vim writes to `.viminfo` when you exit normally (`:q` or `ZZ`).\n- The file is updated incrementally, with new entries appended to the end of sections.\n- If the file exceeds a certain size (controlled by the `'viminfo'` option), older entries may be discarded.\n\n---\n\nLet me know if youâ€™d like more details! ðŸ˜Š","finish_reason":"stop","ts":1.739800174676E9}
{"role":"user","content":"huh! so when running, vim uses a buffer for command history that is filled end-to-start?\n","ts":1.739800205468E9}
{"role":"assistant","content":"Yes, exactly! When Vim is running, it maintains an **in-memory buffer** for command history, and this buffer is filled in a **last-in, first-out (LIFO)** manner. Hereâ€™s how it works:\n\n---\n\n### **In-Memory Command History Buffer**\n1. **Order of Commands**:\n   - When you execute a command in Vim (e.g., `:colorscheme mytheme`), it is **prepended** to the in-memory history buffer.\n   - This means the **most recent command** is always at the **beginning** of the buffer.\n\n2. **Viewing History**:\n   - When you press `:` to enter command mode and use the **Up Arrow** or `Ctrl+P`, Vim traverses the in-memory buffer from newest to oldest.\n   - Similarly, the `:history` command lists commands in the order they were executed, with the **most recent command at the top**.\n\n---\n\n### **How the `.viminfo` File Relates**\n- The **`.viminfo` file** is a persistent store for history and other session data, but it doesnâ€™t directly reflect the in-memory bufferâ€™s order.\n- **When Vim exits**, it writes the in-memory command history to the `.viminfo` file, but it **appends** the commands to the existing history section rather than rewriting the entire file.\n- As a result, the `.viminfo` file grows **older-to-newer** over time (new commands are added at the end of the file).\n\n---\n\n### **Why the Discrepancy?**\n- **In-Memory Buffer**: Newest commands are at the **top** (prepended).\n-","finish_reason":"runtime_error SIGINT","ts":1.739800256485E9}
{"role":"user","content":"I mean how do they do it algorithmically? Is it done like many stacks, where a large block is allocated and the write pointer is set to the end?\n","ts":1.739800290884E9}
{"role":"assistant","content":"Ah, I seeâ€”you're asking about the **algorithmic implementation** of Vim's command history buffer. While the exact implementation details aren't publicly documented in the Vim source code (and can vary across versions), hereâ€™s how itâ€™s *likely* implemented based on common practices for such systems and the behavior observed:\n\n---\n\n### **Likely Implementation of Vimâ€™s Command History Buffer**\n1. **Data Structure**:\n   - The command history buffer is likely implemented as a **dynamic array** (or a similar contiguous memory structure) rather than a classic stack.\n   - This allows for efficient insertion and traversal of commands.\n\n2. **Pointer Management**:\n   - A **write pointer** (or index) keeps track of the current position in the array.\n  ","finish_reason":"runtime_error SIGINT","ts":1.739800313876E9}
{"role":"user","content":"Where would we check this online? Where is vim's git repository?\n","ts":1.739800323997E9}
{"role":"assistant","content":"Great question! You can explore Vim's source code directly in its official Git repository to understand how the command history buffer and other features are implemented. Hereâ€™s how to find it:\n\n---\n\n### **Vimâ€™s Git Repository**\nVimâ€™s source code is hosted on **GitHub** and **GitLab**. The primary repository is:\n\n- **GitHub**: [https://github.com/vim/vim](https://github.com/vim/vim)  \n  This is the most commonly used mirror for Vimâ€™","finish_reason":"runtime_error SIGINT","ts":1.739800333889E9}
{"role":"user","content":"Do you know where we would fetch with curl first to find the implementation of this buffer?\n","ts":1.739800343612E9}
{"role":"assistant","content":"Yes! To explore the implementation of Vimâ€™s command history buffer, you can fetch specific parts of the Vim source code or clone the entire repository and search through it. Hereâ€™s how to do it efficiently:\n\n---\n\n### **Step 1: Find the Relevant Source Files**\nThe logic for command history is likely located in one of the core source files. Here are some key files to check:\n1. **`src/ex_cmds.c`**: Contains implementations for Vimâ€™s command","finish_reason":"runtime_error SIGINT","ts":1.739800358756E9}
{"role":"user","content":"Gimme a curl url\n","ts":1.739800361258E9}
{"role":"assistant","content":"Got it! Hereâ€™s a `curl` command to directly fetch the `src/ex_cmds.c` file from Vimâ€™s GitHub repository:\n\n```bash\ncurl -O https://raw.githubusercontent.com/vim/vim/master/src/ex_cmds.c\n```\n\nThis will download the `ex_cmds.c","finish_reason":"runtime_error SIGINT","ts":1.739800375532E9}
{"role":"user","content":"[1]\n\n1: **https://raw.githubusercontent.com/vim/vim/master/src/ex_cmds.c**\n```\n/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * ex_cmds.c: some functions for command line commands\n */\n\n#include \"vim.h\"\n#include \"version.h\"\n\n#include <float.h>\n\nstatic int linelen(int *has_tab);\nstatic void do_filter(linenr_T line1, linenr_T line2, exarg_T *eap, char_u *cmd, int do_in, int do_out);\nstatic int not_writing(void);\nstatic int check_readonly(int *forceit, buf_T *buf);\nstatic void delbuf_msg(char_u *name);\n\n/*\n * \":ascii\" and \"ga\".\n */\n    void\ndo_ascii(exarg_T *eap UNUSED)\n{\n    int\t\tc;\n    int\t\tcval;\n    char\tbuf1[20];\n    char\tbuf2[20];\n    char_u\tbuf3[7];\n#ifdef FEAT_DIGRAPHS\n    char_u      *dig;\n#endif\n    int\t\tcc[MAX_MCO];\n    int\t\tci = 0;\n    int\t\tlen;\n\n    if (enc_utf8)\n\tc = utfc_ptr2char(ml_get_cursor(), cc);\n    else\n\tc = gchar_cursor();\n    if (c == NUL)\n    {\n\tmsg(\"NUL\");\n\treturn;\n    }\n\n    IObuff[0] = NUL;\n    if (!has_mbyte || (enc_dbcs != 0 && c < 0x100) || c < 0x80)\n    {\n\tif (c == NL)\t    // NUL is stored as NL\n\t    c = NUL;\n\tif (c == CAR && get_fileformat(curbuf) == EOL_MAC)\n\t    cval = NL;\t    // NL is stored as CR\n\telse\n\t    cval = c;\n\tif (vim_isprintc_strict(c) && (c < ' ' || c > '~'))\n\t{\n\t    transchar_nonprint(curbuf, buf3, c);\n\t    vim_snprintf(buf1, sizeof(buf1), \"  <%s>\", (char *)buf3);\n\t}\n\telse\n\t    buf1[0] = NUL;\n\tif (c >= 0x80)\n\t    vim_snprintf(buf2, sizeof(buf2), \"  <M-%s>\",\n\t\t\t\t\t\t (char *)transchar(c & 0x7f));\n\telse\n\t    buf2[0] = NUL;\n#ifdef FEAT_DIGRAPHS\n\tdig = get_digraph_for_char(cval);\n\tif (dig != NULL)\n\t    vim_snprintf((char *)IObuff, IOSIZE,\n\t\t_(\"<%s>%s%s  %d,  Hex %02x,  Oct %03o, Digr %s\"),\n\t\t\t      transchar(c), buf1, buf2, cval, cval, cval, dig);\n\telse\n#endif\n\t    vim_snprintf((char *)IObuff, IOSIZE,\n\t\t_(\"<%s>%s%s  %d,  Hex %02x,  Octal %03o\"),\n\t\t\t\t  transchar(c), buf1, buf2, cval, cval, cval);\n\tif (enc_utf8)\n\t    c = cc[ci++];\n\telse\n\t    c = 0;\n    }\n\n    // Repeat for combining characters.\n    while (has_mbyte && (c >= 0x100 || (enc_utf8 && c >= 0x80)))\n    {\n\tlen = (int)STRLEN(IObuff);\n\t// This assumes every multi-byte char is printable...\n\tif (len > 0)\n\t    IObuff[len++] = ' ';\n\tIObuff[len++] = '<';\n\tif (enc_utf8 && utf_iscomposing(c)\n#ifdef USE_GUI\n\t\t&& !gui.in_use\n#endif\n\t\t)\n\t    IObuff[len++] = ' '; // draw composing char on top of a space\n\tlen += (*mb_char2bytes)(c, IObuff + len);\n#ifdef FEAT_DIGRAPHS\n\tdig = get_digraph_for_char(c);\n\tif (dig != NULL)\n\t    vim_snprintf((char *)IObuff + len, IOSIZE - len,\n\t\t\tc < 0x10000 ? _(\"> %d, Hex %04x, Oct %o, Digr %s\")\n\t\t\t\t    : _(\"> %d, Hex %08x, Oct %o, Digr %s\"),\n\t\t\t\t\tc, c, c, dig);\n\telse\n#endif\n\t    vim_snprintf((char *)IObuff + len, IOSIZE - len,\n\t\t\t c < 0x10000 ? _(\"> %d, Hex %04x, Octal %o\")\n\t\t\t\t     : _(\"> %d, Hex %08x, Octal %o\"),\n\t\t\t\t     c, c, c);\n\tif (ci == MAX_MCO)\n\t    break;\n\tif (enc_utf8)\n\t    c = cc[ci++];\n\telse\n\t    c = 0;\n    }\n\n    msg((char *)IObuff);\n}\n\n/*\n * \":left\", \":center\" and \":right\": align text.\n */\n    void\nex_align(exarg_T *eap)\n{\n    pos_T\tsave_curpos;\n    int\t\tlen;\n    int\t\tindent = 0;\n    int\t\tnew_indent;\n    int\t\thas_tab;\n    int\t\twidth;\n\n#ifdef FEAT_RIGHTLEFT\n    if (curwin->w_p_rl)\n    {\n\t// switch left and right aligning\n\tif (eap->cmdidx == CMD_right)\n\t    eap->cmdidx = CMD_left;\n\telse if (eap->cmdidx == CMD_left)\n\t    eap->cmdidx = CMD_right;\n    }\n#endif\n\n    width = atoi((char *)eap->arg);\n    save_curpos = curwin->w_cursor;\n    if (eap->cmdidx == CMD_left)    // width is used for new indent\n    {\n\tif (width >= 0)\n\t    indent = width;\n    }\n    else\n    {\n\t/*\n\t * if 'textwidth' set, use it\n\t * else if 'wrapmargin' set, use it\n\t * if invalid value, use 80\n\t */\n\tif (width <= 0)\n\t    width = curbuf->b_p_tw;\n\tif (width == 0 && curbuf->b_p_wm > 0)\n\t    width = curwin->w_width - curbuf->b_p_wm;\n\tif (width <= 0)\n\t    width = 80;\n    }\n\n    if (u_save((linenr_T)(eap->line1 - 1), (linenr_T)(eap->line2 + 1)) == FAIL)\n\treturn;\n\n    for (curwin->w_cursor.lnum = eap->line1;\n\t\t curwin->w_cursor.lnum <= eap->line2; ++curwin->w_cursor.lnum)\n    {\n\tif (eap->cmdidx == CMD_left)\t\t// left align\n\t    new_indent = indent;\n\telse\n\t{\n\t    has_tab = FALSE;\t// avoid uninit warnings\n\t    len = linelen(eap->cmdidx == CMD_right ? &has_tab\n\t\t\t\t\t\t   : NULL) - get_indent();\n\n\t    if (len <= 0)\t\t\t// skip blank lines\n\t\tcontinue;\n\n\t    if (eap->cmdidx == CMD_center)\n\t\tnew_indent = (width - len) / 2;\n\t    else\n\t    {\n\t\tnew_indent = width - len;\t// right align\n\n\t\t/*\n\t\t * Make sure that embedded TABs don't make the text go too far\n\t\t * to the right.\n\t\t */\n\t\tif (has_tab)\n\t\t    while (new_indent > 0)\n\t\t    {\n\t\t\t(void)set_indent(new_indent, 0);\n\t\t\tif (linelen(NULL) <= width)\n\t\t\t{\n\t\t\t    /*\n\t\t\t     * Now try to move the line as much as possible to\n\t\t\t     * the right.  Stop when it moves too far.\n\t\t\t     */\n\t\t\t    do\n\t\t\t\t(void)set_indent(++new_indent, 0);\n\t\t\t    while (linelen(NULL) <= width);\n\t\t\t    --new_indent;\n\t\t\t    break;\n\t\t\t}\n\t\t\t--new_indent;\n\t\t    }\n\t    }\n\t}\n\tif (new_indent < 0)\n\t    new_indent = 0;\n\t(void)set_indent(new_indent, 0);\t\t// set indent\n    }\n    changed_lines(eap->line1, 0, eap->line2 + 1, 0L);\n    curwin->w_cursor = save_curpos;\n    beginline(BL_WHITE | BL_FIX);\n}\n\n/*\n * Get the length of the current line, excluding trailing white space.\n */\n    static int\nlinelen(int *has_tab)\n{\n    char_u  *line;\n    char_u  *first;\n    char_u  *last;\n    int\t    save;\n    int\t    len;\n\n    // Get the line.  If it's empty bail out early (could be the empty string\n    // for an unloaded buffer).\n    line = ml_get_curline();\n    if (*line == NUL)\n\treturn 0;\n\n    // find the first non-blank character\n    first = skipwhite(line);\n\n    // find the character after the last non-blank character\n    for (last = first + STRLEN(first);\n\t\t\t\tlast > first && VIM_ISWHITE(last[-1]); --last)\n\t;\n    save = *last;\n    *last = NUL;\n    len = linetabsize_str(line);\t// get line length on screen\n    if (has_tab != NULL)\t\t// check for embedded TAB\n\t*has_tab = (vim_strchr(first, TAB) != NULL);\n    *last = save;\n\n    return len;\n}\n\n// Buffer for two lines used during sorting.  They are allocated to\n// contain the longest line being sorted.\nstatic char_u\t*sortbuf1;\nstatic char_u\t*sortbuf2;\n\nstatic int\tsort_lc;\t// sort using locale\nstatic int\tsort_ic;\t// ignore case\nstatic int\tsort_nr;\t// sort on number\nstatic int\tsort_rx;\t// sort on regex instead of skipping it\nstatic int\tsort_flt;\t// sort on floating number\n\nstatic int\tsort_abort;\t// flag to indicate if sorting has been interrupted\n\n// Struct to store info to be sorted.\ntypedef struct\n{\n    linenr_T\tlnum;\t\t\t// line number\n    union {\n\tstruct\n\t{\n\t    varnumber_T\tstart_col_nr;\t// starting column number\n\t    varnumber_T\tend_col_nr;\t// ending column number\n\t} line;\n\tstruct\n\t{\n\t    varnumber_T\tvalue;\t\t// value if sorting by integer\n\t    int is_number;\t\t// TRUE when line contains a number\n\t} num;\n\tfloat_T value_flt;\t\t// value if sorting by float\n    } st_u;\n} sorti_T;\n\n    static int\nstring_compare(const void *s1, const void *s2)\n{\n    if (sort_lc)\n\treturn strcoll((char *)s1, (char *)s2);\n    return sort_ic ? STRICMP(s1, s2) : STRCMP(s1, s2);\n}\n\n    static int\nsort_compare(const void *s1, const void *s2)\n{\n    sorti_T\tl1 = *(sorti_T *)s1;\n    sorti_T\tl2 = *(sorti_T *)s2;\n    int\t\tresult = 0;\n\n    // If the user interrupts, there's no way to stop qsort() immediately, but\n    // if we return 0 every time, qsort will assume it's done sorting and\n    // exit.\n    if (sort_abort)\n\treturn 0;\n    fast_breakcheck();\n    if (got_int)\n\tsort_abort = TRUE;\n\n    if (sort_nr)\n    {\n\tif (l1.st_u.num.is_number != l2.st_u.num.is_number)\n\t    result = l1.st_u.num.is_number > l2.st_u.num.is_number ? 1 : -1;\n\telse\n\t    result = l1.st_u.num.value == l2.st_u.num.value ? 0\n\t\t\t     : l1.st_u.num.value > l2.st_u.num.value ? 1 : -1;\n    }\n    else if (sort_flt)\n\tresult = l1.st_u.value_flt == l2.st_u.value_flt ? 0\n\t\t\t     : l1.st_u.value_flt > l2.st_u.value_flt ? 1 : -1;\n    else\n    {\n\t// We need to copy one line into \"sortbuf1\", because there is no\n\t// guarantee that the first pointer becomes invalid when obtaining the\n\t// second one.\n\tSTRNCPY(sortbuf1, ml_get(l1.lnum) + l1.st_u.line.start_col_nr,\n\t\t     l1.st_u.line.end_col_nr - l1.st_u.line.start_col_nr + 1);\n\tsortbuf1[l1.st_u.line.end_col_nr - l1.st_u.line.start_col_nr] = 0;\n\tSTRNCPY(sortbuf2, ml_get(l2.lnum) + l2.st_u.line.start_col_nr,\n\t\t     l2.st_u.line.end_col_nr - l2.st_u.line.start_col_nr + 1);\n\tsortbuf2[l2.st_u.line.end_col_nr - l2.st_u.line.start_col_nr] = 0;\n\n\tresult = string_compare(sortbuf1, sortbuf2);\n    }\n\n    // If two lines have the same value, preserve the original line order.\n    if (result == 0)\n\treturn (int)(l1.lnum - l2.lnum);\n    return result;\n}\n\n/*\n * \":sort\".\n */\n    void\nex_sort(exarg_T *eap)\n{\n    regmatch_T\tregmatch;\n    int\t\tlen;\n    linenr_T\tlnum;\n    long\tmaxlen = 0;\n    sorti_T\t*nrs;\n    size_t\tcount = (size_t)(eap->line2 - eap->line1 + 1);\n    size_t\ti;\n    char_u\t*p;\n    char_u\t*s;\n    char_u\t*s2;\n    char_u\tc;\t\t\t// temporary character storage\n    int\t\tunique = FALSE;\n    long\tdeleted;\n    colnr_T\tstart_col;\n    colnr_T\tend_col;\n    int\t\tsort_what = 0;\n    int\t\tformat_found = 0;\n    int\t\tchange_occurred = FALSE; // Buffer contents changed.\n\n    // Sorting one line is really quick!\n    if (count <= 1)\n\treturn;\n\n    if (u_save((linenr_T)(eap->line1 - 1), (linenr_T)(eap->line2 + 1)) == FAIL)\n\treturn;\n    sortbuf1 = NULL;\n    sortbuf2 = NULL;\n    regmatch.regprog = NULL;\n    nrs = ALLOC_MULT(sorti_T, count);\n    if (nrs == NULL)\n\tgoto sortend;\n\n    sort_abort = sort_ic = sort_lc = sort_rx = sort_nr = 0;\n    sort_flt = 0;\n\n    for (p = eap->arg; *p != NUL; ++p)\n    {\n\tif (VIM_ISWHITE(*p))\n\t    ;\n\telse if (*p == 'i')\n\t    sort_ic = TRUE;\n\telse if (*p == 'l')\n\t    sort_lc = TRUE;\n\telse if (*p == 'r')\n\t    sort_rx = TRUE;\n\telse if (*p == 'n')\n\t{\n\t    sort_nr = 1;\n\t    ++format_found;\n\t}\n\telse if (*p == 'f')\n\t{\n\t    sort_flt = 1;\n\t    ++format_found;\n\t}\n\telse if (*p == 'b')\n\t{\n\t    sort_what = STR2NR_BIN + STR2NR_FORCE;\n\t    ++format_found;\n\t}\n\telse if (*p == 'o')\n\t{\n\t    sort_what = STR2NR_OCT + STR2NR_FORCE;\n\t    ++format_found;\n\t}\n\telse if (*p == 'x')\n\t{\n\t    sort_what = STR2NR_HEX + STR2NR_FORCE;\n\t    ++format_found;\n\t}\n\telse if (*p == 'u')\n\t    unique = TRUE;\n\telse if (*p == '\"')\t// comment start\n\t    break;\n\telse if (eap->nextcmd == NULL && check_nextcmd(p) != NULL)\n\t{\n\t    eap->nextcmd = check_nextcmd(p);\n\t    break;\n\t}\n\telse if (!ASCII_ISALPHA(*p) && regmatch.regprog == NULL)\n\t{\n\t    s = skip_regexp_err(p + 1, *p, TRUE);\n\t    if (s == NULL)\n\t\tgoto sortend;\n\t    *s = NUL;\n\t    // Use last search pattern if sort pattern is empty.\n\t    if (s == p + 1)\n\t    {\n\t\tif (last_search_pat() == NULL)\n\t\t{\n\t\t    emsg(_(e_no_previous_regular_expression));\n\t\t    goto sortend;\n\t\t}\n\t\tregmatch.regprog = vim_regcomp(last_search_pat(), RE_MAGIC);\n\t    }\n\t    else\n\t\tregmatch.regprog = vim_regcomp(p + 1, RE_MAGIC);\n\t    if (regmatch.regprog == NULL)\n\t\tgoto sortend;\n\t    p = s;\t\t// continue after the regexp\n\t    regmatch.rm_ic = p_ic;\n\t}\n\telse\n\t{\n\t    semsg(_(e_invalid_argument_str), p);\n\t    goto sortend;\n\t}\n    }\n\n    // Can only have one of 'n', 'b', 'o' and 'x'.\n    if (format_found > 1)\n    {\n\temsg(_(e_invalid_argument));\n\tgoto sortend;\n    }\n\n    // From here on \"sort_nr\" is used as a flag for any integer number\n    // sorting.\n    sort_nr += sort_what;\n\n    /*\n     * Make an array with all line numbers.  This avoids having to copy all\n     * the lines into allocated memory.\n     * When sorting on strings \"start_col_nr\" is the offset in the line, for\n     * numbers sorting it's the number to sort on.  This means the pattern\n     * matching and number conversion only has to be done once per line.\n     * Also get the longest line length for allocating \"sortbuf\".\n     */\n    for (lnum = eap->line1; lnum <= eap->line2; ++lnum)\n    {\n\ts = ml_get(lnum);\n\tlen = ml_get_len(lnum);\n\tif (maxlen < len)\n\t    maxlen = len;\n\n\tstart_col = 0;\n\tend_col = len;\n\tif (regmatch.regprog != NULL && vim_regexec(&regmatch, s, 0))\n\t{\n\t    if (sort_rx)\n\t    {\n\t\tstart_col = (colnr_T)(regmatch.startp[0] - s);\n\t\tend_col = (colnr_T)(regmatch.endp[0] - s);\n\t    }\n\t    else\n\t\tstart_col = (colnr_T)(regmatch.endp[0] - s);\n\t}\n\telse\n\t    if (regmatch.regprog != NULL)\n\t\tend_col = 0;\n\n\tif (sort_nr || sort_flt)\n\t{\n\t    // Make sure vim_str2nr() doesn't read any digits past the end\n\t    // of the match, by temporarily terminating the string there\n\t    s2 = s + end_col;\n\t    c = *s2;\n\t    *s2 = NUL;\n\t    // Sorting on number: Store the number itself.\n\t    p = s + start_col;\n\t    if (sort_nr)\n\t    {\n\t\tif (sort_what & STR2NR_HEX)\n\t\t    s = skiptohex(p);\n\t\telse if (sort_what & STR2NR_BIN)\n\t\t    s = skiptobin(p);\n\t\telse\n\t\t    s = skiptodigit(p);\n\t\tif (s > p && s[-1] == '-')\n\t\t    --s;  // include preceding negative sign\n\t\tif (*s == NUL)\n\t\t{\n\t\t    // line without number should sort before any number\n\t\t    nrs[lnum - eap->line1].st_u.num.is_number = FALSE;\n\t\t    nrs[lnum - eap->line1].st_u.num.value = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t    nrs[lnum - eap->line1].st_u.num.is_number = TRUE;\n\t\t    vim_str2nr(s, NULL, NULL, sort_what,\n\t\t\t&nrs[lnum - eap->line1].st_u.num.value,\n\t\t\tNULL, 0, FALSE, NULL);\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\ts = skipwhite(p);\n\t\tif (*s == '+')\n\t\t    s = skipwhite(s + 1);\n\n\t\tif (*s == NUL)\n\t\t    // empty line should sort before any number\n\t\t    nrs[lnum - eap->line1].st_u.value_flt = -DBL_MAX;\n\t\telse\n\t\t    nrs[lnum - eap->line1].st_u.value_flt =\n\t\t\t\t\t\t      strtod((char *)s, NULL);\n\t    }\n\t    *s2 = c;\n\t}\n\telse\n\t{\n\t    // Store the column to sort at.\n\t    nrs[lnum - eap->line1].st_u.line.start_col_nr = start_col;\n\t    nrs[lnum - eap->line1].st_u.line.end_col_nr = end_col;\n\t}\n\n\tnrs[lnum - eap->line1].lnum = lnum;\n\n\tif (regmatch.regprog != NULL)\n\t    fast_breakcheck();\n\tif (got_int)\n\t    goto sortend;\n    }\n\n    // Allocate a buffer that can hold the longest line.\n    sortbuf1 = alloc(maxlen + 1);\n    if (sortbuf1 == NULL)\n\tgoto sortend;\n    sortbuf2 = alloc(maxlen + 1);\n    if (sortbuf2 == NULL)\n\tgoto sortend;\n\n    // Sort the array of line numbers.  Note: can't be interrupted!\n    qsort((void *)nrs, count, sizeof(sorti_T), sort_compare);\n\n    if (sort_abort)\n\tgoto sortend;\n\n    // Insert the lines in the sorted order below the last one.\n    lnum = eap->line2;\n    for (i = 0; i < count; ++i)\n    {\n\tlinenr_T get_lnum = nrs[eap->forceit ? count - i - 1 : i].lnum;\n\n\t// If the original line number of the line being placed is not the same\n\t// as \"lnum\" (accounting for offset), we know that the buffer changed.\n\tif (get_lnum + ((linenr_T)count - 1) != lnum)\n\t    change_occurred = TRUE;\n\n\ts = ml_get(get_lnum);\n\tif (!unique || i == 0 || string_compare(s, sortbuf1) != 0)\n\t{\n\t    // Copy the line into a buffer, it may become invalid in\n\t    // ml_append(). And it's needed for \"unique\".\n\t    STRCPY(sortbuf1, s);\n\t    if (ml_append(lnum++, sortbuf1, (colnr_T)0, FALSE) == FAIL)\n\t\tbreak;\n\t}\n\tfast_breakcheck();\n\tif (got_int)\n\t    goto sortend;\n    }\n\n    // delete the original lines if appending worked\n    if (i == count)\n\tfor (i = 0; i < count; ++i)\n\t    ml_delete(eap->line1);\n    else\n\tcount = 0;\n\n    // Adjust marks for deleted (or added) lines and prepare for displaying.\n    deleted = (long)(count - (lnum - eap->line2));\n    if (deleted > 0)\n    {\n\tmark_adjust(eap->line2 - deleted, eap->line2, (long)MAXLNUM, -deleted);\n\tmsgmore(-deleted);\n    }\n    else if (deleted < 0)\n\tmark_adjust(eap->line2, MAXLNUM, -deleted, 0L);\n\n    if (change_occurred || deleted != 0)\n\tchanged_lines(eap->line1, 0, eap->line2 + 1, -deleted);\n\n    curwin->w_cursor.lnum = eap->line1;\n    beginline(BL_WHITE | BL_FIX);\n\nsortend:\n    vim_free(nrs);\n    vim_free(sortbuf1);\n    vim_free(sortbuf2);\n    vim_regfree(regmatch.regprog);\n    if (got_int)\n\temsg(_(e_interrupted));\n}\n\n/*\n * :move command - move lines line1-line2 to line dest\n *\n * return FAIL for failure, OK otherwise\n */\n    int\ndo_move(linenr_T line1, linenr_T line2, linenr_T dest)\n{\n    char_u\t*str;\n    linenr_T\tl;\n    linenr_T\textra;\t    // Num lines added before line1\n    linenr_T\tnum_lines;  // Num lines moved\n    linenr_T\tlast_line;  // Last line in file after adding new text\n#ifdef FEAT_FOLDING\n    win_T\t*win;\n    tabpage_T\t*tp;\n#endif\n\n    if (dest >= line1 && dest < line2)\n    {\n\temsg(_(e_cannot_move_range_of_lines_into_itself));\n\treturn FAIL;\n    }\n\n    // Do nothing if we are not actually moving any lines.  This will prevent\n    // the 'modified' flag from being set without cause.\n    if (dest == line1 - 1 || dest == line2)\n    {\n\t// Move the cursor as if lines were moved (see below) to be backwards\n\t// compatible.\n\tif (dest >= line1)\n\t    curwin->w_cursor.lnum = dest;\n\telse\n\t    curwin->w_cursor.lnum = dest + (line2 - line1) + 1;\n\n\treturn OK;\n    }\n\n    num_lines = line2 - line1 + 1;\n\n    /*\n     * First we copy the old text to its new location -- webb\n     * Also copy the flag that \":global\" command uses.\n     */\n    if (u_save(dest, dest + 1) == FAIL)\n\treturn FAIL;\n    for (extra = 0, l = line1; l <= line2; l++)\n    {\n\tstr = vim_strnsave(ml_get(l + extra), ml_get_len(l + extra));\n\tif (str != NULL)\n\t{\n\t    ml_append(dest + l - line1, str, (colnr_T)0, FALSE);\n\t    vim_free(str);\n\t    if (dest < line1)\n\t\textra++;\n\t}\n    }\n\n    /*\n     * Now we must be careful adjusting our marks so that we don't overlap our\n     * mark_adjust() calls.\n     *\n     * We adjust the marks within the old text so that they refer to the\n     * last lines of the file (temporarily), because we know no other marks\n     * will be set there since these line numbers did not exist until we added\n     * our new lines.\n     *\n     * Then we adjust the marks on lines between the old and new text positions\n     * (either forwards or backwards).\n     *\n     * And Finally we adjust the marks we put at the end of the file back to\n     * their final destination at the new text position -- webb\n     */\n    last_line = curbuf->b_ml.ml_line_count;\n    mark_adjust_nofold(line1, line2, last_line - line2, 0L);\n    if (dest >= line2)\n    {\n\tmark_adjust_nofold(line2 + 1, dest, -num_lines, 0L);\n#ifdef FEAT_FOLDING\n\tFOR_ALL_TAB_WINDOWS(tp, win)\n\t{\n\t    if (win->w_buffer == curbuf)\n\t\tfoldMoveRange(&win->w_folds, line1, line2, dest);\n\t}\n#endif\n\tif ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n\t{\n\t    curbuf->b_op_start.lnum = dest - num_lines + 1;\n\t    curbuf->b_op_end.lnum = dest;\n\t}\n    }\n    else\n    {\n\tmark_adjust_nofold(dest + 1, line1 - 1, num_lines, 0L);\n#ifdef FEAT_FOLDING\n\tFOR_ALL_TAB_WINDOWS(tp, win)\n\t{\n\t    if (win->w_buffer == curbuf)\n\t\tfoldMoveRange(&win->w_folds, dest + 1, line1 - 1, line2);\n\t}\n#endif\n\tif ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n\t{\n\t    curbuf->b_op_start.lnum = dest + 1;\n\t    curbuf->b_op_end.lnum = dest + num_lines;\n\t}\n    }\n    if ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n\tcurbuf->b_op_start.col = curbuf->b_op_end.col = 0;\n    mark_adjust_nofold(last_line - num_lines + 1, last_line,\n\t\t\t\t\t     -(last_line - dest - extra), 0L);\n\n    /*\n     * Now we delete the original text -- webb\n     */\n    if (u_save(line1 + extra - 1, line2 + extra + 1) == FAIL)\n\treturn FAIL;\n\n    for (l = line1; l <= line2; l++)\n\tml_delete_flags(line1 + extra, ML_DEL_MESSAGE);\n\n    if (!global_busy && num_lines > p_report)\n\tsmsg(NGETTEXT(\"%ld line moved\", \"%ld lines moved\", num_lines),\n\t\t\t(long)num_lines);\n\n    /*\n     * Leave the cursor on the last of the moved lines.\n     */\n    if (dest >= line1)\n\tcurwin->w_cursor.lnum = dest;\n    else\n\tcurwin->w_cursor.lnum = dest + (line2 - line1) + 1;\n\n    if (line1 < dest)\n    {\n\tdest += num_lines + 1;\n\tlast_line = curbuf->b_ml.ml_line_count;\n\tif (dest > last_line + 1)\n\t    dest = last_line + 1;\n\tchanged_lines(line1, 0, dest, 0L);\n    }\n    else\n\tchanged_lines(dest + 1, 0, line1 + num_lines, 0L);\n\n    return OK;\n}\n\n/*\n * \":copy\"\n */\n    void\nex_copy(linenr_T line1, linenr_T line2, linenr_T n)\n{\n    linenr_T\tcount;\n    char_u\t*p;\n\n    count = line2 - line1 + 1;\n    if ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n    {\n\tcurbuf->b_op_start.lnum = n + 1;\n\tcurbuf->b_op_end.lnum = n + count;\n\tcurbuf->b_op_start.col = curbuf->b_op_end.col = 0;\n    }\n\n    /*\n     * there are three situations:\n     * 1. destination is above line1\n     * 2. destination is between line1 and line2\n     * 3. destination is below line2\n     *\n     * n = destination (when starting)\n     * curwin->w_cursor.lnum = destination (while copying)\n     * line1 = start of source (while copying)\n     * line2 = end of source (while copying)\n     */\n    if (u_save(n, n + 1) == FAIL)\n\treturn;\n\n    curwin->w_cursor.lnum = n;\n    while (line1 <= line2)\n    {\n\t// need to make a copy because the line will be unlocked within\n\t// ml_append()\n\tp = vim_strnsave(ml_get(line1), ml_get_len(line1));\n\tif (p != NULL)\n\t{\n\t    ml_append(curwin->w_cursor.lnum, p, (colnr_T)0, FALSE);\n\t    vim_free(p);\n\t}\n\t// situation 2: skip already copied lines\n\tif (line1 == n)\n\t    line1 = curwin->w_cursor.lnum;\n\t++line1;\n\tif (curwin->w_cursor.lnum < line1)\n\t    ++line1;\n\tif (curwin->w_cursor.lnum < line2)\n\t    ++line2;\n\t++curwin->w_cursor.lnum;\n    }\n\n    appended_lines_mark(n, count);\n    if (VIsual_active)\n\tcheck_pos(curbuf, &VIsual);\n\n    msgmore((long)count);\n}\n\nstatic char_u\t*prevcmd = NULL;\t// the previous command\n\n#if defined(EXITFREE) || defined(PROTO)\n    void\nfree_prev_shellcmd(void)\n{\n    vim_free(prevcmd);\n}\n#endif\n\n/*\n * Check that \"prevcmd\" is not NULL.  If it is NULL then give an error message\n * and return FALSE.\n */\n    static int\nprevcmd_is_set(void)\n{\n    if (prevcmd == NULL)\n    {\n\temsg(_(e_no_previous_command));\n\treturn FALSE;\n    }\n    return TRUE;\n}\n\n/*\n * Handle the \":!cmd\" command.\tAlso for \":r !cmd\" and \":w !cmd\"\n * Bangs in the argument are replaced with the previously entered command.\n * Remember the argument.\n */\n    void\ndo_bang(\n    int\t\taddr_count,\n    exarg_T\t*eap,\n    int\t\tforceit,\n    int\t\tdo_in,\n    int\t\tdo_out)\n{\n    char_u\t\t*arg = eap->arg;\t// command\n    linenr_T\t\tline1 = eap->line1;\t// start of range\n    linenr_T\t\tline2 = eap->line2;\t// end of range\n    char_u\t\t*newcmd = NULL;\t\t// the new command\n    int\t\t\tfree_newcmd = FALSE;    // need to free() newcmd\n    int\t\t\tins_prevcmd;\n    char_u\t\t*t;\n    char_u\t\t*p;\n    char_u\t\t*trailarg;\n    int\t\t\tlen;\n    int\t\t\tscroll_save = msg_scroll;\n\n    /*\n     * Disallow shell commands for \"rvim\".\n     * Disallow shell commands from .exrc and .vimrc in current directory for\n     * security reasons.\n     */\n    if (check_restricted() || check_secure())\n\treturn;\n\n    if (addr_count == 0)\t\t// :!\n    {\n\tmsg_scroll = FALSE;\t    // don't scroll here\n\tautowrite_all();\n\tmsg_scroll = scroll_save;\n    }\n\n    /*\n     * Try to find an embedded bang, like in \":!<cmd> ! [args]\"\n     * \":!!\" is indicated by the 'forceit' variable.\n     */\n    ins_prevcmd = forceit;\n\n    // Skip leading white space to avoid a strange error with some shells.\n    trailarg = skipwhite(arg);\n    do\n    {\n\tlen = (int)STRLEN(trailarg) + 1;\n\tif (newcmd != NULL)\n\t    len += (int)STRLEN(newcmd);\n\tif (ins_prevcmd)\n\t{\n\t    if (!prevcmd_is_set())\n\t    {\n\t\tvim_free(newcmd);\n\t\treturn;\n\t    }\n\t    len += (int)STRLEN(prevcmd);\n\t}\n\tif ((t = alloc(len)) == NULL)\n\t{\n\t    vim_free(newcmd);\n\t    return;\n\t}\n\t*t = NUL;\n\tif (newcmd != NULL)\n\t    STRCAT(t, newcmd);\n\tif (ins_prevcmd)\n\t    STRCAT(t, prevcmd);\n\tp = t + STRLEN(t);\n\tSTRCAT(t, trailarg);\n\tvim_free(newcmd);\n\tnewcmd = t;\n\n\t/*\n\t * Scan the rest of the argument for '!', which is replaced by the\n\t * previous command.  \"\\!\" is replaced by \"!\" (this is vi compatible).\n\t */\n\ttrailarg = NULL;\n\twhile (*p)\n\t{\n\t    if (*p == '!')\n\t    {\n\t\tif (p > newcmd && p[-1] == '\\\\')\n\t\t    STRMOVE(p - 1, p);\n\t\telse\n\t\t{\n\t\t    trailarg = p;\n\t\t    *trailarg++ = NUL;\n\t\t    ins_prevcmd = TRUE;\n\t\t    break;\n\t\t}\n\t    }\n\t    ++p;\n\t}\n    } while (trailarg != NULL);\n\n    // Only set \"prevcmd\" if there is a command to run, otherwise keep te one\n    // we have.\n    if (STRLEN(newcmd) > 0)\n    {\n\tvim_free(prevcmd);\n\tprevcmd = newcmd;\n    }\n    else\n\tfree_newcmd = TRUE;\n\n    if (bangredo)\t    // put cmd in redo buffer for ! command\n    {\n\tif (!prevcmd_is_set())\n\t    goto theend;\n\n\t// If % or # appears in the command, it must have been escaped.\n\t// Reescape them, so that redoing them does not substitute them by the\n\t// buffername.\n\tchar_u *cmd = vim_strsave_escaped(prevcmd, (char_u *)\"%#\");\n\n\tif (cmd != NULL)\n\t{\n\t    AppendToRedobuffLit(cmd, -1);\n\t    vim_free(cmd);\n\t}\n\telse\n\t    AppendToRedobuffLit(prevcmd, -1);\n\tAppendToRedobuff((char_u *)\"\\n\");\n\tbangredo = FALSE;\n    }\n    /*\n     * Add quotes around the command, for shells that need them.\n     */\n    if (*p_shq != NUL)\n    {\n\tif (free_newcmd)\n\t    vim_free(newcmd);\n\tnewcmd = alloc(STRLEN(prevcmd) + 2 * STRLEN(p_shq) + 1);\n\tif (newcmd == NULL)\n\t    return;\n\tSTRCPY(newcmd, p_shq);\n\tSTRCAT(newcmd, prevcmd);\n\tSTRCAT(newcmd, p_shq);\n\tfree_newcmd = TRUE;\n    }\n    if (addr_count == 0)\t\t// :!\n    {\n\t// echo the command\n\tmsg_start();\n\tmsg_putchar(':');\n\tmsg_putchar('!');\n\tmsg_outtrans(newcmd);\n\tmsg_clr_eos();\n\twindgoto(msg_row, msg_col);\n\n\tdo_shell(newcmd, 0);\n    }\n    else\t\t\t\t// :range!\n    {\n\t// Careful: This may recursively call do_bang() again! (because of\n\t// autocommands)\n\tdo_filter(line1, line2, eap, newcmd, do_in, do_out);\n\tapply_autocmds(EVENT_SHELLFILTERPOST, NULL, NULL, FALSE, curbuf);\n    }\n\ntheend:\n    if (free_newcmd)\n\tvim_free(newcmd);\n}\n\n/*\n * do_filter: filter lines through a command given by the user\n *\n * We mostly use temp files and the call_shell() routine here. This would\n * normally be done using pipes on a UNIX machine, but this is more portable\n * to non-unix machines. The call_shell() routine needs to be able\n * to deal with redirection somehow, and should handle things like looking\n * at the PATH env. variable, and adding reasonable extensions to the\n * command name given by the user. All reasonable versions of call_shell()\n * do this.\n * Alternatively, if on Unix and redirecting input or output, but not both,\n * and the 'shelltemp' option isn't set, use pipes.\n * We use input redirection if do_in is TRUE.\n * We use output redirection if do_out is TRUE.\n */\n    static void\ndo_filter(\n    linenr_T\tline1,\n    linenr_T\tline2,\n    exarg_T\t*eap,\t\t// for forced 'ff' and 'fenc'\n    char_u\t*cmd,\n    int\t\tdo_in,\n    int\t\tdo_out)\n{\n    char_u\t*itmp = NULL;\n    char_u\t*otmp = NULL;\n    linenr_T\tlinecount;\n    linenr_T\tread_linecount;\n    pos_T\tcursor_save;\n    char_u\t*cmd_buf;\n    buf_T\t*old_curbuf = curbuf;\n    int\t\tshell_flags = 0;\n    pos_T\torig_start = curbuf->b_op_start;\n    pos_T\torig_end = curbuf->b_op_end;\n    int\t\tsave_cmod_flags = cmdmod.cmod_flags;\n#ifdef FEAT_FILTERPIPE\n    int\t\tstmp = p_stmp;\n#endif\n\n    if (*cmd == NUL)\t    // no filter command\n\treturn;\n\n    // Temporarily disable lockmarks since that's needed to propagate changed\n    // regions of the buffer for foldUpdate(), linecount, etc.\n    cmdmod.cmod_flags &= ~CMOD_LOCKMARKS;\n\n    cursor_save = curwin->w_cursor;\n    linecount = line2 - line1 + 1;\n    curwin->w_cursor.lnum = line1;\n    curwin->w_cursor.col = 0;\n    changed_line_abv_curs();\n    invalidate_botline();\n\n    /*\n     * When using temp files:\n     * 1. * Form temp file names\n     * 2. * Write the lines to a temp file\n     * 3.   Run the filter command on the temp file\n     * 4. * Read the output of the command into the buffer\n     * 5. * Delete the original lines to be filtered\n     * 6. * Remove the temp files\n     *\n     * When writing the input with a pipe or when catching the output with a\n     * pipe only need to do 3.\n     */\n\n    if (do_out)\n\tshell_flags |= SHELL_DOOUT;\n\n#ifdef FEAT_FILTERPIPE\n# ifdef VIMDLL\n    if (!gui.in_use && !gui.starting)\n\tstmp = 1;   // Console mode doesn't support filterpipe.\n# endif\n\n    if (!do_in && do_out && !stmp)\n    {\n\t// Use a pipe to fetch stdout of the command, do not use a temp file.\n\tshell_flags |= SHELL_READ;\n\tcurwin->w_cursor.lnum = line2;\n    }\n    else if (do_in && !do_out && !stmp)\n    {\n\t// Use a pipe to write stdin of the command, do not use a temp file.\n\tshell_flags |= SHELL_WRITE;\n\tcurbuf->b_op_start.lnum = line1;\n\tcurbuf->b_op_end.lnum = line2;\n    }\n    else if (do_in && do_out && !stmp)\n    {\n\t// Use a pipe to write stdin and fetch stdout of the command, do not\n\t// use a temp file.\n\tshell_flags |= SHELL_READ|SHELL_WRITE;\n\tcurbuf->b_op_start.lnum = line1;\n\tcurbuf->b_op_end.lnum = line2;\n\tcurwin->w_cursor.lnum = line2;\n    }\n    else\n#endif\n\tif ((do_in && (itmp = vim_tempname('i', FALSE)) == NULL)\n\t\t|| (do_out && (otmp = vim_tempname('o', FALSE)) == NULL))\n\t{\n\t    emsg(_(e_cant_get_temp_file_name));\n\t    goto filterend;\n\t}\n\n/*\n * The writing and reading of temp files will not be shown.\n * Vi also doesn't do this and the messages are not very informative.\n */\n    ++no_wait_return;\t\t// don't call wait_return() while busy\n    if (itmp != NULL && buf_write(curbuf, itmp, NULL, line1, line2, eap,\n\t\t\t\t\t   FALSE, FALSE, FALSE, TRUE) == FAIL)\n    {\n\tmsg_putchar('\\n');\t\t// keep message from buf_write()\n\t--no_wait_return;\n#if defined(FEAT_EVAL)\n\tif (!aborting())\n#endif\n\t    // will call wait_return()\n\t    (void)semsg(_(e_cant_create_file_str), itmp);\n\tgoto filterend;\n    }\n    if (curbuf != old_curbuf)\n\tgoto filterend;\n\n    if (!do_out)\n\tmsg_putchar('\\n');\n\n    // Create the shell command in allocated memory.\n    cmd_buf = make_filter_cmd(cmd, itmp, otmp);\n    if (cmd_buf == NULL)\n\tgoto filterend;\n\n    windgoto((int)Rows - 1, 0);\n    cursor_on();\n\n    /*\n     * When not redirecting the output the command can write anything to the\n     * screen. If 'shellredir' is equal to \">\", screen may be messed up by\n     * stderr output of external command. Clear the screen later.\n     * If do_in is FALSE, this could be something like \":r !cat\", which may\n     * also mess up the screen, clear it later.\n     */\n    if (!do_out || STRCMP(p_srr, \">\") == 0 || !do_in)\n\tredraw_later_clear();\n\n    if (do_out)\n    {\n\tif (u_save(line2, (linenr_T)(line2 + 1)) == FAIL)\n\t{\n\t    vim_free(cmd_buf);\n\t    goto error;\n\t}\n\tredraw_curbuf_later(UPD_VALID);\n    }\n    read_linecount = curbuf->b_ml.ml_line_count;\n\n    /*\n     * When call_shell() fails wait_return() is called to give the user a\n     * chance to read the error messages. Otherwise errors are ignored, so you\n     * can see the error messages from the command that appear on stdout; use\n     * 'u' to fix the text\n     * Switch to cooked mode when not redirecting stdin, avoids that something\n     * like \":r !cat\" hangs.\n     * Pass on the SHELL_DOOUT flag when the output is being redirected.\n     */\n    if (call_shell(cmd_buf, SHELL_FILTER | SHELL_COOKED | shell_flags))\n    {\n\tredraw_later_clear();\n\twait_return(FALSE);\n    }\n    vim_free(cmd_buf);\n\n    did_check_timestamps = FALSE;\n    need_check_timestamps = TRUE;\n\n    // When interrupting the shell command, it may still have produced some\n    // useful output.  Reset got_int here, so that readfile() won't cancel\n    // reading.\n    ui_breakcheck();\n    got_int = FALSE;\n\n    if (do_out)\n    {\n\tif (otmp != NULL)\n\t{\n\t    if (readfile(otmp, NULL, line2, (linenr_T)0, (linenr_T)MAXLNUM,\n\t\t\t\t\t\t    eap, READ_FILTER) != OK)\n\t    {\n#if defined(FEAT_EVAL)\n\t\tif (!aborting())\n#endif\n\t\t{\n\t\t    msg_putchar('\\n');\n\t\t    semsg(_(e_cant_read_file_str), otmp);\n\t\t}\n\t\tgoto error;\n\t    }\n\t    if (curbuf != old_curbuf)\n\t\tgoto filterend;\n\t}\n\n\tread_linecount = curbuf->b_ml.ml_line_count - read_linecount;\n\n\tif (shell_flags & SHELL_READ)\n\t{\n\t    curbuf->b_op_start.lnum = line2 + 1;\n\t    curbuf->b_op_end.lnum = curwin->w_cursor.lnum;\n\t    appended_lines_mark(line2, read_linecount);\n\t}\n\n\tif (do_in)\n\t{\n\t    if ((cmdmod.cmod_flags & CMOD_KEEPMARKS)\n\t\t\t\t     || vim_strchr(p_cpo, CPO_REMMARK) == NULL)\n\t    {\n\t\tif (read_linecount >= linecount)\n\t\t    // move all marks from old lines to new lines\n\t\t    mark_adjust(line1, line2, linecount, 0L);\n\t\telse if (save_cmod_flags & CMOD_LOCKMARKS)\n\t\t{\n\t\t    // Move marks from the lines below the new lines down by\n\t\t    // the number of lines lost.\n\t\t    // Move marks from the lines that will be deleted to the\n\t\t    // new lines and below.\n\t\t    mark_adjust(line2 + 1, (linenr_T)MAXLNUM,\n\t\t\t\t\t       linecount - read_linecount, 0L);\n\t\t    mark_adjust(line1, line2, linecount, 0L);\n\t\t}\n\t\telse\n\t\t{\n\t\t    // move marks from old lines to new lines, delete marks\n\t\t    // that are in deleted lines\n\t\t    mark_adjust(line1, line1 + read_linecount - 1,\n\t\t\t\t\t\t\t\tlinecount, 0L);\n\t\t    mark_adjust(line1 + read_linecount, line2, MAXLNUM, 0L);\n\t\t}\n\t    }\n\n\t    /*\n\t     * Put cursor on first filtered line for \":range!cmd\".\n\t     * Adjust '[ and '] (set by buf_write()).\n\t     */\n\t    curwin->w_cursor.lnum = line1;\n\t    del_lines(linecount, TRUE);\n\t    curbuf->b_op_start.lnum -= linecount;\t// adjust '[\n\t    curbuf->b_op_end.lnum -= linecount;\t\t// adjust ']\n\t    write_lnum_adjust(-linecount);\t\t// adjust last line\n\t\t\t\t\t\t\t// for next write\n#ifdef FEAT_FOLDING\n\t    foldUpdate(curwin, curbuf->b_op_start.lnum, curbuf->b_op_end.lnum);\n#endif\n\t}\n\telse\n\t{\n\t    /*\n\t     * Put cursor on last new line for \":r !cmd\".\n\t     */\n\t    linecount = curbuf->b_op_end.lnum - curbuf->b_op_start.lnum + 1;\n\t    curwin->w_cursor.lnum = curbuf->b_op_end.lnum;\n\t}\n\n\tbeginline(BL_WHITE | BL_FIX);\t    // cursor on first non-blank\n\t--no_wait_return;\n\n\tif (linecount > p_report)\n\t{\n\t    if (do_in)\n\t    {\n\t\tvim_snprintf(msg_buf, sizeof(msg_buf),\n\t\t\t\t    _(\"%ld lines filtered\"), (long)linecount);\n\t\tif (msg(msg_buf) && !msg_scroll)\n\t\t    // save message to display it after redraw\n\t\t    set_keep_msg((char_u *)msg_buf, 0);\n\t    }\n\t    else\n\t\tmsgmore((long)linecount);\n\t}\n    }\n    else\n    {\nerror:\n\t// put cursor back in same position for \":w !cmd\"\n\tcurwin->w_cursor = cursor_save;\n\t--no_wait_return;\n\twait_return(FALSE);\n    }\n\nfilterend:\n\n    cmdmod.cmod_flags = save_cmod_flags;\n    if (curbuf != old_curbuf)\n    {\n\t--no_wait_return;\n\temsg(_(e_filter_autocommands_must_not_change_current_buffer));\n    }\n    else if (cmdmod.cmod_flags & CMOD_LOCKMARKS)\n    {\n\tcurbuf->b_op_start = orig_start;\n\tcurbuf->b_op_end = orig_end;\n    }\n\n    if (itmp != NULL)\n\tmch_remove(itmp);\n    if (otmp != NULL)\n\tmch_remove(otmp);\n    vim_free(itmp);\n    vim_free(otmp);\n}\n\n/*\n * Call a shell to execute a command.\n * When \"cmd\" is NULL start an interactive shell.\n */\n    void\ndo_shell(\n    char_u\t*cmd,\n    int\t\tflags)\t// may be SHELL_DOOUT when output is redirected\n{\n    buf_T\t*buf;\n#if !defined(FEAT_GUI_MSWIN) || defined(VIMDLL)\n    int\t\tsave_nwr;\n#endif\n#ifdef MSWIN\n    int\t\twinstart = FALSE;\n#endif\n    int\t\tkeep_termcap = !termcap_active;\n\n    /*\n     * Disallow shell commands for \"rvim\".\n     * Disallow shell commands from .exrc and .vimrc in current directory for\n     * security reasons.\n     */\n    if (check_restricted() || check_secure())\n    {\n\tmsg_end();\n\treturn;\n    }\n\n#ifdef MSWIN\n    /*\n     * Check if \":!start\" is used.  This implies not stopping termcap mode.\n     */\n    if (cmd != NULL)\n\tkeep_termcap = winstart = (STRNICMP(cmd, \"start \", 6) == 0);\n\n# if defined(FEAT_GUI) && defined(FEAT_TERMINAL)\n    // Don't stop termcap mode when using a terminal window for the shell.\n    if (gui.in_use && vim_strchr(p_go, GO_TERMINAL) != NULL)\n\tkeep_termcap = TRUE;\n# endif\n#endif\n\n    /*\n     * For autocommands we want to get the output on the current screen, to\n     * avoid having to type return below.\n     */\n    msg_putchar('\\r');\t\t\t// put cursor at start of line\n    if (!autocmd_busy)\n    {\n\tif (!keep_termcap)\n\t    stoptermcap();\n    }\n#ifdef MSWIN\n    if (!winstart)\n#endif\n\tmsg_putchar('\\n');\t\t// may shift screen one line up\n\n    // warning message before calling the shell\n    if (p_warn && !autocmd_busy && msg_silent == 0)\n\tFOR_ALL_BUFFERS(buf)\n\t    if (bufIsChangedNotTerm(buf))\n\t    {\n#ifdef FEAT_GUI_MSWIN\n\t\tif (!keep_termcap)\n\t\t    starttermcap();\t// don't want a message box here\n#endif\n\t\tmsg_puts(_(\"[No write since last change]\\n\"));\n#ifdef FEAT_GUI_MSWIN\n\t\tif (!keep_termcap)\n\t\t    stoptermcap();\n#endif\n\t\tbreak;\n\t    }\n\n    // This windgoto is required for when the '\\n' resulted in a \"delete line\n    // 1\" command to the terminal.\n    if (!swapping_screen())\n\twindgoto(msg_row, msg_col);\n    cursor_on();\n    (void)call_shell(cmd, SHELL_COOKED | flags);\n    did_check_timestamps = FALSE;\n    need_check_timestamps = TRUE;\n\n    /*\n     * put the message cursor at the end of the screen, avoids wait_return()\n     * to overwrite the text that the external command showed\n     */\n    if (!swapping_screen())\n    {\n\tmsg_row = Rows - 1;\n\tmsg_col = 0;\n    }\n\n    if (autocmd_busy)\n    {\n\tif (msg_silent == 0)\n\t    redraw_later_clear();\n    }\n    else\n    {\n\t/*\n\t * For \":sh\" there is no need to call wait_return(), just redraw.\n\t * Also for the Win32 GUI (the output is in a console window).\n\t * Otherwise there is probably text on the screen that the user wants\n\t * to read before redrawing, so call wait_return().\n\t */\n#if !defined(FEAT_GUI_MSWIN) || defined(VIMDLL)\n# ifdef VIMDLL\n\tif (!gui.in_use)\n# endif\n\t{\n\t    if (cmd == NULL\n# ifdef MSWIN\n\t\t    || (keep_termcap && !need_wait_return)\n# endif\n\t       )\n\t    {\n\t\tif (msg_silent == 0)\n\t\t    redraw_later_clear();\n\t\tneed_wait_return = FALSE;\n\t    }\n\t    else\n\t    {\n\t\t/*\n\t\t * If we switch screens when starttermcap() is called, we\n\t\t * really want to wait for \"hit return to continue\".\n\t\t */\n\t\tsave_nwr = no_wait_return;\n\t\tif (swapping_screen())\n\t\t    no_wait_return = FALSE;\n# ifdef AMIGA\n\t\twait_return(term_console ? -1 : msg_silent == 0); // see below\n# else\n\t\twait_return(msg_silent == 0);\n# endif\n\t\tno_wait_return = save_nwr;\n\t    }\n\t}\n#endif // FEAT_GUI_MSWIN\n\n\tif (!keep_termcap)\t// if keep_termcap is TRUE didn't stop termcap\n\t    starttermcap();\t// start termcap if not done by wait_return()\n\n\t/*\n\t * In an Amiga window redrawing is caused by asking the window size.\n\t * If we got an interrupt this will not work. The chance that the\n\t * window size is wrong is very small, but we need to redraw the\n\t * screen.  Don't do this if ':' hit in wait_return().\tTHIS IS UGLY\n\t * but it saves an extra redraw.\n\t */\n#ifdef AMIGA\n\tif (skip_redraw)\t\t// ':' hit in wait_return()\n\t{\n\t    if (msg_silent == 0)\n\t\tredraw_later_clear();\n\t}\n\telse if (term_console)\n\t{\n\t    OUT_STR(\"\\033[0 q\");\t// get window size\n\t    if (got_int && msg_silent == 0)\n\t\tredraw_later_clear();\t// if got_int is TRUE, redraw needed\n\t    else\n\t\tmust_redraw = 0;\t// no extra redraw needed\n\t}\n#endif\n    }\n\n    // display any error messages now\n    display_errors();\n\n    apply_autocmds(EVENT_SHELLCMDPOST, NULL, NULL, FALSE, curbuf);\n}\n\n#if !defined(UNIX)\n    static char_u *\nfind_pipe(char_u *cmd)\n{\n    char_u  *p;\n    int\t    inquote = FALSE;\n\n    for (p = cmd; *p != NUL; ++p)\n    {\n\tif (!inquote && *p == '|')\n\t    return p;\n\tif (*p == '\"')\n\t    inquote = !inquote;\n\telse if (rem_backslash(p))\n\t    ++p;\n    }\n    return NULL;\n}\n#endif\n\n/*\n * Create a shell command from a command string, input redirection file and\n * output redirection file.\n * Returns an allocated string with the shell command, or NULL for failure.\n */\n    char_u *\nmake_filter_cmd(\n    char_u\t*cmd,\t\t// command\n    char_u\t*itmp,\t\t// NULL or name of input file\n    char_u\t*otmp)\t\t// NULL or name of output file\n{\n    char_u\t*buf;\n    long_u\tlen;\n    int\t\tis_powershell = FALSE;\n#ifdef UNIX\n    int\t\tis_fish_shell;\n#endif\n\n    char_u *shell_name = get_isolated_shell_name();\n    if (shell_name == NULL)\n\treturn NULL;\n\n#if defined(UNIX)\n    // Account for fish's different syntax for subshells\n    is_fish_shell = fnamecmp(shell_name, \"fish\") == 0;\n    if (is_fish_shell)\n\tlen = (long_u)STRLEN(cmd) + 13;\t\t// \"begin; \" + \"; end\" + NUL\n    else\n#endif\n    {\n\tis_powershell = (shell_name[0] == 'p')\n\t\t\t&& (fnamecmp(shell_name, \"powershell\") == 0\n\t\t\t\t|| fnamecmp(shell_name, \"powershell.exe\") == 0\n\t\t\t\t|| fnamecmp(shell_name, \"pwsh\") == 0\n\t\t\t\t|| fnamecmp(shell_name, \"pwsh.exe\") == 0);\n\tlen = (long_u)STRLEN(cmd) + 3;\t\t// \"()\" + NUL\n    }\n\n    if (itmp != NULL)\n    {\n\tif (is_powershell)\n\t    // \"& { Get-Content \" + \" | & \" + \" }\"\n\t    len += (long_u)STRLEN(itmp) + 24;\n\telse\n\t    len += (long_u)STRLEN(itmp) + 9;\t// \" { < \" + \" } \"\n    }\n    if (otmp != NULL)\n\tlen += (long_u)STRLEN(otmp) + (long_u)STRLEN(p_srr) + 2; // \"  \"\n\n    vim_free(shell_name);\n\n    buf = alloc(len);\n    if (buf == NULL)\n\treturn NULL;\n\n    if (is_powershell)\n    {\n\tif (itmp != NULL)\n\t    vim_snprintf((char *)buf, len, \"& { Get-Content %s | & %s }\",\n\t\t\t\t\t\t\t\titmp, cmd);\n\telse\n\t    vim_snprintf((char *)buf, len, \"(%s)\", cmd);\n    }\n    else\n    {\n#if defined(UNIX)\n\t// Put braces around the command (for concatenated commands) when\n\t// redirecting input and/or output.\n\tif (itmp != NULL || otmp != NULL)\n\t{\n\t    if (is_fish_shell)\n\t\tvim_snprintf((char *)buf, len, \"begin; %s; end\", (char *)cmd);\n\t    else\n\t\tvim_snprintf((char *)buf, len, \"(%s)\", (char *)cmd);\n\t}\n\telse\n\t    STRCPY(buf, cmd);\n\tif (itmp != NULL)\n\t{\n\t    STRCAT(buf, \" < \");\n\t    STRCAT(buf, itmp);\n\t}\n#else\n\t// For shells that don't understand braces around commands, at least\n\t// allow the use of commands in a pipe.\n\tif (*p_sxe != NUL && *p_sxq == '(')\n\t{\n\t    if (itmp != NULL || otmp != NULL)\n\t\tvim_snprintf((char *)buf, len, \"(%s)\", (char *)cmd);\n\t    else\n\t\tSTRCPY(buf, cmd);\n\t    if (itmp != NULL)\n\t    {\n\t\tSTRCAT(buf, \" < \");\n\t\tSTRCAT(buf, itmp);\n\t    }\n\t}\n\telse\n\t{\n\t    STRCPY(buf, cmd);\n\t    if (itmp != NULL)\n\t    {\n\t\tchar_u\t*p;\n\n\t\t// If there is a pipe, we have to put the '<' in front of it.\n\t\t// Don't do this when 'shellquote' is not empty, otherwise the\n\t\t// redirection would be inside the quotes.\n\t\tif (*p_shq == NUL)\n\t\t{\n\t\t    p = find_pipe(buf);\n\t\t    if (p != NULL)\n\t\t\t*p = NUL;\n\t\t}\n\t\tSTRCAT(buf, \" <\");\t// \" < \" causes problems on Amiga\n\t\tSTRCAT(buf, itmp);\n\t\tif (*p_shq == NUL)\n\t\t{\n\t\t    p = find_pipe(cmd);\n\t\t    if (p != NULL)\n\t\t    {\n\t\t\t// insert a space before the '|' for DOS\n\t\t\tSTRCAT(buf, \" \");\n\t\t\tSTRCAT(buf, p);\n\t\t    }\n\t\t}\n\t    }\n\t}\n#endif\n    }\n    if (otmp != NULL)\n\tappend_redir(buf, (int)len, p_srr, otmp);\n\n    return buf;\n}\n\n/*\n * Append output redirection for file \"fname\" to the end of string buffer\n * \"buf[buflen]\"\n * Works with the 'shellredir' and 'shellpipe' options.\n * The caller should make sure that there is enough room:\n *\tSTRLEN(opt) + STRLEN(fname) + 3\n */\n    void\nappend_redir(\n    char_u\t*buf,\n    int\t\tbuflen,\n    char_u\t*opt,\n    char_u\t*fname)\n{\n    char_u\t*p;\n    char_u\t*end;\n\n    end = buf + STRLEN(buf);\n    // find \"%s\"\n    for (p = opt; (p = vim_strchr(p, '%')) != NULL; ++p)\n    {\n\tif (p[1] == 's') // found %s\n\t    break;\n\tif (p[1] == '%') // skip %%\n\t    ++p;\n    }\n    if (p != NULL)\n    {\n#ifdef MSWIN\n\t*end++ = ' '; // not really needed? Not with sh, ksh or bash\n#endif\n\tvim_snprintf((char *)end, (size_t)(buflen - (end - buf)),\n\t\t\t\t\t\t  (char *)opt, (char *)fname);\n    }\n    else\n\tvim_snprintf((char *)end, (size_t)(buflen - (end - buf)), \" %s %s\",\n\t\t(char *)opt, (char *)fname);\n}\n\n/*\n * Implementation of \":fixdel\", also used by get_stty().\n *  <BS>    resulting <Del>\n *   ^?\t\t^H\n * not ^?\t^?\n */\n    void\ndo_fixdel(exarg_T *eap UNUSED)\n{\n    char_u  *p;\n\n    p = find_termcode((char_u *)\"kb\");\n    add_termcode((char_u *)\"kD\", p != NULL\n\t    && *p == DEL ? (char_u *)CTRL_H_STR : DEL_STR, FALSE);\n}\n\n    void\nprint_line_no_prefix(\n    linenr_T\tlnum,\n    int\t\tuse_number,\n    int\t\tlist)\n{\n    char\tnumbuf[30];\n\n    if (curwin->w_p_nu || use_number)\n    {\n\tvim_snprintf(numbuf, sizeof(numbuf),\n\t\t\t\t   \"%*ld \", number_width(curwin), (long)lnum);\n\tmsg_puts_attr(numbuf, HL_ATTR(HLF_N));\t// Highlight line nrs\n    }\n    msg_prt_line(ml_get(lnum), list);\n}\n\n/*\n * Print a text line.  Also in silent mode (\"ex -s\").\n */\n    void\nprint_line(linenr_T lnum, int use_number, int list)\n{\n    int\t\tsave_silent = silent_mode;\n\n    // apply :filter /pat/\n    if (message_filtered(ml_get(lnum)))\n\treturn;\n\n    msg_start();\n    silent_mode = FALSE;\n    info_message = TRUE;\t// use mch_msg(), not mch_errmsg()\n    print_line_no_prefix(lnum, use_number, list);\n    if (save_silent)\n    {\n\tmsg_putchar('\\n');\n\tcursor_on();\t\t// msg_start() switches it off\n\tout_flush();\n\tsilent_mode = save_silent;\n    }\n    info_message = FALSE;\n}\n\n    int\nrename_buffer(char_u *new_fname)\n{\n    char_u\t*fname, *sfname, *xfname;\n    buf_T\t*buf;\n\n    buf = curbuf;\n    apply_autocmds(EVENT_BUFFILEPRE, NULL, NULL, FALSE, curbuf);\n    // buffer changed, don't change name now\n    if (buf != curbuf)\n\treturn FAIL;\n#ifdef FEAT_EVAL\n    if (aborting())\t    // autocmds may abort script processing\n\treturn FAIL;\n#endif\n    /*\n     * The name of the current buffer will be changed.\n     * A new (unlisted) buffer entry needs to be made to hold the old file\n     * name, which will become the alternate file name.\n     * But don't set the alternate file name if the buffer didn't have a\n     * name.\n     */\n    fname = curbuf->b_ffname;\n    sfname = curbuf->b_sfname;\n    xfname = curbuf->b_fname;\n    curbuf->b_ffname = NULL;\n    curbuf->b_sfname = NULL;\n    if (setfname(curbuf, new_fname, NULL, TRUE) == FAIL)\n    {\n\tcurbuf->b_ffname = fname;\n\tcurbuf->b_sfname = sfname;\n\treturn FAIL;\n    }\n    curbuf->b_flags |= BF_NOTEDITED;\n    if (xfname != NULL && *xfname != NUL)\n    {\n\tbuf = buflist_new(fname, xfname, curwin->w_cursor.lnum, 0);\n\tif (buf != NULL && (cmdmod.cmod_flags & CMOD_KEEPALT) == 0)\n\t    curwin->w_alt_fnum = buf->b_fnum;\n    }\n    vim_free(fname);\n    vim_free(sfname);\n    apply_autocmds(EVENT_BUFFILEPOST, NULL, NULL, FALSE, curbuf);\n\n    // Change directories when the 'acd' option is set.\n    DO_AUTOCHDIR;\n    return OK;\n}\n\n/*\n * \":file[!] [fname]\".\n */\n    void\nex_file(exarg_T *eap)\n{\n    // \":0file\" removes the file name.  Check for illegal uses \":3file\",\n    // \"0file name\", etc.\n    if (eap->addr_count > 0\n\t    && (*eap->arg != NUL\n\t\t|| eap->line2 > 0\n\t\t|| eap->addr_count > 1))\n    {\n\temsg(_(e_invalid_argument));\n\treturn;\n    }\n\n    if (*eap->arg != NUL || eap->addr_count == 1)\n    {\n\tif (rename_buffer(eap->arg) == FAIL)\n\t    return;\n\tredraw_tabline = TRUE;\n    }\n\n    // print file name if no argument or 'F' is not in 'shortmess'\n    if (*eap->arg == NUL || !shortmess(SHM_FILEINFO))\n\tfileinfo(FALSE, FALSE, eap->forceit);\n}\n\n/*\n * \":update\".\n */\n    void\nex_update(exarg_T *eap)\n{\n    if (curbufIsChanged())\n\t(void)do_write(eap);\n}\n\n/*\n * \":write\" and \":saveas\".\n */\n    void\nex_write(exarg_T *eap)\n{\n    if (eap->cmdidx == CMD_saveas)\n    {\n\t// :saveas does not take a range, uses all lines.\n\teap->line1 = 1;\n\teap->line2 = curbuf->b_ml.ml_line_count;\n    }\n\n    if (eap->usefilter)\t\t// input lines to shell command\n\tdo_bang(1, eap, FALSE, TRUE, FALSE);\n    else\n\t(void)do_write(eap);\n}\n\n#ifdef UNIX\n    static int\ncheck_writable(char_u *fname)\n{\n    if (mch_nodetype(fname) == NODE_OTHER)\n    {\n\tsemsg(_(e_str_is_not_file_or_writable_device), fname);\n\treturn FAIL;\n    }\n    return OK;\n}\n#endif\n\n/*\n * Write the current buffer to file \"eap->arg\".\n * If \"eap->append\" is TRUE, append to the file.\n *\n * If \"*eap->arg == NUL\" write to current file.\n *\n * Return FAIL for failure, OK otherwise.\n */\n    int\ndo_write(exarg_T *eap)\n{\n    int\t\tother;\n    char_u\t*fname = NULL;\t\t// init to shut up gcc\n    char_u\t*ffname;\n    int\t\tretval = FAIL;\n    char_u\t*free_fname = NULL;\n#ifdef FEAT_BROWSE\n    char_u\t*browse_file = NULL;\n#endif\n    buf_T\t*alt_buf = NULL;\n    int\t\tname_was_missing;\n\n    if (not_writing())\t\t// check 'write' option\n\treturn FAIL;\n\n    ffname = eap->arg;\n#ifdef FEAT_BROWSE\n    if ((cmdmod.cmod_flags & CMOD_BROWSE) && !exiting)\n    {\n\tbrowse_file = do_browse(BROWSE_SAVE, (char_u *)_(\"Save As\"), ffname,\n\t\t\t\t\t\t    NULL, NULL, NULL, curbuf);\n\tif (browse_file == NULL)\n\t    goto theend;\n\tffname = browse_file;\n    }\n#endif\n    if (*ffname == NUL)\n    {\n\tif (eap->cmdidx == CMD_saveas)\n\t{\n\t    emsg(_(e_argument_required));\n\t    goto theend;\n\t}\n\tother = FALSE;\n    }\n    else\n    {\n\tfname = ffname;\n\tfree_fname = fix_fname(ffname);\n\t/*\n\t * When out-of-memory, keep unexpanded file name, because we MUST be\n\t * able to write the file in this situation.\n\t */\n\tif (free_fname != NULL)\n\t    ffname = free_fname;\n\tother = otherfile(ffname);\n    }\n\n    /*\n     * If we have a new file, put its name in the list of alternate file names.\n     */\n    if (other)\n    {\n\tif (vim_strchr(p_cpo, CPO_ALTWRITE) != NULL\n\t\t\t\t\t\t || eap->cmdidx == CMD_saveas)\n\t    alt_buf = setaltfname(ffname, fname, (linenr_T)1);\n\telse\n\t    alt_buf = buflist_findname(ffname);\n\tif (alt_buf != NULL && alt_buf->b_ml.ml_mfp != NULL)\n\t{\n\t    // Overwriting a file that is loaded in another buffer is not a\n\t    // good idea.\n\t    emsg(_(e_file_is_loaded_in_another_buffer));\n\t    goto theend;\n\t}\n    }\n\n    /*\n     * Writing to the current file is not allowed in readonly mode\n     * and a file name is required.\n     * \"nofile\" and \"nowrite\" buffers cannot be written implicitly either.\n     */\n    if (!other && (bt_dontwrite_msg(curbuf) || check_fname() == FAIL\n#ifdef UNIX\n\t\t|| check_writable(curbuf->b_ffname) == FAIL\n#endif\n\t\t|| check_readonly(&eap->forceit, curbuf)))\n\tgoto theend;\n\n    if (!other)\n    {\n\tffname = curbuf->b_ffname;\n\tfname = curbuf->b_fname;\n\t/*\n\t * Not writing the whole file is only allowed with '!'.\n\t */\n\tif (\t   (eap->line1 != 1\n\t\t    || eap->line2 != curbuf->b_ml.ml_line_count)\n\t\t&& !eap->forceit\n\t\t&& !eap->append\n\t\t&& !p_wa)\n\t{\n#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)\n\t    if (p_confirm || (cmdmod.cmod_flags & CMOD_CONFIRM))\n\t    {\n\t\tif (vim_dialog_yesno(VIM_QUESTION, NULL,\n\t\t\t       (char_u *)_(\"Write partial file?\"), 2) != VIM_YES)\n\t\t    goto theend;\n\t\teap->forceit = TRUE;\n\t    }\n\t    else\n#endif\n\t    {\n\t\temsg(_(e_use_bang_to_write_partial_buffer));\n\t\tgoto theend;\n\t    }\n\t}\n    }\n\n    if (check_overwrite(eap, curbuf, fname, ffname, other) == OK)\n    {\n\tif (eap->cmdidx == CMD_saveas && alt_buf != NULL)\n\t{\n\t    buf_T\t*was_curbuf = curbuf;\n\n\t    apply_autocmds(EVENT_BUFFILEPRE, NULL, NULL, FALSE, curbuf);\n\t    apply_autocmds(EVENT_BUFFILEPRE, NULL, NULL, FALSE, alt_buf);\n#ifdef FEAT_EVAL\n\t    if (curbuf != was_curbuf || aborting())\n#else\n\t    if (curbuf != was_curbuf)\n#endif\n\t    {\n\t\t// buffer changed, don't change name now\n\t\tretval = FAIL;\n\t\tgoto theend;\n\t    }\n\t    // Exchange the file names for the current and the alternate\n\t    // buffer.  This makes it look like we are now editing the buffer\n\t    // under the new name.  Must be done before buf_write(), because\n\t    // if there is no file name and 'cpo' contains 'F', it will set\n\t    // the file name.\n\t    fname = alt_buf->b_fname;\n\t    alt_buf->b_fname = curbuf->b_fname;\n\t    curbuf->b_fname = fname;\n\t    fname = alt_buf->b_ffname;\n\t    alt_buf->b_ffname = curbuf->b_ffname;\n\t    curbuf->b_ffname = fname;\n\t    fname = alt_buf->b_sfname;\n\t    alt_buf->b_sfname = curbuf->b_sfname;\n\t    curbuf->b_sfname = fname;\n\t    buf_name_changed(curbuf);\n\n\t    apply_autocmds(EVENT_BUFFILEPOST, NULL, NULL, FALSE, curbuf);\n\t    apply_autocmds(EVENT_BUFFILEPOST, NULL, NULL, FALSE, alt_buf);\n\t    if (!alt_buf->b_p_bl)\n\t    {\n\t\talt_buf->b_p_bl = TRUE;\n\t\tapply_autocmds(EVENT_BUFADD, NULL, NULL, FALSE, alt_buf);\n\t    }\n#ifdef FEAT_EVAL\n\t    if (curbuf != was_curbuf || aborting())\n#else\n\t    if (curbuf != was_curbuf)\n#endif\n\t    {\n\t\t// buffer changed, don't write the file\n\t\tretval = FAIL;\n\t\tgoto theend;\n\t    }\n\n\t    // If 'filetype' was empty try detecting it now.\n\t    if (*curbuf->b_p_ft == NUL)\n\t    {\n\t\tif (au_has_group((char_u *)\"filetypedetect\"))\n\t\t    (void)do_doautocmd((char_u *)\"filetypedetect BufRead\",\n\t\t\t\t\t\t\t\t  TRUE, NULL);\n\t\tdo_modelines(0);\n\t    }\n\n\t    // Autocommands may have changed buffer names, esp. when\n\t    // 'autochdir' is set.\n\t    fname = curbuf->b_sfname;\n\t}\n\n\tname_was_missing = curbuf->b_ffname == NULL;\n\n\tretval = buf_write(curbuf, ffname, fname, eap->line1, eap->line2,\n\t\t\t\t eap, eap->append, eap->forceit, TRUE, FALSE);\n\n\t// After \":saveas fname\" reset 'readonly'.\n\tif (eap->cmdidx == CMD_saveas)\n\t{\n\t    if (retval == OK)\n\t    {\n\t\tcurbuf->b_p_ro = FALSE;\n\t\tredraw_tabline = TRUE;\n\t    }\n\t}\n\n\t// Change directories when the 'acd' option is set and the file name\n\t// got changed or set.\n\tif (eap->cmdidx == CMD_saveas || name_was_missing)\n\t    DO_AUTOCHDIR;\n    }\n\ntheend:\n#ifdef FEAT_BROWSE\n    vim_free(browse_file);\n#endif\n    vim_free(free_fname);\n    return retval;\n}\n\n/*\n * Check if it is allowed to overwrite a file.  If b_flags has BF_NOTEDITED,\n * BF_NEW or BF_READERR, check for overwriting current file.\n * May set eap->forceit if a dialog says it's OK to overwrite.\n * Return OK if it's OK, FAIL if it is not.\n */\n    int\ncheck_overwrite(\n    exarg_T\t*eap,\n    buf_T\t*buf,\n    char_u\t*fname,\t    // file name to be used (can differ from\n\t\t\t    // buf->ffname)\n    char_u\t*ffname,    // full path version of fname\n    int\t\tother)\t    // writing under other name\n{\n    /*\n     * Write to another file or b_flags set or not writing the whole file:\n     * overwriting only allowed with '!'.\n     * If \"other\" is FALSE and bt_nofilename(buf) is TRUE, this must be\n     * writing an \"acwrite\" buffer to the same file as its b_ffname, and\n     * buf_write() will only allow writing with BufWriteCmd autocommands,\n     * so there is no need for an overwrite check.\n     */\n    if (       (other\n\t\t|| (!bt_nofilename(buf)\n\t\t    && ((buf->b_flags & BF_NOTEDITED)\n\t\t\t|| ((buf->b_flags & BF_NEW)\n\t\t\t    && vim_strchr(p_cpo, CPO_OVERNEW) == NULL)\n\t\t\t|| (buf->b_flags & BF_READERR))))\n\t    && !p_wa\n\t    && vim_fexists(ffname))\n    {\n\tif (!eap->forceit && !eap->append)\n\t{\n#ifdef UNIX\n\t    // with UNIX it is possible to open a directory\n\t    if (mch_isdir(ffname))\n\t    {\n\t\tsemsg(_(e_str_is_directory), ffname);\n\t\treturn FAIL;\n\t    }\n#endif\n#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)\n\t    if (p_confirm || (cmdmod.cmod_flags & CMOD_CONFIRM))\n\t    {\n\t\tchar_u\tbuff[DIALOG_MSG_SIZE];\n\n\t\tdialog_msg(buff, _(\"Overwrite existing file \\\"%s\\\"?\"), fname);\n\t\tif (vim_dialog_yesno(VIM_QUESTION, NULL, buff, 2) != VIM_YES)\n\t\t    return FAIL;\n\t\teap->forceit = TRUE;\n\t    }\n\t    else\n#endif\n\t    {\n\t\temsg(_(e_file_exists));\n\t\treturn FAIL;\n\t    }\n\t}\n\n\t// For \":w! filename\" check that no swap file exists for \"filename\".\n\tif (other && !emsg_silent)\n\t{\n\t    char_u\t*dir;\n\t    char_u\t*p;\n\t    int\t\tr;\n\t    char_u\t*swapname;\n\n\t    // We only try the first entry in 'directory', without checking if\n\t    // it's writable.  If the \".\" directory is not writable the write\n\t    // will probably fail anyway.\n\t    // Use 'shortname' of the current buffer, since there is no buffer\n\t    // for the written file.\n\t    if (*p_dir == NUL)\n\t    {\n\t\tdir = alloc(5);\n\t\tif (dir == NULL)\n\t\t    return FAIL;\n\t\tSTRCPY(dir, \".\");\n\t    }\n\t    else\n\t    {\n\t\tdir = alloc(MAXPATHL);\n\t\tif (dir == NULL)\n\t\t    return FAIL;\n\t\tp = p_dir;\n\t\tcopy_option_part(&p, dir, MAXPATHL, \",\");\n\t    }\n\t    swapname = makeswapname(fname, ffname, curbuf, dir);\n\t    vim_free(dir);\n\t    r = vim_fexists(swapname);\n\t    if (r)\n\t    {\n#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)\n\t\tif (p_confirm || (cmdmod.cmod_flags & CMOD_CONFIRM))\n\t\t{\n\t\t    char_u\tbuff[DIALOG_MSG_SIZE];\n\n\t\t    dialog_msg(buff,\n\t\t\t    _(\"Swap file \\\"%s\\\" exists, overwrite anyway?\"),\n\t\t\t\t\t\t\t\t    swapname);\n\t\t    if (vim_dialog_yesno(VIM_QUESTION, NULL, buff, 2)\n\t\t\t\t\t\t\t\t   != VIM_YES)\n\t\t    {\n\t\t\tvim_free(swapname);\n\t\t\treturn FAIL;\n\t\t    }\n\t\t    eap->forceit = TRUE;\n\t\t}\n\t\telse\n#endif\n\t\t{\n\t\t    semsg(_(e_swap_file_exists_str_silent_overrides), swapname);\n\t\t    vim_free(swapname);\n\t\t    return FAIL;\n\t\t}\n\t    }\n\t    vim_free(swapname);\n\t}\n    }\n    return OK;\n}\n\n/*\n * Handle \":wnext\", \":wNext\" and \":wprevious\" commands.\n */\n    void\nex_wnext(exarg_T *eap)\n{\n    int\t\ti;\n\n    if (eap->cmd[1] == 'n')\n\ti = curwin->w_arg_idx + (int)eap->line2;\n    else\n\ti = curwin->w_arg_idx - (int)eap->line2;\n    eap->line1 = 1;\n    eap->line2 = curbuf->b_ml.ml_line_count;\n    if (do_write(eap) != FAIL)\n\tdo_argfile(eap, i);\n}\n\n/*\n * \":wall\", \":wqall\" and \":xall\": Write all changed files (and exit).\n */\n    void\ndo_wqall(exarg_T *eap)\n{\n    buf_T\t*buf;\n    int\t\terror = 0;\n    int\t\tsave_forceit = eap->forceit;\n\n    if (eap->cmdidx == CMD_xall || eap->cmdidx == CMD_wqall)\n    {\n\tif (before_quit_all(eap) == FAIL)\n\t    return;\n\texiting = TRUE;\n    }\n\n    FOR_ALL_BUFFERS(buf)\n    {\n#ifdef FEAT_TERMINAL\n\tif (exiting && term_job_running(buf->b_term))\n\t{\n\t    no_write_message_nobang(buf);\n\t    ++error;\n\t}\n\telse\n#endif\n\tif (bufIsChanged(buf) && !bt_dontwrite(buf))\n\t{\n\t    /*\n\t     * Check if there is a reason the buffer cannot be written:\n\t     * 1. if the 'write' option is set\n\t     * 2. if there is no file name (even after browsing)\n\t     * 3. if the 'readonly' is set (even after a dialog)\n\t     * 4. if overwriting is allowed (even after a dialog)\n\t     */\n\t    if (not_writing())\n\t    {\n\t\t++error;\n\t\tbreak;\n\t    }\n#ifdef FEAT_BROWSE\n\t    // \":browse wall\": ask for file name if there isn't one\n\t    if (buf->b_ffname == NULL && (cmdmod.cmod_flags & CMOD_BROWSE))\n\t\tbrowse_save_fname(buf);\n#endif\n\t    if (buf->b_ffname == NULL)\n\t    {\n\t\tsemsg(_(e_no_file_name_for_buffer_nr), (long)buf->b_fnum);\n\t\t++error;\n\t    }\n\t    else if (check_readonly(&eap->forceit, buf)\n\t\t    || check_overwrite(eap, buf, buf->b_fname, buf->b_ffname,\n\t\t\t\t\t\t\t       FALSE) == FAIL)\n\t    {\n\t\t++error;\n\t    }\n\t    else\n\t    {\n\t\tbufref_T bufref;\n\n\t\tset_bufref(&bufref, buf);\n\t\tif (buf_write_all(buf, eap->forceit) == FAIL)\n\t\t    ++error;\n\t\t// an autocommand may have deleted the buffer\n\t\tif (!bufref_valid(&bufref))\n\t\t    buf = firstbuf;\n\t    }\n\t    eap->forceit = save_forceit;    // check_overwrite() may set it\n\t}\n    }\n    if (exiting)\n    {\n\tif (!error)\n\t    getout(0);\t\t// exit Vim\n\tnot_exiting();\n    }\n}\n\n/*\n * Check the 'write' option.\n * Return TRUE and give a message when it's not set.\n */\n    static int\nnot_writing(void)\n{\n    if (p_write)\n\treturn FALSE;\n    emsg(_(e_file_not_written_writing_is_disabled_by_write_option));\n    return TRUE;\n}\n\n/*\n * Check if a buffer is read-only (either 'readonly' option is set or file is\n * read-only). Ask for overruling in a dialog. Return TRUE and give an error\n * message when the buffer is readonly.\n */\n    static int\ncheck_readonly(int *forceit, buf_T *buf)\n{\n    stat_T\tst;\n\n    // Handle a file being readonly when the 'readonly' option is set or when\n    // the file exists and permissions are read-only.\n    // We will send 0777 to check_file_readonly(), as the \"perm\" variable is\n    // important for device checks but not here.\n    if (!*forceit && (buf->b_p_ro\n\t\t|| (mch_stat((char *)buf->b_ffname, &st) >= 0\n\t\t    && check_file_readonly(buf->b_ffname, 0777))))\n    {\n#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)\n\tif ((p_confirm || (cmdmod.cmod_flags & CMOD_CONFIRM))\n\t\t\t\t\t\t       && buf->b_fname != NULL)\n\t{\n\t    char_u\tbuff[DIALOG_MSG_SIZE];\n\n\t    if (buf->b_p_ro)\n\t\tdialog_msg(buff, _(\"'readonly' option is set for \\\"%s\\\".\\nDo you wish to write anyway?\"),\n\t\t    buf->b_fname);\n\t    else\n\t\tdialog_msg(buff, _(\"File permissions of \\\"%s\\\" are read-only.\\nIt may still be possible to write it.\\nDo you wish to try?\"),\n\t\t    buf->b_fname);\n\n\t    if (vim_dialog_yesno(VIM_QUESTION, NULL, buff, 2) == VIM_YES)\n\t    {\n\t\t// Set forceit, to force the writing of a readonly file\n\t\t*forceit = TRUE;\n\t\treturn FALSE;\n\t    }\n\t    else\n\t\treturn TRUE;\n\t}\n\telse\n#endif\n\tif (buf->b_p_ro)\n\t    emsg(_(e_readonly_option_is_set_add_bang_to_override));\n\telse\n\t    semsg(_(e_str_is_read_only_add_bang_to_override), buf->b_fname);\n\treturn TRUE;\n    }\n\n    return FALSE;\n}\n\n/*\n * Try to abandon the current file and edit a new or existing file.\n * \"fnum\" is the number of the file, if zero use \"ffname_arg\"/\"sfname_arg\".\n * \"lnum\" is the line number for the cursor in the new file (if non-zero).\n *\n * Return:\n * GETFILE_ERROR for \"normal\" error,\n * GETFILE_NOT_WRITTEN for \"not written\" error,\n * GETFILE_SAME_FILE for success\n * GETFILE_OPEN_OTHER for successfully opening another file.\n */\n    int\ngetfile(\n    int\t\tfnum,\n    char_u\t*ffname_arg,\n    char_u\t*sfname_arg,\n    int\t\tsetpm,\n    linenr_T\tlnum,\n    int\t\tforceit)\n{\n    char_u\t*ffname = ffname_arg;\n    char_u\t*sfname = sfname_arg;\n    int\t\tother;\n    int\t\tretval;\n    char_u\t*free_me = NULL;\n\n    if (!check_can_set_curbuf_forceit(forceit))\n\treturn GETFILE_ERROR;\n\n    if (text_locked())\n\treturn GETFILE_ERROR;\n    if (curbuf_locked())\n\treturn GETFILE_ERROR;\n\n    if (fnum == 0)\n    {\n\t\t\t\t\t// make ffname full path, set sfname\n\tfname_expand(curbuf, &ffname, &sfname);\n\tother = otherfile(ffname);\n\tfree_me = ffname;\t\t// has been allocated, free() later\n    }\n    else\n\tother = (fnum != curbuf->b_fnum);\n\n    if (other)\n\t++no_wait_return;\t    // don't wait for autowrite message\n    if (other && !forceit && curbuf->b_nwindows == 1 && !buf_hide(curbuf)\n\t\t   && curbufIsChanged() && autowrite(curbuf, forceit) == FAIL)\n    {\n#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)\n\tif (p_confirm && p_write)\n\t    dialog_changed(curbuf, FALSE);\n\tif (curbufIsChanged())\n#endif\n\t{\n\t    --no_wait_return;\n\t    no_write_message();\n\t    retval = GETFILE_NOT_WRITTEN;\t// file has been changed\n\t    goto theend;\n\t}\n    }\n    if (other)\n\t--no_wait_return;\n    if (setpm)\n\tsetpcmark();\n    if (!other)\n    {\n\tif (lnum != 0)\n\t    curwin->w_cursor.lnum = lnum;\n\tcheck_cursor_lnum();\n\tbeginline(BL_SOL | BL_FIX);\n\tretval = GETFILE_SAME_FILE;\t// it's in the same file\n    }\n    else if (do_ecmd(fnum, ffname, sfname, NULL, lnum,\n\t     (buf_hide(curbuf) ? ECMD_HIDE : 0) + (forceit ? ECMD_FORCEIT : 0),\n\t\tcurwin) == OK)\n\tretval = GETFILE_OPEN_OTHER;\t// opened another file\n    else\n\tretval = GETFILE_ERROR;\t\t// error encountered\n\ntheend:\n    vim_free(free_me);\n    return retval;\n}\n\n/*\n * start editing a new file\n *\n *     fnum: file number; if zero use ffname/sfname\n *   ffname: the file name\n *\t\t- full path if sfname used,\n *\t\t- any file name if sfname is NULL\n *\t\t- empty string to re-edit with the same file name (but may be\n *\t\t    in a different directory)\n *\t\t- NULL to start an empty buffer\n *   sfname: the short file name (or NULL)\n *\teap: contains the command to be executed after loading the file and\n *\t     forced 'ff' and 'fenc'\n *  newlnum: if > 0: put cursor on this line number (if possible)\n *\t     if ECMD_LASTL: use last position in loaded file\n *\t     if ECMD_LAST: use last position in all files\n *\t     if ECMD_ONE: use first line\n *    flags:\n *\t   ECMD_HIDE: if TRUE don't free the current buffer\n *     ECMD_SET_HELP: set b_help flag of (new) buffer before opening file\n *\t ECMD_OLDBUF: use existing buffer if it exists\n *\tECMD_FORCEIT: ! used for Ex command\n *\t ECMD_ADDBUF: don't edit, just add to buffer list\n *\t ECMD_ALTBUF: like ECMD_ADDBUF and also set the alternate file\n *   ECMD_NOWINENTER: Do not trigger BufWinEnter\n *   oldwin: Should be \"curwin\" when editing a new buffer in the current\n *\t     window, NULL when splitting the window first.  When not NULL info\n *\t     of the previous buffer for \"oldwin\" is stored.\n *\n * return FAIL for failure, OK otherwise\n */\n    int\ndo_ecmd(\n    int\t\tfnum,\n    char_u\t*ffname,\n    char_u\t*sfname,\n    exarg_T\t*eap,\t\t\t// can be NULL!\n    linenr_T\tnewlnum,\n    int\t\tflags,\n    win_T\t*oldwin)\n{\n    int\t\tother_file;\t\t// TRUE if editing another file\n    int\t\toldbuf;\t\t\t// TRUE if using existing buffer\n    int\t\tauto_buf = FALSE;\t// TRUE if autocommands brought us\n\t\t\t\t\t// into the buffer unexpectedly\n    char_u\t*new_name = NULL;\n#if defined(FEAT_EVAL)\n    int\t\tdid_set_swapcommand = FALSE;\n#endif\n    buf_T\t*buf;\n    bufref_T\tbufref;\n    bufref_T\told_curbuf;\n    char_u\t*free_fname = NULL;\n#ifdef FEAT_BROWSE\n    char_u\tdot_path[] = \".\";\n    char_u\t*browse_file = NULL;\n#endif\n    int\t\tretval = FAIL;\n    long\tn;\n    pos_T\torig_pos;\n    linenr_T\ttopline = 0;\n    int\t\tnewcol = -1;\n    int\t\tsolcol = -1;\n    pos_T\t*pos;\n    char_u\t*command = NULL;\n#ifdef FEAT_SPELL\n    int\t\tdid_get_winopts = FALSE;\n#endif\n    int\t\treadfile_flags = 0;\n    int\t\tdid_inc_redrawing_disabled = FALSE;\n    long\t*so_ptr = curwin->w_p_so >= 0 ? &curwin->w_p_so : &p_so;\n\n#ifdef FEAT_PROP_POPUP\n    if (ERROR_IF_TERM_POPUP_WINDOW)\n\treturn FAIL;\n#endif\n\n    if (eap != NULL)\n\tcommand = eap->do_ecmd_cmd;\n    set_bufref(&old_curbuf, curbuf);\n\n    if (fnum != 0)\n    {\n\tif (fnum == curbuf->b_fnum)\t// file is already being edited\n\t    return OK;\t\t\t// nothing to do\n\tother_file = TRUE;\n    }\n    else\n    {\n#ifdef FEAT_BROWSE\n\tif ((cmdmod.cmod_flags & CMOD_BROWSE) && !exiting)\n\t{\n\t    if (\n# ifdef FEAT_GUI\n\t\t!gui.in_use &&\n# endif\n\t\t    au_has_group((char_u *)\"FileExplorer\"))\n\t    {\n\t\t// No browsing supported but we do have the file explorer:\n\t\t// Edit the directory.\n\t\tif (ffname == NULL || !mch_isdir(ffname))\n\t\t    ffname = dot_path;\n\t    }\n\t    else\n\t    {\n\t\tbrowse_file = do_browse(0, (char_u *)_(\"Edit File\"), ffname,\n\t\t\t\t\t\t    NULL, NULL, NULL, curbuf);\n\t\tif (browse_file == NULL)\n\t\t    goto theend;\n\t\tffname = browse_file;\n\t    }\n\t}\n#endif\n\t// if no short name given, use ffname for short name\n\tif (sfname == NULL)\n\t    sfname = ffname;\n#ifdef USE_FNAME_CASE\n\tif (sfname != NULL)\n\t    fname_case(sfname, 0);   // set correct case for sfname\n#endif\n\n\tif ((flags & (ECMD_ADDBUF | ECMD_ALTBUF))\n\t\t\t\t\t && (ffname == NULL || *ffname == NUL))\n\t    goto theend;\n\n\tif (ffname == NULL)\n\t    other_file = TRUE;\n\t\t\t\t\t    // there is no file name\n\telse if (*ffname == NUL && curbuf->b_ffname == NULL)\n\t    other_file = FALSE;\n\telse\n\t{\n\t    if (*ffname == NUL)\t\t    // re-edit with same file name\n\t    {\n\t\tffname = curbuf->b_ffname;\n\t\tsfname = curbuf->b_fname;\n\t    }\n\t    free_fname = fix_fname(ffname); // may expand to full path name\n\t    if (free_fname != NULL)\n\t\tffname = free_fname;\n\t    other_file = otherfile(ffname);\n\t}\n    }\n\n    /*\n     * If the file was changed we may not be allowed to abandon it:\n     * - if we are going to re-edit the same file\n     * - or if we are the only window on this file and if ECMD_HIDE is FALSE\n     */\n    if (  ((!other_file && !(flags & ECMD_OLDBUF))\n\t    || (curbuf->b_nwindows == 1\n\t\t&& !(flags & (ECMD_HIDE | ECMD_ADDBUF | ECMD_ALTBUF))))\n\t&& check_changed(curbuf, (p_awa ? CCGD_AW : 0)\n\t\t\t       | (other_file ? 0 : CCGD_MULTWIN)\n\t\t\t       | ((flags & ECMD_FORCEIT) ? CCGD_FORCEIT : 0)\n\t\t\t       | (eap == NULL ? 0 : CCGD_EXCMD)))\n    {\n\tif (fnum == 0 && other_file && ffname != NULL)\n\t    (void)setaltfname(ffname, sfname, newlnum < 0 ? 0 : newlnum);\n\tgoto theend;\n    }\n\n\n    // End Visual mode before switching to another buffer, so the text can be\n    // copied into the GUI selection buffer.\n    // Careful: may trigger ModeChanged() autocommand\n\n    // Should we block autocommands here?\n    reset_VIsual();\n\n    // autocommands freed window :(\n    if (oldwin != NULL && !win_valid(oldwin))\n\toldwin = NULL;\n\n#if defined(FEAT_EVAL)\n    if ((command != NULL || newlnum > (linenr_T)0)\n\t    && *get_vim_var_str(VV_SWAPCOMMAND) == NUL)\n    {\n\tint\tlen;\n\tchar_u\t*p;\n\n\t// Set v:swapcommand for the SwapExists autocommands.\n\tif (command != NULL)\n\t    len = (int)STRLEN(command) + 3;\n\telse\n\t    len = 30;\n\tp = alloc(len);\n\tif (p != NULL)\n\t{\n\t    if (command != NULL)\n\t\tvim_snprintf((char *)p, len, \":%s\\r\", command);\n\t    else\n\t\tvim_snprintf((char *)p, len, \"%ldG\", (long)newlnum);\n\t    set_vim_var_string(VV_SWAPCOMMAND, p, -1);\n\t    did_set_swapcommand = TRUE;\n\t    vim_free(p);\n\t}\n    }\n#endif\n\n    /*\n     * If we are starting to edit another file, open a (new) buffer.\n     * Otherwise we re-use the current buffer.\n     */\n    if (other_file)\n    {\n\tint prev_alt_fnum = curwin->w_alt_fnum;\n\n\tif (!(flags & (ECMD_ADDBUF | ECMD_ALTBUF)))\n\t{\n\t    if ((cmdmod.cmod_flags & CMOD_KEEPALT) == 0)\n\t\tcurwin->w_alt_fnum = curbuf->b_fnum;\n\t    if (oldwin != NULL)\n\t\tbuflist_altfpos(oldwin);\n\t}\n\n\tif (fnum)\n\t    buf = buflist_findnr(fnum);\n\telse\n\t{\n\t    if (flags & (ECMD_ADDBUF | ECMD_ALTBUF))\n\t    {\n\t\t// Default the line number to zero to avoid that a wininfo item\n\t\t// is added for the current window.\n\t\tlinenr_T\ttlnum = 0;\n\t\tbuf_T\t\t*newbuf;\n\n\t\tif (command != NULL)\n\t\t{\n\t\t    tlnum = atol((char *)command);\n\t\t    if (tlnum <= 0)\n\t\t\ttlnum = 1L;\n\t\t}\n\t\t// Add BLN_NOCURWIN to avoid a new wininfo items are associated\n\t\t// with the current window.\n\t\tnewbuf = buflist_new(ffname, sfname, tlnum,\n\t\t\t\t\t\t    BLN_LISTED | BLN_NOCURWIN);\n\t\tif (newbuf != NULL)\n\t\t{\n\t\t    if (flags & ECMD_ALTBUF)\n\t\t\tcurwin->w_alt_fnum = newbuf->b_fnum;\n\t\t    if (tlnum > 0)\n\t\t\tnewbuf->b_last_cursor.lnum = tlnum;\n\t\t}\n\t\tgoto theend;\n\t    }\n\t    buf = buflist_new(ffname, sfname, 0L,\n\t\t    BLN_CURBUF | ((flags & ECMD_SET_HELP) ? 0 : BLN_LISTED));\n\n\t    // autocommands may change curwin and curbuf\n\t    if (oldwin != NULL)\n\t\toldwin = curwin;\n\t    set_bufref(&old_curbuf, curbuf);\n\t}\n\tif (buf == NULL)\n\t    goto theend;\n\t// autocommands try to edit a file that is going to be removed,\n\t// abort\n\tif (buf_locked(buf))\n\t{\n\t    // window was split, but not editing the new buffer,\n\t    // reset b_nwindows again\n\t    if (oldwin == NULL\n\t\t    && curwin->w_buffer != NULL\n\t\t    && curwin->w_buffer->b_nwindows > 1)\n\t\t--curwin->w_buffer->b_nwindows;\n\t    goto theend;\n\t}\n\tif (curwin->w_alt_fnum == buf->b_fnum && prev_alt_fnum != 0)\n\t    // reusing the buffer, keep the old alternate file\n\t    curwin->w_alt_fnum = prev_alt_fnum;\n\n\tif (buf->b_ml.ml_mfp == NULL)\t\t// no memfile yet\n\t{\n\t    oldbuf = FALSE;\n\t}\n\telse\t\t\t\t\t// existing memfile\n\t{\n\t    oldbuf = TRUE;\n\t    set_bufref(&bufref, buf);\n\t    (void)buf_check_timestamp(buf, FALSE);\n\t    // Check if autocommands made the buffer invalid or changed the\n\t    // current buffer.\n\t    if (!bufref_valid(&bufref) || curbuf != old_curbuf.br_buf)\n\t\tgoto theend;\n#ifdef FEAT_EVAL\n\t    if (aborting())\t    // autocmds may abort script processing\n\t\tgoto theend;\n#endif\n\t}\n\n\t// May jump to last used line number for a loaded buffer or when asked\n\t// for explicitly\n\tif ((oldbuf && newlnum == ECMD_LASTL) || newlnum == ECMD_LAST)\n\t{\n\t    pos = buflist_findfpos(buf);\n\t    newlnum = pos->lnum;\n\t    solcol = pos->col;\n\t}\n\n\t/*\n\t * Make the (new) buffer the one used by the current window.\n\t * If the old buffer becomes unused, free it if ECMD_HIDE is FALSE.\n\t * If the current buffer was empty and has no file name, curbuf\n\t * is returned by buflist_new(), nothing to do here.\n\t */\n\tif (buf != curbuf)\n\t{\n\t    bufref_T\tsave_au_new_curbuf;\n\t    int\t\tsave_cmdwin_type = cmdwin_type;\n\t    win_T\t*save_cmdwin_win = cmdwin_win;\n\n\t    // Should only be possible to get here if the cmdwin is closed, or\n\t    // if it's opening and its buffer hasn't been set yet (the new\n\t    // buffer is for it).\n\t    assert(cmdwin_buf == NULL);\n\n\t    // BufLeave applies to the old buffer.\n\t    cmdwin_type = 0;\n\t    cmdwin_win = NULL;\n\n\t    /*\n\t     * Be careful: The autocommands may delete any buffer and change\n\t     * the current buffer.\n\t     * - If the buffer we are going to edit is deleted, give up.\n\t     * - If the current buffer is deleted, prefer to load the new\n\t     *   buffer when loading a buffer is required.  This avoids\n\t     *   loading another buffer which then must be closed again.\n\t     * - If we ended up in the new buffer already, need to skip a few\n\t     *\t things, set auto_buf.\n\t     */\n\t    if (buf->b_fname != NULL)\n\t\tnew_name = vim_strsave(buf->b_fname);\n\t    save_au_new_curbuf = au_new_curbuf;\n\t    set_bufref(&au_new_curbuf, buf);\n\t    apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, FALSE, curbuf);\n\n\t    cmdwin_type = save_cmdwin_type;\n\t    cmdwin_win = save_cmdwin_win;\n\n\t    if (!bufref_valid(&au_new_curbuf))\n\t    {\n\t\t// new buffer has been deleted\n\t\tdelbuf_msg(new_name);\t// frees new_name\n\t\tau_new_curbuf = save_au_new_curbuf;\n\t\tgoto theend;\n\t    }\n#ifdef FEAT_EVAL\n\t    if (aborting())\t    // autocmds may abort script processing\n\t    {\n\t\tvim_free(new_name);\n\t\tau_new_curbuf = save_au_new_curbuf;\n\t\tgoto theend;\n\t    }\n#endif\n\t    if (buf == curbuf)\t\t// already in new buffer\n\t\tauto_buf = TRUE;\n\t    else\n\t    {\n\t\twin_T\t    *the_curwin = curwin;\n\t\tint\t    did_decrement;\n\t\tbuf_T\t    *was_curbuf = curbuf;\n\n\t\t// Set the w_locked flag to avoid that autocommands close the\n\t\t// window.  And set b_locked for the same reason.\n\t\tthe_curwin->w_locked = TRUE;\n\t\t++buf->b_locked;\n\n\t\tif (curbuf == old_curbuf.br_buf)\n\t\t    buf_copy_options(buf, BCO_ENTER);\n\n\t\t// Close the link to the current buffer. This will set\n\t\t// oldwin->w_buffer to NULL.\n\t\tu_sync(FALSE);\n\t\tdid_decrement = close_buffer(oldwin, curbuf,\n\t\t\t (flags & ECMD_HIDE) ? 0 : DOBUF_UNLOAD, FALSE, FALSE);\n\n\t\t// Autocommands may have closed the window.\n\t\tif (win_valid(the_curwin))\n\t\t    the_curwin->w_locked = FALSE;\n\t\t--buf->b_locked;\n\n#ifdef FEAT_EVAL\n\t\t// autocmds may abort script processing\n\t\tif (aborting() && curwin->w_buffer != NULL)\n\t\t{\n\t\t    vim_free(new_name);\n\t\t    au_new_curbuf = save_au_new_curbuf;\n\t\t    goto theend;\n\t\t}\n#endif\n\t\t// Be careful again, like above.\n\t\tif (!bufref_valid(&au_new_curbuf))\n\t\t{\n\t\t    // new buffer has been deleted\n\t\t    delbuf_msg(new_name);\t// frees new_name\n\t\t    au_new_curbuf = save_au_new_curbuf;\n\t\t    goto theend;\n\t\t}\n\t\tif (buf == curbuf)\t\t// already in new buffer\n\t\t{\n\t\t    // close_buffer() has decremented the window count,\n\t\t    // increment it again here and restore w_buffer.\n\t\t    if (did_decrement && buf_valid(was_curbuf))\n\t\t\t++was_curbuf->b_nwindows;\n\t\t    if (win_valid_any_tab(oldwin) && oldwin->w_buffer == NULL)\n\t\t\toldwin->w_buffer = was_curbuf;\n\t\t    auto_buf = TRUE;\n\t\t}\n\t\telse\n\t\t{\n#ifdef FEAT_SYN_HL\n\t\t    /*\n\t\t     * <VN> We could instead free the synblock\n\t\t     * and re-attach to buffer, perhaps.\n\t\t     */\n\t\t    if (curwin->w_buffer == NULL\n\t\t\t    || curwin->w_s == &(curwin->w_buffer->b_s))\n\t\t\tcurwin->w_s = &(buf->b_s);\n#endif\n\t\t    curwin->w_buffer = buf;\n\t\t    curbuf = buf;\n\t\t    ++curbuf->b_nwindows;\n\n\t\t    // Set 'fileformat', 'binary' and 'fenc' when forced.\n\t\t    if (!oldbuf && eap != NULL)\n\t\t    {\n\t\t\tset_file_options(TRUE, eap);\n\t\t\tset_forced_fenc(eap);\n\t\t    }\n\t\t}\n\n\t\t// May get the window options from the last time this buffer\n\t\t// was in this window (or another window).  If not used\n\t\t// before, reset the local window options to the global\n\t\t// values.  Also restores old folding stuff.\n\t\tget_winopts(curbuf);\n#ifdef FEAT_SPELL\n\t\tdid_get_winopts = TRUE;\n#endif\n\t    }\n\t    vim_free(new_name);\n\t    au_new_curbuf = save_au_new_curbuf;\n\t}\n\n\tcurwin->w_pcmark.lnum = 1;\n\tcurwin->w_pcmark.col = 0;\n    }\n    else // !other_file\n    {\n\tif ((flags & (ECMD_ADDBUF | ECMD_ALTBUF)) || check_fname() == FAIL)\n\t    goto theend;\n\n\toldbuf = (flags & ECMD_OLDBUF);\n    }\n\n    // Don't redraw until the cursor is in the right line, otherwise\n    // autocommands may cause ml_get errors.\n    ++RedrawingDisabled;\n    did_inc_redrawing_disabled = TRUE;\n\n    buf = curbuf;\n    if ((flags & ECMD_SET_HELP) || keep_help_flag)\n    {\n\tprepare_help_buffer();\n    }\n    else\n    {\n\t// Don't make a buffer listed if it's a help buffer.  Useful when\n\t// using CTRL-O to go back to a help file.\n\tif (!curbuf->b_help)\n\t    set_buflisted(TRUE);\n    }\n\n    // If autocommands change buffers under our fingers, forget about\n    // editing the file.\n    if (buf != curbuf)\n\tgoto theend;\n#ifdef FEAT_EVAL\n    if (aborting())\t    // autocmds may abort script processing\n\tgoto theend;\n#endif\n\n    // Since we are starting to edit a file, consider the filetype to be\n    // unset.  Helps for when an autocommand changes files and expects syntax\n    // highlighting to work in the other file.\n    curbuf->b_did_filetype = FALSE;\n\n/*\n * other_file\toldbuf\n *  FALSE\tFALSE\t    re-edit same file, buffer is re-used\n *  FALSE\tTRUE\t    re-edit same file, nothing changes\n *  TRUE\tFALSE\t    start editing new file, new buffer\n *  TRUE\tTRUE\t    start editing in existing buffer (nothing to do)\n */\n    if (!other_file && !oldbuf)\t\t// re-use the buffer\n    {\n\tset_last_cursor(curwin);\t// may set b_last_cursor\n\tif (newlnum == ECMD_LAST || newlnum == ECMD_LASTL)\n\t{\n\t    newlnum = curwin->w_cursor.lnum;\n\t    solcol = curwin->w_cursor.col;\n\t}\n\tbuf = curbuf;\n\tif (buf->b_fname != NULL)\n\t    new_name = vim_strsave(buf->b_fname);\n\telse\n\t    new_name = NULL;\n\tset_bufref(&bufref, buf);\n\n\t// If the buffer was used before, store the current contents so that\n\t// the reload can be undone.  Do not do this if the (empty) buffer is\n\t// being re-used for another file.\n\tif (!(curbuf->b_flags & BF_NEVERLOADED)\n\t\t&& (p_ur < 0 || curbuf->b_ml.ml_line_count <= p_ur))\n\t{\n\t    // Sync first so that this is a separate undo-able action.\n\t    u_sync(FALSE);\n\t    if (u_savecommon(0, curbuf->b_ml.ml_line_count + 1, 0, TRUE)\n\t\t\t\t\t\t\t\t     == FAIL)\n\t    {\n\t\tvim_free(new_name);\n\t\tgoto theend;\n\t    }\n\t    u_unchanged(curbuf);\n\t    buf_freeall(curbuf, BFA_KEEP_UNDO);\n\n\t    // tell readfile() not to clear or reload undo info\n\t    readfile_flags = READ_KEEP_UNDO;\n\t}\n\telse\n\t    buf_freeall(curbuf, 0);   // free all things for buffer\n\n\t// If autocommands deleted the buffer we were going to re-edit, give\n\t// up and jump to the end.\n\tif (!bufref_valid(&bufref))\n\t{\n\t    delbuf_msg(new_name);\t// frees new_name\n\t    goto theend;\n\t}\n\tvim_free(new_name);\n\n\t// If autocommands change buffers under our fingers, forget about\n\t// re-editing the file.  Should do the buf_clear_file(), but perhaps\n\t// the autocommands changed the buffer...\n\tif (buf != curbuf)\n\t    goto theend;\n#ifdef FEAT_EVAL\n\tif (aborting())\t    // autocmds may abort script processing\n\t    goto theend;\n#endif\n\tbuf_clear_file(curbuf);\n\tcurbuf->b_op_start.lnum = 0;\t// clear '[ and '] marks\n\tcurbuf->b_op_end.lnum = 0;\n    }\n\n/*\n * If we get here we are sure to start editing\n */\n    // Assume success now\n    retval = OK;\n\n    // If the file name was changed, reset the not-edit flag so that \":write\"\n    // works.\n    if (!other_file)\n\tcurbuf->b_flags &= ~BF_NOTEDITED;\n\n    /*\n     * Check if we are editing the w_arg_idx file in the argument list.\n     */\n    check_arg_idx(curwin);\n\n    if (!auto_buf)\n    {\n\t/*\n\t * Set cursor and init window before reading the file and executing\n\t * autocommands.  This allows for the autocommands to position the\n\t * cursor.\n\t */\n\tcurwin_init();\n\n#ifdef FEAT_FOLDING\n\t// It's possible that all lines in the buffer changed.  Need to update\n\t// automatic folding for all windows where it's used.\n\t{\n\t    win_T\t    *win;\n\t    tabpage_T\t    *tp;\n\n\t    FOR_ALL_TAB_WINDOWS(tp, win)\n\t\tif (win->w_buffer == curbuf)\n\t\t    foldUpdateAll(win);\n\t}\n#endif\n\n\t// Change directories when the 'acd' option is set.\n\tDO_AUTOCHDIR;\n\n\t/*\n\t * Careful: open_buffer() and apply_autocmds() may change the current\n\t * buffer and window.\n\t */\n\torig_pos = curwin->w_cursor;\n\ttopline = curwin->w_topline;\n\tif (!oldbuf)\t\t\t    // need to read the file\n\t{\n#ifdef FEAT_PROP_POPUP\n\t    // Don't use the swap-exists dialog for a popup window, can't edit\n\t    // the buffer.\n\t    if (WIN_IS_POPUP(curwin))\n\t\tcurbuf->b_flags |= BF_NO_SEA;\n#endif\n\t    swap_exists_action = SEA_DIALOG;\n\t    curbuf->b_flags |= BF_CHECK_RO; // set/reset 'ro' flag\n\n\t    /*\n\t     * Open the buffer and read the file.\n\t     */\n\t    if (flags & ECMD_NOWINENTER)\n\t\treadfile_flags |= READ_NOWINENTER;\n#if defined(FEAT_EVAL)\n\t    if (should_abort(open_buffer(FALSE, eap, readfile_flags)))\n\t\tretval = FAIL;\n#else\n\t    (void)open_buffer(FALSE, eap, readfile_flags);\n#endif\n\n#ifdef FEAT_PROP_POPUP\n\t    curbuf->b_flags &= ~BF_NO_SEA;\n#endif\n\t    if (swap_exists_action == SEA_QUIT)\n\t\tretval = FAIL;\n\t    handle_swap_exists(&old_curbuf);\n\t}\n\telse\n\t{\n\t    // Read the modelines, but only to set window-local options.  Any\n\t    // buffer-local options have already been set and may have been\n\t    // changed by the user.\n\t    do_modelines(OPT_WINONLY);\n\n\t    apply_autocmds_retval(EVENT_BUFENTER, NULL, NULL, FALSE,\n\t\t\t\t\t\t\t      curbuf, &retval);\n\t    if ((flags & ECMD_NOWINENTER) == 0)\n\t\tapply_autocmds_retval(EVENT_BUFWINENTER, NULL, NULL, FALSE,\n\t\t\t\t\t\t\t      curbuf, &retval);\n\t}\n\tcheck_arg_idx(curwin);\n\n\t// If autocommands change the cursor position or topline, we should\n\t// keep it.  Also when it moves within a line. But not when it moves\n\t// to the first non-blank.\n\tif (!EQUAL_POS(curwin->w_cursor, orig_pos))\n\t{\n\t    char_u *text = ml_get_curline();\n\n\t    if (curwin->w_cursor.lnum != orig_pos.lnum\n\t\t    || curwin->w_cursor.col != (int)(skipwhite(text) - text))\n\t    {\n\t\tnewlnum = curwin->w_cursor.lnum;\n\t\tnewcol = curwin->w_cursor.col;\n\t    }\n\t}\n\tif (curwin->w_topline == topline)\n\t    topline = 0;\n\n\t// Even when cursor didn't move we need to recompute topline.\n\tchanged_line_abv_curs();\n\n\tmaketitle();\n#if defined(FEAT_PROP_POPUP) && defined(FEAT_QUICKFIX)\n\tif (WIN_IS_POPUP(curwin) && curwin->w_p_pvw && retval != FAIL)\n\t    popup_set_title(curwin);\n#endif\n    }\n\n#ifdef FEAT_DIFF\n    // Tell the diff stuff that this buffer is new and/or needs updating.\n    // Also needed when re-editing the same buffer, because unloading will\n    // have removed it as a diff buffer.\n    if (curwin->w_p_diff)\n    {\n\tdiff_buf_add(curbuf);\n\tdiff_invalidate(curbuf);\n    }\n#endif\n\n#ifdef FEAT_SPELL\n    // If the window options were changed may need to set the spell language.\n    // Can only do this after the buffer has been properly setup.\n    if (did_get_winopts && curwin->w_p_spell && *curwin->w_s->b_p_spl != NUL)\n\t(void)parse_spelllang(curwin);\n#endif\n\n    if (command == NULL)\n    {\n\tif (newcol >= 0)\t// position set by autocommands\n\t{\n\t    curwin->w_cursor.lnum = newlnum;\n\t    curwin->w_cursor.col = newcol;\n\t    check_cursor();\n\t}\n\telse if (newlnum > 0)\t// line number from caller or old position\n\t{\n\t    curwin->w_cursor.lnum = newlnum;\n\t    check_cursor_lnum();\n\t    if (solcol >= 0 && !p_sol)\n\t    {\n\t\t// 'sol' is off: Use last known column.\n\t\tcurwin->w_cursor.col = solcol;\n\t\tcheck_cursor_col();\n\t\tcurwin->w_cursor.coladd = 0;\n\t\tcurwin->w_set_curswant = TRUE;\n\t    }\n\t    else\n\t\tbeginline(BL_SOL | BL_FIX);\n\t}\n\telse\t\t\t// no line number, go to last line in Ex mode\n\t{\n\t    if (exmode_active)\n\t\tcurwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\t    beginline(BL_WHITE | BL_FIX);\n\t}\n    }\n\n    // Check if cursors in other windows on the same buffer are still valid\n    check_lnums(FALSE);\n\n    /*\n     * Did not read the file, need to show some info about the file.\n     * Do this after setting the cursor.\n     */\n    if (oldbuf && !auto_buf)\n    {\n\tint\tmsg_scroll_save = msg_scroll;\n\n\t// Obey the 'O' flag in 'cpoptions': overwrite any previous file\n\t// message.\n\tif (shortmess(SHM_OVERALL) && !exiting && p_verbose == 0)\n\t    msg_scroll = FALSE;\n\tif (!msg_scroll)\t// wait a bit when overwriting an error msg\n\t    check_for_delay(FALSE);\n\tmsg_start();\n\tmsg_scroll = msg_scroll_save;\n\tmsg_scrolled_ign = TRUE;\n\n\tif (!shortmess(SHM_FILEINFO))\n\t    fileinfo(FALSE, TRUE, FALSE);\n\n\tmsg_scrolled_ign = FALSE;\n    }\n\n#ifdef FEAT_VIMINFO\n    curbuf->b_last_used = vim_time();\n#endif\n\n    if (command != NULL)\n\tdo_cmdline(command, NULL, NULL, DOCMD_VERBOSE|DOCMD_RANGEOK);\n\n#ifdef FEAT_KEYMAP\n    if (curbuf->b_kmap_state & KEYMAP_INIT)\n\t(void)keymap_init();\n#endif\n\n    if (RedrawingDisabled > 0)\n\t--RedrawingDisabled;\n    did_inc_redrawing_disabled = FALSE;\n    if (!skip_redraw)\n    {\n\tn = *so_ptr;\n\tif (topline == 0 && command == NULL)\n\t    *so_ptr = 9999;\t\t// force cursor halfway the window\n\tupdate_topline();\n\tcurwin->w_scbind_pos = curwin->w_topline;\n\t*so_ptr = n;\n\tredraw_curbuf_later(UPD_NOT_VALID);\t// redraw this buffer later\n    }\n\n    if (p_im && (State & MODE_INSERT) == 0)\n\tneed_start_insertmode = TRUE;\n\n#ifdef FEAT_AUTOCHDIR\n    // Change directories when the 'acd' option is set and we aren't already in\n    // that directory (should already be done above). Expect getcwd() to be\n    // faster than calling shorten_fnames() unnecessarily.\n    if (p_acd && curbuf->b_ffname != NULL)\n    {\n\tchar_u\tcurdir[MAXPATHL];\n\tchar_u\tfiledir[MAXPATHL];\n\n\tvim_strncpy(filedir, curbuf->b_ffname, MAXPATHL - 1);\n\t*gettail_sep(filedir) = NUL;\n\tif (mch_dirname(curdir, MAXPATHL) != FAIL\n\t\t&& vim_fnamecmp(curdir, filedir) != 0)\n\t    do_autochdir();\n    }\n#endif\n\n#if defined(FEAT_NETBEANS_INTG)\n    if (curbuf->b_ffname != NULL)\n    {\n# ifdef FEAT_NETBEANS_INTG\n\tif ((flags & ECMD_SET_HELP) != ECMD_SET_HELP)\n\t    netbeans_file_opened(curbuf);\n# endif\n    }\n#endif\n\ntheend:\n    if (did_inc_redrawing_disabled && RedrawingDisabled > 0)\n\t--RedrawingDisabled;\n#if defined(FEAT_EVAL)\n    if (did_set_swapcommand)\n\tset_vim_var_string(VV_SWAPCOMMAND, NULL, -1);\n#endif\n#ifdef FEAT_BROWSE\n    vim_free(browse_file);\n#endif\n    vim_free(free_fname);\n    return retval;\n}\n\n    static void\ndelbuf_msg(char_u *name)\n{\n    semsg(_(e_autocommands_unexpectedly_deleted_new_buffer_str),\n\t\t\t\t\t   name == NULL ? (char_u *)\"\" : name);\n    vim_free(name);\n    au_new_curbuf.br_buf = NULL;\n    au_new_curbuf.br_buf_free_count = 0;\n}\n\nstatic int append_indent = 0;\t    // autoindent for first line\n\n/*\n * \":insert\" and \":append\", also used by \":change\"\n */\n    void\nex_append(exarg_T *eap)\n{\n    char_u\t*theline;\n    int\t\tdid_undo = FALSE;\n    linenr_T\tlnum = eap->line2;\n    int\t\tindent = 0;\n    char_u\t*p;\n    int\t\tvcol;\n    int\t\tempty = (curbuf->b_ml.ml_flags & ML_EMPTY);\n\n#ifdef FEAT_EVAL\n    if (not_in_vim9(eap) == FAIL)\n\treturn;\n#endif\n    // the ! flag toggles autoindent\n    if (eap->forceit)\n\tcurbuf->b_p_ai = !curbuf->b_p_ai;\n\n    // First autoindent comes from the line we start on\n    if (eap->cmdidx != CMD_change && curbuf->b_p_ai && lnum > 0)\n\tappend_indent = get_indent_lnum(lnum);\n\n    if (eap->cmdidx != CMD_append)\n\t--lnum;\n\n    // when the buffer is empty need to delete the dummy line\n    if (empty && lnum == 1)\n\tlnum = 0;\n\n    State = MODE_INSERT;\t\t    // behave like in Insert mode\n    if (curbuf->b_p_iminsert == B_IMODE_LMAP)\n\tState |= MODE_LANGMAP;\n\n    for (;;)\n    {\n\tmsg_scroll = TRUE;\n\tneed_wait_return = FALSE;\n\tif (curbuf->b_p_ai)\n\t{\n\t    if (append_indent >= 0)\n\t    {\n\t\tindent = append_indent;\n\t\tappend_indent = -1;\n\t    }\n\t    else if (lnum > 0)\n\t\tindent = get_indent_lnum(lnum);\n\t}\n\tex_keep_indent = FALSE;\n\tif (*eap->arg == '|')\n\t{\n\t    // Get the text after the trailing bar.\n\t    theline = vim_strsave(eap->arg + 1);\n\t    *eap->arg = NUL;\n\t}\n\telse if (eap->ea_getline == NULL)\n\t{\n\t    // No getline() function, use the lines that follow. This ends\n\t    // when there is no more.\n\t    if (eap->nextcmd == NULL)\n\t\tbreak;\n\t    p = vim_strchr(eap->nextcmd, NL);\n\t    if (p == NULL)\n\t\tp = eap->nextcmd + STRLEN(eap->nextcmd);\n\t    theline = vim_strnsave(eap->nextcmd, p - eap->nextcmd);\n\t    if (*p != NUL)\n\t\t++p;\n\t    else\n\t\tp = NULL;\n\t    eap->nextcmd = p;\n\t}\n\telse\n\t{\n\t    int save_State = State;\n\n\t    // Set State to avoid the cursor shape to be set to MODE_INSERT\n\t    // state when getline() returns.\n\t    State = MODE_CMDLINE;\n\t    theline = eap->ea_getline(\n#ifdef FEAT_EVAL\n\t\t    eap->cstack->cs_looplevel > 0 ? -1 :\n#endif\n\t\t    NUL, eap->cookie, indent, TRUE);\n\t    State = save_State;\n\t}\n\tlines_left = Rows - 1;\n\tif (theline == NULL)\n\t    break;\n\n\t// Using ^ CTRL-D in getexmodeline() makes us repeat the indent.\n\tif (ex_keep_indent)\n\t    append_indent = indent;\n\n\t// Look for the \".\" after automatic indent.\n\tvcol = 0;\n\tfor (p = theline; indent > vcol; ++p)\n\t{\n\t    if (*p == ' ')\n\t\t++vcol;\n\t    else if (*p == TAB)\n\t\tvcol += 8 - vcol % 8;\n\t    else\n\t\tbreak;\n\t}\n\tif ((p[0] == '.' && p[1] == NUL)\n\t\t|| (!did_undo && u_save(lnum, lnum + 1 + (empty ? 1 : 0))\n\t\t\t\t\t\t\t\t     == FAIL))\n\t{\n\t    vim_free(theline);\n\t    break;\n\t}\n\n\t// don't use autoindent if nothing was typed.\n\tif (p[0] == NUL)\n\t    theline[0] = NUL;\n\n\tdid_undo = TRUE;\n\tml_append(lnum, theline, (colnr_T)0, FALSE);\n\tif (empty)\n\t    // there are no marks below the inserted lines\n\t    appended_lines(lnum, 1L);\n\telse\n\t    appended_lines_mark(lnum, 1L);\n\n\tvim_free(theline);\n\t++lnum;\n\n\tif (empty)\n\t{\n\t    ml_delete(2L);\n\t    empty = FALSE;\n\t}\n    }\n    State = MODE_NORMAL;\n\n    if (eap->forceit)\n\tcurbuf->b_p_ai = !curbuf->b_p_ai;\n\n    // \"start\" is set to eap->line2+1 unless that position is invalid (when\n    // eap->line2 pointed to the end of the buffer and nothing was appended)\n    // \"end\" is set to lnum when something has been appended, otherwise\n    // it is the same as \"start\"  -- Acevedo\n    if ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n    {\n\tcurbuf->b_op_start.lnum = (eap->line2 < curbuf->b_ml.ml_line_count) ?\n\t    eap->line2 + 1 : curbuf->b_ml.ml_line_count;\n\tif (eap->cmdidx != CMD_append)\n\t    --curbuf->b_op_start.lnum;\n\tcurbuf->b_op_end.lnum = (eap->line2 < lnum)\n\t\t\t\t\t      ? lnum : curbuf->b_op_start.lnum;\n\tcurbuf->b_op_start.col = curbuf->b_op_end.col = 0;\n    }\n    curwin->w_cursor.lnum = lnum;\n    check_cursor_lnum();\n    beginline(BL_SOL | BL_FIX);\n\n    need_wait_return = FALSE;\t// don't use wait_return() now\n    ex_no_reprint = TRUE;\n}\n\n/*\n * \":change\"\n */\n    void\nex_change(exarg_T *eap)\n{\n    linenr_T\tlnum;\n\n#ifdef FEAT_EVAL\n    if (not_in_vim9(eap) == FAIL)\n\treturn;\n#endif\n    if (eap->line2 >= eap->line1\n\t    && u_save(eap->line1 - 1, eap->line2 + 1) == FAIL)\n\treturn;\n\n    // the ! flag toggles autoindent\n    if (eap->forceit ? !curbuf->b_p_ai : curbuf->b_p_ai)\n\tappend_indent = get_indent_lnum(eap->line1);\n\n    for (lnum = eap->line2; lnum >= eap->line1; --lnum)\n    {\n\tif (curbuf->b_ml.ml_flags & ML_EMPTY)\t    // nothing to delete\n\t    break;\n\tml_delete(eap->line1);\n    }\n\n    // make sure the cursor is not beyond the end of the file now\n    check_cursor_lnum();\n    deleted_lines_mark(eap->line1, (long)(eap->line2 - lnum));\n\n    // \":append\" on the line above the deleted lines.\n    eap->line2 = eap->line1;\n    ex_append(eap);\n}\n\n    void\nex_z(exarg_T *eap)\n{\n    char_u\t*x;\n    long\tbigness;\n    char_u\t*kind;\n    int\t\tminus = 0;\n    linenr_T\tstart, end, curs, i;\n    int\t\tj;\n    linenr_T\tlnum = eap->line2;\n\n    // Vi compatible: \":z!\" uses display height, without a count uses\n    // 'scroll'\n    if (eap->forceit)\n\tbigness = Rows - 1;\n    else if (!ONE_WINDOW)\n\tbigness = curwin->w_height - 3;\n    else\n\tbigness = curwin->w_p_scr * 2;\n    if (bigness < 1)\n\tbigness = 1;\n\n    x = eap->arg;\n    kind = x;\n    if (*kind == '-' || *kind == '+' || *kind == '='\n\t\t\t\t\t      || *kind == '^' || *kind == '.')\n\t++x;\n    while (*x == '-' || *x == '+')\n\t++x;\n\n    if (*x != 0)\n    {\n\tif (!VIM_ISDIGIT(*x))\n\t{\n\t    emsg(_(e_non_numeric_argument_to_z));\n\t    return;\n\t}\n\telse\n\t{\n\t    bigness = atol((char *)x);\n\n\t    // bigness could be < 0 if atol(x) overflows.\n\t    if (bigness > 2 * curbuf->b_ml.ml_line_count || bigness < 0)\n\t\tbigness = 2 * curbuf->b_ml.ml_line_count;\n\n\t    p_window = bigness;\n\t    if (*kind == '=')\n\t\tbigness += 2;\n\t}\n    }\n\n    // the number of '-' and '+' multiplies the distance\n    if (*kind == '-' || *kind == '+')\n\tfor (x = kind + 1; *x == *kind; ++x)\n\t    ;\n\n    switch (*kind)\n    {\n\tcase '-':\n\t    start = lnum - bigness * (linenr_T)(x - kind) + 1;\n\t    end = start + bigness - 1;\n\t    curs = end;\n\t    break;\n\n\tcase '=':\n\t    start = lnum - (bigness + 1) / 2 + 1;\n\t    end = lnum + (bigness + 1) / 2 - 1;\n\t    curs = lnum;\n\t    minus = 1;\n\t    break;\n\n\tcase '^':\n\t    start = lnum - bigness * 2;\n\t    end = lnum - bigness;\n\t    curs = lnum - bigness;\n\t    break;\n\n\tcase '.':\n\t    start = lnum - (bigness + 1) / 2 + 1;\n\t    end = lnum + (bigness + 1) / 2 - 1;\n\t    curs = end;\n\t    break;\n\n\tdefault:  // '+'\n\t    start = lnum;\n\t    if (*kind == '+')\n\t\tstart += bigness * (linenr_T)(x - kind - 1) + 1;\n\t    else if (eap->addr_count == 0)\n\t\t++start;\n\t    end = start + bigness - 1;\n\t    curs = end;\n\t    break;\n    }\n\n    if (start < 1)\n\tstart = 1;\n\n    if (end > curbuf->b_ml.ml_line_count)\n\tend = curbuf->b_ml.ml_line_count;\n\n    if (curs > curbuf->b_ml.ml_line_count)\n\tcurs = curbuf->b_ml.ml_line_count;\n    else if (curs < 1)\n\tcurs = 1;\n\n    for (i = start; i <= end; i++)\n    {\n\tif (minus && i == lnum)\n\t{\n\t    msg_putchar('\\n');\n\n\t    for (j = 1; j < Columns; j++)\n\t\tmsg_putchar('-');\n\t}\n\n\tprint_line(i, eap->flags & EXFLAG_NR, eap->flags & EXFLAG_LIST);\n\n\tif (minus && i == lnum)\n\t{\n\t    msg_putchar('\\n');\n\n\t    for (j = 1; j < Columns; j++)\n\t\tmsg_putchar('-');\n\t}\n    }\n\n    if (curwin->w_cursor.lnum != curs)\n    {\n\tcurwin->w_cursor.lnum = curs;\n\tcurwin->w_cursor.col = 0;\n    }\n    ex_no_reprint = TRUE;\n}\n\n/*\n * Check if the restricted flag is set.\n * If so, give an error message and return TRUE.\n * Otherwise, return FALSE.\n */\n    int\ncheck_restricted(void)\n{\n    if (restricted)\n    {\n\temsg(_(e_shell_commands_and_some_functionality_not_allowed_in_rvim));\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Check if the secure flag is set (.exrc or .vimrc in current directory).\n * If so, give an error message and return TRUE.\n * Otherwise, return FALSE.\n */\n    int\ncheck_secure(void)\n{\n    if (secure)\n    {\n\tsecure = 2;\n\temsg(_(e_command_not_allowed_from_vimrc_in_current_dir_or_tag_search));\n\treturn TRUE;\n    }\n#ifdef HAVE_SANDBOX\n    /*\n     * In the sandbox more things are not allowed, including the things\n     * disallowed in secure mode.\n     */\n    if (sandbox != 0)\n    {\n\temsg(_(e_not_allowed_in_sandbox));\n\treturn TRUE;\n    }\n#endif\n    return FALSE;\n}\n\nstatic char_u\t*old_sub = NULL;\t// previous substitute pattern\nstatic int\tglobal_need_beginline;\t// call beginline() after \":g\"\n\n/*\n * Flags that are kept between calls to :substitute.\n */\ntypedef struct {\n    int\tdo_all;\t\t// do multiple substitutions per line\n    int\tdo_ask;\t\t// ask for confirmation\n    int\tdo_count;\t// count only\n    int\tdo_error;\t// if false, ignore errors\n    int\tdo_print;\t// print last line with subs.\n    int\tdo_list;\t// list last line with subs.\n    int\tdo_number;\t// list last line with line nr\n    int\tdo_ic;\t\t// ignore case flag\n} subflags_T;\n\n/*\n * Skip over the \"sub\" part in :s/pat/sub/ where \"delimiter\" is the separating\n * character.\n */\n    char_u *\nskip_substitute(char_u *start, int delimiter)\n{\n    char_u *p = start;\n\n    while (p[0])\n    {\n\tif (p[0] == delimiter)\t\t// end delimiter found\n\t{\n\t    *p++ = NUL;\t\t\t// replace it with a NUL\n\t    break;\n\t}\n\tif (p[0] == '\\\\' && p[1] != 0)\t// skip escaped characters\n\t    ++p;\n\tMB_PTR_ADV(p);\n    }\n    return p;\n}\n\n    static int\ncheck_regexp_delim(int c)\n{\n    if (SAFE_isalpha(c))\n    {\n\temsg(_(e_regular_expressions_cant_be_delimited_by_letters));\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * Perform a substitution from line eap->line1 to line eap->line2 using the\n * command pointed to by eap->arg which should be of the form:\n *\n * /pattern/substitution/{flags}\n *\n * The usual escapes are supported as described in the regexp docs.\n */\n    void\nex_substitute(exarg_T *eap)\n{\n    linenr_T\tlnum;\n    long\ti = 0;\n    regmmatch_T regmatch;\n    static subflags_T subflags = {FALSE, FALSE, FALSE, TRUE, FALSE,\n\t\t\t\t\t\t\t      FALSE, FALSE, 0};\n#ifdef FEAT_EVAL\n    subflags_T\tsubflags_save;\n#endif\n    int\t\tsave_do_all;\t\t// remember user specified 'g' flag\n    int\t\tsave_do_ask;\t\t// remember user specified 'c' flag\n    char_u\t*pat = NULL, *sub = NULL;\t// init for GCC\n    size_t\tpatlen = 0;\n    int\t\tdelimiter;\n    int\t\tsublen;\n    int\t\tgot_quit = FALSE;\n    int\t\tgot_match = FALSE;\n    int\t\twhich_pat;\n    char_u\t*cmd;\n    char_u\t*p;\n    int\t\tsave_State;\n    linenr_T\tfirst_line = 0;\t\t// first changed line\n    linenr_T\tlast_line= 0;\t\t// below last changed line AFTER the\n\t\t\t\t\t// change\n    linenr_T\told_line_count = curbuf->b_ml.ml_line_count;\n    linenr_T\tline2;\n    long\tnmatch;\t\t\t// number of lines in match\n    char_u\t*sub_firstline;\t\t// allocated copy of first sub line\n    int\t\tendcolumn = FALSE;\t// cursor in last column when done\n    pos_T\told_cursor = curwin->w_cursor;\n    int\t\tstart_nsubs;\n    int\t\tkeeppatterns = cmdmod.cmod_flags & CMOD_KEEPPATTERNS;\n#ifdef FEAT_EVAL\n    int\t\tsave_ma = 0;\n    int\t\tsave_sandbox = 0;\n#endif\n#ifdef FEAT_PROP_POPUP\n    textprop_T\t*text_props = NULL;\n#endif\n\n    cmd = eap->arg;\n    if (!global_busy)\n    {\n\tsub_nsubs = 0;\n\tsub_nlines = 0;\n    }\n    start_nsubs = sub_nsubs;\n\n    if (eap->cmdidx == CMD_tilde)\n\twhich_pat = RE_LAST;\t// use last used regexp\n    else\n\twhich_pat = RE_SUBST;\t// use last substitute regexp\n\n\t\t\t\t// new pattern and substitution\n    if (eap->cmd[0] == 's' && *cmd != NUL && !VIM_ISWHITE(*cmd)\n\t\t&& vim_strchr((char_u *)\"0123456789cegriIp|\\\"\", *cmd) == NULL)\n    {\n\t\t\t\t// don't accept alphanumeric for separator\n\tif (check_regexp_delim(*cmd) == FAIL)\n\t    return;\n#ifdef FEAT_EVAL\n\tif (in_vim9script() && check_global_and_subst(eap->cmd, eap->arg)\n\t\t\t\t\t\t\t\t      == FAIL)\n\t    return;\n#endif\n\n\t/*\n\t * undocumented vi feature:\n\t *  \"\\/sub/\" and \"\\?sub?\" use last used search pattern (almost like\n\t *  //sub/r).  \"\\&sub&\" use last substitute pattern (like //sub/).\n\t */\n\tif (*cmd == '\\\\')\n\t{\n\t    if (in_vim9script())\n\t    {\n\t\temsg(_(e_cannot_use_s_backslash_in_vim9_script));\n\t\treturn;\n\t    }\n\t    ++cmd;\n\t    if (vim_strchr((char_u *)\"/?&\", *cmd) == NULL)\n\t    {\n\t\temsg(_(e_backslash_should_be_followed_by));\n\t\treturn;\n\t    }\n\t    if (*cmd != '&')\n\t\twhich_pat = RE_SEARCH;\t    // use last '/' pattern\n\t    pat = (char_u *)\"\";\t\t    // empty search pattern\n\t    patlen = 0;\n\t    delimiter = *cmd++;\t\t    // remember delimiter character\n\t}\n\telse\t\t// find the end of the regexp\n\t{\n\t    which_pat = RE_LAST;\t    // use last used regexp\n\t    delimiter = *cmd++;\t\t    // remember delimiter character\n\t    pat = cmd;\t\t\t    // remember start of search pat\n\t    cmd = skip_regexp_ex(cmd, delimiter, magic_isset(),\n\t\t\t\t\t\t\t&eap->arg, NULL, NULL);\n\t    if (cmd[0] == delimiter)\t    // end delimiter found\n\t\t*cmd++ = NUL;\t\t    // replace it with a NUL\n\t    patlen = STRLEN(pat);\n\t}\n\n\t/*\n\t * Small incompatibility: vi sees '\\n' as end of the command, but in\n\t * Vim we want to use '\\n' to find/substitute a NUL.\n\t */\n\tp = cmd;\t    // remember the start of the substitution\n\tcmd = skip_substitute(cmd, delimiter);\n\tsub = vim_strsave(p);\n\tif (sub == NULL)\n\t    // out of memory\n\t    return;\n\n\tif (!eap->skip)\n\t{\n\t    // In POSIX vi \":s/pat/%/\" uses the previous subst. string.\n\t    if (STRCMP(sub, \"%\") == 0\n\t\t\t\t && vim_strchr(p_cpo, CPO_SUBPERCENT) != NULL)\n\t    {\n\t\tif (old_sub == NULL)\t// there is no previous command\n\t\t{\n\t\t    emsg(_(e_no_previous_substitute_regular_expression));\n\t\t    vim_free(sub);\n\t\t    return;\n\t\t}\n\t\tvim_free(sub);\n\t\tsub = vim_strsave(old_sub);\n\t\tif (sub == NULL)\n\t\t    // out of memory\n\t\t    return;\n\t    }\n\t    else if (!keeppatterns)\n\t    {\n\t\tvim_free(old_sub);\n\t\told_sub = vim_strsave(sub);\n\t\tif (old_sub == NULL)\n\t\t    // out of memory\n\t\t    return;\n\t    }\n\t}\n    }\n    else if (!eap->skip)\t// use previous pattern and substitution\n    {\n\tif (old_sub == NULL)\t// there is no previous command\n\t{\n\t    emsg(_(e_no_previous_substitute_regular_expression));\n\t    return;\n\t}\n\tpat = NULL;\t\t// search_regcomp() will use previous pattern\n\tpatlen = 0;\n\tsub = vim_strsave(old_sub);\n\n\t// Vi compatibility quirk: repeating with \":s\" keeps the cursor in the\n\t// last column after using \"$\".\n\tendcolumn = (curwin->w_curswant == MAXCOL);\n    }\n\n    // Recognize \":%s/\\n//\" and turn it into a join command, which is much\n    // more efficient.\n    // TODO: find a generic solution to make line-joining operations more\n    // efficient, avoid allocating a string that grows in size.\n    if (pat != NULL && STRCMP(pat, \"\\\\n\") == 0\n\t    && *sub == NUL\n\t    && (*cmd == NUL || (cmd[1] == NUL && (*cmd == 'g' || *cmd == 'l'\n\t\t\t\t\t     || *cmd == 'p' || *cmd == '#'))))\n    {\n\tlinenr_T    joined_lines_count;\n\n\tif (eap->skip)\n\t{\n\t    vim_free(sub);\n\t    return;\n\t}\n\tcurwin->w_cursor.lnum = eap->line1;\n\tif (*cmd == 'l')\n\t    eap->flags = EXFLAG_LIST;\n\telse if (*cmd == '#')\n\t    eap->flags = EXFLAG_NR;\n\telse if (*cmd == 'p')\n\t    eap->flags = EXFLAG_PRINT;\n\n\t// The number of lines joined is the number of lines in the range plus\n\t// one.  One less when the last line is included.\n\tjoined_lines_count = eap->line2 - eap->line1 + 1;\n\tif (eap->line2 < curbuf->b_ml.ml_line_count)\n\t    ++joined_lines_count;\n\tif (joined_lines_count > 1)\n\t{\n\t    (void)do_join(joined_lines_count, FALSE, TRUE, FALSE, TRUE);\n\t    sub_nsubs = joined_lines_count - 1;\n\t    sub_nlines = 1;\n\t    (void)do_sub_msg(FALSE);\n\t    ex_may_print(eap);\n\t}\n\n\tif (!keeppatterns)\n\t    save_re_pat(RE_SUBST, pat, patlen, magic_isset());\n\t// put pattern in history\n\tadd_to_history(HIST_SEARCH, pat, patlen, TRUE, NUL);\n\tvim_free(sub);\n\n\treturn;\n    }\n\n    /*\n     * Find trailing options.  When '&' is used, keep old options.\n     */\n    if (*cmd == '&')\n\t++cmd;\n    else\n    {\n#ifdef FEAT_EVAL\n\tif (in_vim9script())\n\t{\n\t    // ignore 'gdefault' and 'edcompatible'\n\t    subflags.do_all = FALSE;\n\t    subflags.do_ask = FALSE;\n\t}\n\telse\n#endif\n\tif (!p_ed)\n\t{\n\t    if (p_gd)\t\t// default is global on\n\t\tsubflags.do_all = TRUE;\n\t    else\n\t\tsubflags.do_all = FALSE;\n\t    subflags.do_ask = FALSE;\n\t}\n\tsubflags.do_error = TRUE;\n\tsubflags.do_print = FALSE;\n\tsubflags.do_list = FALSE;\n\tsubflags.do_count = FALSE;\n\tsubflags.do_number = FALSE;\n\tsubflags.do_ic = 0;\n    }\n    while (*cmd)\n    {\n\t/*\n\t * Note that 'g' and 'c' are always inverted, also when p_ed is off.\n\t * 'r' is never inverted.\n\t */\n\tif (*cmd == 'g')\n\t    subflags.do_all = !subflags.do_all;\n\telse if (*cmd == 'c')\n\t    subflags.do_ask = !subflags.do_ask;\n\telse if (*cmd == 'n')\n\t    subflags.do_count = TRUE;\n\telse if (*cmd == 'e')\n\t    subflags.do_error = !subflags.do_error;\n\telse if (*cmd == 'r')\t    // use last used regexp\n\t    which_pat = RE_LAST;\n\telse if (*cmd == 'p')\n\t    subflags.do_print = TRUE;\n\telse if (*cmd == '#')\n\t{\n\t    subflags.do_print = TRUE;\n\t    subflags.do_number = TRUE;\n\t}\n\telse if (*cmd == 'l')\n\t{\n\t    subflags.do_print = TRUE;\n\t    subflags.do_list = TRUE;\n\t}\n\telse if (*cmd == 'i')\t    // ignore case\n\t    subflags.do_ic = 'i';\n\telse if (*cmd == 'I')\t    // don't ignore case\n\t    subflags.do_ic = 'I';\n\telse\n\t    break;\n\t++cmd;\n    }\n    if (subflags.do_count)\n\tsubflags.do_ask = FALSE;\n\n    save_do_all = subflags.do_all;\n    save_do_ask = subflags.do_ask;\n\n    /*\n     * check for a trailing count\n     */\n    cmd = skipwhite(cmd);\n    if (VIM_ISDIGIT(*cmd))\n    {\n\ti = getdigits(&cmd);\n\tif (i <= 0 && !eap->skip && subflags.do_error)\n\t{\n\t    emsg(_(e_positive_count_required));\n\t    vim_free(sub);\n\t    return;\n\t}\n\telse if (i >= INT_MAX)\n\t{\n\t    char\tbuf[20];\n\t    vim_snprintf(buf, sizeof(buf), \"%ld\", i);\n\t    semsg(_(e_val_too_large), buf);\n\t    vim_free(sub);\n\t    return;\n\t}\n\teap->line1 = eap->line2;\n\teap->line2 += i - 1;\n\tif (eap->line2 > curbuf->b_ml.ml_line_count)\n\t    eap->line2 = curbuf->b_ml.ml_line_count;\n    }\n\n    /*\n     * check for trailing command or garbage\n     */\n    cmd = skipwhite(cmd);\n    if (*cmd && *cmd != '\"')\t    // if not end-of-line or comment\n    {\n\tset_nextcmd(eap, cmd);\n\tif (eap->nextcmd == NULL)\n\t{\n\t    semsg(_(e_trailing_characters_str), cmd);\n\t    vim_free(sub);\n\t    return;\n\t}\n    }\n\n    if (eap->skip)\t    // not executing commands, only parsing\n    {\n\tvim_free(sub);\n\treturn;\n    }\n\n    if (!subflags.do_count && !curbuf->b_p_ma)\n    {\n\t// Substitution is not allowed in non-'modifiable' buffer\n\temsg(_(e_cannot_make_changes_modifiable_is_off));\n\tvim_free(sub);\n\treturn;\n    }\n\n    if (search_regcomp(pat, patlen, NULL, RE_SUBST, which_pat, SEARCH_HIS, &regmatch) == FAIL)\n    {\n\tif (subflags.do_error)\n\t    emsg(_(e_invalid_command));\n\tvim_free(sub);\n\treturn;\n    }\n\n    // the 'i' or 'I' flag overrules 'ignorecase' and 'smartcase'\n    if (subflags.do_ic == 'i')\n\tregmatch.rmm_ic = TRUE;\n    else if (subflags.do_ic == 'I')\n\tregmatch.rmm_ic = FALSE;\n\n    sub_firstline = NULL;\n\n    /*\n     * If the substitute pattern starts with \"\\=\" then it's an expression.\n     * Make a copy, a recursive function may free it.\n     * Otherwise, '~' in the substitute pattern is replaced with the old\n     * pattern.  We do it here once to avoid it to be replaced over and over\n     * again.\n     */\n    if (sub[0] == '\\\\' && sub[1] == '=')\n    {\n\tp = vim_strsave(sub);\n\tvim_free(sub);\n\tif (p == NULL)\n\t    return;\n\tsub = p;\n    }\n    else\n    {\n\tp = regtilde(sub, magic_isset());\n\n\tif (p != sub)\n\t{\n\t    vim_free(sub);\n\t    sub = p;\n\t}\n    }\n\n    /*\n     * Check for a match on each line.\n     */\n    line2 = eap->line2;\n    for (lnum = eap->line1; lnum <= line2 && !(got_quit\n#if defined(FEAT_EVAL)\n\t\t|| aborting()\n#endif\n\t\t); ++lnum)\n    {\n\tnmatch = vim_regexec_multi(&regmatch, curwin, curbuf, lnum,\n\t\t\t\t\t\t       (colnr_T)0, NULL);\n\tif (nmatch)\n\t{\n\t    colnr_T\tcopycol;\n\t    colnr_T\tmatchcol;\n\t    colnr_T\tprev_matchcol = MAXCOL;\n\t    char_u\t*new_end, *new_start = NULL;\n\t    unsigned\tnew_start_len = 0;\n\t    char_u\t*p1;\n\t    int\t\tdid_sub = FALSE;\n\t    int\t\tlastone;\n\t    int\t\tlen, copy_len, needed_len;\n\t    long\tnmatch_tl = 0;\t// nr of lines matched below lnum\n\t    int\t\tdo_again;\t// do it again after joining lines\n\t    int\t\tskip_match = FALSE;\n\t    linenr_T\tsub_firstlnum;\t// nr of first sub line\n#ifdef FEAT_PROP_POPUP\n\t    int\t\tapc_flags = APC_SAVE_FOR_UNDO | APC_SUBSTITUTE;\n\t    colnr_T\ttotal_added =  0;\n\t    int\t\ttext_prop_count = 0;\n#endif\n\n\t    /*\n\t     * The new text is build up step by step, to avoid too much\n\t     * copying.  There are these pieces:\n\t     * sub_firstline\tThe old text, unmodified.\n\t     * copycol\t\tColumn in the old text where we started\n\t     *\t\t\tlooking for a match; from here old text still\n\t     *\t\t\tneeds to be copied to the new text.\n\t     * matchcol\t\tColumn number of the old text where to look\n\t     *\t\t\tfor the next match.  It's just after the\n\t     *\t\t\tprevious match or one further.\n\t     * prev_matchcol\tColumn just after the previous match (if any).\n\t     *\t\t\tMostly equal to matchcol, except for the first\n\t     *\t\t\tmatch and after skipping an empty match.\n\t     * regmatch.*pos\tWhere the pattern matched in the old text.\n\t     * new_start\tThe new text, all that has been produced so\n\t     *\t\t\tfar.\n\t     * new_end\t\tThe new text, where to append new text.\n\t     *\n\t     * lnum\t\tThe line number where we found the start of\n\t     *\t\t\tthe match.  Can be below the line we searched\n\t     *\t\t\twhen there is a \\n before a \\zs in the\n\t     *\t\t\tpattern.\n\t     * sub_firstlnum\tThe line number in the buffer where to look\n\t     *\t\t\tfor a match.  Can be different from \"lnum\"\n\t     *\t\t\twhen the pattern or substitute string contains\n\t     *\t\t\tline breaks.\n\t     *\n\t     * Special situations:\n\t     * - When the substitute string contains a line break, the part up\n\t     *   to the line break is inserted in the text, but the copy of\n\t     *   the original line is kept.  \"sub_firstlnum\" is adjusted for\n\t     *   the inserted lines.\n\t     * - When the matched pattern contains a line break, the old line\n\t     *   is taken from the line at the end of the pattern.  The lines\n\t     *   in the match are deleted later, \"sub_firstlnum\" is adjusted\n\t     *   accordingly.\n\t     *\n\t     * The new text is built up in new_start[].  It has some extra\n\t     * room to avoid using alloc()/free() too often.  new_start_len is\n\t     * the length of the allocated memory at new_start.\n\t     *\n\t     * Make a copy of the old line, so it won't be taken away when\n\t     * updating the screen or handling a multi-line match.  The \"old_\"\n\t     * pointers point into this copy.\n\t     */\n\t    sub_firstlnum = lnum;\n\t    copycol = 0;\n\t    matchcol = 0;\n\n\t    // At first match, remember current cursor position.\n\t    if (!got_match)\n\t    {\n\t\tsetpcmark();\n\t\tgot_match = TRUE;\n\t    }\n\n\t    /*\n\t     * Loop until nothing more to replace in this line.\n\t     * 1. Handle match with empty string.\n\t     * 2. If do_ask is set, ask for confirmation.\n\t     * 3. substitute the string.\n\t     * 4. if do_all is set, find next match\n\t     * 5. break if there isn't another match in this line\n\t     */\n\t    for (;;)\n\t    {\n\t\t// Advance \"lnum\" to the line where the match starts.  The\n\t\t// match does not start in the first line when there is a line\n\t\t// break before \\zs.\n\t\tif (regmatch.startpos[0].lnum > 0)\n\t\t{\n\t\t    lnum += regmatch.startpos[0].lnum;\n\t\t    sub_firstlnum += regmatch.startpos[0].lnum;\n\t\t    nmatch -= regmatch.startpos[0].lnum;\n\t\t    VIM_CLEAR(sub_firstline);\n\t\t}\n\n\t\t// Match might be after the last line for \"\\n\\zs\" matching at\n\t\t// the end of the last line.\n\t\tif (lnum > curbuf->b_ml.ml_line_count)\n\t\t    break;\n\n\t\tif (sub_firstline == NULL)\n\t\t{\n\t\t    sub_firstline = vim_strnsave(ml_get(sub_firstlnum),\n\t\t\t\t\t\t    ml_get_len(sub_firstlnum));\n\t\t    if (sub_firstline == NULL)\n\t\t    {\n\t\t\tvim_free(new_start);\n\t\t\tgoto outofmem;\n\t\t    }\n\t\t}\n\n\t\t// Save the line number of the last change for the final\n\t\t// cursor position (just like Vi).\n\t\tcurwin->w_cursor.lnum = lnum;\n\t\tdo_again = FALSE;\n\n\t\t/*\n\t\t * 1. Match empty string does not count, except for first\n\t\t * match.  This reproduces the strange vi behaviour.\n\t\t * This also catches endless loops.\n\t\t */\n\t\tif (matchcol == prev_matchcol\n\t\t\t&& regmatch.endpos[0].lnum == 0\n\t\t\t&& matchcol == regmatch.endpos[0].col)\n\t\t{\n\t\t    if (sub_firstline[matchcol] == NUL)\n\t\t\t// We already were at the end of the line.  Don't look\n\t\t\t// for a match in this line again.\n\t\t\tskip_match = TRUE;\n\t\t    else\n\t\t    {\n\t\t\t // search for a match at next column\n\t\t\tif (has_mbyte)\n\t\t\t    matchcol += mb_ptr2len(sub_firstline + matchcol);\n\t\t\telse\n\t\t\t    ++matchcol;\n\t\t    }\n\t\t    goto skip;\n\t\t}\n\n\t\t// Normally we continue searching for a match just after the\n\t\t// previous match.\n\t\tmatchcol = regmatch.endpos[0].col;\n\t\tprev_matchcol = matchcol;\n\n\t\t/*\n\t\t * 2. If do_count is set only increase the counter.\n\t\t *    If do_ask is set, ask for confirmation.\n\t\t */\n\t\tif (subflags.do_count)\n\t\t{\n\t\t    // For a multi-line match, put matchcol at the NUL at\n\t\t    // the end of the line and set nmatch to one, so that\n\t\t    // we continue looking for a match on the next line.\n\t\t    // Avoids that \":s/\\nB\\@=//gc\" get stuck.\n\t\t    if (nmatch > 1)\n\t\t    {\n\t\t\tmatchcol = (colnr_T)STRLEN(sub_firstline);\n\t\t\tnmatch = 1;\n\t\t\tskip_match = TRUE;\n\t\t    }\n\t\t    sub_nsubs++;\n\t\t    did_sub = TRUE;\n#ifdef FEAT_EVAL\n\t\t    // Skip the substitution, unless an expression is used,\n\t\t    // then it is evaluated in the sandbox.\n\t\t    if (!(sub[0] == '\\\\' && sub[1] == '='))\n#endif\n\t\t\tgoto skip;\n\t\t}\n\n\t\tif (subflags.do_ask)\n\t\t{\n\t\t    int typed = 0;\n\n\t\t    // change State to MODE_CONFIRM, so that the mouse works\n\t\t    // properly\n\t\t    save_State = State;\n\t\t    State = MODE_CONFIRM;\n\t\t    setmouse();\t\t// disable mouse in xterm\n\t\t    curwin->w_cursor.col = regmatch.startpos[0].col;\n\t\t    if (curwin->w_p_crb)\n\t\t\tdo_check_cursorbind();\n\n\t\t    // When 'cpoptions' contains \"u\" don't sync undo when\n\t\t    // asking for confirmation.\n\t\t    if (vim_strchr(p_cpo, CPO_UNDO) != NULL)\n\t\t\t++no_u_sync;\n\n\t\t    /*\n\t\t     * Loop until 'y', 'n', 'q', CTRL-E or CTRL-Y typed.\n\t\t     */\n\t\t    while (subflags.do_ask)\n\t\t    {\n\t\t\tif (exmode_active)\n\t\t\t{\n\t\t\t    char_u\t*resp;\n\t\t\t    colnr_T\tsc, ec;\n\n\t\t\t    print_line_no_prefix(lnum,\n\t\t\t\t\t subflags.do_number, subflags.do_list);\n\n\t\t\t    getvcol(curwin, &curwin->w_cursor, &sc, NULL, NULL);\n\t\t\t    curwin->w_cursor.col = regmatch.endpos[0].col - 1;\n\t\t\t    if (curwin->w_cursor.col < 0)\n\t\t\t\tcurwin->w_cursor.col = 0;\n\t\t\t    getvcol(curwin, &curwin->w_cursor, NULL, NULL, &ec);\n\t\t\t    curwin->w_cursor.col = regmatch.startpos[0].col;\n\t\t\t    if (subflags.do_number || curwin->w_p_nu)\n\t\t\t    {\n\t\t\t\tint numw = number_width(curwin) + 1;\n\t\t\t\tsc += numw;\n\t\t\t\tec += numw;\n\t\t\t    }\n\t\t\t    msg_start();\n\t\t\t    for (i = 0; i < (long)sc; ++i)\n\t\t\t\tmsg_putchar(' ');\n\t\t\t    for ( ; i <= (long)ec; ++i)\n\t\t\t\tmsg_putchar('^');\n\n\t\t\t    resp = getexmodeline('?', NULL, 0, TRUE);\n\t\t\t    if (resp != NULL)\n\t\t\t    {\n\t\t\t\ttyped = *resp;\n\t\t\t\tvim_free(resp);\n\t\t\t\t// When \":normal\" runs out of characters we get\n\t\t\t\t// an empty line.  Use \"q\" to get out of the\n\t\t\t\t// loop.\n\t\t\t\tif (ex_normal_busy && typed == NUL)\n\t\t\t\t    typed = 'q';\n\t\t\t    }\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    char_u *orig_line = NULL;\n\t\t\t    int    len_change = 0;\n\t\t\t    int\t   save_p_lz = p_lz;\n#ifdef FEAT_FOLDING\n\t\t\t    int save_p_fen = curwin->w_p_fen;\n\n\t\t\t    curwin->w_p_fen = FALSE;\n#endif\n\t\t\t    // Invert the matched string.\n\t\t\t    // Remove the inversion afterwards.\n\t\t\t    int save_RedrawingDisabled = RedrawingDisabled;\n\t\t\t    RedrawingDisabled = 0;\n\n\t\t\t    // avoid calling update_screen() in vgetorpeek()\n\t\t\t    p_lz = FALSE;\n\n\t\t\t    if (new_start != NULL)\n\t\t\t    {\n\t\t\t\t// There already was a substitution, we would\n\t\t\t\t// like to show this to the user.  We cannot\n\t\t\t\t// really update the line, it would change\n\t\t\t\t// what matches.  Temporarily replace the line\n\t\t\t\t// and change it back afterwards.\n\t\t\t\torig_line = vim_strnsave(ml_get(lnum),\n\t\t\t\t\t\t\t     ml_get_len(lnum));\n\t\t\t\tif (orig_line != NULL)\n\t\t\t\t{\n\t\t\t\t    char_u *new_line = concat_str(new_start,\n\t\t\t\t\t\t     sub_firstline + copycol);\n\n\t\t\t\t    if (new_line == NULL)\n\t\t\t\t\tVIM_CLEAR(orig_line);\n\t\t\t\t    else\n\t\t\t\t    {\n\t\t\t\t\t// Position the cursor relative to the\n\t\t\t\t\t// end of the line, the previous\n\t\t\t\t\t// substitute may have inserted or\n\t\t\t\t\t// deleted characters before the\n\t\t\t\t\t// cursor.\n\t\t\t\t\tlen_change = (int)STRLEN(new_line)\n\t\t\t\t\t\t     - (int)STRLEN(orig_line);\n\t\t\t\t\tcurwin->w_cursor.col += len_change;\n\t\t\t\t\tml_replace(lnum, new_line, FALSE);\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t    }\n\n\t\t\t    search_match_lines = regmatch.endpos[0].lnum\n\t\t\t\t\t\t  - regmatch.startpos[0].lnum;\n\t\t\t    search_match_endcol = regmatch.endpos[0].col\n\t\t\t\t\t\t\t\t + len_change;\n\t\t\t    if (search_match_lines == 0\n\t\t\t\t\t\t   && search_match_endcol == 0)\n\t\t\t\t// highlight at least one character for /^/\n\t\t\t\tsearch_match_endcol = 1;\n\t\t\t    highlight_match = TRUE;\n\n\t\t\t    update_topline();\n\t\t\t    validate_cursor();\n\t\t\t    update_screen(UPD_SOME_VALID);\n\t\t\t    highlight_match = FALSE;\n\t\t\t    redraw_later(UPD_SOME_VALID);\n\n#ifdef FEAT_FOLDING\n\t\t\t    curwin->w_p_fen = save_p_fen;\n#endif\n\t\t\t    if (msg_row == Rows - 1)\n\t\t\t\tmsg_didout = FALSE;\t// avoid a scroll-up\n\t\t\t    msg_starthere();\n\t\t\t    i = msg_scroll;\n\t\t\t    msg_scroll = 0;\t\t// truncate msg when\n\t\t\t\t\t\t\t// needed\n\t\t\t    msg_no_more = TRUE;\n\t\t\t    // write message same highlighting as for\n\t\t\t    // wait_return()\n\t\t\t    smsg_attr(HL_ATTR(HLF_R),\n\t\t\t\t_(\"replace with %s (y/n/a/q/l/^E/^Y)?\"), sub);\n\t\t\t    msg_no_more = FALSE;\n\t\t\t    msg_scroll = i;\n\t\t\t    showruler(TRUE);\n\t\t\t    windgoto(msg_row, msg_col);\n\t\t\t    RedrawingDisabled = save_RedrawingDisabled;\n\n#ifdef USE_ON_FLY_SCROLL\n\t\t\t    dont_scroll = FALSE; // allow scrolling here\n#endif\n\t\t\t    ++no_mapping;\t// don't map this key\n\t\t\t    ++allow_keys;\t// allow special keys\n\t\t\t    typed = plain_vgetc();\n\t\t\t    --allow_keys;\n\t\t\t    --no_mapping;\n\n\t\t\t    // clear the question\n\t\t\t    msg_didout = FALSE;\t// don't scroll up\n\t\t\t    msg_col = 0;\n\t\t\t    gotocmdline(TRUE);\n\t\t\t    p_lz = save_p_lz;\n\n\t\t\t    // restore the line\n\t\t\t    if (orig_line != NULL)\n\t\t\t\tml_replace(lnum, orig_line, FALSE);\n\t\t\t}\n\n\t\t\tneed_wait_return = FALSE; // no hit-return prompt\n\t\t\tif (typed == 'q' || typed == ESC || typed == Ctrl_C\n#ifdef UNIX\n\t\t\t\t|| typed == intr_char\n#endif\n\t\t\t\t)\n\t\t\t{\n\t\t\t    got_quit = TRUE;\n\t\t\t    break;\n\t\t\t}\n\t\t\tif (typed == 'n')\n\t\t\t    break;\n\t\t\tif (typed == 'y')\n\t\t\t    break;\n\t\t\tif (typed == 'l')\n\t\t\t{\n\t\t\t    // last: replace and then stop\n\t\t\t    subflags.do_all = FALSE;\n\t\t\t    line2 = lnum;\n\t\t\t    break;\n\t\t\t}\n\t\t\tif (typed == 'a')\n\t\t\t{\n\t\t\t    subflags.do_ask = FALSE;\n\t\t\t    break;\n\t\t\t}\n\t\t\tif (typed == Ctrl_E)\n\t\t\t    scrollup_clamp();\n\t\t\telse if (typed == Ctrl_Y)\n\t\t\t    scrolldown_clamp();\n\t\t    }\n\t\t    State = save_State;\n\t\t    setmouse();\n\t\t    if (vim_strchr(p_cpo, CPO_UNDO) != NULL)\n\t\t\t--no_u_sync;\n\n\t\t    if (typed == 'n')\n\t\t    {\n\t\t\t// For a multi-line match, put matchcol at the NUL at\n\t\t\t// the end of the line and set nmatch to one, so that\n\t\t\t// we continue looking for a match on the next line.\n\t\t\t// Avoids that \":%s/\\nB\\@=//gc\" and \":%s/\\n/,\\r/gc\"\n\t\t\t// get stuck when pressing 'n'.\n\t\t\tif (nmatch > 1)\n\t\t\t{\n\t\t\t    matchcol = (colnr_T)STRLEN(sub_firstline);\n\t\t\t    skip_match = TRUE;\n\t\t\t}\n\t\t\tgoto skip;\n\t\t    }\n\t\t    if (got_quit)\n\t\t\tgoto skip;\n\t\t}\n\n\t\t// Move the cursor to the start of the match, so that we can\n\t\t// use \"\\=col(\".\").\n\t\tcurwin->w_cursor.col = regmatch.startpos[0].col;\n\n\t\t/*\n\t\t * 3. substitute the string.\n\t\t */\n#ifdef FEAT_EVAL\n\t\tsave_ma = curbuf->b_p_ma;\n\t\tsave_sandbox = sandbox;\n\t\tif (subflags.do_count)\n\t\t{\n\t\t    // prevent accidentally changing the buffer by a function\n\t\t    curbuf->b_p_ma = FALSE;\n\t\t    sandbox++;\n\t\t}\n\t\t// Save flags for recursion.  They can change for e.g.\n\t\t// :s/^/\\=execute(\"s#^##gn\")\n\t\tsubflags_save = subflags;\n\n\t\t// Disallow changing text or switching window in an expression.\n\t\t++textlock;\n#endif\n\t\t// Get length of substitution part, including the NUL.\n\t\t// When it fails sublen is zero.\n\t\tsublen = vim_regsub_multi(&regmatch,\n\t\t\t\t    sub_firstlnum - regmatch.startpos[0].lnum,\n\t\t\t       sub, sub_firstline, 0,\n\t\t\t       REGSUB_BACKSLASH\n\t\t\t\t    | (magic_isset() ? REGSUB_MAGIC : 0));\n#ifdef FEAT_EVAL\n\t\t--textlock;\n\n\t\t// If getting the substitute string caused an error, don't do\n\t\t// the replacement.\n\t\t// Don't keep flags set by a recursive call.\n\t\tsubflags = subflags_save;\n\t\tif (sublen == 0 || aborting() || subflags.do_count)\n\t\t{\n\t\t    curbuf->b_p_ma = save_ma;\n\t\t    sandbox = save_sandbox;\n\t\t    goto skip;\n\t\t}\n#endif\n\n\t\t// When the match included the \"$\" of the last line it may\n\t\t// go beyond the last line of the buffer.\n\t\tif (nmatch > curbuf->b_ml.ml_line_count - sub_firstlnum + 1)\n\t\t{\n\t\t    nmatch = curbuf->b_ml.ml_line_count - sub_firstlnum + 1;\n\t\t    skip_match = TRUE;\n\t\t    // safety check\n\t\t    if (nmatch < 0)\n\t\t\tgoto skip;\n\t\t}\n\n\t\t// Need room for:\n\t\t// - result so far in new_start (not for first sub in line)\n\t\t// - original text up to match\n\t\t// - length of substituted part\n\t\t// - original text after match\n\t\t// Adjust text properties here, since we have all information\n\t\t// needed.\n\t\tif (nmatch == 1)\n\t\t{\n\t\t    p1 = sub_firstline;\n#ifdef FEAT_PROP_POPUP\n\t\t    if (curbuf->b_has_textprop)\n\t\t    {\n\t\t\tint bytes_added = sublen - 1 - (regmatch.endpos[0].col\n\t\t\t\t\t\t   - regmatch.startpos[0].col);\n\n\t\t\t// When text properties are changed, need to save for\n\t\t\t// undo first, unless done already.\n\t\t\tif (adjust_prop_columns(lnum,\n\t\t\t\t\ttotal_added + regmatch.startpos[0].col,\n\t\t\t\t\t\t       bytes_added, apc_flags))\n\t\t\t    apc_flags &= ~APC_SAVE_FOR_UNDO;\n\t\t\t// Offset for column byte number of the text property\n\t\t\t// in the resulting buffer afterwards.\n\t\t\ttotal_added += bytes_added;\n\t\t    }\n#endif\n\t\t}\n\t\telse\n\t\t{\n\t\t    linenr_T\tlastlnum = sub_firstlnum + nmatch - 1;\n#ifdef FEAT_PROP_POPUP\n\t\t    if (curbuf->b_has_textprop)\n\t\t    {\n\t\t\tchar_u\t*prop_start;\n\n\t\t\t// Props in the first line may be shortened or deleted\n\t\t\tif (adjust_prop_columns(lnum,\n\t\t\t\t\ttotal_added + regmatch.startpos[0].col,\n\t\t\t\t\t\t       -MAXCOL, apc_flags))\n\t\t\t    apc_flags &= ~APC_SAVE_FOR_UNDO;\n\t\t\ttotal_added -= (colnr_T)STRLEN(\n\t\t\t\t     sub_firstline + regmatch.startpos[0].col);\n\n\t\t\t// Props in the last line may be moved or deleted\n\t\t\tif (adjust_prop_columns(lastlnum,\n\t\t\t\t\t0, -regmatch.endpos[0].col, apc_flags))\n\t\t\t    // When text properties are changed, need to save\n\t\t\t    // for undo first, unless done already.\n\t\t\t    apc_flags &= ~APC_SAVE_FOR_UNDO;\n\n\t\t\t// Copy the text props of the last line, they will be\n\t\t\t// later appended to the changed line.\n\t\t\ttext_prop_count = get_text_props(curbuf, lastlnum,\n\t\t\t\t\t\t\t   &prop_start, FALSE);\n\t\t\tif (text_prop_count > 0)\n\t\t\t{\n\t\t\t    // TODO: what when we already did this?\n\t\t\t    vim_free(text_props);\n\t\t\t    text_props = ALLOC_MULT(textprop_T,\n\t\t\t\t\t\t\t      text_prop_count);\n\t\t\t    if (text_props != NULL)\n\t\t\t    {\n\t\t\t\tint pi;\n\n\t\t\t\tmch_memmove(text_props, prop_start,\n\t\t\t\t\t text_prop_count * sizeof(textprop_T));\n\t\t\t\t// After joining the text prop columns will\n\t\t\t\t// increase.\n\t\t\t\tfor (pi = 0; pi < text_prop_count; ++pi)\n\t\t\t\t    text_props[pi].tp_col +=\n\t\t\t\t\t regmatch.startpos[0].col + sublen - 1;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n#endif\n\t\t    p1 = ml_get(lastlnum);\n\t\t    nmatch_tl += nmatch - 1;\n#ifdef FEAT_PROP_POPUP\n\t\t    if (curbuf->b_has_textprop)\n\t\t\ttotal_added += (colnr_T)STRLEN(\n\t\t\t\t\t\t  p1 + regmatch.endpos[0].col);\n#endif\n\t\t}\n\t\tcopy_len = regmatch.startpos[0].col - copycol;\n\t\tneeded_len = copy_len + ((unsigned)STRLEN(p1)\n\t\t\t\t       - regmatch.endpos[0].col) + sublen + 1;\n\t\tif (new_start == NULL)\n\t\t{\n\t\t    /*\n\t\t     * Get some space for a temporary buffer to do the\n\t\t     * substitution into (and some extra space to avoid\n\t\t     * too many calls to alloc()/free()).\n\t\t     */\n\t\t    new_start_len = needed_len + 50;\n\t\t    if ((new_start = alloc_clear(new_start_len)) == NULL)\n\t\t\tgoto outofmem;\n\t\t    *new_start = NUL;\n\t\t    new_end = new_start;\n\t\t}\n\t\telse\n\t\t{\n\t\t    /*\n\t\t     * Check if the temporary buffer is long enough to do the\n\t\t     * substitution into.  If not, make it larger (with a bit\n\t\t     * extra to avoid too many calls to alloc()/free()).\n\t\t     */\n\t\t    len = (unsigned)STRLEN(new_start);\n\t\t    needed_len += len;\n\t\t    if (needed_len > (int)new_start_len)\n\t\t    {\n\t\t\tnew_start_len = needed_len + 50;\n\t\t\tif ((p1 = alloc_clear(new_start_len)) == NULL)\n\t\t\t{\n\t\t\t    vim_free(new_start);\n\t\t\t    goto outofmem;\n\t\t\t}\n\t\t\tmch_memmove(p1, new_start, (size_t)(len + 1));\n\t\t\tvim_free(new_start);\n\t\t\tnew_start = p1;\n\t\t    }\n\t\t    new_end = new_start + len;\n\t\t}\n\n\t\t/*\n\t\t * copy the text up to the part that matched\n\t\t */\n\t\tmch_memmove(new_end, sub_firstline + copycol, (size_t)copy_len);\n\t\tnew_end += copy_len;\n\n\t\tif ((int)new_start_len - copy_len < sublen)\n\t\t    sublen = new_start_len - copy_len - 1;\n\n#ifdef FEAT_EVAL\n\t\t++textlock;\n#endif\n\t\t(void)vim_regsub_multi(&regmatch,\n\t\t\t\t    sub_firstlnum - regmatch.startpos[0].lnum,\n\t\t\t\t      sub, new_end, sublen,\n\t\t\t\t      REGSUB_COPY | REGSUB_BACKSLASH\n\t\t\t\t\t | (magic_isset() ? REGSUB_MAGIC : 0));\n#ifdef FEAT_EVAL\n\t\t--textlock;\n#endif\n\t\tsub_nsubs++;\n\t\tdid_sub = TRUE;\n\n\t\t// Move the cursor to the start of the line, to avoid that it\n\t\t// is beyond the end of the line after the substitution.\n\t\tcurwin->w_cursor.col = 0;\n\n\t\t// For a multi-line match, make a copy of the last matched\n\t\t// line and continue in that one.\n\t\tif (nmatch > 1)\n\t\t{\n\t\t    sub_firstlnum += nmatch - 1;\n\t\t    vim_free(sub_firstline);\n\t\t    sub_firstline = vim_strnsave(ml_get(sub_firstlnum),\n\t\t\t\t\t\t    ml_get_len(sub_firstlnum));\n\t\t    // When going beyond the last line, stop substituting.\n\t\t    if (sub_firstlnum <= line2)\n\t\t\tdo_again = TRUE;\n\t\t    else\n\t\t\tsubflags.do_all = FALSE;\n\t\t}\n\n\t\t// Remember next character to be copied.\n\t\tcopycol = regmatch.endpos[0].col;\n\n\t\tif (skip_match)\n\t\t{\n\t\t    // Already hit end of the buffer, sub_firstlnum is one\n\t\t    // less than what it ought to be.\n\t\t    vim_free(sub_firstline);\n\t\t    sub_firstline = vim_strsave((char_u *)\"\");\n\t\t    copycol = 0;\n\t\t}\n\n\t\t/*\n\t\t * Now the trick is to replace CTRL-M chars with a real line\n\t\t * break.  This would make it impossible to insert a CTRL-M in\n\t\t * the text.  The line break can be avoided by preceding the\n\t\t * CTRL-M with a backslash.  To be able to insert a backslash,\n\t\t * they must be doubled in the string and are halved here.\n\t\t * That is Vi compatible.\n\t\t */\n\t\tfor (p1 = new_end; *p1; ++p1)\n\t\t{\n\t\t    if (p1[0] == '\\\\' && p1[1] != NUL)  // remove backslash\n\t\t    {\n\t\t\tSTRMOVE(p1, p1 + 1);\n#ifdef FEAT_PROP_POPUP\n\t\t\tif (curbuf->b_has_textprop)\n\t\t\t{\n\t\t\t    // When text properties are changed, need to save\n\t\t\t    // for undo first, unless done already.\n\t\t\t    if (adjust_prop_columns(lnum,\n\t\t\t\t\t(colnr_T)(p1 - new_start), -1,\n\t\t\t\t\tapc_flags))\n\t\t\t\tapc_flags &= ~APC_SAVE_FOR_UNDO;\n\t\t\t}\n#endif\n\t\t    }\n\t\t    else if (*p1 == CAR)\n\t\t    {\n\t\t\tif (u_inssub(lnum) == OK)   // prepare for undo\n\t\t\t{\n\t\t\t    colnr_T\tplen = (colnr_T)(p1 - new_start + 1);\n\n\t\t\t    *p1 = NUL;\t\t    // truncate up to the CR\n\t\t\t    ml_append(lnum - 1, new_start, plen, FALSE);\n\t\t\t    mark_adjust(lnum + 1, (linenr_T)MAXLNUM, 1L, 0L);\n\t\t\t    if (subflags.do_ask)\n\t\t\t\tappended_lines(lnum - 1, 1L);\n\t\t\t    else\n\t\t\t    {\n\t\t\t\tif (first_line == 0)\n\t\t\t\t    first_line = lnum;\n\t\t\t\tlast_line = lnum + 1;\n\t\t\t    }\n#ifdef FEAT_PROP_POPUP\n\t\t\t    adjust_props_for_split(lnum + 1, lnum,\n\t\t\t\t\t\t\t       plen, 1, FALSE);\n#endif\n\t\t\t    // all line numbers increase\n\t\t\t    ++sub_firstlnum;\n\t\t\t    ++lnum;\n\t\t\t    ++line2;\n\t\t\t    // move the cursor to the new line, like Vi\n\t\t\t    ++curwin->w_cursor.lnum;\n\t\t\t    // copy the rest\n\t\t\t    STRMOVE(new_start, p1 + 1);\n\t\t\t    p1 = new_start - 1;\n\t\t\t}\n\t\t    }\n\t\t    else if (has_mbyte)\n\t\t\tp1 += (*mb_ptr2len)(p1) - 1;\n\t\t}\n\n\t\t/*\n\t\t * 4. If do_all is set, find next match.\n\t\t * Prevent endless loop with patterns that match empty\n\t\t * strings, e.g. :s/$/pat/g or :s/[a-z]* /(&)/g.\n\t\t * But \":s/\\n/#/\" is OK.\n\t\t */\nskip:\n\t\t// We already know that we did the last subst when we are at\n\t\t// the end of the line, except that a pattern like\n\t\t// \"bar\\|\\nfoo\" may match at the NUL.  \"lnum\" can be below\n\t\t// \"line2\" when there is a \\zs in the pattern after a line\n\t\t// break.\n\t\tlastone = (skip_match\n\t\t\t|| got_int\n\t\t\t|| got_quit\n\t\t\t|| lnum > line2\n\t\t\t|| !(subflags.do_all || do_again)\n\t\t\t|| (sub_firstline[matchcol] == NUL && nmatch <= 1\n\t\t\t\t\t && !re_multiline(regmatch.regprog)));\n\t\tnmatch = -1;\n\n\t\t/*\n\t\t * Replace the line in the buffer when needed.  This is\n\t\t * skipped when there are more matches.\n\t\t * The check for nmatch_tl is needed for when multi-line\n\t\t * matching must replace the lines before trying to do another\n\t\t * match, otherwise \"\\@<=\" won't work.\n\t\t * When the match starts below where we start searching also\n\t\t * need to replace the line first (using \\zs after \\n).\n\t\t */\n\t\tif (lastone\n\t\t\t|| nmatch_tl > 0\n\t\t\t|| (nmatch = vim_regexec_multi(&regmatch, curwin,\n\t\t\t\t\t\t\tcurbuf, sub_firstlnum,\n\t\t\t\t\t\t    matchcol, NULL)) == 0\n\t\t\t|| regmatch.startpos[0].lnum > 0)\n\t\t{\n\t\t    if (new_start != NULL)\n\t\t    {\n\t\t\t/*\n\t\t\t * Copy the rest of the line, that didn't match.\n\t\t\t * \"matchcol\" has to be adjusted, we use the end of\n\t\t\t * the line as reference, because the substitute may\n\t\t\t * have changed the number of characters.  Same for\n\t\t\t * \"prev_matchcol\".\n\t\t\t */\n\t\t\tSTRCAT(new_start, sub_firstline + copycol);\n\t\t\tmatchcol = (colnr_T)STRLEN(sub_firstline) - matchcol;\n\t\t\tprev_matchcol = (colnr_T)STRLEN(sub_firstline)\n\t\t\t\t\t\t\t      - prev_matchcol;\n\n\t\t\tif (u_savesub(lnum) != OK)\n\t\t\t    break;\n\t\t\tml_replace(lnum, new_start, TRUE);\n#ifdef FEAT_PROP_POPUP\n\t\t\tif (text_props != NULL)\n\t\t\t    add_text_props(lnum, text_props, text_prop_count);\n#endif\n\t\t\tif (nmatch_tl > 0)\n\t\t\t{\n\t\t\t    /*\n\t\t\t     * Matched lines have now been substituted and are\n\t\t\t     * useless, delete them.  The part after the match\n\t\t\t     * has been appended to new_start, we don't need\n\t\t\t     * it in the buffer.\n\t\t\t     */\n\t\t\t    ++lnum;\n\t\t\t    if (u_savedel(lnum, nmatch_tl) != OK)\n\t\t\t\tbreak;\n\t\t\t    for (i = 0; i < nmatch_tl; ++i)\n\t\t\t\tml_delete(lnum);\n\t\t\t    mark_adjust(lnum, lnum + nmatch_tl - 1,\n\t\t\t\t\t\t   (long)MAXLNUM, -nmatch_tl);\n\t\t\t    if (subflags.do_ask)\n\t\t\t\tdeleted_lines(lnum, nmatch_tl);\n\t\t\t    --lnum;\n\t\t\t    line2 -= nmatch_tl; // nr of lines decreases\n\t\t\t    nmatch_tl = 0;\n\t\t\t}\n\n\t\t\t// When asking, undo is saved each time, must also set\n\t\t\t// changed flag each time.\n\t\t\tif (subflags.do_ask)\n\t\t\t    changed_bytes(lnum, 0);\n\t\t\telse\n\t\t\t{\n\t\t\t    if (first_line == 0)\n\t\t\t\tfirst_line = lnum;\n\t\t\t    last_line = lnum + 1;\n\t\t\t}\n\n\t\t\tsub_firstlnum = lnum;\n\t\t\tvim_free(sub_firstline);    // free the temp buffer\n\t\t\tsub_firstline = new_start;\n\t\t\tnew_start = NULL;\n\t\t\tmatchcol = (colnr_T)STRLEN(sub_firstline) - matchcol;\n\t\t\tprev_matchcol = (colnr_T)STRLEN(sub_firstline)\n\t\t\t\t\t\t\t      - prev_matchcol;\n\t\t\tcopycol = 0;\n\t\t    }\n\t\t    if (nmatch == -1 && !lastone)\n\t\t\tnmatch = vim_regexec_multi(&regmatch, curwin, curbuf,\n\t\t\t\t\t  sub_firstlnum, matchcol, NULL);\n\n\t\t    /*\n\t\t     * 5. break if there isn't another match in this line\n\t\t     */\n\t\t    if (nmatch <= 0)\n\t\t    {\n\t\t\t// If the match found didn't start where we were\n\t\t\t// searching, do the next search in the line where we\n\t\t\t// found the match.\n\t\t\tif (nmatch == -1)\n\t\t\t    lnum -= regmatch.startpos[0].lnum;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\n\t\tline_breakcheck();\n\t    }\n\n\t    if (did_sub)\n\t\t++sub_nlines;\n\t    vim_free(new_start);\t// for when substitute was cancelled\n\t    VIM_CLEAR(sub_firstline);\t// free the copy of the original line\n\t}\n\n\tline_breakcheck();\n    }\n\n    if (first_line != 0)\n    {\n\t// Need to subtract the number of added lines from \"last_line\" to get\n\t// the line number before the change (same as adding the number of\n\t// deleted lines).\n\ti = curbuf->b_ml.ml_line_count - old_line_count;\n\tchanged_lines(first_line, 0, last_line - i, i);\n    }\n\noutofmem:\n    vim_free(sub_firstline); // may have to free allocated copy of the line\n\n#ifdef FEAT_PROP_POPUP\n    vim_free(text_props);\n#endif\n\n    // \":s/pat//n\" doesn't move the cursor\n    if (subflags.do_count)\n\tcurwin->w_cursor = old_cursor;\n\n    if (sub_nsubs > start_nsubs)\n    {\n\tif ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n\t{\n\t    // Set the '[ and '] marks.\n\t    curbuf->b_op_start.lnum = eap->line1;\n\t    curbuf->b_op_end.lnum = line2;\n\t    curbuf->b_op_start.col = curbuf->b_op_end.col = 0;\n\t}\n\n\tif (!global_busy)\n\t{\n\t    // when interactive leave cursor on the match\n\t    if (!subflags.do_ask)\n\t    {\n\t\tif (endcolumn)\n\t\t    coladvance((colnr_T)MAXCOL);\n\t\telse\n\t\t    beginline(BL_WHITE | BL_FIX);\n\t    }\n\t    if (!do_sub_msg(subflags.do_count) && subflags.do_ask)\n\t\tmsg(\"\");\n\t}\n\telse\n\t    global_need_beginline = TRUE;\n\tif (subflags.do_print)\n\t    print_line(curwin->w_cursor.lnum,\n\t\t\t\t\t subflags.do_number, subflags.do_list);\n    }\n    else if (!global_busy)\n    {\n\tif (got_int)\t\t// interrupted\n\t    emsg(_(e_interrupted));\n\telse if (got_match)\t// did find something but nothing substituted\n\t    msg(\"\");\n\telse if (subflags.do_error)\t// nothing found\n\t    semsg(_(e_pattern_not_found_str), get_search_pat());\n    }\n\n#ifdef FEAT_FOLDING\n    if (subflags.do_ask && hasAnyFolding(curwin))\n\t// Cursor position may require updating\n\tchanged_window_setting();\n#endif\n\n    vim_regfree(regmatch.regprog);\n    vim_free(sub);\n\n    // Restore the flag values, they can be used for \":&&\".\n    subflags.do_all = save_do_all;\n    subflags.do_ask = save_do_ask;\n}\n\n/*\n * Give message for number of substitutions.\n * Can also be used after a \":global\" command.\n * Return TRUE if a message was given.\n */\n    int\ndo_sub_msg(\n    int\t    count_only)\t\t// used 'n' flag for \":s\"\n{\n    /*\n     * Only report substitutions when:\n     * - more than 'report' substitutions\n     * - command was typed by user, or number of changed lines > 'report'\n     * - giving messages is not disabled by 'lazyredraw'\n     */\n    if (((sub_nsubs > p_report && (KeyTyped || sub_nlines > 1 || p_report < 1))\n\t\t|| count_only)\n\t    && messaging())\n    {\n\tchar\t*msg_single;\n\tchar\t*msg_plural;\n\n\tif (got_int)\n\t    STRCPY(msg_buf, _(\"(Interrupted) \"));\n\telse\n\t    *msg_buf = NUL;\n\n\tmsg_single = count_only\n\t\t    ? NGETTEXT(\"%ld match on %ld line\",\n\t\t\t\t\t  \"%ld matches on %ld line\", sub_nsubs)\n\t\t    : NGETTEXT(\"%ld substitution on %ld line\",\n\t\t\t\t   \"%ld substitutions on %ld line\", sub_nsubs);\n\tmsg_plural = count_only\n\t\t    ? NGETTEXT(\"%ld match on %ld lines\",\n\t\t\t\t\t \"%ld matches on %ld lines\", sub_nsubs)\n\t\t    : NGETTEXT(\"%ld substitution on %ld lines\",\n\t\t\t\t  \"%ld substitutions on %ld lines\", sub_nsubs);\n\n\tvim_snprintf_add(msg_buf, sizeof(msg_buf),\n\t\t\t\t NGETTEXT(msg_single, msg_plural, sub_nlines),\n\t\t\t\t sub_nsubs, (long)sub_nlines);\n\n\tif (msg(msg_buf))\n\t    // save message to display it after redraw\n\t    set_keep_msg((char_u *)msg_buf, 0);\n\treturn TRUE;\n    }\n    if (got_int)\n    {\n\temsg(_(e_interrupted));\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n    static void\nglobal_exe_one(char_u *cmd, linenr_T lnum)\n{\n    curwin->w_cursor.lnum = lnum;\n    curwin->w_cursor.col = 0;\n    if (*cmd == NUL || *cmd == '\\n')\n\tdo_cmdline((char_u *)\"p\", NULL, NULL, DOCMD_NOWAIT);\n    else\n\tdo_cmdline(cmd, NULL, NULL, DOCMD_NOWAIT);\n}\n\n/*\n * Execute a global command of the form:\n *\n * g/pattern/X : execute X on all lines where pattern matches\n * v/pattern/X : execute X on all lines where pattern does not match\n *\n * where 'X' is an EX command\n *\n * The command character (as well as the trailing slash) is optional, and\n * is assumed to be 'p' if missing.\n *\n * This is implemented in two passes: first we scan the file for the pattern and\n * set a mark for each line that (not) matches. Secondly we execute the command\n * for each line that has a mark. This is required because after deleting\n * lines we do not know where to search for the next match.\n */\n    void\nex_global(exarg_T *eap)\n{\n    linenr_T\tlnum;\t\t// line number according to old situation\n    int\t\tndone = 0;\n    int\t\ttype;\t\t// first char of cmd: 'v' or 'g'\n    char_u\t*cmd;\t\t// command argument\n\n    char_u\tdelim;\t\t// delimiter, normally '/'\n    char_u\t*pat;\n    size_t\tpatlen;\n    char_u\t*used_pat;\n    regmmatch_T\tregmatch;\n    int\t\tmatch;\n    int\t\twhich_pat;\n\n    // When nesting the command works on one line.  This allows for\n    // \":g/found/v/notfound/command\".\n    if (global_busy && (eap->line1 != 1\n\t\t\t\t  || eap->line2 != curbuf->b_ml.ml_line_count))\n    {\n\t// will increment global_busy to break out of the loop\n\temsg(_(e_cannot_do_global_recursive_with_range));\n\treturn;\n    }\n\n    if (eap->forceit)\t\t    // \":global!\" is like \":vglobal\"\n\ttype = 'v';\n    else\n\ttype = *eap->cmd;\n    cmd = eap->arg;\n    which_pat = RE_LAST;\t    // default: use last used regexp\n\n#ifdef FEAT_EVAL\n    if (in_vim9script() && check_global_and_subst(eap->cmd, eap->arg) == FAIL)\n\treturn;\n#endif\n\n    /*\n     * undocumented vi feature:\n     *\t\"\\/\" and \"\\?\": use previous search pattern.\n     *\t\t \"\\&\": use previous substitute pattern.\n     */\n    if (*cmd == '\\\\')\n    {\n\t++cmd;\n\tif (vim_strchr((char_u *)\"/?&\", *cmd) == NULL)\n\t{\n\t    emsg(_(e_backslash_should_be_followed_by));\n\t    return;\n\t}\n\tif (*cmd == '&')\n\t    which_pat = RE_SUBST;\t// use previous substitute pattern\n\telse\n\t    which_pat = RE_SEARCH;\t// use previous search pattern\n\t++cmd;\n\tpat = (char_u *)\"\";\n\tpatlen = 0;\n    }\n    else if (*cmd == NUL)\n    {\n\temsg(_(e_regular_expression_missing_from_global));\n\treturn;\n    }\n    else if (check_regexp_delim(*cmd) == FAIL)\n    {\n\treturn;\n    }\n    else\n    {\n\tdelim = *cmd;\t\t// get the delimiter\n\t++cmd;\t\t\t// skip delimiter if there is one\n\tpat = cmd;\t\t// remember start of pattern\n\tcmd = skip_regexp_ex(cmd, delim, magic_isset(), &eap->arg, NULL, NULL);\n\tif (cmd[0] == delim)\t\t    // end delimiter found\n\t    *cmd++ = NUL;\t\t    // replace it with a NUL\n\tpatlen = STRLEN(pat);\n    }\n\n    if (search_regcomp(pat, patlen, &used_pat, RE_BOTH, which_pat, SEARCH_HIS,\n\t\t\t\t\t\t\t    &regmatch) == FAIL)\n    {\n\temsg(_(e_invalid_command));\n\treturn;\n    }\n\n    if (global_busy)\n    {\n\tlnum = curwin->w_cursor.lnum;\n\tmatch = vim_regexec_multi(&regmatch, curwin, curbuf, lnum,\n\t\t\t\t\t\t       (colnr_T)0, NULL);\n\tif ((type == 'g' && match) || (type == 'v' && !match))\n\t    global_exe_one(cmd, lnum);\n    }\n    else\n    {\n\t/*\n\t * pass 1: set marks for each (not) matching line\n\t */\n\tfor (lnum = eap->line1; lnum <= eap->line2 && !got_int; ++lnum)\n\t{\n\t    // a match on this line?\n\t    match = vim_regexec_multi(&regmatch, curwin, curbuf, lnum,\n\t\t\t\t\t\t       (colnr_T)0, NULL);\n\t    if (regmatch.regprog == NULL)\n\t\tbreak;  // re-compiling regprog failed\n\t    if ((type == 'g' && match) || (type == 'v' && !match))\n\t    {\n\t\tml_setmarked(lnum);\n\t\tndone++;\n\t    }\n\t    line_breakcheck();\n\t}\n\n\t/*\n\t * pass 2: execute the command for each line that has been marked\n\t */\n\tif (got_int)\n\t    msg(_(e_interrupted));\n\telse if (ndone == 0)\n\t{\n\t    if (type == 'v')\n\t    {\n\t\tif (in_vim9script())\n\t\t    semsg(_(e_pattern_found_in_every_line_str), used_pat);\n\t\telse\n\t\t    smsg(_(\"Pattern found in every line: %s\"), used_pat);\n\t    }\n\t    else\n\t    {\n\t\tif (in_vim9script())\n\t\t    semsg(_(e_pattern_not_found_str), used_pat);\n\t\telse\n\t\t    smsg(_(\"Pattern not found: %s\"), used_pat);\n\t    }\n\t}\n\telse\n\t{\n#ifdef FEAT_CLIPBOARD\n\t    start_global_changes();\n#endif\n\t    global_exe(cmd);\n#ifdef FEAT_CLIPBOARD\n\t    end_global_changes();\n#endif\n\t}\n\n\tml_clearmarked();\t   // clear rest of the marks\n    }\n\n    vim_regfree(regmatch.regprog);\n}\n\n/*\n * Execute \"cmd\" on lines marked with ml_setmarked().\n */\n    void\nglobal_exe(char_u *cmd)\n{\n    linenr_T old_lcount;\t// b_ml.ml_line_count before the command\n    buf_T    *old_buf = curbuf;\t// remember what buffer we started in\n    linenr_T lnum;\t\t// line number according to old situation\n\n    /*\n     * Set current position only once for a global command.\n     * If global_busy is set, setpcmark() will not do anything.\n     * If there is an error, global_busy will be incremented.\n     */\n    setpcmark();\n\n    // When the command writes a message, don't overwrite the command.\n    msg_didout = TRUE;\n\n    sub_nsubs = 0;\n    sub_nlines = 0;\n    global_need_beginline = FALSE;\n    global_busy = 1;\n    old_lcount = curbuf->b_ml.ml_line_count;\n    while (!got_int && (lnum = ml_firstmarked()) != 0 && global_busy == 1)\n    {\n\tglobal_exe_one(cmd, lnum);\n\tui_breakcheck();\n    }\n\n    global_busy = 0;\n    if (global_need_beginline)\n\tbeginline(BL_WHITE | BL_FIX);\n    else\n\tcheck_cursor();\t// cursor may be beyond the end of the line\n\n    // the cursor may not have moved in the text but a change in a previous\n    // line may move it on the screen\n    changed_line_abv_curs();\n\n    // If it looks like no message was written, allow overwriting the\n    // command with the report for number of changes.\n    if (msg_col == 0 && msg_scrolled == 0)\n\tmsg_didout = FALSE;\n\n    // If substitutes done, report number of substitutes, otherwise report\n    // number of extra or deleted lines.\n    // Don't report extra or deleted lines in the edge case where the buffer\n    // we are in after execution is different from the buffer we started in.\n    if (!do_sub_msg(FALSE) && curbuf == old_buf)\n\tmsgmore(curbuf->b_ml.ml_line_count - old_lcount);\n}\n\n#ifdef FEAT_VIMINFO\n/*\n * Get the previous substitute pattern.\n */\n    char_u *\nget_old_sub(void)\n{\n    return old_sub;\n}\n\n/*\n * Set the previous substitute pattern.  \"val\" must be allocated.\n */\n    void\nset_old_sub(char_u *val)\n{\n    vim_free(old_sub);\n    old_sub = val;\n}\n#endif // FEAT_VIMINFO\n\n#if defined(EXITFREE) || defined(PROTO)\n    void\nfree_old_sub(void)\n{\n    vim_free(old_sub);\n}\n#endif\n\n#if defined(FEAT_QUICKFIX) || defined(PROTO)\n/*\n * Set up for a tagpreview.\n * Makes the preview window the current window.\n * Return TRUE when it was created.\n */\n    int\nprepare_tagpreview(\n    int\t\tundo_sync,\t    // sync undo when leaving the window\n    int\t\tuse_previewpopup,   // use popup if 'previewpopup' set\n    use_popup_T\tuse_popup)\t    // use other popup window\n{\n    win_T\t*wp;\n\n# ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n# endif\n\n    if (curwin->w_p_pvw)\n\treturn FALSE;\n\n    /*\n     * If there is already a preview window open, use that one.\n     */\n# ifdef FEAT_PROP_POPUP\n    if (use_previewpopup && *p_pvp != NUL)\n    {\n\twp = popup_find_preview_window();\n\tif (wp != NULL)\n\t    popup_set_wantpos_cursor(wp, wp->w_minwidth, NULL);\n    }\n    else if (use_popup != USEPOPUP_NONE)\n    {\n\twp = popup_find_info_window();\n\tif (wp != NULL)\n\t{\n\t    if (use_popup == USEPOPUP_NORMAL)\n\t\tpopup_show(wp);\n\t    else\n\t\tpopup_hide(wp);\n\t    // When the popup moves or resizes it may reveal part of\n\t    // another window.  TODO: can this be done more efficiently?\n\t    redraw_all_later(UPD_NOT_VALID);\n\t}\n    }\n    else\n# endif\n    {\n\tFOR_ALL_WINDOWS(wp)\n\t    if (wp->w_p_pvw)\n\t\tbreak;\n    }\n    if (wp != NULL)\n    {\n\twin_enter(wp, undo_sync);\n\treturn FALSE;\n    }\n\n    /*\n     * There is no preview window open yet.  Create one.\n     */\n# ifdef FEAT_PROP_POPUP\n    if ((use_previewpopup && *p_pvp != NUL)\n\t    || use_popup != USEPOPUP_NONE)\n\treturn popup_create_preview_window(use_popup != USEPOPUP_NONE);\n# endif\n    if (win_split(g_do_tagpreview > 0 ? g_do_tagpreview : 0, 0) == FAIL)\n\treturn FALSE;\n    curwin->w_p_pvw = TRUE;\n    curwin->w_p_wfh = TRUE;\n    RESET_BINDING(curwin);\t    // don't take over 'scrollbind'\n\t\t\t\t    // and 'cursorbind'\n# ifdef FEAT_DIFF\n    curwin->w_p_diff = FALSE;\t    // no 'diff'\n# endif\n# ifdef FEAT_FOLDING\n    curwin->w_p_fdc = 0;\t    // no 'foldcolumn'\n# endif\n    return TRUE;\n}\n\n#endif\n\n/*\n * Make the user happy.\n */\n    void\nex_smile(exarg_T *eap UNUSED)\n{\n    static char *code[] = {\n\t\"\\34 \\4o\\14$\\4ox\\30 \\2o\\30$\\1ox\\25 \\2o\\36$\\1o\\11 \\1o\\1$\\3 \\2$\\1 \\1o\\1$x\\5 \\1o\\1 \\1$\\1 \\2o\\10 \\1o\\44$\\1o\\7 \\2$\\1 \\2$\\1 \\2$\\1o\\1$x\\2 \\2o\\1 \\1$\\1 \\1$\\1 \\1\\\"\\1$\\6 \\1o\\11$\\4 \\15$\\4 \\11$\\1o\\7 \\3$\\1o\\2$\\1o\\1$x\\2 \\1\\\"\\6$\\1o\\1$\\5 \\1o\\11$\\6 \\13$\\6 \\12$\\1o\\4 \\10$x\\4 \\7$\\4 \\13$\\6 \\13$\\6 \\27$x\\4 \\27$\\4 \\15$\\4 \\16$\\2 \\3\\\"\\3$x\\5 \\1\\\"\\3$\\4\\\"\\61$\\5 \\1\\\"\\3$x\\6 \\3$\\3 \\1o\\62$\\5 \\1\\\"\\3$\\1ox\\5 \\1o\\2$\\1\\\"\\3 \\63$\\7 \\3$\\1ox\\5 \\3$\\4 \\55$\\1\\\"\\1 \\1\\\"\\6$\",\n\t\"\\5o\\4$\\1ox\\4 \\1o\\3$\\4o\\5$\\2 \\45$\\3 \\1o\\21$x\\4 \\10$\\1\\\"\\4$\\3 \\42$\\5 \\4$\\10\\\"x\\3 \\4\\\"\\7 \\4$\\4 \\1\\\"\\34$\\1\\\"\\6 \\1o\\3$x\\16 \\1\\\"\\3$\\1o\\5 \\3\\\"\\22$\\1\\\"\\2$\\1\\\"\\11 \\3$x\\20 \\3$\\1o\\12 \\1\\\"\\2$\\2\\\"\\6$\\4\\\"\\13 \\1o\\3$x\\21 \\4$\\1o\\40 \\1o\\3$\\1\\\"x\\22 \\1\\\"\\4$\\1o\\6 \\1o\\6$\\1o\\1\\\"\\4$\\1o\\10 \\1o\\4$x\\24 \\1\\\"\\5$\\2o\\5 \\2\\\"\\4$\\1o\\5$\\1o\\3 \\1o\\4$\\2\\\"x\\27 \\2\\\"\\5$\\4o\\2 \\1\\\"\\3$\\1o\\11$\\3\\\"x\\32 \\2\\\"\\7$\\2o\\1 \\12$x\\42 \\4\\\"\\13$x\\46 \\14$x\\47 \\12$\\1\\\"x\\50 \\1\\\"\\3$\\4\\\"x\"\n    };\n    char *p;\n    int n;\n    int i;\n\n    msg_start();\n    msg_putchar('\\n');\n    for (i = 0; i < 2; ++i)\n\tfor (p = code[i]; *p != NUL; ++p)\n\t    if (*p == 'x')\n\t\tmsg_putchar('\\n');\n\t    else\n\t\tfor (n = *p++; n > 0; --n)\n\t\t    if (*p == 'o' || *p == '$')\n\t\t\tmsg_putchar_attr(*p, HL_ATTR(HLF_L));\n\t\t    else\n\t\t\tmsg_putchar(*p);\n    msg_clr_eos();\n}\n\n/*\n * \":drop\"\n * Opens the first argument in a window, and the argument list is redefined.\n */\n    void\nex_drop(exarg_T *eap)\n{\n    int\t\tsplit = FALSE;\n    win_T\t*wp;\n    buf_T\t*buf;\n    tabpage_T\t*tp;\n\n    if (ERROR_IF_POPUP_WINDOW || ERROR_IF_TERM_POPUP_WINDOW)\n\treturn;\n\n    /*\n     * Check if the first argument is already being edited in a window.  If\n     * so, jump to that window.\n     * We would actually need to check all arguments, but that's complicated\n     * and mostly only one file is dropped.\n     * This also ignores wildcards, since it is very unlikely the user is\n     * editing a file name with a wildcard character.\n     */\n    set_arglist(eap->arg);\n\n    /*\n     * Expanding wildcards may result in an empty argument list.  E.g. when\n     * editing \"foo.pyc\" and \".pyc\" is in 'wildignore'.  Assume that we\n     * already did an error message for this.\n     */\n    if (ARGCOUNT == 0)\n\treturn;\n\n    if (cmdmod.cmod_tab)\n    {\n\t// \":tab drop file ...\": open a tab for each argument that isn't\n\t// edited in a window yet.  It's like \":tab all\" but without closing\n\t// windows or tabs.\n\tex_all(eap);\n\tcmdmod.cmod_tab = 0;\n\tex_rewind(eap);\n\treturn;\n    }\n\n    // \":drop file ...\": Edit the first argument.  Jump to an existing\n    // window if possible, edit in current window if the current buffer\n    // can be abandoned, otherwise open a new window.\n    buf = buflist_findnr(ARGLIST[0].ae_fnum);\n\n    FOR_ALL_TAB_WINDOWS(tp, wp)\n    {\n\tif (wp->w_buffer == buf)\n\t{\n\t    goto_tabpage_win(tp, wp);\n\t    curwin->w_arg_idx = 0;\n\t    if (!bufIsChanged(curbuf))\n\t    {\n\t\tint save_ar = curbuf->b_p_ar;\n\n\t\t// reload the file if it is newer\n\t\tcurbuf->b_p_ar = TRUE;\n\t\tbuf_check_timestamp(curbuf, FALSE);\n\t\tcurbuf->b_p_ar = save_ar;\n\t    }\n\t    if (curbuf->b_ml.ml_flags & ML_EMPTY)\n\t\tex_rewind(eap);\n\t    return;\n\t}\n    }\n\n    /*\n     * Check whether the current buffer is changed. If so, we will need\n     * to split the current window or data could be lost.\n     * Skip the check if the 'hidden' option is set, as in this case the\n     * buffer won't be lost.\n     */\n    if (!buf_hide(curbuf))\n    {\n\t++emsg_off;\n\tsplit = check_changed(curbuf, CCGD_AW | CCGD_EXCMD);\n\t--emsg_off;\n    }\n\n    // Fake a \":sfirst\" or \":first\" command edit the first argument.\n    if (split)\n    {\n\teap->cmdidx = CMD_sfirst;\n\teap->cmd[0] = 's';\n    }\n    else\n\teap->cmdidx = CMD_first;\n    ex_rewind(eap);\n}\n\n/*\n * Skip over the pattern argument of \":vimgrep /pat/[g][j]\".\n * Put the start of the pattern in \"*s\", unless \"s\" is NULL.\n * If \"flags\" is not NULL put the flags in it: VGR_GLOBAL, VGR_NOJUMP.\n * If \"s\" is not NULL terminate the pattern with a NUL.\n * Return a pointer to the char just past the pattern plus flags.\n */\n    char_u *\nskip_vimgrep_pat(char_u *p, char_u **s, int *flags)\n{\n    return skip_vimgrep_pat_ext(p, s, flags, NULL, NULL);\n}\n\n/*\n * As skip_vimgrep_pat() and store the character overwritten by NUL in \"cp\"\n * and the pointer to it in \"nulp\".\n */\n    char_u *\nskip_vimgrep_pat_ext(char_u *p, char_u **s, int *flags, char_u **nulp, int *cp)\n{\n    int\t\tc;\n\n    if (vim_isIDc(*p))\n    {\n\t// \":vimgrep pattern fname\"\n\tif (s != NULL)\n\t    *s = p;\n\tp = skiptowhite(p);\n\tif (s != NULL && *p != NUL)\n\t{\n\t    if (nulp != NULL)\n\t    {\n\t\t*nulp = p;\n\t\t*cp = *p;\n\t    }\n\t    *p++ = NUL;\n\t}\n    }\n    else\n    {\n\t// \":vimgrep /pattern/[g][j] fname\"\n\tif (s != NULL)\n\t    *s = p + 1;\n\tc = *p;\n\tp = skip_regexp(p + 1, c, TRUE);\n\tif (*p != c)\n\t    return NULL;\n\n\t// Truncate the pattern.\n\tif (s != NULL)\n\t{\n\t    if (nulp != NULL)\n\t    {\n\t\t*nulp = p;\n\t\t*cp = *p;\n\t    }\n\t    *p = NUL;\n\t}\n\t++p;\n\n\t// Find the flags\n\twhile (*p == 'g' || *p == 'j' || *p == 'f')\n\t{\n\t    if (flags != NULL)\n\t    {\n\t\tif (*p == 'g')\n\t\t    *flags |= VGR_GLOBAL;\n\t\telse if (*p == 'j')\n\t\t    *flags |= VGR_NOJUMP;\n\t\telse\n\t\t    *flags |= VGR_FUZZY;\n\t    }\n\t    ++p;\n\t}\n    }\n    return p;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * List v:oldfiles in a nice way.\n */\n    void\nex_oldfiles(exarg_T *eap UNUSED)\n{\n    list_T\t*l = get_vim_var_list(VV_OLDFILES);\n    listitem_T\t*li;\n    int\t\tnr = 0;\n    char_u\t*fname;\n    // for a single filtered match, remember the number\n    // so we can jump directly to it without prompting\n    int\t\tmatches = -1;\n\n    if (l == NULL)\n    {\n\tmsg(_(\"No old files\"));\n\treturn;\n    }\n\n    msg_start();\n    msg_scroll = TRUE;\n    for (li = l->lv_first; li != NULL && !got_int; li = li->li_next)\n    {\n\t++nr;\n\tfname = tv_get_string(&li->li_tv);\n\tif (!message_filtered(fname))\n\t{\n\t    if (matches < 0)\n\t\tmatches = nr;\n\t    else\n\t\tmatches = 0;\n\t    msg_outnum((long)nr);\n\t    msg_puts(\": \");\n\t    msg_outtrans(fname);\n\t    msg_clr_eos();\n\t    msg_putchar('\\n');\n\t    out_flush();\t    // output one line at a time\n\t    ui_breakcheck();\n\t}\n    }\n\n    // Assume \"got_int\" was set to truncate the listing.\n    got_int = FALSE;\n\n# ifdef FEAT_BROWSE_CMD\n    if (cmdmod.cmod_flags & CMOD_BROWSE)\n    {\n\tquit_more = FALSE;\n\t// we only need to prompt if there is more than 1 match\n\tif (matches > 0)\n\t{\n\t    nr = matches;\n\t    // msg_putchar above sets needs_wait_return\n\t    need_wait_return = FALSE;\n\t}\n\telse\n\t    nr = prompt_for_number(FALSE);\n\tmsg_starthere();\n\tif (nr > 0)\n\t{\n\t    char_u *p = list_find_str(get_vim_var_list(VV_OLDFILES),\n\t\t    (long)nr);\n\n\t    if (p != NULL)\n\t    {\n\t\tp = expand_env_save(p);\n\t\teap->arg = p;\n\t\teap->cmdidx = CMD_edit;\n\t\tcmdmod.cmod_flags &= ~CMOD_BROWSE;\n\t\tdo_exedit(eap, NULL);\n\t\tvim_free(p);\n\t    }\n\t}\n    }\n# endif\n}\n#endif\n```\n","ts":1.739800385409E9}
