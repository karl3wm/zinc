{"prompt":"<|begin_of_text|><|start_header_id|>user<|end_header_id|>\n\nCan you explain what xdl_trim_ends and xdl_cleanup_records do exactly with the underlying data structures and what this implies about the use and contracts of these internal data structures?\n\n**third_party/xdiff/xutils.h**\n```\n/*\n *  LibXDiff by Davide Libenzi ( File Differential Library )\n *  Copyright (C) 2003  Davide Libenzi\n *\n *  This library is free software; you can redistribute it and/or\n *  modify it under the terms of the GNU Lesser General Public\n *  License as published by the Free Software Foundation; either\n *  version 2.1 of the License, or (at your option) any later version.\n *\n *  This library is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n *  Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; if not, see\n *  <http://www.gnu.org/licenses/>.\n *\n *  Davide Libenzi <davidel@xmailserver.org>\n *\n */\n\n#if !defined(XUTILS_H)\n#define XUTILS_H\n\n\n\nlong xdl_bogosqrt(long n);\nint xdl_emit_diffrec(char const *rec, long size, char const *pre, long psize,\n\t\t     xdemitcb_t *ecb);\nint xdl_cha_init(chastore_t *cha, long isize, long icount);\nvoid xdl_cha_free(chastore_t *cha);\nvoid *xdl_cha_alloc(chastore_t *cha);\nlong xdl_guess_lines(mmfile_t *mf, long sample);\nint xdl_blankline(const char *line, long size, long flags);\nint xdl_recmatch(const char *l1, long s1, const char *l2, long s2, long flags);\nunsigned long xdl_hash_record(char const **data, char const *top, long flags);\nunsigned int xdl_hashbits(unsigned int size);\nint xdl_num_out(char *out, long val);\nint xdl_emit_hunk_hdr(long s1, long c1, long s2, long c2,\n\t\t      const char *func, long funclen, xdemitcb_t *ecb);\nint xdl_fall_back_diff(xdfenv_t *diff_env, xpparam_t const *xpp,\n\t\t       int line1, int count1, int line2, int count2);\n\n/* Do not call this function, use XDL_ALLOC_GROW instead */\nvoid* xdl_alloc_grow_helper(void* p, long nr, long* alloc, size_t size);\n\n#endif /* #if !defined(XUTILS_H) */\n\n```\n\n**third_party/xdiff/xmacros.h**\n```\n/*\n *  LibXDiff by Davide Libenzi ( File Differential Library )\n *  Copyright (C) 2003  Davide Libenzi\n *\n *  This library is free software; you can redistribute it and/or\n *  modify it under the terms of the GNU Lesser General Public\n *  License as published by the Free Software Foundation; either\n *  version 2.1 of the License, or (at your option) any later version.\n *\n *  This library is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n *  Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; if not, see\n *  <http://www.gnu.org/licenses/>.\n *\n *  Davide Libenzi <davidel@xmailserver.org>\n *\n */\n\n#if !defined(XMACROS_H)\n#define XMACROS_H\n\n\n\n\n#define XDL_MIN(a, b) ((a) < (b) ? (a): (b))\n#define XDL_MAX(a, b) ((a) > (b) ? (a): (b))\n#define XDL_ABS(v) ((v) >= 0 ? (v): -(v))\n#define XDL_ISDIGIT(c) ((c) >= '0' && (c) <= '9')\n#define XDL_ISSPACE(c) (isspace((unsigned char)(c)))\n#define XDL_ADDBITS(v,b)\t((v) + ((v) >> (b)))\n#define XDL_MASKBITS(b)\t\t((1UL << (b)) - 1)\n#define XDL_HASHLONG(v,b)\t(XDL_ADDBITS((unsigned long)(v), b) & XDL_MASKBITS(b))\n#define XDL_LE32_PUT(p, v) \\\ndo { \\\n\tunsigned char *__p = (unsigned char *) (p); \\\n\t*__p++ = (unsigned char) (v); \\\n\t*__p++ = (unsigned char) ((v) >> 8); \\\n\t*__p++ = (unsigned char) ((v) >> 16); \\\n\t*__p = (unsigned char) ((v) >> 24); \\\n} while (0)\n#define XDL_LE32_GET(p, v) \\\ndo { \\\n\tunsigned char const *__p = (unsigned char const *) (p); \\\n\t(v) = (unsigned long) __p[0] | ((unsigned long) __p[1]) << 8 | \\\n\t\t((unsigned long) __p[2]) << 16 | ((unsigned long) __p[3]) << 24; \\\n} while (0)\n\n/* Allocate an array of nr elements, returns NULL on failure */\n#define XDL_ALLOC_ARRAY(p, nr)\t\t\t\t\\\n\t((p) = SIZE_MAX / sizeof(*(p)) >= (size_t)(nr)\t\\\n\t\t? xdl_malloc((nr) * sizeof(*(p)))\t\\\n\t\t: NULL)\n\n/* Allocate an array of nr zeroed out elements, returns NULL on failure */\n#define XDL_CALLOC_ARRAY(p, nr)\t((p) = xdl_calloc(nr, sizeof(*(p))))\n\n/*\n * Ensure array p can accommodate at least nr elements, growing the\n * array and updating alloc (which is the number of allocated\n * elements) as necessary. Frees p and returns -1 on failure, returns\n * 0 on success\n */\n#define XDL_ALLOC_GROW(p, nr, alloc)\t\\\n\t(-!((nr) <= (alloc) ||\t\t\\\n\t    ((p) = xdl_alloc_grow_helper((p), (nr), &(alloc), sizeof(*(p))))))\n\n#endif /* #if !defined(XMACROS_H) */\n\n```\n\n**third_party/xdiff/xdiff.h**\n```\n/*\n *  LibXDiff by Davide Libenzi ( File Differential Library )\n *  Copyright (C) 2003  Davide Libenzi\n *\n *  This library is free software; you can redistribute it and/or\n *  modify it under the terms of the GNU Lesser General Public\n *  License as published by the Free Software Foundation; either\n *  version 2.1 of the License, or (at your option) any later version.\n *\n *  This library is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n *  Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; if not, see\n *  <http://www.gnu.org/licenses/>.\n *\n *  Davide Libenzi <davidel@xmailserver.org>\n *\n */\n\n#if !defined(XDIFF_H)\n#define XDIFF_H\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif /* #ifdef __cplusplus */\n\n#include \"git-xdiff.h\"\n\n/* xpparm_t.flags */\n#define XDF_NEED_MINIMAL (1 << 0)\n\n#define XDF_IGNORE_WHITESPACE (1 << 1)\n#define XDF_IGNORE_WHITESPACE_CHANGE (1 << 2)\n#define XDF_IGNORE_WHITESPACE_AT_EOL (1 << 3)\n#define XDF_IGNORE_CR_AT_EOL (1 << 4)\n#define XDF_WHITESPACE_FLAGS (XDF_IGNORE_WHITESPACE | \\\n\t\t\t      XDF_IGNORE_WHITESPACE_CHANGE | \\\n\t\t\t      XDF_IGNORE_WHITESPACE_AT_EOL | \\\n\t\t\t      XDF_IGNORE_CR_AT_EOL)\n\n#define XDF_IGNORE_BLANK_LINES (1 << 7)\n\n#define XDF_PATIENCE_DIFF (1 << 14)\n#define XDF_HISTOGRAM_DIFF (1 << 15)\n#define XDF_DIFF_ALGORITHM_MASK (XDF_PATIENCE_DIFF | XDF_HISTOGRAM_DIFF)\n#define XDF_DIFF_ALG(x) ((x) & XDF_DIFF_ALGORITHM_MASK)\n\n#define XDF_INDENT_HEURISTIC (1 << 23)\n\n/* xdemitconf_t.flags */\n#define XDL_EMIT_FUNCNAMES (1 << 0)\n#define XDL_EMIT_NO_HUNK_HDR (1 << 1)\n#define XDL_EMIT_FUNCCONTEXT (1 << 2)\n\n/* merge simplification levels */\n#define XDL_MERGE_MINIMAL 0\n#define XDL_MERGE_EAGER 1\n#define XDL_MERGE_ZEALOUS 2\n#define XDL_MERGE_ZEALOUS_ALNUM 3\n\n/* merge favor modes */\n#define XDL_MERGE_FAVOR_OURS 1\n#define XDL_MERGE_FAVOR_THEIRS 2\n#define XDL_MERGE_FAVOR_UNION 3\n\n/* merge output styles */\n#define XDL_MERGE_DIFF3 1\n#define XDL_MERGE_ZEALOUS_DIFF3 2\n\ntypedef struct s_mmfile {\n\tchar *ptr;\n\tlong size;\n} mmfile_t;\n\ntypedef struct s_mmbuffer {\n\tchar *ptr;\n\tlong size;\n} mmbuffer_t;\n\ntypedef struct s_xpparam {\n\tunsigned long flags;\n\n\t/* -I<regex> */\n\txdl_regex_t **ignore_regex;\n\tsize_t ignore_regex_nr;\n\n\t/* See Documentation/diff-options.txt. */\n\tchar **anchors;\n\tsize_t anchors_nr;\n} xpparam_t;\n\ntypedef struct s_xdemitcb {\n\tvoid *priv;\n\tint (*out_hunk)(void *,\n\t\t\tlong old_begin, long old_nr,\n\t\t\tlong new_begin, long new_nr,\n\t\t\tconst char *func, long funclen);\n\tint (*out_line)(void *, mmbuffer_t *, int);\n} xdemitcb_t;\n\ntypedef long (*find_func_t)(const char *line, long line_len, char *buffer, long buffer_size, void *priv);\n\ntypedef int (*xdl_emit_hunk_consume_func_t)(long start_a, long count_a,\n\t\t\t\t\t    long start_b, long count_b,\n\t\t\t\t\t    void *cb_data);\n\ntypedef struct s_xdemitconf {\n\tlong ctxlen;\n\tlong interhunkctxlen;\n\tunsigned long flags;\n\tfind_func_t find_func;\n\tvoid *find_func_priv;\n\txdl_emit_hunk_consume_func_t hunk_func;\n} xdemitconf_t;\n\ntypedef struct s_bdiffparam {\n\tlong bsize;\n} bdiffparam_t;\n\n\nvoid *xdl_mmfile_first(mmfile_t *mmf, long *size);\nlong xdl_mmfile_size(mmfile_t *mmf);\n\nint xdl_diff(mmfile_t *mf1, mmfile_t *mf2, xpparam_t const *xpp,\n\t     xdemitconf_t const *xecfg, xdemitcb_t *ecb);\n\ntypedef struct s_xmparam {\n\txpparam_t xpp;\n\tint marker_size;\n\tint level;\n\tint favor;\n\tint style;\n\tconst char *ancestor;\t/* label for orig */\n\tconst char *file1;\t/* label for mf1 */\n\tconst char *file2;\t/* label for mf2 */\n} xmparam_t;\n\n#define DEFAULT_CONFLICT_MARKER_SIZE 7\n\nint xdl_merge(mmfile_t *orig, mmfile_t *mf1, mmfile_t *mf2,\n\t\txmparam_t const *xmp, mmbuffer_t *result);\n\n#ifdef __cplusplus\n}\n#endif /* #ifdef __cplusplus */\n\n#endif /* #if !defined(XDIFF_H) */\n\n```\n\n**third_party/xdiff/xprepare.c**\n```\n/*\n *  LibXDiff by Davide Libenzi ( File Differential Library )\n *  Copyright (C) 2003  Davide Libenzi\n *\n *  This library is free software; you can redistribute it and/or\n *  modify it under the terms of the GNU Lesser General Public\n *  License as published by the Free Software Foundation; either\n *  version 2.1 of the License, or (at your option) any later version.\n *\n *  This library is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n *  Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; if not, see\n *  <http://www.gnu.org/licenses/>.\n *\n *  Davide Libenzi <davidel@xmailserver.org>\n *\n */\n\n#include \"xinclude.h\"\n\n\n#define XDL_KPDIS_RUN 4\n#define XDL_MAX_EQLIMIT 1024\n#define XDL_SIMSCAN_WINDOW 100\n#define XDL_GUESS_NLINES1 256\n#define XDL_GUESS_NLINES2 20\n\n\ntypedef struct s_xdlclass {\n\tstruct s_xdlclass *next;\n\tunsigned long ha;\n\tchar const *line;\n\tlong size;\n\tlong idx;\n\tlong len1, len2;\n} xdlclass_t;\n\ntypedef struct s_xdlclassifier {\n\tunsigned int hbits;\n\tlong hsize;\n\txdlclass_t **rchash;\n\tchastore_t ncha;\n\txdlclass_t **rcrecs;\n\tlong alloc;\n\tlong count;\n\tlong flags;\n} xdlclassifier_t;\n\n\n\n\nstatic int xdl_init_classifier(xdlclassifier_t *cf, long size, long flags);\nstatic void xdl_free_classifier(xdlclassifier_t *cf);\nstatic int xdl_classify_record(unsigned int pass, xdlclassifier_t *cf, xrecord_t **rhash,\n\t\t\t       unsigned int hbits, xrecord_t *rec);\nstatic int xdl_prepare_ctx(unsigned int pass, mmfile_t *mf, long narec, xpparam_t const *xpp,\n\t\t\t   xdlclassifier_t *cf, xdfile_t *xdf);\nstatic void xdl_free_ctx(xdfile_t *xdf);\nstatic int xdl_clean_mmatch(char const *dis, long i, long s, long e);\nstatic int xdl_cleanup_records(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);\nstatic int xdl_trim_ends(xdfile_t *xdf1, xdfile_t *xdf2);\nstatic int xdl_optimize_ctxs(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);\n\n\n\n\nstatic int xdl_init_classifier(xdlclassifier_t *cf, long size, long flags) {\n\tcf->flags = flags;\n\n\tcf->hbits = xdl_hashbits((unsigned int) size);\n\tcf->hsize = 1 << cf->hbits;\n\n\tif (xdl_cha_init(&cf->ncha, sizeof(xdlclass_t), size / 4 + 1) < 0) {\n\n\t\treturn -1;\n\t}\n\tif (!XDL_CALLOC_ARRAY(cf->rchash, cf->hsize)) {\n\n\t\txdl_cha_free(&cf->ncha);\n\t\treturn -1;\n\t}\n\n\tcf->alloc = size;\n\tif (!XDL_ALLOC_ARRAY(cf->rcrecs, cf->alloc)) {\n\n\t\txdl_free(cf->rchash);\n\t\txdl_cha_free(&cf->ncha);\n\t\treturn -1;\n\t}\n\n\tcf->count = 0;\n\n\treturn 0;\n}\n\n\nstatic void xdl_free_classifier(xdlclassifier_t *cf) {\n\n\txdl_free(cf->rcrecs);\n\txdl_free(cf->rchash);\n\txdl_cha_free(&cf->ncha);\n}\n\n\nstatic int xdl_classify_record(unsigned int pass, xdlclassifier_t *cf, xrecord_t **rhash,\n\t\t\t       unsigned int hbits, xrecord_t *rec) {\n\tlong hi;\n\tchar const *line;\n\txdlclass_t *rcrec;\n\n\tline = rec->ptr;\n\thi = (long) XDL_HASHLONG(rec->ha, cf->hbits);\n\tfor (rcrec = cf->rchash[hi]; rcrec; rcrec = rcrec->next)\n\t\tif (rcrec->ha == rec->ha &&\n\t\t\t\txdl_recmatch(rcrec->line, rcrec->size,\n\t\t\t\t\trec->ptr, rec->size, cf->flags))\n\t\t\tbreak;\n\n\tif (!rcrec) {\n\t\tif (!(rcrec = xdl_cha_alloc(&cf->ncha))) {\n\n\t\t\treturn -1;\n\t\t}\n\t\trcrec->idx = cf->count++;\n\t\tif (XDL_ALLOC_GROW(cf->rcrecs, cf->count, cf->alloc))\n\t\t\t\treturn -1;\n\t\tcf->rcrecs[rcrec->idx] = rcrec;\n\t\trcrec->line = line;\n\t\trcrec->size = rec->size;\n\t\trcrec->ha = rec->ha;\n\t\trcrec->len1 = rcrec->len2 = 0;\n\t\trcrec->next = cf->rchash[hi];\n\t\tcf->rchash[hi] = rcrec;\n\t}\n\n\t(pass == 1) ? rcrec->len1++ : rcrec->len2++;\n\n\trec->ha = (unsigned long) rcrec->idx;\n\n\thi = (long) XDL_HASHLONG(rec->ha, hbits);\n\trec->next = rhash[hi];\n\trhash[hi] = rec;\n\n\treturn 0;\n}\n\n\nstatic int xdl_prepare_ctx(unsigned int pass, mmfile_t *mf, long narec, xpparam_t const *xpp,\n\t\t\t   xdlclassifier_t *cf, xdfile_t *xdf) {\n\tunsigned int hbits;\n\tlong nrec, hsize, bsize;\n\tunsigned long hav;\n\tchar const *blk, *cur, *top, *prev;\n\txrecord_t *crec;\n\txrecord_t **recs;\n\txrecord_t **rhash;\n\tunsigned long *ha;\n\tchar *rchg;\n\tlong *rindex;\n\n\tha = NULL;\n\trindex = NULL;\n\trchg = NULL;\n\trhash = NULL;\n\trecs = NULL;\n\n\tif (xdl_cha_init(&xdf->rcha, sizeof(xrecord_t), narec / 4 + 1) < 0)\n\t\tgoto abort;\n\tif (!XDL_ALLOC_ARRAY(recs, narec))\n\t\tgoto abort;\n\n\thbits = xdl_hashbits((unsigned int) narec);\n\thsize = 1 << hbits;\n\tif (!XDL_CALLOC_ARRAY(rhash, hsize))\n\t\tgoto abort;\n\n\tnrec = 0;\n\tif ((cur = blk = xdl_mmfile_first(mf, &bsize))) {\n\t\tfor (top = blk + bsize; cur < top; ) {\n\t\t\tprev = cur;\n\t\t\thav = xdl_hash_record(&cur, top, xpp->flags);\n\t\t\tif (XDL_ALLOC_GROW(recs, nrec + 1, narec))\n\t\t\t\tgoto abort;\n\t\t\tif (!(crec = xdl_cha_alloc(&xdf->rcha)))\n\t\t\t\tgoto abort;\n\t\t\tcrec->ptr = prev;\n\t\t\tcrec->size = (long) (cur - prev);\n\t\t\tcrec->ha = hav;\n\t\t\trecs[nrec++] = crec;\n\t\t\tif (xdl_classify_record(pass, cf, rhash, hbits, crec) < 0)\n\t\t\t\tgoto abort;\n\t\t}\n\t}\n\n\tif (!XDL_CALLOC_ARRAY(rchg, nrec + 2))\n\t\tgoto abort;\n\n\tif ((XDF_DIFF_ALG(xpp->flags) != XDF_PATIENCE_DIFF) &&\n\t    (XDF_DIFF_ALG(xpp->flags) != XDF_HISTOGRAM_DIFF)) {\n\t\tif (!XDL_ALLOC_ARRAY(rindex, nrec + 1))\n\t\t\tgoto abort;\n\t\tif (!XDL_ALLOC_ARRAY(ha, nrec + 1))\n\t\t\tgoto abort;\n\t}\n\n\txdf->nrec = nrec;\n\txdf->recs = recs;\n\txdf->hbits = hbits;\n\txdf->rhash = rhash;\n\txdf->rchg = rchg + 1;\n\txdf->rindex = rindex;\n\txdf->nreff = 0;\n\txdf->ha = ha;\n\txdf->dstart = 0;\n\txdf->dend = nrec - 1;\n\n\treturn 0;\n\nabort:\n\txdl_free(ha);\n\txdl_free(rindex);\n\txdl_free(rchg);\n\txdl_free(rhash);\n\txdl_free(recs);\n\txdl_cha_free(&xdf->rcha);\n\treturn -1;\n}\n\n\nstatic void xdl_free_ctx(xdfile_t *xdf) {\n\n\txdl_free(xdf->rhash);\n\txdl_free(xdf->rindex);\n\txdl_free(xdf->rchg - 1);\n\txdl_free(xdf->ha);\n\txdl_free(xdf->recs);\n\txdl_cha_free(&xdf->rcha);\n}\n\n\nint xdl_prepare_env(mmfile_t *mf1, mmfile_t *mf2, xpparam_t const *xpp,\n\t\t    xdfenv_t *xe) {\n\tlong enl1, enl2, sample;\n\txdlclassifier_t cf;\n\n\tmemset(&cf, 0, sizeof(cf));\n\n\t/*\n\t * For histogram diff, we can afford a smaller sample size and\n\t * thus a poorer estimate of the number of lines, as the hash\n\t * table (rhash) won't be filled up/grown. The number of lines\n\t * (nrecs) will be updated correctly anyway by\n\t * xdl_prepare_ctx().\n\t */\n\tsample = (XDF_DIFF_ALG(xpp->flags) == XDF_HISTOGRAM_DIFF\n\t\t  ? XDL_GUESS_NLINES2 : XDL_GUESS_NLINES1);\n\n\tenl1 = xdl_guess_lines(mf1, sample) + 1;\n\tenl2 = xdl_guess_lines(mf2, sample) + 1;\n\n\tif (xdl_init_classifier(&cf, enl1 + enl2 + 1, xpp->flags) < 0)\n\t\treturn -1;\n\n\tif (xdl_prepare_ctx(1, mf1, enl1, xpp, &cf, &xe->xdf1) < 0) {\n\n\t\txdl_free_classifier(&cf);\n\t\treturn -1;\n\t}\n\tif (xdl_prepare_ctx(2, mf2, enl2, xpp, &cf, &xe->xdf2) < 0) {\n\n\t\txdl_free_ctx(&xe->xdf1);\n\t\txdl_free_classifier(&cf);\n\t\treturn -1;\n\t}\n\n\tif ((XDF_DIFF_ALG(xpp->flags) != XDF_PATIENCE_DIFF) &&\n\t    (XDF_DIFF_ALG(xpp->flags) != XDF_HISTOGRAM_DIFF) &&\n\t    xdl_optimize_ctxs(&cf, &xe->xdf1, &xe->xdf2) < 0) {\n\n\t\txdl_free_ctx(&xe->xdf2);\n\t\txdl_free_ctx(&xe->xdf1);\n\t\txdl_free_classifier(&cf);\n\t\treturn -1;\n\t}\n\n\txdl_free_classifier(&cf);\n\n\treturn 0;\n}\n\n\nvoid xdl_free_env(xdfenv_t *xe) {\n\n\txdl_free_ctx(&xe->xdf2);\n\txdl_free_ctx(&xe->xdf1);\n}\n\n\nstatic int xdl_clean_mmatch(char const *dis, long i, long s, long e) {\n\tlong r, rdis0, rpdis0, rdis1, rpdis1;\n\n\t/*\n\t * Limits the window the is examined during the similar-lines\n\t * scan. The loops below stops when dis[i - r] == 1 (line that\n\t * has no match), but there are corner cases where the loop\n\t * proceed all the way to the extremities by causing huge\n\t * performance penalties in case of big files.\n\t */\n\tif (i - s > XDL_SIMSCAN_WINDOW)\n\t\ts = i - XDL_SIMSCAN_WINDOW;\n\tif (e - i > XDL_SIMSCAN_WINDOW)\n\t\te = i + XDL_SIMSCAN_WINDOW;\n\n\t/*\n\t * Scans the lines before 'i' to find a run of lines that either\n\t * have no match (dis[j] == 0) or have multiple matches (dis[j] > 1).\n\t * Note that we always call this function with dis[i] > 1, so the\n\t * current line (i) is already a multimatch line.\n\t */\n\tfor (r = 1, rdis0 = 0, rpdis0 = 1; (i - r) >= s; r++) {\n\t\tif (!dis[i - r])\n\t\t\trdis0++;\n\t\telse if (dis[i - r] == 2)\n\t\t\trpdis0++;\n\t\telse\n\t\t\tbreak;\n\t}\n\t/*\n\t * If the run before the line 'i' found only multimatch lines, we\n\t * return 0 and hence we don't make the current line (i) discarded.\n\t * We want to discard multimatch lines only when they appear in the\n\t * middle of runs with nomatch lines (dis[j] == 0).\n\t */\n\tif (rdis0 == 0)\n\t\treturn 0;\n\tfor (r = 1, rdis1 = 0, rpdis1 = 1; (i + r) <= e; r++) {\n\t\tif (!dis[i + r])\n\t\t\trdis1++;\n\t\telse if (dis[i + r] == 2)\n\t\t\trpdis1++;\n\t\telse\n\t\t\tbreak;\n\t}\n\t/*\n\t * If the run after the line 'i' found only multimatch lines, we\n\t * return 0 and hence we don't make the current line (i) discarded.\n\t */\n\tif (rdis1 == 0)\n\t\treturn 0;\n\trdis1 += rdis0;\n\trpdis1 += rpdis0;\n\n\treturn rpdis1 * XDL_KPDIS_RUN < (rpdis1 + rdis1);\n}\n\n\n/*\n * Try to reduce the problem complexity, discard records that have no\n * matches on the other file. Also, lines that have multiple matches\n * might be potentially discarded if they happear in a run of discardable.\n */\nstatic int xdl_cleanup_records(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2) {\n\tlong i, nm, nreff, mlim;\n\txrecord_t **recs;\n\txdlclass_t *rcrec;\n\tchar *dis, *dis1, *dis2;\n\n\tif (!XDL_CALLOC_ARRAY(dis, xdf1->nrec + xdf2->nrec + 2))\n\t\treturn -1;\n\tdis1 = dis;\n\tdis2 = dis1 + xdf1->nrec + 1;\n\n\tif ((mlim = xdl_bogosqrt(xdf1->nrec)) > XDL_MAX_EQLIMIT)\n\t\tmlim = XDL_MAX_EQLIMIT;\n\tfor (i = xdf1->dstart, recs = &xdf1->recs[xdf1->dstart]; i <= xdf1->dend; i++, recs++) {\n\t\trcrec = cf->rcrecs[(*recs)->ha];\n\t\tnm = rcrec ? rcrec->len2 : 0;\n\t\tdis1[i] = (nm == 0) ? 0: (nm >= mlim) ? 2: 1;\n\t}\n\n\tif ((mlim = xdl_bogosqrt(xdf2->nrec)) > XDL_MAX_EQLIMIT)\n\t\tmlim = XDL_MAX_EQLIMIT;\n\tfor (i = xdf2->dstart, recs = &xdf2->recs[xdf2->dstart]; i <= xdf2->dend; i++, recs++) {\n\t\trcrec = cf->rcrecs[(*recs)->ha];\n\t\tnm = rcrec ? rcrec->len1 : 0;\n\t\tdis2[i] = (nm == 0) ? 0: (nm >= mlim) ? 2: 1;\n\t}\n\n\tfor (nreff = 0, i = xdf1->dstart, recs = &xdf1->recs[xdf1->dstart];\n\t     i <= xdf1->dend; i++, recs++) {\n\t\tif (dis1[i] == 1 ||\n\t\t    (dis1[i] == 2 && !xdl_clean_mmatch(dis1, i, xdf1->dstart, xdf1->dend))) {\n\t\t\txdf1->rindex[nreff] = i;\n\t\t\txdf1->ha[nreff] = (*recs)->ha;\n\t\t\tnreff++;\n\t\t} else\n\t\t\txdf1->rchg[i] = 1;\n\t}\n\txdf1->nreff = nreff;\n\n\tfor (nreff = 0, i = xdf2->dstart, recs = &xdf2->recs[xdf2->dstart];\n\t     i <= xdf2->dend; i++, recs++) {\n\t\tif (dis2[i] == 1 ||\n\t\t    (dis2[i] == 2 && !xdl_clean_mmatch(dis2, i, xdf2->dstart, xdf2->dend))) {\n\t\t\txdf2->rindex[nreff] = i;\n\t\t\txdf2->ha[nreff] = (*recs)->ha;\n\t\t\tnreff++;\n\t\t} else\n\t\t\txdf2->rchg[i] = 1;\n\t}\n\txdf2->nreff = nreff;\n\n\txdl_free(dis);\n\n\treturn 0;\n}\n\n\n/*\n * Early trim initial and terminal matching records.\n */\nstatic int xdl_trim_ends(xdfile_t *xdf1, xdfile_t *xdf2) {\n\tlong i, lim;\n\txrecord_t **recs1, **recs2;\n\n\trecs1 = xdf1->recs;\n\trecs2 = xdf2->recs;\n\tfor (i = 0, lim = XDL_MIN(xdf1->nrec, xdf2->nrec); i < lim;\n\t     i++, recs1++, recs2++)\n\t\tif ((*recs1)->ha != (*recs2)->ha)\n\t\t\tbreak;\n\n\txdf1->dstart = xdf2->dstart = i;\n\n\trecs1 = xdf1->recs + xdf1->nrec - 1;\n\trecs2 = xdf2->recs + xdf2->nrec - 1;\n\tfor (lim -= i, i = 0; i < lim; i++, recs1--, recs2--)\n\t\tif ((*recs1)->ha != (*recs2)->ha)\n\t\t\tbreak;\n\n\txdf1->dend = xdf1->nrec - i - 1;\n\txdf2->dend = xdf2->nrec - i - 1;\n\n\treturn 0;\n}\n\n\nstatic int xdl_optimize_ctxs(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2) {\n\n\tif (xdl_trim_ends(xdf1, xdf2) < 0 ||\n\t    xdl_cleanup_records(cf, xdf1, xdf2) < 0) {\n\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n```\n\n**third_party/xdiff/xdiffi.h**\n```\n/*\n *  LibXDiff by Davide Libenzi ( File Differential Library )\n *  Copyright (C) 2003  Davide Libenzi\n *\n *  This library is free software; you can redistribute it and/or\n *  modify it under the terms of the GNU Lesser General Public\n *  License as published by the Free Software Foundation; either\n *  version 2.1 of the License, or (at your option) any later version.\n *\n *  This library is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n *  Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; if not, see\n *  <http://www.gnu.org/licenses/>.\n *\n *  Davide Libenzi <davidel@xmailserver.org>\n *\n */\n\n#if !defined(XDIFFI_H)\n#define XDIFFI_H\n\n\ntypedef struct s_diffdata {\n\tlong nrec;\n\tunsigned long const *ha;\n\tlong *rindex;\n\tchar *rchg;\n} diffdata_t;\n\ntypedef struct s_xdalgoenv {\n\tlong mxcost;\n\tlong snake_cnt;\n\tlong heur_min;\n} xdalgoenv_t;\n\ntypedef struct s_xdchange {\n\tstruct s_xdchange *next;\n\tlong i1, i2;\n\tlong chg1, chg2;\n\tint ignore;\n} xdchange_t;\n\n\n\nint xdl_recs_cmp(diffdata_t *dd1, long off1, long lim1,\n\t\t diffdata_t *dd2, long off2, long lim2,\n\t\t long *kvdf, long *kvdb, int need_min, xdalgoenv_t *xenv);\nint xdl_do_diff(mmfile_t *mf1, mmfile_t *mf2, xpparam_t const *xpp,\n\t\txdfenv_t *xe);\nint xdl_change_compact(xdfile_t *xdf, xdfile_t *xdfo, long flags);\nint xdl_build_script(xdfenv_t *xe, xdchange_t **xscr);\nvoid xdl_free_script(xdchange_t *xscr);\nint xdl_emit_diff(xdfenv_t *xe, xdchange_t *xscr, xdemitcb_t *ecb,\n\t\t  xdemitconf_t const *xecfg);\nint xdl_do_patience_diff(xpparam_t const *xpp, xdfenv_t *env);\nint xdl_do_histogram_diff(xpparam_t const *xpp, xdfenv_t *env);\n\n#endif /* #if !defined(XDIFFI_H) */\n\n```<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\n","ts":1.738978907523E9}
{"completion":"The functions `xdl_trim_ends` and `xdl_cleanup_records` are part of the LibXDiff library, which is used for computing the differences between two files.\n\n**xdl_trim_ends**\n\nThis function trims the initial and terminal matching records from two files. It takes two `xdfile_t` structures as input, which represent the two files being compared. The function compares the records (lines) of the two files from the beginning and end, and removes the matching records from the beginning and end of both files.\n\nHere's a step-by-step breakdown of what the function does:\n\n1. It initializes two pointers, `recs1` and `recs2`, to the beginning of the records in each file.\n2. It loops through the records, comparing the hash values (`ha`) of the records at the current positions in both files. If the hash values match, it increments the pointers and continues to the next record.\n3. If the hash values do not match, it breaks out of the loop and sets the `dstart` field of both `xdfile_t` structures to the current position. This effectively trims the matching records from the beginning of both files.\n4. It then repeats the process from the end of the files, comparing the hash values of the records at the current positions in both files and trimming the matching records from the end of both files.\n\n**xdl_cleanup_records**\n\nThis function cleans up the records in two files by removing records that have no matches in the other file. It also removes records that have multiple matches in the other file, but only if they appear in a run of discardable records.\n\nHere's a step-by-step breakdown of what the function does:\n\n1. It allocates memory for an array `dis` to keep track of the records that have been discarded.\n2. It loops through the records in the first file, and for each record, it checks if there is a matching record in the second file. If there is no match, it sets the corresponding element in the `dis` array to 0. If there is a match, it sets the element to 1 if the match is unique, or 2 if there are multiple matches.\n3. It repeats the process for the second file, looping through its records and checking for matches in the first file.\n4. It then loops through the records in both files again, and for each record, it checks the corresponding element in the `dis` array. If the element is 1 or 2, it means the record has a match in the other file, so it is kept. If the element is 0, it means the record has no match, so it is discarded.\n5. If a record has multiple matches (i.e., the element in the `dis` array is 2), it checks if the record appears in a run of discardable records. If it does, it discards the record.\n\n**Underlying data structures**\n\nThe functions operate on the following data structures:\n\n* `xdfile_t`: represents a file being compared. It contains fields such as `nrec` (the number of records in the file), `recs` (an array of `xrecord_t` structures representing the records in the file), `dstart` and `dend` (the start and end positions of the records in the file), and `rchg` (an array of booleans indicating whether each record has been changed).\n* `xrecord_t`: represents a record (line) in a file. It contains fields such as `ptr` (a pointer to the record data), `size` (the size of the record data), and `ha` (a hash value for the record).\n* `xdlclassifier_t`: represents a classifier for records. It contains fields such as `hbits` (the number of bits in the hash values), `hsize` (the size of the hash table), and `rchash` (an array of `xdlclass_t` structures representing the hash table).\n\n**Contracts**\n\nThe functions assume that the input data structures are valid and properly initialized. They also assume that the records in the files are properly formatted and can be compared using the hash values.\n\nThe functions modify the input data structures by trimming the matching records from the beginning and end of the files, and by removing records that have no matches or appear in a run of discardable records.\n\nOverall, the functions are designed to optimize the comparison of two files by removing unnecessary records and reducing the problem size.","ts":1.738978941297E9}
