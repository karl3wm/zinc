{"role":"user","content":"Write a boost::json parser and handler that tracks the ranges of characters associated with each value.","ts":1.739098475216E9}
{"role":"assistant","content":"Below is an example of a `boost::json` parser and handler that tracks the ranges of characters associated with each value.\n\n```cpp\n#include <boost/json.hpp>\n#include <iostream>\n#include <string>\n\n// Define a custom handler that tracks the ranges of characters associated with each value\nclass range_handler {\npublic:\n    range_handler(std::string const& input) : input_(input) {}\n\n    bool on_document_begin(boost::json::error_code& ec) {\n        return true;\n    }\n\n    bool on_document_end(boost::json::error_code& ec) {\n        return true;\n    }\n\n    bool on_object_begin(boost::json::error_code& ec) {\n        stack_.push_back(range_);\n        range_ = {};\n        return true;\n    }\n\n    bool on_object_end(boost::json::error_code& ec) {\n        if (!stack_.empty()) {\n            range_ = stack_.back();\n            stack_.pop_back();\n        }\n        return true;\n    }\n\n    bool on_array_begin(boost::json::error_code& ec) {\n        stack_.push_back(range_);\n        range_ = {};\n        return true;\n    }\n\n    bool on_array_end(boost::json::error_code& ec) {\n        if (!stack_.empty()) {\n            range_ = stack_.back();\n            stack_.pop_back();\n        }\n        return true;\n    }\n\n    bool on_string_part(boost::json::string_view const& sv, boost::json::error_code& ec) {\n        if (range_.start == 0) {\n            range_.start = sv.data() - input_.data();\n        }\n        range_.end = sv.data() - input_.data() + sv.size();\n        return true;\n    }\n\n    bool on_int64(int64_t, boost::json::error_code& ec) {\n        return true;\n    }\n\n    bool on_uint64(uint64_t, boost::json::error_code& ec) {\n        return true;\n    }\n\n    bool on_double(double, boost::json::error_code& ec) {\n        return true;\n    }\n\n    bool on_bool(bool, boost::json::error_code& ec) {\n        return true;\n    }\n\n    bool on_null(boost::json::error_code& ec) {\n        return true;\n    }\n\n    struct range {\n        size_t start = 0;\n        size_t end = 0;\n    };\n\n    range get_range() const {\n        return range_;\n    }\n\nprivate:\n    std::string const& input_;\n    range range_;\n    std::vector<range> stack_;\n};\n\nint main() {\n    std::string input = \"{\\\"key\\\":\\\"value\\\"}\";\n    range_handler handler(input);\n    boost::json::parser parser;\n    parser.write(input, handler);\n    auto range = handler.get_range();\n    std::cout << \"Range: [\" << range.start << \", \" << range.end << \"]\" << std::endl;\n    return 0;\n}\n```\n\nThis code defines a custom handler `range_handler` that tracks the ranges of characters associated with each value. The handler uses a stack to keep track of the current range and updates it as it encounters different JSON elements.\n\nIn the `main` function, we create an instance of the `range_handler` and pass it to the `boost::json::parser` along with the input JSON string. After parsing the JSON, we retrieve the range from the handler and print it to the console.\n\nNote that this code assumes that the input JSON string is a single document. If you need to parse multiple documents, you will need to modify the handler to reset the range after each document.\n\nAlso, this code only tracks the range of the last value encountered. If you need to track the ranges of all values, you will need to modify the handler to store the ranges in a data structure, such as a vector or map.","ts":1.739098481123E9}
