{"prompt":"<|begin_of_text|><|start_header_id|>user<|end_header_id|>\n\nCan you update src/diff.cpp to match the rest of the project as well as make an include/zinc/diff.hpp and a tests/test_diff.cpp? In test_diff output the streaming diff so that I can use the test behavior to modify the class.\n\n**src/diff.cpp**\n```\n//#include <generator>\n#include <string_view>\n#include <fstream>\n#include <unordered_map>\n#include <vector>\n#include <deque>\n#include <functional>\n//#include <format>\n#include <chrono>\n#include <filesystem>\n\nclass UnifiedDiffGenerator {\nprivate:\n    struct LineLocation {\n        std::streamoff offset;\n        size_t length;\n        size_t line_number;\n    };\n\n    struct HunkState {\n        bool is_active = false;\n        size_t old_start = 0;\n        size_t new_start = 0;\n        size_t old_count = 0;\n        size_t new_count = 0;\n        std::deque<std::string> pending_output;\n\n        zinc::generator<std::string_view> flush()\n        {\n            if (is_active && !pending_output.empty()) {\n                {\n                    std::stringstream header;\n                    header << \"@@ -\" << old_start << \",\" << old_count << \" +\" << new_start << \",\" << new_count << \" @@\\n\";\n                    co_yield header.str();\n                }\n\n                for (const auto& line : pending_output) {\n                    co_yield line;\n                }\n\n                pending_output.clear();\n                is_active = false;\n            }\n        }\n    };\n\n    static std::string readLine(std::ifstream& file, const LineLocation& loc) {\n        std::string line;\n        line.resize(loc.length);\n        file.seekg(loc.offset);\n        file.read(line.data(), loc.length);\n        if (!line.empty() && line.back() == '\\n') {\n            line.pop_back();\n        }\n        return line;\n    }\n\n    static std::string formatTimestamp(const std::filesystem::file_time_type& ftime) {\n        std::chrono::system_clock::time_point sctp(std::chrono::duration_cast<std::chrono::system_clock::duration>(ftime.time_since_epoch()));\n        auto tt = std::chrono::system_clock::to_time_t(sctp);\n        std::string timestamp = std::ctime(&tt);\n        if (!timestamp.empty() && timestamp.back() == '\\n') {\n            timestamp.pop_back();\n        }\n        return timestamp;\n    }\n\npublic:\n    static zinc::generator<std::string_view> generateDiff(\n        const std::filesystem::path& filepath,\n        std::ifstream& file,\n        zinc::generator<std::string_view> newContent,\n        size_t context_lines = 3\n    ) {\n        // Build multimap of line hashes to line locations\n        std::unordered_multimap<size_t, LineLocation> line_map;\n        std::vector<LineLocation> line_locations;\n        std::string line;\n        size_t line_num = 1;  // 1-based line numbers\n        std::hash<std::string_view> hasher;\n\n        // Record file positions and build hash map\n        file.seekg(0);\n        std::streamoff current_pos = file.tellg();\n        while (std::getline(file, line)) {\n            size_t length = line.length() + 1;  // Include newline\n            LineLocation loc{current_pos, length, line_num};\n            line_locations.push_back(loc);\n\n            size_t hash = hasher(std::string_view(line));\n            line_map.emplace(hash, loc);\n\n            current_pos += length;\n            line_num++;\n        }\n        file.clear();\n\n        // Generate header\n        auto fileTime = std::filesystem::last_write_time(filepath);\n        {\n            std::stringstream header;\n\n            header << \"--- \" << filepath.string() << \"\\t\" << formatTimestamp(fileTime) << \"\\n+++ \" << filepath.string() << \"\\t\" << formatTimestamp(std::filesystem::file_time_type::clock::now()) << \"\\n\";\n\n            co_yield header.str();\n        }\n\n        // Process incoming lines\n        size_t expected_line = 1;\n        size_t new_line_num = 1;\n        HunkState current_hunk;\n        std::deque<std::string> context_buffer;\n\n        auto startNewHunk = [&](size_t old_line, size_t new_line) {\n            if (!current_hunk.is_active) {\n                current_hunk.is_active = true;\n                current_hunk.old_start = std::max<size_t>(1, old_line - context_lines);\n                current_hunk.new_start = std::max<size_t>(1, new_line - context_lines);\n                current_hunk.old_count = 0;\n                current_hunk.new_count = 0;\n\n                // Add leading context\n                for (size_t i = current_hunk.old_start; i < old_line; ++i) {\n                    if (i <= line_locations.size()) {\n                        std::string context_line = readLine(file, line_locations[i - 1]);\n                        current_hunk.pending_output.push_back(\" \" + context_line + \"\\n\");\n                        current_hunk.old_count++;\n                        current_hunk.new_count++;\n                    }\n                }\n            }\n        };\n\n        for (std::string_view new_line : newContent) {\n            size_t hash = hasher(new_line);\n            auto [start, end] = line_map.equal_range(hash);\n\n            bool found = false;\n            size_t best_line_num = SIZE_MAX;\n            LineLocation matched_loc;\n\n            // Find the first matching line that hasn't been processed\n            for (auto it = start; it != end; ++it) {\n                if (it->second.line_number >= expected_line &&\n                    it->second.line_number < best_line_num) {\n                    best_line_num = it->second.line_number;\n                    matched_loc = it->second;\n                    found = true;\n                }\n            }\n\n            if (found) {\n                // Output any skipped lines as deletions\n                if (best_line_num > expected_line) {\n                    startNewHunk(expected_line, new_line_num);\n\n                    while (expected_line < best_line_num) {\n                        std::string deleted_line = readLine(file, line_locations[expected_line - 1]);\n                        current_hunk.pending_output.push_back(\"-\" + deleted_line + \"\\n\");\n                        current_hunk.old_count++;\n                        expected_line++;\n                    }\n                }\n\n                // Add unchanged line to context\n                if (!current_hunk.is_active) {\n                    context_buffer.push_back(\" \" + std::string(new_line) + \"\\n\");\n                    if (context_buffer.size() > context_lines * 2) {\n                        context_buffer.pop_front();\n                    }\n                } else {\n                    current_hunk.pending_output.push_back(\" \" + std::string(new_line) + \"\\n\");\n                    current_hunk.old_count++;\n                    current_hunk.new_count++;\n                }\n\n                expected_line = best_line_num + 1;\n            } else {\n                // Line not found - it's an addition\n                startNewHunk(expected_line, new_line_num);\n                current_hunk.pending_output.push_back(\"+\" + std::string(new_line) + \"\\n\");\n                current_hunk.new_count++;\n            }\n\n            // Check if we should close the current hunk\n            if (current_hunk.is_active && current_hunk.pending_output.size() >= context_lines * 2) {\n                co_yield zinc::ranges::elements_of(current_hunk.flush());\n            }\n\n            new_line_num++;\n        }\n\n        // Output remaining lines from original as deletions\n        if (expected_line <= line_locations.size()) {\n            startNewHunk(expected_line, new_line_num);\n\n            while (expected_line <= line_locations.size()) {\n                std::string deleted_line = readLine(file, line_locations[expected_line - 1]);\n                current_hunk.pending_output.push_back(\"-\" + deleted_line + \"\\n\");\n                current_hunk.old_count++;\n                expected_line++;\n            }\n        }\n\n        // Flush final hunk if active\n        if (current_hunk.is_active) {\n            co_yield zinc::ranges::elements_of(current_hunk.flush());\n        }\n    }\n};\n\n```\n\n**include/zinc/common.hpp**\n```\n#pragma once\n\n// zinc::generator is based on c++23 std::generator,\n// with the change that initial_suspend is never_suspend.\n// Because of this change, passed temporaries stay in scope.\n#include <zinc/__generator.hpp>\n\n#include <initializer_list>\n#include <span>\n#include <string>\n#include <string_view>\n\nnamespace zinc {\n\nusing StringViewPair = std::pair<std::string_view, std::string_view>;\nusing StringPair = std::pair<std::string, std::string>;\n\n// Helper function to create a literal span\ntemplate <typename T>\nstd::span<T const> span(std::initializer_list<T> const & contiguous)\n{\n    return std::span((T const*)contiguous.begin(), contiguous.size());\n}\n\n// Helper functions to replace substrings\nstd::string replaced(\n    std::string_view haystack,\n    std::span<StringViewPair const> replacements\n);\n\n}\n\nextern \"C\" {\nconst char *__asan_default_options();\nconst char *__msan_default_options();\nconst char *__lsan_default_options();\nconst char *__tsan_default_options();\n}\n\n```\n\n**include/zinc/configuration.hpp**\n```\n#pragma once\n\n#include <zinc/common.hpp>\n\n#include <span>\n#include <string_view>\n\nnamespace zinc {\n\nclass Configuration {\npublic:\n    /*\n     * Create the configuration directories if they don't exist.\n     *\n     * Returns true if new directories were created.\n     */\n    static bool init();\n\n    /*\n     * Get a per-project configuration path.\n     */\n    static std::string_view path_local(std::span<std::string_view const> subpaths = {}, bool is_dir = false);\n\n    /*\n     * Get a per-user configuration path.\n     */\n    static std::string_view path_user(std::span<std::string_view const> subpaths = {}, bool is_dir = false);\n};\n\n}\n\n```\n\n**src/configuration.cpp**\n```\n#include <zinc/configuration.hpp>\n\n#include <filesystem>\n#include <stdexcept>\n#include <thread>\n\nnamespace fs = std::filesystem;\n\nnamespace zinc {\n\nnamespace {\n\nfs::path const & config_dir_user()\n{\n    static struct ConfigDirUser\n    {\n        ConfigDirUser()\n        {\n            char const* xdg_config_home = getenv(\"XDG_CONFIG_HOME\");\n            if (xdg_config_home != nullptr) {\n                path = fs::path(xdg_config_home);\n            }\n            if (path.empty()) {\n                char const* home = getenv(\"HOME\");\n                if (home != nullptr) {\n                    path = fs::path(home) / \".config\";\n                }\n            }\n            if (!path.empty()) {\n                path /= \"zinc\";\n            } else {\n                // Handle the case where neither XDG_CONFIG_HOME nor HOME is set.\n                // You could throw an exception or set a default path.\n                throw std::runtime_error(\"Neither XDG_CONFIG_HOME nor HOME is set.\");\n            }\n        }\n\n        fs::path path;\n    } config_dir_user;\n\n    return config_dir_user.path;\n};\n\nstd::string_view path_helper(fs::path& path, std::span<std::string_view const> subpaths, bool is_dir) {\n    for (const auto& subpath : subpaths) {\n        path /= subpath;\n    }\n    if (is_dir) {\n        fs::create_directories(path);\n        path /= \"\";\n    } else {\n        fs::create_directories(path.parent_path());\n    }\n    return path.native();\n}\n\n} // namespace\n\nbool Configuration::init() {\n    try {\n        path_local();\n    } catch (std::invalid_argument const& e) {\n        // Create a .zinc folder in the current directory if an exception is thrown\n        fs::create_directory(\".zinc\");\n        return true;\n    }\n    return false;\n}\n\nstd::string_view Configuration::path_local(std::span<std::string_view const> subpaths, bool is_dir) {\n    static fs::path config_dir_local;\n\n    {\n        static std::mutex mtx;\n        std::lock_guard<std::mutex> lock(mtx);\n\n        if (config_dir_local.empty()) {\n            fs::path zinc_dir;\n            for (\n                fs::path path = fs::current_path(), parent_path = path.parent_path();\n                !path.empty() && path != parent_path;\n                path = parent_path, parent_path = path.parent_path()\n            ) {\n                zinc_dir = path / \".zinc\";\n                if (zinc_dir == config_dir_user()) {\n                    break;\n                }\n                if (fs::exists(zinc_dir)) {\n                    config_dir_local = zinc_dir;\n                    break;\n                }\n            }\n            if (config_dir_local.empty()) {\n                throw std::invalid_argument(\"Could not find .zinc directory for project. Create one.\");\n            }\n        }\n    }\n\n    static thread_local fs::path path;\n    path = config_dir_local;\n    return path_helper(path, subpaths, is_dir);\n}\n\nstd::string_view Configuration::path_user(std::span<std::string_view const> subpaths, bool is_dir) {\n    static thread_local fs::path path;\n    path = config_dir_user();\n    return path_helper(path, subpaths, is_dir);\n}\n\n} // namespace zinc\n\n```\n\n**tests/test_configuration.cpp**\n```\n#define BOOST_TEST_MAIN\n#include <boost/test/unit_test.hpp>\n#include <zinc/configuration.hpp>\n#include <filesystem>\n#include <thread>\n\nnamespace fs = std::filesystem;\n\nBOOST_AUTO_TEST_SUITE(ConfigurationTest)\n\nBOOST_AUTO_TEST_CASE(init)\n{\n    // Create a temporary directory\n    fs::path temp_dir = fs::temp_directory_path() / \"zinc-test\";\n    fs::create_directory(temp_dir);\n\n    // Change into the temporary directory\n    fs::current_path(temp_dir);\n\n    // Call init() and check that a .zinc directory is created\n    BOOST_CHECK(zinc::Configuration::init());\n    BOOST_CHECK(fs::exists(\".zinc\"));\n\n    // Clean up\n    fs::remove_all(temp_dir);\n}\n\nBOOST_AUTO_TEST_CASE(path_local)\n{\n    // Create a temporary directory with a .zinc subdirectory\n    fs::path temp_dir = fs::temp_directory_path() / \"zinc-test\";\n    fs::create_directory(temp_dir);\n    fs::create_directory(temp_dir / \".zinc\");\n\n    // Change into the temporary directory\n    fs::current_path(temp_dir);\n\n    // Get the local configuration path\n    std::string_view path = zinc::Configuration::path_local();\n\n    // Check that the path is correct\n    BOOST_CHECK_EQUAL(path, (temp_dir / \".zinc\").native());\n\n    // Clean up\n    fs::remove_all(temp_dir);\n}\n\n/*\nBOOST_AUTO_TEST_CASE(path_user)\n{\n    // Get the user configuration path\n    std::string_view path = zinc::Configuration::path_user();\n\n    // Check that the path is correct\n    fs::path expected_path = fs::path(getenv(\"XDG_CONFIG_HOME\"));\n    if (expected_path.empty()) {\n        expected_path = fs::path(getenv(\"HOME\")) / \".config\";\n    }\n    expected_path /= \"zinc\";\n    BOOST_CHECK_EQUAL(path, expected_path.native());\n}\n*/\n\nBOOST_AUTO_TEST_CASE(path_local_subpaths)\n{\n    // Create a temporary directory with a .zinc subdirectory\n    fs::path temp_dir = fs::temp_directory_path() / \"zinc-test\";\n    fs::create_directory(temp_dir);\n    fs::create_directory(temp_dir / \".zinc\");\n\n    // Change into the temporary directory\n    fs::current_path(temp_dir);\n\n    // Get the local configuration path with subpaths\n    std::string_view path = zinc::Configuration::path_local(zinc::span<std::string_view>({\"subdir\", \"subsubdir\"}), true);\n\n    // Check that the path is correct\n    BOOST_CHECK_EQUAL(path, (temp_dir / \".zinc\" / \"subdir\" / \"subsubdir\" / \"\").native());\n\n    // Clean up\n    fs::remove_all(temp_dir);\n}\n\nBOOST_AUTO_TEST_CASE(path_user_subpaths)\n{\n    fs::path expected_path = zinc::Configuration::path_user();\n\n    // Get the user configuration path with subpaths\n    std::string_view path = zinc::Configuration::path_user(zinc::span<std::string_view>({\"subdir\", \"subsubdir\"}), true);\n\n    expected_path /= \"subdir\";\n    expected_path /= \"subsubdir\";\n    expected_path /= \"\";\n    BOOST_CHECK_EQUAL(path, expected_path.native());\n\n    // Clean up\n    fs::remove_all(expected_path.parent_path().parent_path());\n}\n\nBOOST_AUTO_TEST_SUITE_END()\n\n```<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\n","ts":1.73860831592E9}
{"completion":"Here are the updated files:\n\n**src/diff.cpp**\n```cpp\n#include <zinc/diff.hpp>\n\n#include <string_view>\n#include <fstream>\n#include <unordered_map>\n#include <vector>\n#include <deque>\n#include <functional>\n#include <chrono>\n#include <filesystem>\n\nnamespace zinc {\n\nclass UnifiedDiffGenerator {\nprivate:\n    struct LineLocation {\n        std::streamoff offset;\n        size_t length;\n        size_t line_number;\n    };\n\n    struct HunkState {\n        bool is_active = false;\n        size_t old_start = 0;\n        size_t new_start = 0;\n        size_t old_count = 0;\n        size_t new_count = 0;\n        std::deque<std::string> pending_output;\n\n        generator<std::string_view> flush()\n        {\n            if (is_active && !pending_output.empty()) {\n                {\n                    std::stringstream header;\n                    header << \"@@ -\" << old_start << \",\" << old_count << \" +\" << new_start << \",\" << new_count << \" @@\\n\";\n                    co_yield header.str();\n                }\n\n                for (const auto& line : pending_output) {\n                    co_yield line;\n                }\n\n                pending_output.clear();\n                is_active = false;\n            }\n        }\n    };\n\n    static std::string readLine(std::ifstream& file, const LineLocation& loc) {\n        std::string line;\n        line.resize(loc.length);\n        file.seekg(loc.offset);\n        file.read(line.data(), loc.length);\n        if (!line.empty() && line.back() == '\\n') {\n            line.pop_back();\n        }\n        return line;\n    }\n\n    static std::string formatTimestamp(const std::filesystem::file_time_type& ftime) {\n        std::chrono::system_clock::time_point sctp(std::chrono::duration_cast<std::chrono::system_clock::duration>(ftime.time_since_epoch()));\n        auto tt = std::chrono::system_clock::to_time_t(sctp);\n        std::string timestamp = std::ctime(&tt);\n        if (!timestamp.empty() && timestamp.back() == '\\n') {\n            timestamp.pop_back();\n        }\n        return timestamp;\n    }\n\npublic:\n    static generator<std::string_view> generateDiff(\n        const std::filesystem::path& filepath,\n        std::ifstream& file,\n        generator<std::string_view> newContent,\n        size_t context_lines = 3\n    ) {\n        // Build multimap of line hashes to line locations\n        std::unordered_multimap<size_t, LineLocation> line_map;\n        std::vector<LineLocation> line_locations;\n        std::string line;\n        size_t line_num = 1;  // 1-based line numbers\n        std::hash<std::string_view> hasher;\n\n        // Record file positions and build hash map\n        file.seekg(0);\n        std::streamoff current_pos = file.tellg();\n        while (std::getline(file, line)) {\n            size_t length = line.length() + 1;  // Include newline\n            LineLocation loc{current_pos, length, line_num};\n            line_locations.push_back(loc);\n\n            size_t hash = hasher(std::string_view(line));\n            line_map.emplace(hash, loc);\n\n            current_pos += length;\n            line_num++;\n        }\n        file.clear();\n\n        // Generate header\n        auto fileTime = std::filesystem::last_write_time(filepath);\n        {\n            std::stringstream header;\n\n            header << \"--- \" << filepath.string() << \"\\t\" << formatTimestamp(fileTime) << \"\\n+++ \" << filepath.string() << \"\\t\" << formatTimestamp(std::filesystem::file_time_type::clock::now()) << \"\\n\";\n\n            co_yield header.str();\n        }\n\n        // Process incoming lines\n        size_t expected_line = 1;\n        size_t new_line_num = 1;\n        HunkState current_hunk;\n        std::deque<std::string> context_buffer;\n\n        auto startNewHunk = [&](size_t old_line, size_t new_line) {\n            if (!current_hunk.is_active) {\n                current_hunk.is_active = true;\n                current_hunk.old_start = std::max<size_t>(1, old_line - context_lines);\n                current_hunk.new_start = std::max<size_t>(1, new_line - context_lines);\n                current_hunk.old_count = 0;\n                current_hunk.new_count = 0;\n\n                // Add leading context\n                for (size_t i = current_hunk.old_start; i < old_line; ++i) {\n                    if (i <= line_locations.size()) {\n                        std::string context_line = readLine(file, line_locations[i - 1]);\n                        current_hunk.pending_output.push_back(\" \" + context_line + \"\\n\");\n                        current_hunk.old_count++;\n                        current_hunk.new_count++;\n                    }\n                }\n            }\n        };\n\n        for (std::string_view new_line : newContent) {\n            size_t hash = hasher(new_line);\n            auto [start, end] = line_map.equal_range(hash);\n\n            bool found = false;\n            size_t best_line_num = SIZE_MAX;\n            LineLocation matched_loc;\n\n            // Find the first matching line that hasn't been processed\n            for (auto it = start; it != end; ++it) {\n                if (it->second.line_number >= expected_line &&\n                    it->second.line_number < best_line_num) {\n                    best_line_num = it->second.line_number;\n                    matched_loc = it->second;\n                    found = true;\n                }\n            }\n\n            if (found) {\n                // Output any skipped lines as deletions\n                if (best_line_num > expected_line) {\n                    startNewHunk(expected_line, new_line_num);\n\n                    while (expected_line < best_line_num) {\n                        std::string deleted_line = readLine(file, line_locations[expected_line - 1]);\n                        current_hunk.pending_output.push_back(\"-\" + deleted_line + \"\\n\");\n                        current_hunk.old_count++;\n                        expected_line++;\n                    }\n                }\n\n                // Add unchanged line to context\n                if (!current_hunk.is_active) {\n                    context_buffer.push_back(\" \" + std::string(new_line) + \"\\n\");\n                    if (context_buffer.size() > context_lines * 2) {\n                        context_buffer.pop_front();\n                    }\n                } else {\n                    current_hunk.pending_output.push_back(\" \" + std::string(new_line) + \"\\n\");\n                    current_hunk.old_count++;\n                    current_hunk.new_count++;\n                }\n\n                expected_line = best_line_num + 1;\n            } else {\n                // Line not found - it's an addition\n                startNewHunk(expected_line, new_line_num);\n                current_hunk.pending_output.push_back(\"+\" + std::string(new_line) + \"\\n\");\n                current_hunk.new_count++;\n            }\n\n            // Check if we should close the current hunk\n            if (current_hunk.is_active && current_hunk.pending_output.size() >= context_lines * 2) {\n                co_yield ranges::elements_of(current_hunk.flush());\n            }\n\n            new_line_num++;\n        }\n\n        // Output remaining lines from original as deletions\n        if (expected_line <= line_locations.size()) {\n            startNewHunk(expected_line, new_line_num);\n\n            while (expected_line <= line_locations.size()) {\n                std::string deleted_line = readLine(file, line_locations[expected_line - 1]);\n                current_hunk.pending_output.push_back(\"-\" + deleted_line + \"\\n\");\n                current_hunk.old_count++;\n                expected_line++;\n            }\n        }\n\n        // Flush final hunk if active\n        if (current_hunk.is_active) {\n            co_yield ranges::elements_of(current_hunk.flush());\n        }\n    }\n};\n\n} // namespace zinc\n```\n\n**include/zinc/diff.hpp**\n```cpp\n#pragma once\n\n#include <zinc/common.hpp>\n\n#include <filesystem>\n#include <fstream>\n\nnamespace zinc {\n\nclass UnifiedDiffGenerator {\npublic:\n    static generator<std::string_view> generateDiff(\n        const std::filesystem::path& filepath,\n        std::ifstream& file,\n        generator<std::string_view> newContent,\n        size_t context_lines = 3\n    );\n};\n\n} // namespace zinc\n```\n\n**tests/test_diff.cpp**\n```cpp\n#define BOOST_TEST_MAIN\n#include <boost/test/unit_test.hpp>\n#include <zinc/diff.hpp>\n#include <fstream>\n#include <sstream>\n#include <vector>\n\nBOOST_AUTO_TEST_SUITE(DiffTest)\n\nBOOST_AUTO_TEST_CASE(generateDiff)\n{\n    // Create a temporary file\n    std::ofstream file(\"temp.txt\");\n    file << \"Line 1\\nLine 2\\nLine 3\\nLine 4\\nLine 5\\n\";\n    file.close();\n\n    // Create a generator for the new content\n    auto newContent = []() -> generator<std::string_view> {\n        co_yield \"Line 1\\n\";\n        co_yield \"New Line 2\\n\";\n        co_yield \"Line 3\\n\";\n        co_yield \"New Line 4\\n\";\n        co_yield \"Line 5\\n\";\n    };\n\n    // Open the file for reading\n    std::ifstream inputFile(\"temp.txt\");\n\n    // Generate the diff\n    auto diff = UnifiedDiffGenerator::generateDiff(\"temp.txt\", inputFile, newContent());\n\n    // Check the diff output\n    std::vector<std::string> expectedOutput = {\n        \"--- temp.txt\\t\",\n        \"+++ temp.txt\\t\",\n        \"@@ -1,5 +1,5 @@\\n\",\n        \" Line 1\\n\",\n        \"-Line 2\\n\",\n        \"+New Line 2\\n\",\n        \" Line 3\\n\",\n        \"-Line 4\\n\",\n        \"+New Line 4\\n\",\n        \" Line 5\\n\"\n    };\n\n    std::vector<std::string> actualOutput;\n    for (const auto& line : diff) {\n        actualOutput.push_back(line);\n    }\n\n    BOOST_CHECK_EQUAL_COLLECTIONS(expectedOutput.begin(), expectedOutput.end(), actualOutput.begin(), actualOutput.end());\n\n    // Clean up\n    std::remove(\"temp.txt\");\n}\n\nBOOST_AUTO_TEST_SUITE_END()\n```","ts":1.738608345504E9}
