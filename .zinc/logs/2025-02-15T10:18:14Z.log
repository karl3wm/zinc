{"role":"user","content":"[1] [2] [3] Is anything important missing from the testsuite?\n\n1: include/zinc/configuration.hpp\n\n**include/zinc/configuration.hpp**\n```\n#pragma once\n\n#include <zinc/common.hpp>\n\n#include <span>\n#include <string_view>\n\nnamespace zinc {\n\nclass Configuration {\npublic:\n    /*\n     * Create the configuration directories if they don't exist.\n     *\n     * Returns true if new directories were created.\n     */\n    static bool init();\n\n    /*\n     * Constructor\n     */\n    Configuration(std::span<std::string_view const> subpath, bool user_wide = false);\n\n    /*\n     * Accessor for configuration values within a configuration file.\n     */\n    std::string & operator[](std::span<std::string_view const> locator);\n\n    /*\n     * Generator to iterate over sections (subcategories).\n     */\n    zinc::generator<std::string_view> sections(std::span<std::string_view const> locator = {});\n\n    /*\n     * Generator to iterate over key-value pairs.\n     */\n    zinc::generator<StringViewPair> values(std::span<std::string_view const> locator);\n\n    /*\n     * Destructor\n     */\n    ~Configuration();\n\n    /*\n     * Get a per-project configuration path.\n     */\n    static std::string_view path_local(std::span<std::string_view const> subpath = {}, bool is_dir = false);\n\n    /*\n     * Get a per-user configuration path.\n     */\n    static std::string_view path_user(std::span<std::string_view const> subpath = {}, bool is_dir = false);\n\nprivate:\n    void* impl_;\n};\n\n} // namespace zinc\n\n```\n\n2: tests/test_configuration.cpp\n\n**tests/test_configuration.cpp**\n```\n#define BOOST_TEST_MAIN\n#include <boost/test/unit_test.hpp>\n\n#include <zinc/configuration.hpp>\n\n#include <chrono>\n#include <filesystem>\n#include <fstream>\n#include <iomanip>\n#include <sstream>\n#include <string>\n#include <thread>\n\nnamespace fs = std::filesystem;\n\n// RAII class for managing temporary directories\nclass TemporaryDirectory {\npublic:\n    TemporaryDirectory() {\n        // Generate a unique directory name using PID, thread ID, and timestamp\n        auto pid = getpid();\n        auto tid = std::this_thread::get_id();\n        static auto now = std::chrono::system_clock::now();\n        auto timestamp = std::chrono::duration_cast<std::chrono::milliseconds>(now.time_since_epoch()).count();\n\n        std::ostringstream oss;\n        oss << \"zinc-test-\" << pid << \"-\" << tid << \"-\" << timestamp;\n        path_ = fs::temp_directory_path() / oss.str();\n\n        // Create the directory\n        fs::create_directory(path_);\n    }\n\n    ~TemporaryDirectory() {\n        // Clean up: remove the directory and its contents\n        fs::remove_all(path_);\n    }\n\n    const fs::path& path() const {\n        return path_;\n    }\n\nprivate:\n    fs::path path_;\n};\n\nBOOST_AUTO_TEST_SUITE(ConfigurationTest)\n\nBOOST_AUTO_TEST_CASE(init)\n{\n    TemporaryDirectory temp_dir;\n    fs::current_path(temp_dir.path());\n\n    BOOST_CHECK(zinc::Configuration::init());\n    BOOST_CHECK(fs::exists(\".zinc\"));\n}\n\nBOOST_AUTO_TEST_CASE(path_local)\n{\n    TemporaryDirectory temp_dir;\n    fs::create_directory(temp_dir.path() / \".zinc\");\n    fs::current_path(temp_dir.path());\n\n    std::string_view path = zinc::Configuration::path_local();\n    BOOST_CHECK_EQUAL(path, (temp_dir.path() / \".zinc\").native());\n}\n\nBOOST_AUTO_TEST_CASE(path_user)\n{\n    fs::path expected_path;\n    if (const char* xdg_config_home = getenv(\"XDG_CONFIG_HOME\")) {\n        expected_path = fs::path(xdg_config_home);\n    } else if (const char* home = getenv(\"HOME\")) {\n        expected_path = fs::path(home) / \".config\";\n    } else {\n        BOOST_FAIL(\"Neither XDG_CONFIG_HOME nor HOME is set.\");\n    }\n    expected_path /= \"zinc\";\n\n    std::string_view path = zinc::Configuration::path_user();\n    BOOST_CHECK_EQUAL(path, expected_path.native());\n}\n\nBOOST_AUTO_TEST_CASE(path_local_subpaths)\n{\n    TemporaryDirectory temp_dir;\n    fs::create_directory(temp_dir.path() / \".zinc\");\n    fs::current_path(temp_dir.path());\n\n    std::string_view path = zinc::Configuration::path_local(zinc::span<std::string_view>({\"subdir\", \"subsubdir\"}), true);\n    BOOST_CHECK_EQUAL(path, (temp_dir.path() / \".zinc\" / \"subdir\" / \"subsubdir\" / \"\").native());\n}\n\nBOOST_AUTO_TEST_CASE(path_user_subpaths)\n{\n    fs::path expected_path = zinc::Configuration::path_user();\n    std::string_view path = zinc::Configuration::path_user(zinc::span<std::string_view>({\"subdir\", \"subsubdir\"}), true);\n\n    expected_path /= \"subdir\";\n    expected_path /= \"subsubdir\";\n    expected_path /= \"\";\n    BOOST_CHECK_EQUAL(path, expected_path.native());\n\n    fs::remove_all(expected_path.parent_path().parent_path());\n}\n\nBOOST_AUTO_TEST_CASE(default_to_user_parameters)\n{\n    TemporaryDirectory temp_dir;\n    fs::current_path(temp_dir.path());\n\n    // Create a user config file with some parameters\n    fs::create_directories(zinc::Configuration::path_user());\n    std::ofstream user_config(std::string(zinc::Configuration::path_user(zinc::span<std::string_view>({\"test.ini\"}))));\n    user_config << \"[section]\\nkey = value_from_user\\n\";\n    user_config.close();\n\n    // Create a local config file with the same section but different key\n    fs::create_directories(zinc::Configuration::path_local());\n    std::ofstream local_config(std::string(zinc::Configuration::path_local(zinc::span<std::string_view>({\"test.ini\"}))));\n    local_config << \"[section]\\nother_key = value_from_local\\n\";\n    local_config.close();\n\n    // Inspect the local config file\n    zinc::Configuration config(zinc::span<std::string_view>({\"test.ini\"}));\n\n    // Check that the key from the user config is used\n    BOOST_CHECK_EQUAL(config[zinc::span<std::string_view>({\"section\", \"key\"})], \"value_from_user\");\n\n    // Check that the local-only key is used\n    BOOST_CHECK_EQUAL(config[zinc::span<std::string_view>({\"section\", \"other_key\"})], \"value_from_local\");\n}\n\nBOOST_AUTO_TEST_CASE(write_changed_parameters)\n{\n    TemporaryDirectory temp_dir;\n    fs::current_path(temp_dir.path());\n\n    // Create a user config file with some parameters\n    fs::create_directories(zinc::Configuration::path_user());\n    std::ofstream user_config(std::string(zinc::Configuration::path_user(zinc::span<std::string_view>({\"test.ini\"}))));\n    user_config << \"[section]\\nkey = value_from_user\\n\";\n    user_config.close();\n\n    // Create a local config file\n    fs::create_directories(zinc::Configuration::path_local());\n    std::ofstream local_config(std::string(zinc::Configuration::path_local(zinc::span<std::string_view>({\"test.ini\"}))));\n    local_config << \"[section]\\nother_key = value_from_local\\n\";\n    local_config.close();\n\n    // Modify a parameter from the user config\n    {\n        zinc::Configuration config(zinc::span<std::string_view>({\"test.ini\"}));\n        config[zinc::span<std::string_view>({\"section\", \"key\"})] = \"new_value\";\n    }\n\n    // Verify that the change was written to the local config file\n    std::ifstream local_config_updated(std::string(zinc::Configuration::path_local(zinc::span<std::string_view>({\"test.ini\"}))));\n    std::string content((std::istreambuf_iterator<char>(local_config_updated)), std::istreambuf_iterator<char>());\n    BOOST_CHECK(content.find(\"key = new_value\") != std::string::npos);\n}\n\nBOOST_AUTO_TEST_CASE(do_not_write_unmodified_parameters)\n{\n    TemporaryDirectory temp_dir;\n    fs::current_path(temp_dir.path());\n\n    // Create a user config file with some parameters\n    fs::create_directories(zinc::Configuration::path_user());\n    std::ofstream user_config(std::string(zinc::Configuration::path_user(zinc::span<std::string_view>({\"test.ini\"}))));\n    user_config << \"[section]\\nkey = value_from_user\\n\";\n    user_config.close();\n\n    // Create a local config file\n    fs::create_directories(zinc::Configuration::path_local());\n    std::ofstream local_config(std::string(zinc::Configuration::path_local(zinc::span<std::string_view>({\"test.ini\"}))));\n    local_config << \"[section]\\nother_key = value_from_local\\n\";\n    local_config.close();\n\n    // Read a parameter from the user config without modifying it\n    {\n        zinc::Configuration config(zinc::span<std::string_view>({\"test.ini\"}));\n        std::string value = config[zinc::span<std::string_view>({\"section\", \"key\"})];\n    }\n\n    // Verify that the user config was not written to the local config file\n    std::ifstream local_config_updated(std::string(zinc::Configuration::path_local(zinc::span<std::string_view>({\"test.ini\"}))));\n    std::string content((std::istreambuf_iterator<char>(local_config_updated)), std::istreambuf_iterator<char>());\n    BOOST_CHECK(content.find(\"key = value_from_user\") == std::string::npos);\n}\n\nBOOST_AUTO_TEST_CASE(locator_length_1)\n{\n    TemporaryDirectory temp_dir;\n    fs::current_path(temp_dir.path());\n    zinc::Configuration::init();\n\n    {\n        zinc::Configuration config(zinc::span<std::string_view>({\"test.ini\"}));\n        config[zinc::span<std::string_view>({\"section\"})] = \"section_value\";\n    }\n\n    std::ifstream config_file(std::string(zinc::Configuration::path_local(zinc::span<std::string_view>({\"test.ini\"}))));\n    std::string content((std::istreambuf_iterator<char>(config_file)), std::istreambuf_iterator<char>());\n    BOOST_CHECK(content.find(\"section = section_value\") != std::string::npos);\n}\n\nBOOST_AUTO_TEST_CASE(locator_length_2)\n{\n    TemporaryDirectory temp_dir;\n    fs::current_path(temp_dir.path());\n    zinc::Configuration::init();\n\n    {\n        zinc::Configuration config(zinc::span<std::string_view>({\"test.ini\"}));\n        config[zinc::span<std::string_view>({\"section\", \"subsection\"})] = \"subsection_value\";\n    }\n\n    std::ifstream config_file(std::string(zinc::Configuration::path_local(zinc::span<std::string_view>({\"test.ini\"}))));\n    std::string content((std::istreambuf_iterator<char>(config_file)), std::istreambuf_iterator<char>());\n    BOOST_CHECK(content.find(\"[section]\\n\\tsubsection = subsection_value\") != std::string::npos);\n}\n\nBOOST_AUTO_TEST_CASE(locator_length_greater_than_2)\n{\n    TemporaryDirectory temp_dir;\n    fs::current_path(temp_dir.path());\n    zinc::Configuration::init();\n\n    {\n        zinc::Configuration config(zinc::span<std::string_view>({\"test.ini\"}));\n        config[zinc::span<std::string_view>({\"section\", \"subsection\", \"subsubsection\"})] = \"subsubsection_value\";\n    }\n\n    std::ifstream config_file(std::string(zinc::Configuration::path_local(zinc::span<std::string_view>({\"test.ini\"}))));\n    std::string content((std::istreambuf_iterator<char>(config_file)), std::istreambuf_iterator<char>());\n    BOOST_CHECK(content.find(\"[section \\\"subsection\\\"]\\n\\tsubsubsection = subsubsection_value\") != std::string::npos);\n}\n\nBOOST_AUTO_TEST_SUITE_END()\n\n```\n\n3: src/configuration.cpp\n\n**src/configuration.cpp**\n```\n#include <zinc/configuration.hpp>\n\n#include <filesystem>\n#include <stdexcept>\n#include <thread>\n#include <unordered_set>\n#include <boost/iostreams/stream.hpp>\n#include <boost/property_tree/ptree.hpp>\n#include <boost/property_tree/ini_parser.hpp>\n//#include <regex>\n\nnamespace fs = std::filesystem;\n\nnamespace boost { namespace property_tree { namespace ini_parser {\nnamespace detail {\ntemplate <>\nvoid write_keys<ptree>(std::basic_ostream<ptree::key_type::value_type> & stream, const ptree& pt, bool throw_on_children)\n{\n    typedef typename ptree::key_type::value_type Ch;\n    for (typename ptree::const_iterator it = pt.begin(), end = pt.end();\n         it != end; ++it)\n    {\n        if (!it->second.empty()) {\n            if (throw_on_children) {\n                BOOST_PROPERTY_TREE_THROW(ini_parser_error(\n                    \"ptree is too deep\", \"\", 0));\n            }\n            continue;\n        }\n        if (throw_on_children) {\n            // indent innermost keys\n            stream << Ch('\\t');\n        }\n        stream << it->first << \" = \"\n            << it->second.template get_value<\n                std::basic_string<Ch> >()\n            << Ch('\\n');\n    }\n}\n}\n} } }\n\nnamespace zinc {\n\nnamespace {\n\nstatic const size_t EMPTY_HASH = std::hash<std::string_view>()({});\n\nfs::path const & config_dir_user()\n{\n    static struct ConfigDirUser\n    {\n        ConfigDirUser()\n        {\n            char const* xdg_config_home = getenv(\"XDG_CONFIG_HOME\");\n            if (xdg_config_home != nullptr) {\n                path = fs::path(xdg_config_home);\n            }\n            if (path.empty()) {\n                char const* home = getenv(\"HOME\");\n                if (home != nullptr) {\n                    path = fs::path(home) / \".config\";\n                }\n            }\n            if (!path.empty()) {\n                path /= \"zinc\";\n            } else {\n                throw std::runtime_error(\"Neither XDG_CONFIG_HOME nor HOME is set.\");\n            }\n        }\n\n        fs::path path;\n    } config_dir_user;\n\n    return config_dir_user.path;\n};\n\nstd::string_view path_helper(fs::path& path, std::span<std::string_view const> subpaths, bool is_dir) {\n    for (const auto& subpath : subpaths) {\n        path /= subpath;\n    }\n    if (is_dir) {\n        fs::create_directories(path);\n        path /= \"\";\n    } else {\n        fs::create_directories(path.parent_path());\n    }\n    return path.native();\n}\n\n/*\n// Helper to convert Git-style [section \"subsection\"] to Boost Property Tree path\nstd::string git_to_ptree_path(std::span<std::string_view const> locator) {\n    std::string path;\n    for (const auto& part : locator) {\n        if (!path.empty()) {\n            path += \".\";\n        }\n        path += part;\n    }\n    return path;\n}\n*/\n\nclass ConfigurationImpl {\npublic:\n    ConfigurationImpl(std::span<std::string_view const> subpath, bool user_wide)\n    : ptreep_(std::string(user_wide ? Configuration::path_user(subpath) : Configuration::path_local(subpath)), {})\n    {\n        if (!user_wide) {\n            auto path_user = Configuration::path_user(subpath);\n            if (fs::exists(path_user)) {\n                dflts_.emplace_back(std::string(path_user), decltype(ptreep_.second)());\n                boost::property_tree::ini_parser::read_ini(dflts_[0].first, dflts_[0].second);\n            }\n        }\n        if (fs::exists(ptreep_.first)) {\n            boost::property_tree::ini_parser::read_ini(ptreep_.first, ptreep_.second);\n        }\n    }\n\n    ~ConfigurationImpl() {\n        bool changed = false;\n        bool possibly_returned_to_normal;\n        do {\n            possibly_returned_to_normal = true;\n            for (auto it = accessed_.begin(); it != accessed_.end();) {\n                auto & [pt, hash] = *it;\n                if (std::hash<std::string_view>()(pt->data()) != hash) {\n                    changed = true;\n                    it = accessed_.erase(it);\n                } else {\n                    if (pt->empty()) {\n                        it = accessed_.erase(it);\n                        possibly_returned_to_normal = false;\n                    }\n                }\n            }\n        } while (!possibly_returned_to_normal);\n        assert(possibly_returned_to_normal == true);\n        assert(accessed_.empty() || changed); // things should only dangle if they have dangling children or are changed; so recursively the former implies the latter\n        if (changed) {\n            boost::property_tree::ini_parser::write_ini(ptreep_.first, ptreep_.second);\n        }\n    }\n\n    std::string& operator[](std::span<std::string_view const> locator) {\n        auto & value = get_value(locator);\n        auto it = accessed_.find(&value);\n        if (accessed_.end() == it) {\n            // note: the approach does not yet use defaults if a section is also a value\n            // because the creating walk prevents the found flag from falling later in middle sections, in multiple calls to the get() functions\n            accessed_[&value] = std::hash<std::string_view>()(value.data());\n        }\n\n        return value.data();\n    }\n\n    zinc::generator<std::string_view> sections(std::span<std::string_view const> locator) {\n        if (locator.size() == 1) {\n            static thread_local boost::iostreams::stream<boost::iostreams::array_source> iss;\n            static std::string subsection;\n            for (auto & [key, pt] : get_below({})) {\n                if (\n                        key.starts_with(locator[0]) &&\n                        key.size() >= locator.size() + 3 &&\n                        std::string_view(key.begin() + (ssize_t)locator.size(), key.begin() + (ssize_t)locator.size() + 2) == \" \\\"\" &&\n                        key[key.size() - 1] == '\"'\n                ) {\n                    iss.open(&*key.begin() + (ssize_t)(locator.size()) + 1, &*key.end());\n                    iss >> std::quoted(subsection);\n                    co_yield subsection;\n                }\n            }\n        } else {\n            for (auto & [key, pt] : get_below(locator)) {\n                if (pt.size()) {\n                    co_yield key;\n                }\n            }\n        }\n    }\n\n    zinc::generator<StringViewPair> values(std::span<std::string_view const> locator) {\n        for (auto & [key, pt] : get_below(locator)) {\n            if (!pt.data().empty()) {\n                co_yield {key, pt.data()};\n            }\n        }\n    }\n\nprivate:\n    boost::property_tree::ptree & get_value(std::span<std::string_view const> locator) {\n        bool found;\n        auto * value = get(ptreep_, locator, false, true, found);\n        if (!found) {\n            bool dflt_found = false;\n            auto * dflt = value;\n            for (auto it = dflts_.begin(); !dflt_found && it != dflts_.end(); ++ it) {\n                dflt = get(*it, locator, false, false, dflt_found);\n            }\n            if (dflt_found) {\n                value->data() = dflt->data();\n            }\n        }\n        return *value;\n    }\n    zinc::generator<boost::property_tree::ptree::value_type&> get_below(std::span<std::string_view const> locator) {\n        bool found;\n        auto * value = get(ptreep_, locator, true, false, found);\n        std::unordered_set<size_t> found_keys;\n        if (found) {\n            for (auto & val : *value) {\n                co_yield val;\n                found_keys.insert(std::hash<std::string_view>()(val.first));\n            }\n        }\n        for (auto & dflt : dflts_) {\n            value = get(dflt, locator, true, false, found);\n            if (found) {\n                for (auto & val : *value) {\n                    auto [_, inserted] = found_keys.insert(std::hash<std::string_view>()(val.first));\n                    if (inserted) {\n                        co_yield val;\n                    }\n                }\n            }\n        }\n    }\n    boost::property_tree::ptree * get(boost::property_tree::ptree::value_type & ptp, std::span<std::string_view const> locator, bool is_section, bool create, bool & found) {\n        if (locator.empty()) {\n            found = true;\n            return &ptp.second;\n        }\n        static thread_local std::stringstream ss;\n        static thread_local std::string fragment; // because ptree uses std::string for find()\n        if (locator.size() >= (is_section ? 2 : 3)) {\n            ss.clear();\n            ss << locator[0];\n            ss << ' ' << std::quoted(locator[1]);\n            fragment = ss.view();\n            locator = {locator.begin() + 2, locator.end()};\n        } else {\n            fragment = locator[0];\n            locator = {locator.begin() + 1, locator.end()};\n        }\n        auto* key_pt = &ptp;\n        auto pt_it = key_pt->second.find(fragment);\n        auto fragment_it = locator.begin();\n        while(true) {\n            if (pt_it == key_pt->second.not_found()) {\n                found = false;\n                if (create) {\n                    break;\n                } else {\n                    return nullptr;\n                }\n            } else {\n                found = true;\n            }\n            key_pt = &*pt_it;\n            if (locator.end() == fragment_it) {\n                break;\n            }\n            fragment = *fragment_it;\n            pt_it = key_pt->second.find(fragment);\n            ++ fragment_it;\n        }\n        if (false == found) {\n            assert(create);\n            std::lock_guard<std::mutex> lk(mtx);\n            while (true) {\n                key_pt = &*key_pt->second.push_back(std::make_pair(fragment, boost::property_tree::ptree()));\n\n                if (locator.end() == fragment_it) {\n                    break;\n                }\n                fragment = *fragment_it;\n                ++ fragment_it;\n            }\n        }\n        fragment.clear();\n        return &key_pt->second;\n    }\n\n    //boost::property_tree::ptree& ptree_() { return ptreep_.second };\n\n    boost::property_tree::ptree::value_type ptreep_;\n    std::vector<boost::property_tree::ptree::value_type> dflts_;\n    //std::vector<boost::property_tree::ptree::value_type*> chks_paths_;\n    //std::unordered_map<boost::property_tree::ptree*node, std::pair<size_t, size_t>> chks_;\n    std::mutex mtx;\n    std::unordered_map<boost::property_tree::ptree*, size_t> accessed_;\n        /*\n         * the idea is to store every created path with a hash of its value.\n         * on destruction, all paths are iterated, and ones that both match their hash and are empty are removed.\n         * the iteration is repeated (walking upward) until all empty ones are removed.\n         */\n};\n\n} // namespace\n\nbool Configuration::init() {\n    try {\n        path_local();\n    } catch (std::invalid_argument const& e) {\n        fs::create_directory(\".zinc\");\n        return true;\n    }\n    return false;\n}\n\nConfiguration::Configuration(std::span<std::string_view const> subpath, bool user_wide)\n    : impl_(reinterpret_cast<void*>(new ConfigurationImpl(subpath, user_wide))) {}\n\nConfiguration::~Configuration() {\n    delete reinterpret_cast<ConfigurationImpl*>(impl_);\n}\n\nstd::string& Configuration::operator[](std::span<std::string_view const> locator) {\n    return (*reinterpret_cast<ConfigurationImpl*>(impl_))[locator];\n}\n\nzinc::generator<std::string_view> Configuration::sections(std::span<std::string_view const> locator) {\n    return reinterpret_cast<ConfigurationImpl*>(impl_)->sections(locator);\n}\n\nzinc::generator<StringViewPair> Configuration::values(std::span<std::string_view const> locator) {\n    return reinterpret_cast<ConfigurationImpl*>(impl_)->values(locator);\n}\n\nstd::string_view Configuration::path_local(std::span<std::string_view const> subpaths, bool is_dir) {\n    // just looked at this briefly, if this were managed with static lifetime as a local class the check and mutex could be avoided\n    static fs::path config_dir_local;\n\n    {\n        static std::mutex mtx;\n        std::lock_guard<std::mutex> lock(mtx);\n\n        if (config_dir_local.empty()) {\n            fs::path zinc_dir;\n            for (\n                fs::path path = fs::current_path(), parent_path = path.parent_path();\n                !path.empty() && path != parent_path;\n                path = parent_path, parent_path = path.parent_path()\n            ) {\n                zinc_dir = path / \".zinc\";\n                if (zinc_dir == config_dir_user()) {\n                    break;\n                }\n                if (fs::exists(zinc_dir)) {\n                    config_dir_local = zinc_dir;\n                    break;\n                }\n            }\n            if (config_dir_local.empty()) {\n                throw std::invalid_argument(\"Could not find .zinc directory for project. Create one.\");\n            }\n        }\n    }\n\n    static thread_local fs::path path;\n    path = config_dir_local;\n    return path_helper(path, subpaths, is_dir);\n}\n\nstd::string_view Configuration::path_user(std::span<std::string_view const> subpaths, bool is_dir) {\n    static thread_local fs::path path;\n    path = config_dir_user();\n    return path_helper(path, subpaths, is_dir);\n}\n\n} // namespace zinc\n\n```\n","ts":1.739632703199E9}
