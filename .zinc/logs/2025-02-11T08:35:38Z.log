{"role":"user","content":"[1] [2] Make a call graph depicting this failure.\n\n1: **build/log.txt**\n```\nThe following will be replaced:\n- $(<pathname) will read a file\n- $(commands) will capture output from commands\n- `commands` is the same as $(commands)\n- http://url will fetch a url\n- https://url will also fetch a url\nPresently no escaping is processed, so be careful not to end commands early.\n\n\nuser: \nassistant: =================================================================\n==102008==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x50c00005a9c0 at pc 0x7f9038528e29 bp 0x7ffc3823bb80 sp 0x7ffc3823bb78\nREAD of size 1 at 0x50c00005a9c0 thread T0\n    #0 0x7f9038528e28 in std::variant<decltype(nullptr), bool, long, double, std::basic_string_view<char, std::char_traits<char> >, std::span<zinc::JSON, 18446744073709551615ul>, std::span<std::pair<std::basic_string_view<char, std::char_traits<char> >, zinc::JSON>, 18446744073709551615ul> >::index() const /usr/include/c++/12/variant:1598\n    #1 0x7f903852f511 in std::add_pointer<std::variant_alternative<5ul, std::variant<decltype(nullptr), bool, long, double, std::basic_string_view<char, std::char_traits<char> >, std::span<zinc::JSON, 18446744073709551615ul>, std::span<std::pair<std::basic_string_view<char, std::char_traits<char> >, zinc::JSON>, 18446744073709551615ul> > >::type const>::type std::get_if<5ul, decltype(nullptr), bool, long, double, std::basic_string_view<char, std::char_traits<char> >, std::span<zinc::JSON, 18446744073709551615ul>, std::span<std::pair<std::basic_string_view<char, std::char_traits<char> >, zinc::JSON>, 18446744073709551615ul> >(std::variant<decltype(nullptr), bool, long, double, std::basic_string_view<char, std::char_traits<char> >, std::span<zinc::JSON, 18446744073709551615ul>, std::span<std::pair<std::basic_string_view<char, std::char_traits<char> >, zinc::JSON>, 18446744073709551615ul> > const*) /usr/include/c++/12/variant:1185\n    #2 0x7f9038521240 in std::add_pointer<std::span<zinc::JSON, 18446744073709551615ul> const>::type std::get_if<std::span<zinc::JSON, 18446744073709551615ul>, decltype(nullptr), bool, long, double, std::basic_string_view<char, std::char_traits<char> >, std::span<zinc::JSON, 18446744073709551615ul>, std::span<std::pair<std::basic_string_view<char, std::char_traits<char> >, zinc::JSON>, 18446744073709551615ul> >(std::variant<decltype(nullptr), bool, long, double, std::basic_string_view<char, std::char_traits<char> >, std::span<zinc::JSON, 18446744073709551615ul>, std::span<std::pair<std::basic_string_view<char, std::char_traits<char> >, zinc::JSON>, 18446744073709551615ul> > const*) /usr/include/c++/12/variant:1209\n    #3 0x7f90384903c7 in dbg_walk /home/karl3/projects/zinc/src/json_boost.cpp:29\n    #4 0x7f903849d31c in store_json /home/karl3/projects/zinc/src/json_boost.cpp:259\n    #5 0x7f903849fde5 in on_object_end /home/karl3/projects/zinc/src/json_boost.cpp:324\n    #6 0x7f90384d4e6e in parse_object<true, false> /usr/include/boost/json/basic_parser_impl.hpp:1854\n    #7 0x7f90384b6bd5 in parse_value<true, false> /usr/include/boost/json/basic_parser_impl.hpp:609\n    #8 0x7f90384d45be in parse_object<true, false> /usr/include/boost/json/basic_parser_impl.hpp:1805\n    #9 0x7f90384b6bd5 in parse_value<true, false> /usr/include/boost/json/basic_parser_impl.hpp:609\n    #10 0x7f90384d2aba in parse_array<true, false> /usr/include/boost/json/basic_parser_impl.hpp:1936\n    #11 0x7f90384b6b7e in parse_value<true, false> /usr/include/boost/json/basic_parser_impl.hpp:607\n    #12 0x7f90384d45be in parse_object<true, false> /usr/include/boost/json/basic_parser_impl.hpp:1805\n    #13 0x7f90384b6bd5 in parse_value<true, false> /usr/include/boost/json/basic_parser_impl.hpp:609\n    #14 0x7f90384b1b90 in parse_document<true> /usr/include/boost/json/basic_parser_impl.hpp:520\n    #15 0x7f90384aea3f in write_some /usr/include/boost/json/basic_parser_impl.hpp:2728\n    #16 0x7f90384a9710 in write_some /usr/include/boost/json/basic_parser_impl.hpp:2784\n    #17 0x7f90384a2be3 in zinc::JSON::decode(std::basic_string_view<char, std::char_traits<char> >) /home/karl3/projects/zinc/src/json_boost.cpp:694\n    #18 0x7f903857bde1 in process_response_lines /home/karl3/projects/zinc/src/openai.cpp:49\n    #19 0x7f903857a87e in process_response_lines /home/karl3/projects/zinc/src/openai.cpp:35\n    #20 0x7f903858af0f in chat /home/karl3/projects/zinc/src/openai.cpp:243\n    #21 0x7f9038586e1a in zinc::OpenAI::chat(std::span<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > const, 18446744073709551615ul>, std::span<std::pair<std::basic_string_view<char, std::char_traits<char> >, zinc::JSON> const, 18446744073709551615ul>) const /home/karl3/projects/zinc/src/openai.cpp:202\n    #22 0x55d87a7f24d5 in main /home/karl3/projects/zinc/cli/chatabout.cpp:180\n    #23 0x7f9036a33d67 in __libc_start_call_main ../sysdeps/nptl/libc_start_call_main.h:58\n    #24 0x7f9036a33e24 in __libc_start_main_impl ../csu/libc-start.c:360\n    #25 0x55d87a7ec5d0 in _start (/home/karl3/projects/zinc/build/chatabout+0x325d0) (BuildId: 24bcd8e227c4a4f495e19caf206978496c65ff1d)\n\n0x50c00005a9c0 is located 0 bytes after 128-byte region [0x50c00005a940,0x50c00005a9c0)\nfreed by thread T0 here:\n    #0 0x7f90390f6698 in operator delete(void*, unsigned long) ../../../../src/libsanitizer/asan/asan_new_delete.cpp:164\n    #1 0x7f90385597e0 in boost::container::new_allocator<char>::deallocate(char*, unsigned long) /usr/include/boost/container/new_allocator.hpp:169\n    #2 0x7f903854010b in boost::container::allocator_traits<boost::container::new_allocator<char> >::deallocate(boost::container::new_allocator<char>&, char*, unsigned long) /usr/include/boost/container/allocator_traits.hpp:308\n    #3 0x7f903854010b in boost::container::devector<char, void, void>::deallocate_buffer() /usr/include/boost/container/devector.hpp:2231\n    #4 0x7f9038548468 in char* boost::container::devector<char, void, void>::insert_range_slow_path<boost::container::dtl::insert_range_proxy<boost::container::new_allocator<char>, char*> >(char const*, unsigned long, boost::container::dtl::insert_range_proxy<boost::container::new_allocator<char>, char*>) /usr/include/boost/container/devector.hpp:2697\n    #5 0x7f903853771f in char* boost::container::devector<char, void, void>::insert_range<char*>(char const*, char*, char*) /usr/include/boost/container/devector.hpp:2645\n    #6 0x7f903849d2cf in char* boost::container::devector<char, void, void>::insert<char*>(char const*, char*, char*, boost::move_detail::disable_if_or<void, boost::move_detail::is_convertible<char*, unsigned long>, boost::container::dtl::is_input_iterator<char*, boost::container::dtl::has_iterator_category<char*>::value>, boost::move_detail::bool_<false>, boost::move_detail::bool_<false> >::type*) /usr/include/boost/container/devector.hpp:1944\n    #7 0x7f903849d2cf in store_json /home/karl3/projects/zinc/src/json_boost.cpp:256\n    #8 0x7f903849fde5 in on_object_end /home/karl3/projects/zinc/src/json_boost.cpp:324\n    #9 0x7f90384d4e6e in parse_object<true, false> /usr/include/boost/json/basic_parser_impl.hpp:1854\n    #10 0x7f90384b6bd5 in parse_value<true, false> /usr/include/boost/json/basic_parser_impl.hpp:609\n    #11 0x7f90384d45be in parse_object<true, false> /usr/include/boost/json/basic_parser_impl.hpp:1805\n    #12 0x7f90384b6bd5 in parse_value<true, false> /usr/include/boost/json/basic_parser_impl.hpp:609\n    #13 0x7f90384d2aba in parse_array<true, false> /usr/include/boost/json/basic_parser_impl.hpp:1936\n    #14 0x7f90384b6b7e in parse_value<true, false> /usr/include/boost/json/basic_parser_impl.hpp:607\n    #15 0x7f90384d45be in parse_object<true, false> /usr/include/boost/json/basic_parser_impl.hpp:1805\n    #16 0x7f90384b6bd5 in parse_value<true, false> /usr/include/boost/json/basic_parser_impl.hpp:609\n    #17 0x7f90384b1b90 in parse_document<true> /usr/include/boost/json/basic_parser_impl.hpp:520\n    #18 0x7f90384aea3f in write_some /usr/include/boost/json/basic_parser_impl.hpp:2728\n    #19 0x7f90384a9710 in write_some /usr/include/boost/json/basic_parser_impl.hpp:2784\n    #20 0x7f90384a2be3 in zinc::JSON::decode(std::basic_string_view<char, std::char_traits<char> >) /home/karl3/projects/zinc/src/json_boost.cpp:694\n    #21 0x7f903857bde1 in process_response_lines /home/karl3/projects/zinc/src/openai.cpp:49\n    #22 0x7f903857a87e in process_response_lines /home/karl3/projects/zinc/src/openai.cpp:35\n    #23 0x7f903858af0f in chat /home/karl3/projects/zinc/src/openai.cpp:243\n    #24 0x7f9038586e1a in zinc::OpenAI::chat(std::span<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > const, 18446744073709551615ul>, std::span<std::pair<std::basic_string_view<char, std::char_traits<char> >, zinc::JSON> const, 18446744073709551615ul>) const /home/karl3/projects/zinc/src/openai.cpp:202\n    #25 0x55d87a7f24d5 in main /home/karl3/projects/zinc/cli/chatabout.cpp:180\n    #26 0x7f9036a33d67 in __libc_start_call_main ../sysdeps/nptl/libc_start_call_main.h:58\n\npreviously allocated by thread T0 here:\n    #0 0x7f90390f5798 in operator new(unsigned long) ../../../../src/libsanitizer/asan/asan_new_delete.cpp:95\n    #1 0x7f9038566bff in boost::container::new_allocator<char>::allocate(unsigned long) /usr/include/boost/container/new_allocator.hpp:160\n    #2 0x7f903854da4b in boost::container::allocator_traits<boost::container::new_allocator<char> >::allocate(boost::container::new_allocator<char>&, unsigned long) /usr/include/boost/container/allocator_traits.hpp:302\n    #3 0x7f903854da4b in boost::container::devector<char, void, void>::impl::do_allocate(boost::container::new_allocator<char>&, unsigned long) /usr/include/boost/container/devector.hpp:2818\n    #4 0x7f903853f958 in boost::container::devector<char, void, void>::allocate(unsigned long) /usr/include/boost/container/devector.hpp:2212\n    #5 0x7f9038530f38 in boost::container::devector<char, void, void>::reallocate_at(unsigned long, unsigned long) /usr/include/boost/container/devector.hpp:2570\n    #6 0x7f9038499b04 in boost::container::devector<char, void, void>::reserve_back(unsigned long) /usr/include/boost/container/devector.hpp:1264\n    #7 0x7f9038499b04 in reserve /home/karl3/projects/zinc/src/json_boost.cpp:195\n    #8 0x7f903849d58e in store_doc /home/karl3/projects/zinc/src/json_boost.cpp:271\n    #9 0x7f903849eb43 in on_document_begin /home/karl3/projects/zinc/src/json_boost.cpp:291\n    #10 0x7f90384ae810 in write_some /usr/include/boost/json/basic_parser_impl.hpp:2722\n    #11 0x7f90384a9710 in write_some /usr/include/boost/json/basic_parser_impl.hpp:2784\n    #12 0x7f90384a2be3 in zinc::JSON::decode(std::basic_string_view<char, std::char_traits<char> >) /home/karl3/projects/zinc/src/json_boost.cpp:694\n    #13 0x7f903857bde1 in process_response_lines /home/karl3/projects/zinc/src/openai.cpp:49\n    #14 0x7f903857a87e in process_response_lines /home/karl3/projects/zinc/src/openai.cpp:35\n    #15 0x7f903858af0f in chat /home/karl3/projects/zinc/src/openai.cpp:243\n    #16 0x7f9038586e1a in zinc::OpenAI::chat(std::span<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > const, 18446744073709551615ul>, std::span<std::pair<std::basic_string_view<char, std::char_traits<char> >, zinc::JSON> const, 18446744073709551615ul>) const /home/karl3/projects/zinc/src/openai.cpp:202\n    #17 0x55d87a7f24d5 in main /home/karl3/projects/zinc/cli/chatabout.cpp:180\n    #18 0x7f9036a33d67 in __libc_start_call_main ../sysdeps/nptl/libc_start_call_main.h:58\n\nSUMMARY: AddressSanitizer: heap-buffer-overflow /usr/include/c++/12/variant:1598 in std::variant<decltype(nullptr), bool, long, double, std::basic_string_view<char, std::char_traits<char> >, std::span<zinc::JSON, 18446744073709551615ul>, std::span<std::pair<std::basic_string_view<char, std::char_traits<char> >, zinc::JSON>, 18446744073709551615ul> >::index() const\nShadow bytes around the buggy address:\n  0x50c00005a700: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 01\n  0x50c00005a780: fa fa fa fa fa fa fa fa 00 00 00 00 00 00 00 00\n  0x50c00005a800: 00 00 00 00 00 00 00 fa fa fa fa fa fa fa fa fa\n  0x50c00005a880: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x50c00005a900: fa fa fa fa fa fa fa fa fd fd fd fd fd fd fd fd\n=>0x50c00005a980: fd fd fd fd fd fd fd fd[fa]fa fa fa fa fa fa fa\n  0x50c00005aa00: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x50c00005aa80: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x50c00005ab00: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x50c00005ab80: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x50c00005ac00: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n==102008==ABORTING\n\n```\n\n2: **src/json_boost.cpp**\n```\n#include <zinc/json.hpp>\n\n#include <boost/container/devector.hpp>\n#include <boost/json/basic_parser_impl.hpp>\n#define enum public: enum // make serializer public in boost 1.81.0\n#include <boost/json/serializer.hpp>\n#undef enum\n#include <boost/json/impl/serializer.ipp>\n\n#include <map>\n#include <memory>\n//#include <iostream> /*dbg*/\n\nusing namespace boost::json;\n\nnamespace zinc {\n\nnamespace {\n\nstruct ParseHandler\n{\n    static constexpr std::size_t max_object_size = (size_t)-1;\n    static constexpr std::size_t max_array_size = (size_t)-1;\n    static constexpr std::size_t max_key_size = (size_t)-1;\n    static constexpr std::size_t max_string_size = (size_t)-1;\n\n    ///*\n    void dbg_walk(JSON const*json, int depth=0) {\n        if (auto*array = std::get_if<std::span<JSON>>(json)) {\n            //if(depth==0)std::cerr << \"array \"; /*dbg*/\n            assert((void*)&*array->begin() >= (void*)store.begin() && (void*)&*array->end() <= (void*)store.end() && array->end() >= array->begin());\n            for (auto & elem : *array) {\n                dbg_walk(&elem, depth+1);\n            }\n        } else if(auto*dict = std::get_if<std::span<KeyJSONPair>>(json)) {\n            //if(depth==0)std::cerr << \"dict \"; /*dbg*/\n            assert((void*)&*dict->begin() >= (void*)&*store.begin() && (void*)&*dict->end() <= (void*)&*store.end() && dict->end() >= dict->begin());\n            for (auto & [k,v] : *dict) {\n                assert(k.begin() >= (void*)&*store.begin() && (void*)&*k.end() <= (void*)&*store.end() && k.end() >= k.begin());\n                static std::string string(k);\n                dbg_walk(&v, depth+1);\n            }\n        } else if(auto*str = std::get_if<std::string_view>(json)) {\n            assert((void*)&*str->begin() >= (void*)&*store.begin() && (void*)&*str->end() <= (void*)&*store.end() && str->end() >= str->begin());\n            //if(depth==0)std::cerr << \"\\\"\" << *str << \"\\\" \"; /*dbg*/\n            static std::string string(*str);\n        }\n    }\n    //*/\n\n    struct DocImpl : public zinc::JSON {\n        DocImpl(\n            JSON root, ParseHandler* handler,\n            char* store_start, char* store_end,\n            JSON** ptrs_start, JSON** ptrs_end\n        ) : JSON(root), handler(handler),\n            store_start(store_start), store_end(store_end),\n            ptrs_start(ptrs_start), ptrs_end(ptrs_end)\n        { }\n        ParseHandler * handler;\n        char* store_start;\n        char* store_end;\n        JSON** ptrs_start;\n        JSON** ptrs_end;\n    };\n    DocImpl* docimpl;\n\n    std::vector<JSON> stack;\n    boost::container::devector<char> store;\n    boost::container::devector<JSON*> ptr_jsons;\n    boost::container::devector<DocImpl*> docs;\n\n    JSON* get() {\n        auto ptr = docimpl;\n        docimpl = nullptr;\n        return ptr;\n    }\n    void abort() {\n        assert(docs.back() == docimpl);\n        store.erase(docimpl->store_start, store.end());\n        ptr_jsons.erase(docimpl->ptrs_start, ptr_jsons.end());\n        docs.pop_back();\n        docimpl = nullptr;\n    }\n    void del(DocImpl& doc) {\n        assert((store.end() == doc.store_end || store.begin() == doc.store_start) && \"deallocate jsons in forward or reverse order\");\n        assert((ptr_jsons.end() == doc.ptrs_end || ptr_jsons.begin() == doc.ptrs_start) && \"deallocate jsons in forward or reverse order\");\n        decltype(docs)::iterator doc_it;\n        if (docs.back() == &doc) {\n            doc_it = docs.end() - 1;\n        } else if (docs.front() == &doc) {\n            doc_it = docs.begin();\n        } else {\n            assert(!\"deallocate jsons in forward or reverse order\");\n        }\n        assert(doc.store_start >= store.begin() && doc.store_end <= store.end());\n        assert(doc.store_start <= doc.store_end);\n        assert(doc.ptrs_start >= ptr_jsons.begin() && doc.ptrs_end <= ptr_jsons.end());\n        assert(doc.ptrs_start <= doc.ptrs_end);\n        store.erase(doc.store_start, doc.store_end);\n        ptr_jsons.erase(doc.ptrs_start, doc.ptrs_end);\n        docs.erase(doc_it);\n    }\n    static void del(JSON* doc_) {\n        DocImpl & doc = *(DocImpl*)doc_;\n        doc.handler->del(doc);\n    }\n\n    inline void adjust_store_json_ptrs(JSON*json, ptrdiff_t store_offset)\n    {\n        if (auto span = std::get_if<std::span<JSON>>(json)) {\n            *span = {\n                (JSON*)((char*)span->data() + store_offset),\n                span->size()\n            };\n        } else if (auto span = std::get_if<std::span<KeyJSONPair>>(json)) {\n            *span = {\n                (KeyJSONPair*)((char*)span->data() + store_offset),\n                span->size()\n            };\n            for (auto & [k,_] : *span) {\n                k = {\n                    k.data() + store_offset,\n                    k.size()\n                };\n            }\n        } else if (auto sv = std::get_if<std::string_view>(json)) {\n            *sv = {\n                sv->data() + store_offset,\n                sv->size()\n            };\n            static std::string dbgstr;\n            dbgstr = std::get<std::string_view>(*json);\n        } else {\n            throw std::logic_error(\"non-pointer json in ptr_jsons\");\n        }\n    }\n    inline void adjust_store_pointers(ptrdiff_t store_offset)\n    {\n        if (!store_offset) {\n            return;\n        }\n        for (JSON & json : stack) {\n            if (json_is_ptr(json, store_offset)) {\n                adjust_store_json_ptrs(&json, store_offset);\n            }\n        }\n        for (JSON *& json : ptr_jsons) {\n            json = (JSON*)((char*)json + store_offset);\n            adjust_store_json_ptrs(json, store_offset);\n        }   \n        for (DocImpl*& doc : docs) {\n            doc = (DocImpl*)((char*)doc + store_offset);\n            assert(doc->handler == this);\n            doc->store_start += store_offset;\n            doc->store_end += store_offset;\n            assert(doc->store_start >= store.begin() && doc->store_end <= store.end());\n            assert(doc->store_start <= doc->store_end);\n        }\n        if (docimpl != nullptr) {\n            docimpl = (DocImpl*)((char*)docimpl + store_offset);\n        }\n    }\n\n    inline void adjust_ptr_pointers(ptrdiff_t ptrs_offset)\n    {\n        if (!ptrs_offset) {\n            return;\n        }\n        for (DocImpl*& doc : docs) {\n            assert(doc->handler == this);\n            doc->ptrs_start = (JSON**)((char*)doc->ptrs_start + ptrs_offset);\n            doc->ptrs_end = (JSON**)((char*)doc->ptrs_end + ptrs_offset);\n            assert(doc->ptrs_start >= ptr_jsons.begin() && doc->ptrs_end <= ptr_jsons.end());\n            assert(doc->ptrs_start <= doc->ptrs_end);\n        }\n    }\n\n    inline char* reserve(size_t n, size_t a  = 1) {\n        ///*\n        for (auto &json : stack) {\n            dbg_walk(&json);\n        }\n        //*/\n        size_t avail;\n        void* result;\n        result = std::align(a, n, result = store.end(), avail = store.back_free_capacity()-store.size());\n        if (!result) {\n            n += store.size() + a;\n            size_t new_capacity = std::max(store.size(), 64ul);\n            while (new_capacity < n) {\n                new_capacity *= 2;\n            }\n            char* old = store.data();\n            store.reserve_back(new_capacity);\n            adjust_store_pointers(store.data() - old);\n            ///*\n            for (auto &json : stack) {\n                dbg_walk(&json);\n            }\n            //*/\n            result = std::align(a, n, result = store.end(), avail = store.back_free_capacity()-store.size());\n        }\n        return (char*)result;\n    }\n    inline char* store_chars(std::string_view chars)\n    {\n        reserve(chars.size());\n        store.insert(store.end(), chars.begin(), chars.end());\n        return store.end() - chars.size();\n    }\n    inline std::string_view& store_key(std::string_view key)\n    {\n        //auto seat = (std::string_view*)reserve(sizeof(key));\n        auto dbgcmp1 = store.end(); /* checking reserve is a no-op because key is only used in contiguous spans of pairs */\n        auto dbgcmp2 = store.insert(reserve(sizeof(key), alignof(decltype(key))), (char*)&key, (char*)(&key+1));\n        assert(dbgcmp1 == dbgcmp2);\n        //store.resize_back(store.size() + sizeof(key));\n        //new (seat) std::string_view(key);\n        return *(std::string_view*)(store.end() - sizeof(key));\n    }\n    bool json_is_ptr(JSON const & json, ptrdiff_t store_offset = 0) {\n        if (\n            std::holds_alternative<std::span<JSON>>(json) ||\n            std::holds_alternative<std::span<KeyJSONPair>>(json)\n        ) {\n            return true;\n        } else if (std::string_view const * sv = std::get_if<std::string_view>(&json)) {\n            if (sv->data() >= store.data() - store_offset\n             && sv->data() < &*store.end() - store_offset) {\n                return true;\n            }\n        }\n        return false;\n    }\n    void add_ptr_json(JSON* json)\n    {\n        char* old = (char*)ptr_jsons.data();\n        ptr_jsons.push_back(json);\n        if ((char*)ptr_jsons.data() != old) {\n            adjust_ptr_pointers((char*)ptr_jsons.data() - old);\n        }\n    }\n    inline JSON& store_json(JSON const & json)\n    {\n        bool is_ptr = json_is_ptr(json);\n        ///*\n        dbg_walk(&json);\n        for (auto &json : stack) {\n            dbg_walk(&json);\n        }\n        //*/\n\n        auto seat = (JSON*)reserve(sizeof(JSON), alignof(JSON));\n        dbg_walk(&json);\n        store.insert(store.end(), (char*)&json, (char*)(&json + 1));\n        //store.resize_back(store.size() + sizeof(json));\n        //new (seat) JSON(json);\n        dbg_walk(seat);\n\n        if (is_ptr) {\n            add_ptr_json(seat);\n        }\n\n        return *seat;//store.end();\n    }\n\n    inline DocImpl& store_doc()\n    {\n        assert(nullptr == docimpl);\n        char* storeptr = reserve(sizeof(DocImpl), alignof(DocImpl));\n        JSON** ptrsptr = ptr_jsons.end();\n        docimpl = (DocImpl*)storeptr;\n        docs.push_back(docimpl);\n        store.resize_back(store.size() + sizeof(DocImpl));\n        new (docimpl) DocImpl(\n            nullptr, this,\n            storeptr, storeptr,\n            ptrsptr, ptrsptr\n        );\n        return *docimpl;//store.end();\n    }\n\n    //inline void set_raw(std::string_view raw) {\n    //    JSON & json = stack.back();\n    //    assert(json.raw.empty());\n    //    json.raw = raw;\n    //}\n\n    inline bool on_document_begin(error_code&) {\n        store_doc();\n        return true;\n    }\n    inline bool on_document_end(error_code&) {\n        assert(1 == stack.size());\n        assert(docimpl->handler == this);\n        *(JSON*)docimpl = stack.back();\n        stack.clear();\n        if (json_is_ptr(*docimpl)) {\n            add_ptr_json(docimpl);\n        }\n        docimpl->store_end = store.end();\n        docimpl->ptrs_end = ptr_jsons.end();\n        return true;\n    }\n    inline bool on_object_begin(error_code&) {\n        //std::cerr<< \"ON_OBJECT_BEGIN\" << std::endl; /*dbg*/\n        return true;\n    }\n    inline bool on_object_end(std::size_t n, error_code&) {\n        //std::cerr<< \"ON_OBJECT_END start\" << std::endl; /*dbg*/\n        ///*\n        for (auto &json : stack) {\n            dbg_walk(&json);\n        }\n        //*/\n        auto store_start = (KeyJSONPair*)reserve(sizeof(KeyJSONPair) * n + sizeof(JSON), alignof(KeyJSONPair));\n        auto dbg_store_start = store.begin();\n        auto stack_end = stack.end(), stack_start = stack_end - (ssize_t)n * 2;\n        for (auto it = stack_start; it != stack_end;) {\n            // this shouldn't cause reallocation because reserve was called earlier\n            store_key(std::get<std::string_view>(*it));\n            ++ it;\n            store_json(*it);\n            ++ it;\n        }\n        assert(store.begin() == dbg_store_start);\n        auto store_end = (KeyJSONPair*)&*store.end();\n        assert(store_end == store_start + n);\n        stack.erase(stack_start, stack_end);\n        stack.emplace_back(std::span<KeyJSONPair>(store_start, store_end));\n        //std::cerr<< \"ON_OBJECT_END end\" << std::endl; /*dbg*/\n        return true;\n    }\n    inline bool on_array_begin(error_code&)\n    {\n        return true;\n    }\n    inline bool on_array_end(std::size_t n, error_code&)\n    {\n        auto store_start = (JSON*)reserve(sizeof(JSON) * n + sizeof(JSON), alignof(JSON));\n        auto stack_end = stack.end(), stack_start = stack_end - (ssize_t)n;\n        for (auto it = stack_start; it != stack_end; ++ it) {\n            store_json(*it);\n        }\n        auto store_end = (JSON*)&*store.end();\n        stack.erase(stack_start, stack_end);\n        stack.emplace_back(std::span<JSON>(store_start, store_end));\n        return true;\n    }\n    /*\n     * boost does not forward the original document ranges to on_key* and\n     * on_part*. rather, it puts the data in a buffer on the stack, and hands\n     * pointers that point into this buffer.\n     */\n    inline bool on_key_part(string_view s, std::size_t, error_code&) {\n        store_chars(s);\n        return true;\n    }\n    inline bool on_key(string_view s, std::size_t n, error_code&) {\n        /* if boost::json were adjusted or if the raw pointer offsets were tracked\n         * then the original data could be referenced directly here.\n         * escaping can possibly be checked for with s.size() != n.\n         */\n        store_chars(s);\n        auto end = store.end(), start = end - n;\n        stack.emplace_back(std::string_view{start, end});\n        return true;\n    }\n    inline bool on_string_part(string_view s, std::size_t, error_code&) {\n        store_chars(s);\n        return true;\n    }\n    inline bool on_string(string_view s, std::size_t n, error_code&) {\n        /* if boost::json were adjusted or if the raw pointer offsets were tracked\n         * then the original data could be referenced directly here.\n         * escaping can possibly be checked for with s.size() != n.\n         */\n        store_chars(s);\n        auto end = store.end(), start = end - n;\n        stack.emplace_back(std::string_view{start, end});\n        return true;\n    }\n    inline bool on_number_part(string_view, error_code&)\n    {\n        return true;\n    }\n    inline bool on_int64(std::int64_t i, string_view, error_code&)\n    {\n        stack.emplace_back((long)i);\n        return true;\n    }\n    inline bool on_uint64(std::uint64_t u, string_view, error_code&)\n    {\n        stack.emplace_back((long)u);\n        return true;\n    }\n    inline bool on_double(double d, string_view, error_code&)\n    {\n        stack.emplace_back(d);\n        return true;\n    }\n    inline bool on_bool(bool b, error_code&)\n    {\n        stack.emplace_back(b);\n        return true;\n    }\n    inline bool on_null(error_code&)\n    {\n        stack.emplace_back(nullptr);\n        return true;\n    }\n    inline bool on_comment_part(string_view, error_code&)\n    {\n        return true;\n    }\n    inline bool on_comment(string_view, error_code&)\n    {\n        return true;\n    }\n};\n\nclass Serializer : public boost::json::serializer\n{\n    union\n    {\n        JSON const* pj_;\n        std::span<KeyJSONPair const> const* po_;\n        std::span<JSON const> const* pa_;\n    };\n    JSON const* jj_ = nullptr;\n    boost::json::value boost_value;\npublic:\n\n    bool suspend(\n        state st,\n        std::span<JSON const>::iterator it,\n        std::span<JSON const> const* pa)\n    {\n        st_.push(pa);\n        st_.push(it);\n        st_.push(st);\n        return false;\n    }\n\n    bool suspend(\n        state st,\n        std::span<KeyJSONPair const>::iterator it,\n        std::span<KeyJSONPair const> const* po)\n    {\n        st_.push(po);\n        st_.push(it);\n        st_.push(st);\n        return false;\n    }\n\n    void reset(JSON const* j) noexcept\n    {\n        //pv_ = j;\n        pj_ = j;\n        fn0_ = (fn_t)&Serializer::write_value<true>;\n        fn1_ = (fn_t)&Serializer::write_value<false>;\n\n        jj_ = j;\n        st_.clear();\n        done_ = false;\n    }\n\n    template<bool StackEmpty>\n    bool write_array(stream& ss0)\n    {\n        std::span<JSON const> const* pa;\n        local_stream ss(ss0);\n        std::span<JSON const>::iterator it, end;\n        if(StackEmpty || st_.empty())\n        {\n            pa = pa_;\n            it = pa->begin();\n            end = pa->end();\n        } else {\n            state st;\n            st_.pop(st);\n            st_.pop(it);\n            st_.pop(pa);\n            end = pa->end();\n            switch(st)\n            {\n            default:\n            case state::arr1: goto do_arr1;\n            case state::arr2: goto do_arr2;\n            case state::arr3: goto do_arr3;\n            case state::arr4: goto do_arr4;\n                break;\n            }\n        }\ndo_arr1:\n        if(BOOST_JSON_LIKELY(ss))\n            ss.append('[');\n        else\n            return suspend(\n                state::arr1, it, pa);\n        if(it == end)\n            goto do_arr4;\n        for(;;)\n        {\ndo_arr2:\n            jj_ = &*it;\n            if(! write_value<StackEmpty>(ss))\n                return suspend(\n                    state::arr2, it, pa);\n            if(BOOST_JSON_UNLIKELY(\n                ++it == end))\n                break;\ndo_arr3:\n            if(BOOST_JSON_LIKELY(ss))\n                ss.append(',');\n            else\n                return suspend(\n                    state::arr3, it, pa);\n        }\ndo_arr4:\n        if(BOOST_JSON_LIKELY(ss))\n            ss.append(']');\n        else\n            return suspend(\n                state::arr4, it, pa);\n        return true;\n    }\n\n    template<bool StackEmpty>\n    bool write_object(stream& ss0)\n    {\n        std::span<KeyJSONPair const> const* po;\n        local_stream ss(ss0);\n        std::span<KeyJSONPair const>::iterator it, end;\n        if(StackEmpty || st_.empty())\n        {\n            po = po_;\n            it = po->begin();\n            end = po->end();\n        } else {\n            state st;\n            st_.pop(st);\n            st_.pop(it);\n            st_.pop(po);\n            end = po->end();\n            switch(st)\n            {\n            default:\n            case state::obj1: goto do_obj1;\n            case state::obj2: goto do_obj2;\n            case state::obj3: goto do_obj3;\n            case state::obj4: goto do_obj4;\n            case state::obj5: goto do_obj5;\n            case state::obj6: goto do_obj6;\n                break;\n            }\n        }\ndo_obj1:\n        if(BOOST_JSON_LIKELY(ss))\n            ss.append('{');\n        else\n            return suspend(\n                state::obj1, it, po);\n        if(BOOST_JSON_UNLIKELY(\n            it == end))\n            goto do_obj6;\n        for(;;)\n        {\n            cs0_ = {\n                it->first.data(),\n                it->first.size() };\ndo_obj2:\n            if(BOOST_JSON_UNLIKELY(\n                ! write_string<StackEmpty>(ss)))\n                return suspend(\n                    state::obj2, it, po);\ndo_obj3:\n            if(BOOST_JSON_LIKELY(ss))\n                ss.append(':');\n            else\n                return suspend(\n                    state::obj3, it, po);\ndo_obj4:\n            jj_ = &it->second;\n            if(BOOST_JSON_UNLIKELY(\n                ! write_value<StackEmpty>(ss)))\n                return suspend(\n                    state::obj4, it, po);\n            ++it;\n            if(BOOST_JSON_UNLIKELY(it == end))\n                break;\ndo_obj5:\n            if(BOOST_JSON_UNLIKELY(ss))\n                ss.append(',');\n            else\n                return suspend(\n                    state::obj5, it, po);\n        }\ndo_obj6:\n        if(BOOST_JSON_LIKELY(ss))\n        {\n            ss.append('}');\n            return true;\n        }\n        return suspend(\n            state::obj6, it, po);\n    }\n\n    template<bool StackEmpty>\n    bool write_value(stream& ss)\n    {\n        auto const& jj(*jj_);\n        if (StackEmpty || st_.empty()) {\n            switch(jj.index()) {\n            default:\n            case JSON::OBJECT:\n                po_ = (std::span<KeyJSONPair const>const*)&jj.object();\n                return write_object<true>(ss);\n            case JSON::ARRAY:\n                pa_ = (std::span<JSON const>const*)&jj.array();\n                return write_array<true>(ss);\n            case JSON::STRING:\n            {\n                auto const& js = std::get<std::string_view>(jj);\n                cs0_ = { js.data(), js.size() };\n                return write_string<true>(ss);\n            }\n            case JSON::INTEGER:\n                boost_value = std::get<long>(jj);\n                jv_ = &boost_value;\n                return write_number<true>(ss);\n            case JSON::NUMBER:\n                boost_value = std::get<double>(jj);\n                jv_ = &boost_value;\n                return write_number<true>(ss);\n            case JSON::BOOLEAN:\n                if (std::get<bool>(jj)) {\n                    if(BOOST_JSON_LIKELY(\n                        ss.remain() >= 4))\n                    {\n                        ss.append(\"true\", 4);\n                        return true;\n                    }\n                    return write_true<true>(ss);\n                } else {\n                    if(BOOST_JSON_LIKELY(\n                        ss.remain() >= 5))\n                    {\n                        ss.append(\"false\", 5);\n                        return true;\n                    }\n                    return write_false<true>(ss);\n                }\n            case (JSON::Index)NULL:\n                if(BOOST_JSON_LIKELY(\n                    ss.remain() >= 4))\n                {\n                    ss.append(\"null\", 4);\n                    return true;\n                }\n                return write_null<true>(ss);\n            }\n        } else {\n            state st;\n            st_.peek(st);\n            switch(st)\n            {\n            default:\n                return serializer::write_value<StackEmpty>(ss);\n\n            case state::arr1: case state::arr2:\n            case state::arr3: case state::arr4:\n                return write_array<StackEmpty>(ss);\n\n            case state::obj1: case state::obj2:\n            case state::obj3: case state::obj4:\n            case state::obj5: case state::obj6:\n                return write_object<StackEmpty>(ss);\n            }\n        }\n    }\n};\n\nthread_local boost::json::basic_parser<ParseHandler> parser({});\n\n}\n\nJSON::Doc JSON::decode(std::string_view text)\n{\n    std::error_code ec;\n    parser.reset();\n    try {\n        /*size_t parsed_size = */parser.write_some(false, text.data(), text.size(), ec);\n        if (ec) { throw std::system_error(ec); }\n    } catch(...) {\n        parser.handler().abort();\n        throw;\n    }\n    return parser.handler().get();\n}\n\nstd::string_view JSON::encode() const\n{\n    static thread_local Serializer serializer;\n    static thread_local std::string storage;\n    serializer.reset(this);\n    storage.clear();\n    while (!serializer.done()) {\n        if (storage.capacity() == storage.size()) {\n            storage.reserve(storage.size() * 2);\n        }\n        storage += serializer.read(&*storage.end(), storage.capacity() - storage.size());\n    }\n    return storage;\n}\n\nstd::partial_ordering JSON::operator<=>(JSON const& json) const\n{\n    if (index() != json.index()) {\n        return std::partial_ordering::unordered;\n    }\n    if (auto sv = std::get_if<std::string_view>(this)) {\n        return *sv <=> std::get<std::string_view>(json);\n    } else if (auto d = std::get_if<double>(this)) {\n        return *d <=> std::get<double>(json);\n    } else if (auto l = std::get_if<long>(this)) {\n        return *l <=> std::get<long>(json);\n    } else if (auto b = std::get_if<bool>(this)) {\n        return *b <=> std::get<bool>(json);\n    } else if (auto span = std::get_if<std::span<JSON>>(this)) {\n        auto &lhs = *span;\n        auto &rhs = std::get<std::span<JSON>>(json);\n        std::partial_ordering cmp = std::partial_ordering::equivalent;\n        for (size_t idx = 0; 0 == cmp && lhs.size() > idx; ++ idx) {\n            cmp = lhs[idx] <=> rhs[idx];\n        }\n        return cmp;\n    } else if (auto span = std::get_if<std::span<KeyJSONPair>>(this)) {\n        static thread_local std::map<KeyJSONPair::first_type,KeyJSONPair::second_type> lhs, rhs;\n        auto & rhs_ =std::get<std::span<KeyJSONPair>>(json);\n        lhs.clear(); lhs.insert(span->begin(), span->end());\n        rhs.clear(); rhs.insert(rhs_.begin(), rhs_.end());\n        if (lhs.size() != rhs.size()) {\n            return lhs.size() <=> rhs.size();\n        }\n        std::partial_ordering cmp = std::partial_ordering::equivalent;\n        for (auto lit = lhs.begin(), rit = rhs.begin(); lit != lhs.end() && rit != rhs.end(); ++ lit, ++ rit) {\n            auto & [lk, lv] = *lit;\n            auto & [rk, rv] = *rit;\n            cmp = lk <=> rk; if (cmp != 0) break;\n            cmp = lv <=> rv; if (cmp != 0) break;\n        }\n        return cmp;\n    } else {\n        return std::partial_ordering::equivalent;\n    }\n}\n\nJSON const& JSON::operator[](std::string_view key) const\n{\n    JSON * result = nullptr;\n    for (auto & [k, json] : object()) {\n        if (k == key) {\n            if (result != nullptr) {\n                throw std::out_of_range(\"multiple entries\");\n            }\n            result = &json;\n        }\n    }\n    if (result == nullptr) {\n        throw std::out_of_range(\"not found\");\n    }\n    return *result;\n}\n\nJSON const& JSON::operator[](size_t idx) const\n{\n    return array()[idx];\n}\n\nJSON::Doc::Doc(JSON*root)\n: root_(root)\n{ }\n\nJSON::Doc::Doc(Doc&&doc)\n: root_(doc.root_)\n{\n    doc.root_ = nullptr;\n}\n\nJSON::Doc::~Doc()\n{\n    if (root_) {\n        ParseHandler::del(root_);\n    }\n}\n\n}\n\n```\n","ts":1.739280954735E9}
