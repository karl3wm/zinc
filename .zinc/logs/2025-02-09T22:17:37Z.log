{"role":"user","content":"[1] [2] [3] Can you review logical consistency around adjust_store_pointers()? I'm getting part of my json tree referencing old values outside store somehow.\n\n1: **../src/json_boost.cpp**\n```\n#include <zinc/json.hpp>\n\n#include <boost/container/devector.hpp>\n#include <boost/json/basic_parser_impl.hpp>\n#define enum public: enum // make serializer public in boost 1.81.0\n#include <boost/json/serializer.hpp>\n#undef enum\n#include <boost/json/impl/serializer.ipp>\n\n#include <map>\n\nusing namespace boost::json;\n\nnamespace zinc {\n\nnamespace {\n\nstruct ParseHandler\n{\n    static constexpr std::size_t max_object_size = (size_t)-1;\n    static constexpr std::size_t max_array_size = (size_t)-1;\n    static constexpr std::size_t max_key_size = (size_t)-1;\n    static constexpr std::size_t max_string_size = (size_t)-1;\n\n    struct DocImpl : public zinc::JSON {\n        DocImpl(\n            JSON root, ParseHandler* handler,\n            char* store_start, char* store_end,\n            JSON** ptrs_start, JSON** ptrs_end\n        ) : JSON(root), handler(handler),\n            store_start(store_start), store_end(store_end),\n            ptrs_start(ptrs_start), ptrs_end(ptrs_end)\n        { }\n        ParseHandler * handler;\n        char* store_start;\n        char* store_end;\n        JSON** ptrs_start;\n        JSON** ptrs_end;\n    };\n    DocImpl* docimpl;\n\n    std::vector<JSON> stack;\n    boost::container::devector<char> store;\n    boost::container::devector<JSON*> ptr_jsons;\n    boost::container::devector<DocImpl*> docs;\n\n    JSON* get() {\n        auto ptr = docimpl;\n        docimpl = nullptr;\n        return ptr;\n    }\n    void abort() {\n        assert(docs.back() == docimpl);\n        store.erase(docimpl->store_start, store.end());\n        ptr_jsons.erase(docimpl->ptrs_start, ptr_jsons.end());\n        docs.pop_back();\n        docimpl = nullptr;\n    }\n    void del(DocImpl& doc) {\n        assert((store.end() == doc.store_end || store.begin() == doc.store_start) && \"deallocate jsons in forward or reverse order\");\n        assert((ptr_jsons.end() == doc.ptrs_end || ptr_jsons.begin() == doc.ptrs_start) && \"deallocate jsons in forward or reverse order\");\n        decltype(docs)::iterator doc_it;\n        if (docs.back() == &doc) {\n            doc_it = docs.end() - 1;\n        } else if (docs.front() == &doc) {\n            doc_it = docs.begin();\n        } else {\n            assert(!\"deallocate jsons in forward or reverse order\");\n        }\n        assert(doc.store_start >= store.begin() && doc.store_end <= store.end());\n        assert(doc.store_start <= doc.store_end);\n        assert(doc.ptrs_start >= ptr_jsons.begin() && doc.ptrs_end <= ptr_jsons.end());\n        assert(doc.ptrs_start <= doc.ptrs_end);\n        store.erase(doc.store_start, doc.store_end);\n        ptr_jsons.erase(doc.ptrs_start, doc.ptrs_end);\n        docs.erase(doc_it);\n    }\n    static void del(JSON* doc_) {\n        DocImpl & doc = *(DocImpl*)doc_;\n        doc.handler->del(doc);\n    }\n\n    inline void adjust_store_pointers(ptrdiff_t store_offset)\n    {\n        if (!store_offset) {\n            return;\n        }\n        for (JSON *& json : ptr_jsons) {\n            json = (JSON*)((char*)json + store_offset);\n            if (auto span = std::get_if<std::span<JSON>>(json)) {\n                *span = {\n                    (JSON*)((char*)span->data() + store_offset),\n                    span->size()\n                };\n            } else if (auto span = std::get_if<std::span<KeyJSONPair>>(json)) {\n                *span = {\n                    (KeyJSONPair*)((char*)span->data() + store_offset),\n                    span->size()\n                };\n            } else if (auto sv = std::get_if<std::string_view>(json)) {\n                *sv = {\n                    sv->data() + store_offset,\n                    sv->size()\n                };\n            } else {\n                throw std::logic_error(\"non-pointer json in ptr_jsons\");\n            }\n        }   \n        for (DocImpl*& doc : docs) {\n            doc = (DocImpl*)((char*)doc + store_offset);\n            assert(doc->handler == this);\n            doc->store_start += store_offset;\n            doc->store_end += store_offset;\n            assert(doc->store_start >= store.begin() && doc->store_end <= store.end());\n            assert(doc->store_start <= doc->store_end);\n        }\n        if (docimpl != nullptr) {\n            docimpl = (DocImpl*)((char*)docimpl + store_offset);\n        }\n    }\n\n    inline void adjust_ptr_pointers(ptrdiff_t ptrs_offset)\n    {\n        if (!ptrs_offset) {\n            return;\n        }\n        for (DocImpl*& doc : docs) {\n            assert(doc->handler == this);\n            doc->ptrs_start = (JSON**)((char*)doc->ptrs_start + ptrs_offset);\n            doc->ptrs_end = (JSON**)((char*)doc->ptrs_end + ptrs_offset);\n            assert(doc->ptrs_start >= ptr_jsons.begin() && doc->ptrs_end <= ptr_jsons.end());\n            assert(doc->ptrs_start <= doc->ptrs_end);\n        }\n    }\n\n    inline char* reserve(size_t n) {\n        if (store.back_free_capacity() < n) {\n            size_t new_capacity = std::max(store.size(), 64ul);\n            while (new_capacity < store.size() + n) {\n                new_capacity *= 2;\n            }\n            char* old = store.data();\n            store.reserve_back(new_capacity);\n            adjust_store_pointers(store.data() - old);\n        }\n        return store.end();\n    }\n    inline char* store_chars(std::string_view chars)\n    {\n        reserve(chars.size());\n        store.insert(store.end(), chars.begin(), chars.end());\n        return store.end();\n    }\n    inline char* store_key(std::string_view key)\n    {\n        //auto seat = (std::string_view*)reserve(sizeof(key));\n        store.insert(reserve(sizeof(key)), (char*)&key, (char*)(&key+1));\n        //store.resize_back(store.size() + sizeof(key));\n        //new (seat) std::string_view(key);\n        return store.end();\n    }\n    bool json_is_ptr(JSON const & json) {\n        if (\n            std::holds_alternative<std::span<JSON>>(json) ||\n            std::holds_alternative<std::span<KeyJSONPair>>(json)\n        ) {\n            return true;\n        } else if (std::string_view const * sv = std::get_if<std::string_view>(&json)) {\n            if (sv->data() >= store.data()\n             && sv->data() < &*store.end()) {\n                return true;\n            }\n        }\n        return false;\n    }\n    void add_ptr_json(JSON* json)\n    {\n        char* old = (char*)ptr_jsons.data();\n        ptr_jsons.push_back(json);\n        if ((char*)ptr_jsons.data() != old) {\n            adjust_ptr_pointers((char*)ptr_jsons.data() - old);\n        }\n    }\n    inline char* store_json(JSON const & json)\n    {\n        bool is_ptr = json_is_ptr(json);\n\n        auto seat = (JSON*)reserve(sizeof(JSON));\n        store.insert(store.end(), (char*)&json, (char*)(&json + 1));\n        //store.resize_back(store.size() + sizeof(json));\n        //new (seat) JSON(json);\n\n        if (is_ptr) {\n            add_ptr_json(seat);\n        }\n\n        return store.end();\n    }\n\n    inline char* store_doc()\n    {\n        assert(nullptr == docimpl);\n        char* storeptr = reserve(sizeof(DocImpl));\n        JSON** ptrsptr = ptr_jsons.end();\n        docimpl = (DocImpl*)storeptr;\n        docs.push_back(docimpl);\n        store.resize_back(store.size() + sizeof(DocImpl));\n        new (docimpl) DocImpl(\n            nullptr, this,\n            storeptr, storeptr,\n            ptrsptr, ptrsptr\n        );\n        return store.end();\n    }\n\n    //inline void set_raw(std::string_view raw) {\n    //    JSON & json = stack.back();\n    //    assert(json.raw.empty());\n    //    json.raw = raw;\n    //}\n\n    inline bool on_document_begin(error_code&) {\n        store_doc();\n        return true;\n    }\n    inline bool on_document_end(error_code&) {\n        assert(1 == stack.size());\n        assert(docimpl->handler == this);\n        *(JSON*)docimpl = stack.back();\n        stack.clear();\n        if (json_is_ptr(*docimpl)) {\n            add_ptr_json(docimpl);\n        }\n        docimpl->store_end = store.end();\n        docimpl->ptrs_end = ptr_jsons.end();\n        return true;\n    }\n    inline bool on_object_begin(error_code&) {\n        return true;\n    }\n    inline bool on_object_end(std::size_t n, error_code&) {\n        auto bot_start = (KeyJSONPair*)reserve(sizeof(KeyJSONPair) * n + sizeof(JSON));\n        auto top_end = stack.end(), top_start = top_end - (ssize_t)n * 2;\n        for (auto json = top_start; json != top_end;) {\n            store_key(std::get<std::string_view>(*json));\n            ++ json;\n            store_json(*json);\n            ++ json;\n        }\n        auto bot_end = (KeyJSONPair*)&*store.end();\n        stack.erase(top_start, top_end);\n        stack.emplace_back(std::span<KeyJSONPair>(bot_start, bot_end));\n        return true;\n    }\n    inline bool on_array_begin(error_code&)\n    {\n        return true;\n    }\n    inline bool on_array_end(std::size_t n, error_code&)\n    {\n        auto bot_start = (JSON*)reserve(sizeof(JSON) * n + sizeof(JSON));\n        auto top_end = stack.end(), top_start = top_end - (ssize_t)n;\n        for (auto json = top_start; json != top_end; ++ json) {\n            store_json(*json);\n        }\n        auto bot_end = (JSON*)&*store.end();\n        stack.erase(top_start, top_end);\n        stack.emplace_back(std::span<JSON>(bot_start, bot_end));\n        return true;\n    }\n    inline bool on_key_part(string_view s, std::size_t, error_code&) {\n        store_chars(s);\n        return true;\n    }\n    inline bool on_key(string_view s, std::size_t n, error_code&) {\n        if (s.size() < n) {\n            store_chars(s);\n            auto end = store.end(), start = end - n;\n            stack.emplace_back(std::string_view{start, end});\n        } else {\n            stack.emplace_back(s);\n        }\n        return true;\n    }\n    inline bool on_string_part(string_view s, std::size_t, error_code&) {\n        store_chars(s);\n        return true;\n    }\n    inline bool on_string(string_view s, std::size_t n, error_code&) {\n        if (s.size() < n) {\n            store_chars(s);\n            auto end = store.end(), start = end - n;\n            stack.emplace_back(std::string_view{start, end});\n        } else {\n            stack.emplace_back(s);\n        }\n        return true;\n    }\n    inline bool on_number_part(string_view, error_code&)\n    {\n        return true;\n    }\n    inline bool on_int64(std::int64_t i, string_view, error_code&)\n    {\n        stack.emplace_back((long)i);\n        return true;\n    }\n    inline bool on_uint64(std::uint64_t u, string_view, error_code&)\n    {\n        stack.emplace_back((long)u);\n        return true;\n    }\n    inline bool on_double(double d, string_view, error_code&)\n    {\n        stack.emplace_back(d);\n        return true;\n    }\n    inline bool on_bool(bool b, error_code&)\n    {\n        stack.emplace_back(b);\n        return true;\n    }\n    inline bool on_null(error_code&)\n    {\n        stack.emplace_back(nullptr);\n        return true;\n    }\n    inline bool on_comment_part(string_view, error_code&)\n    {\n        return true;\n    }\n    inline bool on_comment(string_view, error_code&)\n    {\n        return true;\n    }\n};\n\nclass Serializer : public boost::json::serializer\n{\n    union\n    {\n        JSON const* pj_;\n        std::span<KeyJSONPair const> const* po_;\n        std::span<JSON const> const* pa_;\n    };\n    JSON const* jj_ = nullptr;\n    boost::json::value boost_value;\npublic:\n\n    bool suspend(\n        state st,\n        std::span<JSON const>::iterator it,\n        std::span<JSON const> const* pa)\n    {\n        st_.push(pa);\n        st_.push(it);\n        st_.push(st);\n        return false;\n    }\n\n    bool suspend(\n        state st,\n        std::span<KeyJSONPair const>::iterator it,\n        std::span<KeyJSONPair const> const* po)\n    {\n        st_.push(po);\n        st_.push(it);\n        st_.push(st);\n        return false;\n    }\n\n    void reset(JSON const* j) noexcept\n    {\n        //pv_ = j;\n        pj_ = j;\n        fn0_ = (fn_t)&Serializer::write_value<true>;\n        fn1_ = (fn_t)&Serializer::write_value<false>;\n\n        jj_ = j;\n        st_.clear();\n        done_ = false;\n    }\n\n    template<bool StackEmpty>\n    bool write_array(stream& ss0)\n    {\n        std::span<JSON const> const* pa;\n        local_stream ss(ss0);\n        std::span<JSON const>::iterator it, end;\n        if(StackEmpty || st_.empty())\n        {\n            pa = pa_;\n            it = pa->begin();\n            end = pa->end();\n        } else {\n            state st;\n            st_.pop(st);\n            st_.pop(it);\n            st_.pop(pa);\n            end = pa->end();\n            switch(st)\n            {\n            default:\n            case state::arr1: goto do_arr1;\n            case state::arr2: goto do_arr2;\n            case state::arr3: goto do_arr3;\n            case state::arr4: goto do_arr4;\n                break;\n            }\n        }\ndo_arr1:\n        if(BOOST_JSON_LIKELY(ss))\n            ss.append('[');\n        else\n            return suspend(\n                state::arr1, it, pa);\n        if(it == end)\n            goto do_arr4;\n        for(;;)\n        {\ndo_arr2:\n            jj_ = &*it;\n            if(! write_value<StackEmpty>(ss))\n                return suspend(\n                    state::arr2, it, pa);\n            if(BOOST_JSON_UNLIKELY(\n                ++it == end))\n                break;\ndo_arr3:\n            if(BOOST_JSON_LIKELY(ss))\n                ss.append(',');\n            else\n                return suspend(\n                    state::arr3, it, pa);\n        }\ndo_arr4:\n        if(BOOST_JSON_LIKELY(ss))\n            ss.append(']');\n        else\n            return suspend(\n                state::arr4, it, pa);\n        return true;\n    }\n\n    template<bool StackEmpty>\n    bool write_object(stream& ss0)\n    {\n        std::span<KeyJSONPair const> const* po;\n        local_stream ss(ss0);\n        std::span<KeyJSONPair const>::iterator it, end;\n        if(StackEmpty || st_.empty())\n        {\n            po = po_;\n            it = po->begin();\n            end = po->end();\n        } else {\n            state st;\n            st_.pop(st);\n            st_.pop(it);\n            st_.pop(po);\n            end = po->end();\n            switch(st)\n            {\n            default:\n            case state::obj1: goto do_obj1;\n            case state::obj2: goto do_obj2;\n            case state::obj3: goto do_obj3;\n            case state::obj4: goto do_obj4;\n            case state::obj5: goto do_obj5;\n            case state::obj6: goto do_obj6;\n                break;\n            }\n        }\ndo_obj1:\n        if(BOOST_JSON_LIKELY(ss))\n            ss.append('{');\n        else\n            return suspend(\n                state::obj1, it, po);\n        if(BOOST_JSON_UNLIKELY(\n            it == end))\n            goto do_obj6;\n        for(;;)\n        {\n            cs0_ = {\n                it->first.data(),\n                it->first.size() };\ndo_obj2:\n            if(BOOST_JSON_UNLIKELY(\n                ! write_string<StackEmpty>(ss)))\n                return suspend(\n                    state::obj2, it, po);\ndo_obj3:\n            if(BOOST_JSON_LIKELY(ss))\n                ss.append(':');\n            else\n                return suspend(\n                    state::obj3, it, po);\ndo_obj4:\n            jj_ = &it->second;\n            if(BOOST_JSON_UNLIKELY(\n                ! write_value<StackEmpty>(ss)))\n                return suspend(\n                    state::obj4, it, po);\n            ++it;\n            if(BOOST_JSON_UNLIKELY(it == end))\n                break;\ndo_obj5:\n            if(BOOST_JSON_UNLIKELY(ss))\n                ss.append(',');\n            else\n                return suspend(\n                    state::obj5, it, po);\n        }\ndo_obj6:\n        if(BOOST_JSON_LIKELY(ss))\n        {\n            ss.append('}');\n            return true;\n        }\n        return suspend(\n            state::obj6, it, po);\n    }\n\n    template<bool StackEmpty>\n    bool write_value(stream& ss)\n    {\n        auto const& jj(*jj_);\n        if (StackEmpty || st_.empty()) {\n            switch(jj.index()) {\n            default:\n            case JSON::OBJECT:\n                po_ = (std::span<KeyJSONPair const>const*)&jj.object();\n                return write_object<true>(ss);\n            case JSON::ARRAY:\n                pa_ = (std::span<JSON const>const*)&jj.array();\n                return write_array<true>(ss);\n            case JSON::STRING:\n            {\n                auto const& js = std::get<std::string_view>(jj);\n                cs0_ = { js.data(), js.size() };\n                return write_string<true>(ss);\n            }\n            case JSON::INTEGER:\n                boost_value = std::get<long>(jj);\n                jv_ = &boost_value;\n                return write_number<true>(ss);\n            case JSON::NUMBER:\n                boost_value = std::get<double>(jj);\n                jv_ = &boost_value;\n                return write_number<true>(ss);\n            case JSON::BOOLEAN:\n                if (std::get<bool>(jj)) {\n                    if(BOOST_JSON_LIKELY(\n                        ss.remain() >= 4))\n                    {\n                        ss.append(\"true\", 4);\n                        return true;\n                    }\n                    return write_true<true>(ss);\n                } else {\n                    if(BOOST_JSON_LIKELY(\n                        ss.remain() >= 5))\n                    {\n                        ss.append(\"false\", 5);\n                        return true;\n                    }\n                    return write_false<true>(ss);\n                }\n            case (JSON::Index)NULL:\n                if(BOOST_JSON_LIKELY(\n                    ss.remain() >= 4))\n                {\n                    ss.append(\"null\", 4);\n                    return true;\n                }\n                return write_null<true>(ss);\n            }\n        } else {\n            state st;\n            st_.peek(st);\n            switch(st)\n            {\n            default:\n                return serializer::write_value<StackEmpty>(ss);\n\n            case state::arr1: case state::arr2:\n            case state::arr3: case state::arr4:\n                return write_array<StackEmpty>(ss);\n\n            case state::obj1: case state::obj2:\n            case state::obj3: case state::obj4:\n            case state::obj5: case state::obj6:\n                return write_object<StackEmpty>(ss);\n            }\n        }\n    }\n};\n\nthread_local boost::json::basic_parser<ParseHandler> parser({});\n\n}\n\nJSON::Doc JSON::decode(std::string_view text)\n{\n    std::error_code ec;\n    parser.reset();\n    try {\n        /*size_t parsed_size = */parser.write_some(false, text.data(), text.size(), ec);\n        if (ec) { throw std::system_error(ec); }\n    } catch(...) {\n        parser.handler().abort();\n        throw;\n    }\n    return parser.handler().get();\n}\n\nstd::string_view JSON::encode() const\n{\n    static thread_local Serializer serializer;\n    static thread_local std::string storage;\n    serializer.reset(this);\n    storage.clear();\n    while (!serializer.done()) {\n        if (storage.capacity() == storage.size()) {\n            storage.reserve(storage.size() * 2);\n        }\n        storage += serializer.read(&*storage.end(), storage.capacity() - storage.size());\n    }\n    return storage;\n}\n\nstd::partial_ordering JSON::operator<=>(JSON const& json) const\n{\n    if (index() != json.index()) {\n        return std::partial_ordering::unordered;\n    }\n    if (auto sv = std::get_if<std::string_view>(this)) {\n        return *sv <=> std::get<std::string_view>(json);\n    } else if (auto d = std::get_if<double>(this)) {\n        return *d <=> std::get<double>(json);\n    } else if (auto l = std::get_if<long>(this)) {\n        return *l <=> std::get<long>(json);\n    } else if (auto b = std::get_if<bool>(this)) {\n        return *b <=> std::get<bool>(json);\n    } else if (auto span = std::get_if<std::span<JSON>>(this)) {\n        auto &lhs = *span;\n        auto &rhs = std::get<std::span<JSON>>(json);\n        std::partial_ordering cmp = std::partial_ordering::equivalent;\n        for (size_t idx = 0; 0 == cmp && lhs.size() > idx; ++ idx) {\n            cmp = lhs[idx] <=> rhs[idx];\n        }\n        return cmp;\n    } else if (auto span = std::get_if<std::span<KeyJSONPair>>(this)) {\n        static thread_local std::map<KeyJSONPair::first_type,KeyJSONPair::second_type> lhs, rhs;\n        auto & rhs_ =std::get<std::span<KeyJSONPair>>(json);\n        lhs.clear(); lhs.insert(span->begin(), span->end());\n        rhs.clear(); rhs.insert(rhs_.begin(), rhs_.end());\n        if (lhs.size() != rhs.size()) {\n            return lhs.size() <=> rhs.size();\n        }\n        std::partial_ordering cmp = std::partial_ordering::equivalent;\n        for (auto lit = lhs.begin(), rit = rhs.begin(); lit != lhs.end() && rit != rhs.end(); ++ lit, ++ rit) {\n            auto & [lk, lv] = *lit;\n            auto & [rk, rv] = *rit;\n            cmp = lk <=> rk; if (cmp != 0) break;\n            cmp = lv <=> rv; if (cmp != 0) break;\n        }\n        return cmp;\n    } else {\n        return std::partial_ordering::equivalent;\n    }\n}\n\nJSON const& JSON::operator[](std::string_view key) const\n{\n    auto & span = std::get<std::span<KeyJSONPair>>(*this);\n    JSON * result = nullptr;\n    for (auto & [k, json] : span) {\n        if (k == key) {\n            if (result != nullptr) {\n                throw std::out_of_range(\"multiple entries\");\n            }\n            result = &json;\n        }\n    }\n    if (result == nullptr) {\n        throw std::out_of_range(\"not found\");\n    }\n    return *result;\n}\n\nJSON::Doc::Doc(JSON*root)\n: root_(root)\n{ }\n\nJSON::Doc::Doc(Doc&&doc)\n: root_(doc.root_)\n{\n    doc.root_ = nullptr;\n}\n\nJSON::Doc::~Doc()\n{\n    if (root_) {\n        ParseHandler::del(root_);\n    }\n}\n\n}\n\n```\n\n2: **/usr/include/boost/container/devector.hpp**\n```\n//////////////////////////////////////////////////////////////////////////////\n//\n// (C) Copyright Benedek Thaler 2015-2016\n// (C) Copyright Ion Gaztanaga 2019-2020. Distributed under the Boost\n// Software License, Version 1.0. (See accompanying file\n// LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n//\n// See http://www.boost.org/libs/container for documentation.\n//\n//////////////////////////////////////////////////////////////////////////////\n\n#ifndef BOOST_CONTAINER_DEVECTOR_HPP\n#define BOOST_CONTAINER_DEVECTOR_HPP\n\n#include <boost/container/detail/config_begin.hpp>\n#include <boost/container/detail/workaround.hpp>\n\n//#include <algorithm>\n#include <cstring> // memcpy\n\n#include <boost/assert.hpp>\n#include <boost/type_traits/aligned_storage.hpp>\n\n#include <boost/container/detail/copy_move_algo.hpp>\n#include <boost/container/new_allocator.hpp> //new_allocator\n#include <boost/container/allocator_traits.hpp> //allocator_traits\n#include <boost/container/detail/algorithm.hpp> //equal()\n#include <boost/container/throw_exception.hpp>\n#include <boost/container/options.hpp>\n\n#include <boost/container/detail/guards_dended.hpp>\n#include <boost/container/detail/iterator.hpp>\n#include <boost/container/detail/iterators.hpp>\n#include <boost/container/detail/destroyers.hpp>\n#include <boost/container/detail/min_max.hpp>\n#include <boost/container/detail/next_capacity.hpp>\n#include <boost/container/detail/alloc_helpers.hpp>\n#include <boost/container/detail/advanced_insert_int.hpp>\n\n// move\n#if defined(BOOST_NO_CXX11_VARIADIC_TEMPLATES)\n#include <boost/move/detail/fwd_macros.hpp>\n#endif\n#include <boost/move/detail/move_helpers.hpp>\n#include <boost/move/adl_move_swap.hpp>\n#include <boost/move/iterator.hpp>\n#include <boost/move/traits.hpp>\n#include <boost/move/utility_core.hpp>\n#include <boost/move/detail/to_raw_pointer.hpp>\n#include <boost/move/algo/detail/merge.hpp>\n#include <boost/move/detail/force_ptr.hpp>\n\n#include <boost/type_traits/is_nothrow_move_constructible.hpp>\n\n//std\n#if !defined(BOOST_NO_CXX11_HDR_INITIALIZER_LIST)\n#include <initializer_list>    //for std::initializer_list\n#endif\n\nnamespace boost {\nnamespace container {\n\n#if !defined(BOOST_CONTAINER_DOXYGEN_INVOKED)\n\nstruct growth_factor_60;\n\ntemplate<class Options, class AllocatorSizeType>\nstruct get_devector_opt\n{\n    typedef devector_opt< typename default_if_void<typename Options::growth_factor_type, growth_factor_60>::type\n                        , typename default_if_void<typename Options::stored_size_type, AllocatorSizeType>::type\n                        , default_if_zero<Options::free_fraction, relocate_on_90::value>::value\n                        > type;\n};\n\ntemplate<class AllocatorSizeType>\nstruct get_devector_opt<void, AllocatorSizeType>\n{\n    typedef devector_opt< growth_factor_60, AllocatorSizeType, relocate_on_90::value> type;\n};\n\n#endif    //#if defined(BOOST_CONTAINER_DOXYGEN_INVOKED)\n\nstruct reserve_only_tag_t {};\nstruct reserve_uninitialized_t {};\nstruct review_implementation_t {};\n\n//struct unsafe_uninitialized_tag_t {};\n\n/**\n * A vector-like sequence container providing front and back operations\n * (e.g: `push_front`/`pop_front`/`push_back`/`pop_back`) with amortized constant complexity.\n *\n * Models the [SequenceContainer], [ReversibleContainer], and [AllocatorAwareContainer] concepts.\n *\n * **Requires**:\n *   - `T` shall be [MoveInsertable] into the devector.\n *   - `T` shall be [Erasable] from any `devector<T, allocator_type, GP>`.\n *   - `GrowthFactor`, and `Allocator` must model the concepts with the same names or be void.\n *\n * **Definition**: `T` is `NothrowConstructible` if it's either nothrow move constructible or\n * nothrow copy constructible.\n *\n * **Definition**: `T` is `NothrowAssignable` if it's either nothrow move assignable or\n * nothrow copy assignable.\n *\n * **Exceptions**: The exception specifications assume `T` is nothrow [Destructible].\n *\n * Most methods providing the strong exception guarantee assume `T` either has a move\n * constructor marked noexcept or is [CopyInsertable] into the devector. If it isn't true,\n * and the move constructor throws, the guarantee is waived and the effects are unspecified.\n *\n * In addition to the exceptions specified in the **Throws** clause, the following operations\n * of `T` can throw when any of the specified concept is required:\n *   - [DefaultInsertable][]: Default constructor\n *   - [MoveInsertable][]: Move constructor\n *   - [CopyInsertable][]: Copy constructor\n *   - [DefaultConstructible][]: Default constructor\n *   - [EmplaceConstructible][]: Constructor selected by the given arguments\n *   - [MoveAssignable][]: Move assignment operator\n *   - [CopyAssignable][]: Copy assignment operator\n *\n * Furthermore, not `noexcept` methods throws whatever the allocator throws\n * if memory allocation fails. Such methods also throw `length_error` if the capacity\n * exceeds `max_size()`.\n *\n * **Remark**: If a method invalidates some iterators, it also invalidates references\n * and pointers to the elements pointed by the invalidated iterators.\n *\n *! \\tparam Options A type produced from \\c boost::container::devector_options.\n *\n * [SequenceContainer]: http://en.cppreference.com/w/cpp/concept/SequenceContainer\n * [ReversibleContainer]: http://en.cppreference.com/w/cpp/concept/ReversibleContainer\n * [AllocatorAwareContainer]: http://en.cppreference.com/w/cpp/concept/AllocatorAwareContainer\n * [DefaultInsertable]: http://en.cppreference.com/w/cpp/concept/DefaultInsertable\n * [MoveInsertable]: http://en.cppreference.com/w/cpp/concept/MoveInsertable\n * [CopyInsertable]: http://en.cppreference.com/w/cpp/concept/CopyInsertable\n * [Erasable]: http://en.cppreference.com/w/cpp/concept/Erasable\n * [DefaultConstructible]: http://en.cppreference.com/w/cpp/concept/DefaultConstructible\n * [Destructible]: http://en.cppreference.com/w/cpp/concept/Destructible\n * [EmplaceConstructible]: http://en.cppreference.com/w/cpp/concept/EmplaceConstructible\n * [MoveAssignable]: http://en.cppreference.com/w/cpp/concept/MoveAssignable\n * [CopyAssignable]: http://en.cppreference.com/w/cpp/concept/CopyAssignable\n */\ntemplate < typename T, class A BOOST_CONTAINER_DOCONLY(= void), class Options BOOST_CONTAINER_DOCONLY(= void)>\nclass devector\n{\n   #ifndef BOOST_CONTAINER_DOXYGEN_INVOKED\n   typedef boost::container::allocator_traits\n      <typename real_allocator<T, A>::type>                                      allocator_traits_type;\n   typedef typename allocator_traits_type::size_type                             alloc_size_type;\n   typedef typename get_devector_opt<Options, alloc_size_type>::type             options_type;\n   typedef typename options_type::growth_factor_type                             growth_factor_type;\n   typedef typename options_type::stored_size_type                               stored_size_type;\n   static const std::size_t devector_min_free_fraction =\n      options_type::free_fraction;\n\n   #endif // ifndef BOOST_CONTAINER_DOXYGEN_INVOKED\n\n   public:\n   // Standard Interface Types:\n   typedef T                                                                     value_type;\n   typedef BOOST_CONTAINER_IMPDEF\n      (typename real_allocator<T BOOST_MOVE_I A>::type)                          allocator_type;\n   typedef allocator_type                                                        stored_allocator_type;\n   typedef typename    allocator_traits<allocator_type>::pointer                 pointer;\n   typedef typename    allocator_traits<allocator_type>::const_pointer           const_pointer;\n   typedef typename    allocator_traits<allocator_type>::reference               reference;\n   typedef typename    allocator_traits<allocator_type>::const_reference         const_reference;\n   typedef typename    allocator_traits<allocator_type>::size_type               size_type;\n   typedef typename    allocator_traits<allocator_type>::difference_type         difference_type;\n   typedef pointer                                                               iterator;\n   typedef const_pointer                                                         const_iterator;\n   typedef BOOST_CONTAINER_IMPDEF\n      (boost::container::reverse_iterator<iterator>)                             reverse_iterator;\n   typedef BOOST_CONTAINER_IMPDEF\n      (boost::container::reverse_iterator<const_iterator>)                       const_reverse_iterator;\n\n   #ifndef BOOST_CONTAINER_DOXYGEN_INVOKED\n   private:\n   BOOST_COPYABLE_AND_MOVABLE(devector)\n\n   // Guard to deallocate buffer on exception\n   typedef typename detail::allocation_guard<allocator_type> allocation_guard;\n\n   // Random access pseudo iterator always yielding to the same result\n   typedef constant_iterator<T> cvalue_iterator;\n\n   static size_type to_internal_capacity(size_type desired_capacity)\n   {\n      const size_type rounder = devector_min_free_fraction - 2u;\n      const size_type divisor = devector_min_free_fraction - 1u;\n      size_type const nc = ((desired_capacity + rounder) / divisor) * devector_min_free_fraction;\n      BOOST_ASSERT(desired_capacity <= (nc - nc / devector_min_free_fraction));\n      return nc;\n   }\n\n   #endif // ifndef BOOST_CONTAINER_DOXYGEN_INVOKED\n\n   // Standard Interface\n   public:\n   // construct/copy/destroy\n\n   /**\n   * **Effects**: Constructs an empty devector.\n   *\n   * **Postcondition**: `empty() && front_free_capacity() == 0\n   * && back_free_capacity() == 0`.\n   *\n   * **Complexity**: Constant.\n   */\n   devector() BOOST_NOEXCEPT\n      : m_()\n   {}\n\n   /**\n   * **Effects**: Constructs an empty devector, using the specified allocator.\n   *\n   * **Postcondition**: `empty() && front_free_capacity() == 0\n   * && back_free_capacity() == 0`.\n   *\n   * **Complexity**: Constant.\n   */\n   explicit devector(const allocator_type& allocator) BOOST_NOEXCEPT\n      : m_(allocator)\n   {}\n\n   /**\n   * **Effects**: Constructs an empty devector, using the specified allocator\n   * and reserves `n` slots as if `reserve(n)` was called.\n   *\n   * **Postcondition**: `empty() && capacity() >= n`.\n   *\n   * **Exceptions**: Strong exception guarantee.\n   *\n   * **Complexity**: Constant.\n   */\n   devector(size_type n, reserve_only_tag_t, const allocator_type& allocator = allocator_type())\n      : m_(reserve_only_tag_t(), allocator, to_internal_capacity(n))\n   {}\n\n   /**\n   * **Effects**: Constructs an empty devector, using the specified allocator\n   * and reserves at least `front_free_cap + back_free_cap` slots as if `reserve_front(front_cap)` and\n   * `reserve_back(back_cap)` was called.\n   *\n   * **Postcondition**: `empty() && front_free_capacity() >= front_free_cap\n   * && back_free_capacity() >= back_free_cap`.\n   *\n   * **Exceptions**: Strong exception guarantee.\n   *\n   * **Complexity**: Constant.\n   */\n   devector(size_type front_free_cap, size_type back_free_cap, reserve_only_tag_t, const allocator_type& allocator = allocator_type())\n      : m_(reserve_only_tag_t(), allocator, front_free_cap, back_free_cap)\n   {}\n\n   /**\n   * [DefaultInsertable]: http://en.cppreference.com/w/cpp/concept/DefaultInsertable\n   *\n   * **Effects**: Constructs a devector with `n` value_initialized elements using the specified allocator.\n   *\n   * **Requires**: `T` shall be [DefaultInsertable] into `*this`.\n   *\n   * **Postcondition**: `size() == n`.\n   *\n   * **Exceptions**: Strong exception guarantee.\n   *\n   * **Complexity**: Linear in `n`.\n   */\n   explicit devector(size_type n, const allocator_type& allocator = allocator_type())\n      : m_(reserve_uninitialized_t(), allocator, n)\n   {\n      allocation_guard buffer_guard(m_.buffer, m_.capacity, get_allocator_ref());\n      boost::container::uninitialized_value_init_alloc_n(get_allocator_ref(), n, this->priv_raw_begin());\n      buffer_guard.release();\n      BOOST_ASSERT(invariants_ok());\n   }\n\n   /**\n   * **Effects**: Constructs a devector with `n` default-initialized elements using the specified allocator.\n   *\n   * **Requires**: `T` shall be [DefaultInsertable] into `*this`.\n   *\n   * **Postcondition**: `size() == n`.\n   *\n   * **Exceptions**: Strong exception guarantee.\n   *\n   * **Complexity**: Linear in `n`.\n   */\n   explicit devector(size_type n, default_init_t, const allocator_type& allocator = allocator_type())\n      : m_(reserve_uninitialized_t(), allocator, n)\n   {\n      allocation_guard buffer_guard(m_.buffer, m_.capacity, get_allocator_ref());\n      boost::container::uninitialized_default_init_alloc_n(get_allocator_ref(), n, this->priv_raw_begin());\n      buffer_guard.release();\n      BOOST_ASSERT(invariants_ok());\n   }\n\n   /**\n   * [CopyInsertable]: http://en.cppreference.com/w/cpp/concept/CopyInsertable\n   *\n   * **Effects**: Constructs a devector with `n` copies of `value`, using the specified allocator.\n   *\n   * **Requires**: `T` shall be [CopyInsertable] into `*this`.\n   *\n   * **Postcondition**: `size() == n`.\n   *\n   * **Exceptions**: Strong exception guarantee.\n   *\n   * **Complexity**: Linear in `n`.\n   */\n   devector(size_type n, const T& value, const allocator_type& allocator = allocator_type())\n      : m_(reserve_uninitialized_t(), allocator, n)\n   {\n      construct_from_range(cvalue_iterator(value, n), cvalue_iterator());\n      BOOST_ASSERT(invariants_ok());\n   }\n\n   /**\n   * **Effects**: Constructs a devector equal to the range `[first,last)`, using the specified allocator.\n   *\n   * **Requires**: `T` shall be [EmplaceConstructible] into `*this` from `*first`. If the specified\n   * iterator does not meet the forward iterator requirements, `T` shall also be [MoveInsertable]\n   * into `*this`.\n   *\n   * **Postcondition**: `size() == boost::container::iterator_distance(first, last)\n   *\n   * **Exceptions**: Strong exception guarantee.\n   *\n   * **Complexity**: Makes only `N` calls to the copy constructor of `T` (where `N` is the distance between `first`\n   * and `last`), at most one allocation and no reallocations if iterators first and last are of forward,\n   * bidirectional, or random access categories. It makes `O(N)` calls to the copy constructor of `T`\n   * and `O(log(N)) reallocations if they are just input iterators.\n   *\n   * **Remarks**: Each iterator in the range `[first,last)` shall be dereferenced exactly once,\n   * unless an exception is thrown.\n   *\n   * [EmplaceConstructible]: http://en.cppreference.com/w/cpp/concept/EmplaceConstructible\n   * [MoveInsertable]: http://en.cppreference.com/w/cpp/concept/MoveInsertable\n   */\n   template <class InputIterator>\n   devector(InputIterator first, InputIterator last, const allocator_type& allocator = allocator_type()\n      //Input iterators\n      BOOST_CONTAINER_DOCIGN(BOOST_MOVE_I typename dtl::disable_if_or\n            < void\n            BOOST_MOVE_I dtl::is_convertible<InputIterator BOOST_MOVE_I size_type>\n            BOOST_MOVE_I dtl::is_not_input_iterator<InputIterator>\n            >::type * = 0)\n      )\n      : m_(allocator)\n   {\n      BOOST_TRY{\n         while (first != last) {\n            this->emplace_back(*first++);\n         }\n         BOOST_ASSERT(invariants_ok());\n      }\n      BOOST_CATCH(...){\n         this->destroy_elements(m_.buffer + m_.front_idx, m_.buffer + m_.back_idx);\n         this->deallocate_buffer();\n      }\n      BOOST_CATCH_END\n   }\n\n   #ifndef BOOST_CONTAINER_DOXYGEN_INVOKED\n\n   template <class ForwardIterator>\n   devector(ForwardIterator first, ForwardIterator last, const allocator_type& allocator = allocator_type()\n      //Other iterators\n      BOOST_CONTAINER_DOCIGN(BOOST_MOVE_I typename dtl::disable_if_or\n            < void\n            BOOST_MOVE_I dtl::is_convertible<ForwardIterator BOOST_MOVE_I size_type>\n            BOOST_MOVE_I dtl::is_input_iterator<ForwardIterator>\n            >::type * = 0)\n      )\n      : m_(reserve_uninitialized_t(), allocator, boost::container::iterator_udistance(first, last))\n   {\n      this->construct_from_range(first, last);\n      BOOST_ASSERT(invariants_ok());\n   }\n\n   #endif // ifndef BOOST_CONTAINER_DOXYGEN_INVOKED\n\n   /**\n   * [CopyInsertable]: http://en.cppreference.com/w/cpp/concept/CopyInsertable\n   *\n   * **Effects**: Copy constructs a devector.\n   *\n   * **Requires**: `T` shall be [CopyInsertable] into `*this`.\n   *\n   * **Postcondition**: `this->size() == x.size()`.\n   *\n   * **Exceptions**: Strong exception guarantee.\n   *\n   * **Complexity**: Linear in the size of `x`.\n   */\n   devector(const devector& x)\n      : m_(reserve_uninitialized_t(), allocator_traits_type::select_on_container_copy_construction(x.get_allocator_ref()), x.size())\n   {\n      this->construct_from_range(x.begin(), x.end());\n      BOOST_ASSERT(invariants_ok());\n   }\n\n   /**\n   * [CopyInsertable]: http://en.cppreference.com/w/cpp/concept/CopyInsertable\n   *\n   * **Effects**: Copy constructs a devector, using the specified allocator.\n   *\n   * **Requires**: `T` shall be [CopyInsertable] into `*this`.\n   *\n   * **Postcondition**: `*this == x`.\n   *\n   * **Exceptions**: Strong exception guarantee.\n   *\n   * **Complexity**: Linear in the size of `x`.\n   */\n   devector(const devector& x, const allocator_type& allocator)\n      : m_(reserve_uninitialized_t(), allocator, x.size())\n   {\n      this->construct_from_range(x.begin(), x.end());\n      BOOST_ASSERT(invariants_ok());\n   }\n\n   /**\n   * **Effects**: Moves `rhs`'s resources to `*this`.\n   *\n   * **Throws**: Nothing.\n   *\n   * **Postcondition**: *this has the same value `rhs` had before the operation.\n   *                    `rhs` is left in an unspecified but valid state.\n   *\n   * **Exceptions**: Strong exception guarantee if not `noexcept`.\n   *\n   * **Complexity**: Constant.\n   */\n   devector(BOOST_RV_REF(devector) rhs) BOOST_NOEXCEPT_OR_NOTHROW\n      : m_(::boost::move(rhs.m_))\n   {\n      BOOST_ASSERT(      invariants_ok());\n      BOOST_ASSERT(rhs.invariants_ok());\n   }\n\n   /**\n   * **Effects**: Moves `rhs`'s resources to `*this`, using the specified allocator.\n   *\n   * **Throws**: If allocation or T's move constructor throws.\n   *\n   * **Postcondition**: *this has the same value `rhs` had before the operation.\n   *                    `rhs` is left in an unspecified but valid state.\n   *\n   * **Exceptions**: Strong exception guarantee if not `noexcept`.\n   *\n   * **Complexity**: Linear if allocator != rhs.get_allocator(), otherwise constant.\n   */\n   devector(BOOST_RV_REF(devector) rhs, const allocator_type& allocator)\n      : m_(review_implementation_t(), allocator, rhs.m_.buffer, rhs.m_.front_idx, rhs.m_.back_idx, rhs.m_.capacity)\n   {\n      // TODO should move elems-by-elems if the two allocators differ\n      // buffer is already acquired, reset rhs\n      rhs.m_.capacity = 0u;\n      rhs.m_.buffer = pointer();\n      rhs.m_.front_idx = 0;\n      rhs.m_.back_idx = 0;\n      BOOST_ASSERT(      invariants_ok());\n      BOOST_ASSERT(rhs.invariants_ok());\n   }\n\n   #if !defined(BOOST_NO_CXX11_HDR_INITIALIZER_LIST)\n   /**\n   * **Equivalent to**: `devector(il.begin(), il.end(), allocator)`.\n   */\n   devector(const std::initializer_list<T>& il, const allocator_type& allocator = allocator_type())\n      : m_(reserve_uninitialized_t(), allocator, il.size())\n   {\n      this->construct_from_range(il.begin(), il.end());\n      BOOST_ASSERT(invariants_ok());\n   }\n   #endif\n\n/**\n   * **Effects**: Destroys the devector. All stored values are destroyed and\n   * used memory, if any, deallocated.\n   *\n   * **Complexity**: Linear in the size of `*this`.\n   */\n~devector() BOOST_NOEXCEPT\n{\n   destroy_elements(m_.buffer + m_.front_idx, m_.buffer + m_.back_idx);\n   deallocate_buffer();\n}\n\n/**\n   * **Effects**: Copies elements of `x` to `*this`. Previously\n   * held elements get copy assigned to or destroyed.\n   *\n   * **Requires**: `T` shall be [CopyInsertable] into `*this`.\n   *\n   * **Postcondition**: `this->size() == x.size()`, the elements of\n   * `*this` are copies of elements in `x` in the same order.\n   *\n   * **Returns**: `*this`.\n   *\n   * **Exceptions**: Strong exception guarantee if `T` is `NothrowConstructible`\n   * and the allocator is allowed to be propagated\n   * ([propagate_on_container_copy_assignment] is true),\n   * Basic exception guarantee otherwise.\n   *\n   * **Complexity**: Linear in the size of `x` and `*this`.\n   *\n   * [CopyInsertable]: http://en.cppreference.com/w/cpp/concept/CopyInsertable\n   * [propagate_on_container_copy_assignment]: http://en.cppreference.com/w/cpp/memory/allocator_traits\n   */\n\n   BOOST_CONTAINER_FORCEINLINE devector& operator=(BOOST_COPY_ASSIGN_REF(devector) rhs)\n   {\n      const devector &x = rhs;\n      if (this == &x) { return *this; } // skip self\n\n      BOOST_IF_CONSTEXPR(allocator_traits_type::propagate_on_container_copy_assignment::value)\n      {\n            allocator_type &this_alloc = this->get_allocator_ref();\n            const allocator_type &other_alloc = x.get_allocator_ref();\n            if (this_alloc != other_alloc)\n            {\n               // new allocator cannot free existing storage\n               this->clear();\n               this->deallocate_buffer();\n               m_.capacity = 0u;\n               m_.buffer = pointer();\n            }\n\n            this_alloc = other_alloc;\n      }\n\n      size_type n = x.size();\n      if (m_.capacity >= n)\n      {\n            this->overwrite_buffer(x.begin(), x.end());\n      }\n      else\n      {\n            this->allocate_and_copy_range(x.begin(), x.end());\n      }\n\n      BOOST_ASSERT(invariants_ok());\n\n      return *this;\n   }\n\n   /**\n   * [MoveInsertable]: http://en.cppreference.com/w/cpp/concept/MoveInsertable\n   *\n   * **Effects**: Moves elements of `x` to `*this`. Previously\n   * held elements get move/copy assigned to or destroyed.\n   *\n   * **Requires**: `T` shall be [MoveInsertable] into `*this`.\n   *\n   * **Postcondition**: `x` is left in an unspecified but valid state.\n   *\n   * **Returns**: `*this`.\n   *\n   * **Exceptions**: Basic exception guarantee if not `noexcept`.\n   *\n   * **Complexity**: Constant if allocator_traits_type::\n   *   propagate_on_container_move_assignment is true or\n   *   this->get>allocator() == x.get_allocator(). Linear otherwise.\n   */\n   devector& operator=(BOOST_RV_REF(devector) x)\n      BOOST_NOEXCEPT_IF(allocator_traits_type::propagate_on_container_move_assignment::value\n                                 || allocator_traits_type::is_always_equal::value)\n   {\n      BOOST_CONSTEXPR_OR_CONST bool copy_alloc = allocator_traits_type::propagate_on_container_move_assignment::value;\n\n      BOOST_IF_CONSTEXPR (copy_alloc || get_allocator_ref() == x.get_allocator_ref())\n      {\n         this->clear();\n         this->deallocate_buffer();\n\n         if (copy_alloc)\n         {\n            this->get_allocator_ref() = boost::move(x.get_allocator_ref());\n         }\n\n         m_.capacity = x.m_.capacity;\n         m_.buffer = x.m_.buffer;\n         m_.front_idx = x.m_.front_idx;\n         m_.back_idx = x.m_.back_idx;\n\n         // leave x in valid state\n         x.m_.capacity = 0u;\n         x.m_.buffer = pointer();\n         x.m_.back_idx = x.m_.front_idx = 0;\n      }\n      else\n      {\n         // if the allocator shouldn't be copied and they do not compare equal\n         // we can't steal memory.\n\n         move_iterator<iterator> xbegin = boost::make_move_iterator(x.begin());\n         move_iterator<iterator> xend = boost::make_move_iterator(x.end());\n\n         if (copy_alloc)\n         {\n            get_allocator_ref() = boost::move(x.get_allocator_ref());\n         }\n\n         if (m_.capacity >= x.size())\n         {\n            overwrite_buffer(xbegin, xend);\n         }\n         else\n         {\n            allocate_and_copy_range(xbegin, xend);\n         }\n      }\n\n      BOOST_ASSERT(invariants_ok());\n\n      return *this;\n   }\n\n   #if !defined(BOOST_NO_CXX11_HDR_INITIALIZER_LIST)\n   /**\n   * **Effects**: Copies elements of `il` to `*this`. Previously\n   * held elements get copy assigned to or destroyed.\n   *\n   * **Requires**: `T` shall be [CopyInsertable] into `*this` and [CopyAssignable].\n   *\n   * **Postcondition**: `this->size() == il.size()`, the elements of\n   * `*this` are copies of elements in `il` in the same order.\n   *\n   * **Exceptions**: Strong exception guarantee if `T` is nothrow copy assignable\n   * from `T` and `NothrowConstructible`, Basic exception guarantee otherwise.\n   *\n   * **Returns**: `*this`.\n   *\n   * **Complexity**: Linear in the size of `il` and `*this`.\n   *\n   * [CopyInsertable]: http://en.cppreference.com/w/cpp/concept/CopyInsertable\n   * [CopyAssignable]: http://en.cppreference.com/w/cpp/concept/CopyAssignable\n   */\n   BOOST_CONTAINER_FORCEINLINE devector& operator=(std::initializer_list<T> il)\n   {\n      this->assign(il.begin(), il.end());\n      return *this;\n   }\n   #endif\n\n   /**\n   * **Effects**: Replaces elements of `*this` with a copy of `[first,last)`.\n   * Previously held elements get copy assigned to or destroyed.\n   *\n   * **Requires**: `T` shall be [EmplaceConstructible] from `*first`. If the specified iterator\n   * does not meet the forward iterator requirements, `T` shall be also [MoveInsertable] into `*this`.\n   *\n   * **Precondition**: `first` and `last` are not iterators into `*this`.\n   *\n   * **Postcondition**: `size() == N`, where `N` is the distance between `first` and `last`.\n   *\n   * **Exceptions**: Strong exception guarantee if `T` is nothrow copy assignable\n   * from `*first` and `NothrowConstructible`, Basic exception guarantee otherwise.\n   *\n   * **Complexity**: Linear in the distance between `first` and `last`.\n   * Makes a single reallocation at most if the iterators `first` and `last`\n   * are of forward, bidirectional, or random access categories. It makes\n   * `O(log(N))` reallocations if they are just input iterators.\n   *\n   * **Remarks**: Each iterator in the range `[first,last)` shall be dereferenced exactly once,\n   * unless an exception is thrown.\n   *\n   * [EmplaceConstructible]: http://en.cppreference.com/w/cpp/concept/EmplaceConstructible\n   * [MoveInsertable]: http://en.cppreference.com/w/cpp/concept/MoveInsertable\n   */\n   template <class InputIterator>\n   void assign(InputIterator first, InputIterator last\n      //Input iterators\n      BOOST_CONTAINER_DOCIGN(BOOST_MOVE_I typename dtl::disable_if_or\n            < void\n            BOOST_MOVE_I dtl::is_convertible<InputIterator BOOST_MOVE_I size_type>\n            BOOST_MOVE_I dtl::is_not_input_iterator<InputIterator>\n            >::type * = 0)\n      )\n   {\n      first = overwrite_buffer_impl(first, last, dtl::false_());\n      while (first != last)\n      {\n         this->emplace_back(*first++);\n      }\n   }\n\n   #ifndef BOOST_CONTAINER_DOXYGEN_INVOKED\n\n   template <class ForwardIterator>\n   void assign(ForwardIterator first, ForwardIterator last\n      //Other iterators\n      BOOST_CONTAINER_DOCIGN(BOOST_MOVE_I typename dtl::disable_if_or\n            < void\n            BOOST_MOVE_I dtl::is_convertible<ForwardIterator BOOST_MOVE_I size_type>\n            BOOST_MOVE_I dtl::is_input_iterator<ForwardIterator>\n            >::type * = 0)\n      )\n   {\n      const size_type n = boost::container::iterator_udistance(first, last);\n\n      if (m_.capacity >= n)\n      {\n         overwrite_buffer(first, last);\n      }\n      else\n      {\n         allocate_and_copy_range(first, last);\n      }\n\n      BOOST_ASSERT(invariants_ok());\n   }\n\n   #endif // ifndef BOOST_CONTAINER_DOXYGEN_INVOKED\n\n   /**\n    * **Effects**: Replaces elements of `*this` with `n` copies of `u`.\n    * Previously held elements get copy assigned to or destroyed.\n    *\n    * **Requires**: `T` shall be [CopyInsertable] into `*this` and\n    * [CopyAssignable].\n    *\n    * **Precondition**: `u` is not a reference into `*this`.\n    *\n    * **Postcondition**: `size() == n` and the elements of\n    * `*this` are copies of `u`.\n    *\n    * **Exceptions**: Strong exception guarantee if `T` is nothrow copy assignable\n    * from `u` and `NothrowConstructible`, Basic exception guarantee otherwise.\n    *\n    * **Complexity**: Linear in `n` and the size of `*this`.\n    *\n    * [CopyInsertable]: http://en.cppreference.com/w/cpp/concept/CopyInsertable\n    * [CopyAssignable]: http://en.cppreference.com/w/cpp/concept/CopyAssignable\n    */\n   BOOST_CONTAINER_FORCEINLINE void assign(size_type n, const T& u)\n   {\n      cvalue_iterator first(u, n);\n      cvalue_iterator last;\n      this->assign(first, last);\n   }\n\n    #if !defined(BOOST_NO_CXX11_HDR_INITIALIZER_LIST)\n    /** **Equivalent to**: `assign(il.begin(), il.end())`. */\n   BOOST_CONTAINER_FORCEINLINE void assign(std::initializer_list<T> il)\n    {\n         this->assign(il.begin(), il.end());\n    }\n    #endif\n\n   /**\n    * **Returns**: A copy of the allocator associated with the container.\n    *\n    * **Complexity**: Constant.\n    */\n   BOOST_CONTAINER_ATTRIBUTE_NODISCARD BOOST_CONTAINER_FORCEINLINE\n    allocator_type get_allocator() const BOOST_NOEXCEPT\n   {\n      return static_cast<const allocator_type&>(m_);\n   }\n\n   BOOST_CONTAINER_ATTRIBUTE_NODISCARD BOOST_CONTAINER_FORCEINLINE\n    const allocator_type &get_stored_allocator() const BOOST_NOEXCEPT\n   {\n      return static_cast<const allocator_type&>(m_);\n   }\n\n   BOOST_CONTAINER_ATTRIBUTE_NODISCARD BOOST_CONTAINER_FORCEINLINE\n         allocator_type &get_stored_allocator() BOOST_NOEXCEPT\n   {\n      return static_cast<allocator_type&>(m_);\n   }\n\n   // iterators\n\n   /**\n    * **Returns**: A iterator pointing to the first element in the devector,\n    * or the past the end iterator if the devector is empty.\n    *\n    * **Complexity**: Constant.\n    */\n   BOOST_CONTAINER_ATTRIBUTE_NODISCARD BOOST_CONTAINER_FORCEINLINE\n         iterator begin() BOOST_NOEXCEPT\n   {\n      return m_.buffer + m_.front_idx;\n   }\n\n   /**\n    * **Returns**: A constant iterator pointing to the first element in the devector,\n    * or the past the end iterator if the devector is empty.\n    *\n    * **Complexity**: Constant.\n    */\n   BOOST_CONTAINER_ATTRIBUTE_NODISCARD BOOST_CONTAINER_FORCEINLINE\n    const_iterator begin() const BOOST_NOEXCEPT\n   {\n      return m_.buffer + m_.front_idx;\n   }\n\n   /**\n    * **Returns**: An iterator pointing past the last element of the container.\n    *\n    * **Complexity**: Constant.\n    */\n   BOOST_CONTAINER_ATTRIBUTE_NODISCARD BOOST_CONTAINER_FORCEINLINE\n         iterator end() BOOST_NOEXCEPT\n   {\n      return m_.buffer + m_.back_idx;\n   }\n\n   /**\n    * **Returns**: A constant iterator pointing past the last element of the container.\n    *\n    * **Complexity**: Constant.\n    */\n   BOOST_CONTAINER_ATTRIBUTE_NODISCARD BOOST_CONTAINER_FORCEINLINE\n    const_iterator end() const BOOST_NOEXCEPT\n   {\n      return m_.buffer + m_.back_idx;\n   }\n\n   /**\n    * **Returns**: A reverse iterator pointing to the first element in the reversed devector,\n    * or the reverse past the end iterator if the devector is empty.\n    *\n    * **Complexity**: Constant.\n    */\n   BOOST_CONTAINER_ATTRIBUTE_NODISCARD BOOST_CONTAINER_FORCEINLINE\n    reverse_iterator rbegin() BOOST_NOEXCEPT\n   {\n      return reverse_iterator(m_.buffer + m_.back_idx);\n   }\n\n   /**\n    * **Returns**: A constant reverse iterator\n    * pointing to the first element in the reversed devector,\n    * or the reverse past the end iterator if the devector is empty.\n    *\n    * **Complexity**: Constant.\n    */\n   BOOST_CONTAINER_ATTRIBUTE_NODISCARD BOOST_CONTAINER_FORCEINLINE\n    const_reverse_iterator rbegin() const BOOST_NOEXCEPT\n   {\n      return const_reverse_iterator(m_.buffer + m_.back_idx);\n   }\n\n   /**\n    * **Returns**: A reverse iterator pointing past the last element in the\n    * reversed container, or to the beginning of the reversed container if it's empty.\n    *\n    * **Complexity**: Constant.\n    */\n   BOOST_CONTAINER_ATTRIBUTE_NODISCARD BOOST_CONTAINER_FORCEINLINE\n    reverse_iterator rend() BOOST_NOEXCEPT\n   {\n      return reverse_iterator(m_.buffer + m_.front_idx);\n   }\n\n   /**\n    * **Returns**: A constant reverse iterator pointing past the last element in the\n    * reversed container, or to the beginning of the reversed container if it's empty.\n    *\n    * **Complexity**: Constant.\n    */\n   BOOST_CONTAINER_ATTRIBUTE_NODISCARD BOOST_CONTAINER_FORCEINLINE\n    const_reverse_iterator rend() const BOOST_NOEXCEPT\n   {\n      return const_reverse_iterator(m_.buffer + m_.front_idx);\n   }\n\n   /**\n    * **Returns**: A constant iterator pointing to the first element in the devector,\n    * or the past the end iterator if the devector is empty.\n    *\n    * **Complexity**: Constant.\n    */\n   BOOST_CONTAINER_ATTRIBUTE_NODISCARD BOOST_CONTAINER_FORCEINLINE\n    const_iterator cbegin() const BOOST_NOEXCEPT\n   {\n      return m_.buffer + m_.front_idx;\n   }\n\n   /**\n    * **Returns**: A constant iterator pointing past the last element of the container.\n    *\n    * **Complexity**: Constant.\n    */\n   const_iterator cend() const BOOST_NOEXCEPT\n   {\n      return m_.buffer + m_.back_idx;\n   }\n\n   /**\n    * **Returns**: A constant reverse iterator\n    * pointing to the first element in the reversed devector,\n    * or the reverse past the end iterator if the devector is empty.\n    *\n    * **Complexity**: Constant.\n    */\n   BOOST_CONTAINER_ATTRIBUTE_NODISCARD BOOST_CONTAINER_FORCEINLINE\n    const_reverse_iterator crbegin() const BOOST_NOEXCEPT\n   {\n      return const_reverse_iterator(m_.buffer + m_.back_idx);\n   }\n\n   /**\n    * **Returns**: A constant reverse iterator pointing past the last element in the\n    * reversed container, or to the beginning of the reversed container if it's empty.\n    *\n    * **Complexity**: Constant.\n    */\n   BOOST_CONTAINER_ATTRIBUTE_NODISCARD BOOST_CONTAINER_FORCEINLINE\n    const_reverse_iterator crend() const BOOST_NOEXCEPT\n   {\n      return const_reverse_iterator(m_.buffer + m_.front_idx);\n   }\n\n   // capacity\n\n   /**\n    * **Returns**: True, if `size() == 0`, false otherwise.\n    *\n    * **Complexity**: Constant.\n    */\n   BOOST_CONTAINER_ATTRIBUTE_NODISCARD BOOST_CONTAINER_FORCEINLINE\n    bool empty() const BOOST_NOEXCEPT\n   {\n      return m_.front_idx == m_.back_idx;\n   }\n\n   /**\n    * **Returns**: The number of elements the devector contains.\n    *\n    * **Complexity**: Constant.\n    */\n   BOOST_CONTAINER_ATTRIBUTE_NODISCARD BOOST_CONTAINER_FORCEINLINE\n    size_type size() const BOOST_NOEXCEPT\n   {\n      return size_type(m_.back_idx - m_.front_idx);\n   }\n\n   /**\n    * **Returns**: The maximum number of elements the devector could possibly hold.\n    *\n    * **Complexity**: Constant.\n    */\n   BOOST_CONTAINER_ATTRIBUTE_NODISCARD BOOST_CONTAINER_FORCEINLINE\n    size_type max_size() const BOOST_NOEXCEPT\n   {\n      size_type alloc_max = allocator_traits_type::max_size(get_allocator_ref());\n      size_type size_type_max = (size_type)-1;\n      return (alloc_max <= size_type_max) ? size_type(alloc_max) : size_type_max;\n   }\n\n   /**\n   * **Returns**: The *minimum* number of elements that can be inserted into devector using\n   *   position-based insertions without requiring a reallocation. Note that, unlike in \n   *   typical sequence containers like `vector`, `capacity()`, `capacity()` can be smaller than `size()`.\n   *   This can happen if a user inserts elements in a particular way (usually inserting at\n   *   front up to front_free_capacity() and at back up to back_free_capacity()).\n   * \n   * **Complexity**: Constant.\n   */\n   BOOST_CONTAINER_ATTRIBUTE_NODISCARD BOOST_CONTAINER_FORCEINLINE\n   size_type capacity() const BOOST_NOEXCEPT\n   {\n      size_type const cap_reserve = m_.capacity/devector_min_free_fraction;\n      return m_.capacity > cap_reserve ? (m_.capacity - cap_reserve) : 0u;\n   }\n\n   /**\n    * **Returns**: The total number of elements that can be pushed to the front of the\n    * devector without requiring reallocation.\n    *\n    * **Complexity**: Constant.\n    */\n   BOOST_CONTAINER_ATTRIBUTE_NODISCARD BOOST_CONTAINER_FORCEINLINE\n   size_type front_free_capacity() const BOOST_NOEXCEPT\n   {\n      return m_.front_idx;\n   }\n\n   /**\n    * **Returns**: The total number of elements that can be pushed to the back of the\n    * devector without requiring reallocation.\n    *\n    * **Complexity**: Constant.\n    */\n   BOOST_CONTAINER_ATTRIBUTE_NODISCARD BOOST_CONTAINER_FORCEINLINE\n    size_type back_free_capacity() const BOOST_NOEXCEPT\n   {\n      return size_type(m_.capacity - m_.back_idx);\n   }\n\n   /**\n   * **Effects**: If `sz` is greater than the size of `*this`,\n   * additional value-initialized elements are inserted. Invalidates iterators\n   * if reallocation is needed. If `sz` is smaller than than the size of `*this`,\n   * elements are erased from the extremes.\n   *\n   * **Requires**: T shall be [MoveInsertable] into *this and [DefaultConstructible].\n   *\n   * **Postcondition**: `sz == size()`.\n   *\n   * **Exceptions**: Strong exception guarantee.\n   *\n   * **Complexity**: Linear in the size of `*this` and `sz`.\n   *\n   * [MoveInsertable]: http://en.cppreference.com/w/cpp/concept/MoveInsertable\n   * [DefaultConstructible]: http://en.cppreference.com/w/cpp/concept/DefaultConstructible\n   */\n   BOOST_CONTAINER_FORCEINLINE void resize(size_type sz)\n   {\n      this->resize_back(sz);\n   }\n\n   /**\n    * **Effects**: Same as resize(sz) but creates default-initialized\n    * value-initialized.\n    */\n   BOOST_CONTAINER_FORCEINLINE void resize(size_type sz, default_init_t)\n   {\n      this->resize_back(sz, default_init);\n   }\n\n   /**\n   * [CopyInsertable]: http://en.cppreference.com/w/cpp/concept/CopyInsertable\n   *\n   * **Effects**: If `sz` is greater than the size of `*this`,\n   * copies of `c` are inserted at extremes.\n   * If `sz` is smaller than than the size of `*this`,\n   * elements are popped from the extremes.\n   *\n   * **Postcondition**: `sz == size()`.\n   *\n   * **Requires**: `T` shall be [CopyInsertable] into `*this`.\n   *\n   * **Exceptions**: Strong exception guarantee.\n   *\n   * **Complexity**: Linear in the size of `*this` and `sz`.\n   */\n   BOOST_CONTAINER_FORCEINLINE void resize(size_type sz, const T& c)\n   {\n      this->resize_back(sz, c);\n   }\n\n   /**\n    * **Effects**: If `sz` is greater than the size of `*this`,\n    * additional value-initialized elements are inserted\n    * to the front. Invalidates iterators if reallocation is needed.\n    * If `sz` is smaller than than the size of `*this`,\n    * elements are popped from the front.\n    *\n    * **Requires**: T shall be [MoveInsertable] into *this and [DefaultConstructible].\n    *\n    * **Postcondition**: `sz == size()`.\n    *\n    * **Exceptions**: Strong exception guarantee.\n    *\n    * **Complexity**: Linear in the size of `*this` and `sz`.\n    *\n    * [MoveInsertable]: http://en.cppreference.com/w/cpp/concept/MoveInsertable\n    * [DefaultConstructible]: http://en.cppreference.com/w/cpp/concept/DefaultConstructible\n    */\n   BOOST_CONTAINER_FORCEINLINE void resize_front(size_type sz)\n   {\n      resize_front_impl(sz);\n      BOOST_ASSERT(invariants_ok());\n   }\n\n   /**\n    * **Effects**: If `sz` is greater than the size of `*this`,\n    * additional value-initialized elements are inserted\n    * to the front. Invalidates iterators if reallocation is needed.\n    * If `sz` is smaller than than the size of `*this`,\n    * elements are popped from the front.\n    *\n    * **Requires**: T shall be [MoveInsertable] into *this and default_initializable.\n    *\n    * **Postcondition**: `sz == size()`.\n    *\n    * **Exceptions**: Strong exception guarantee.\n    *\n    * **Complexity**: Linear in the size of `*this` and `sz`.\n    *\n    * [MoveInsertable]: http://en.cppreference.com/w/cpp/concept/MoveInsertable\n    */\n   BOOST_CONTAINER_FORCEINLINE void resize_front(size_type sz, default_init_t)\n   {\n      resize_front_impl(sz, default_init);\n      BOOST_ASSERT(invariants_ok());\n   }\n\n   /**\n    * [CopyInsertable]: http://en.cppreference.com/w/cpp/concept/CopyInsertable\n    *\n    * **Effects**: If `sz` is greater than the size of `*this`,\n    * copies of `c` are inserted to the front.\n    * Invalidates iterators if reallocation is needed.\n    * If `sz` is smaller than than the size of `*this`,\n    * elements are popped from the front.\n    *\n    * **Postcondition**: `sz == size()`.\n    *\n    * **Requires**: `T` shall be [CopyInsertable] into `*this`.\n    *\n    * **Exceptions**: Strong exception guarantee.\n    *\n    * **Complexity**: Linear in the size of `*this` and `sz`.\n    */\n   BOOST_CONTAINER_FORCEINLINE void resize_front(size_type sz, const T& c)\n   {\n      resize_front_impl(sz, c);\n      BOOST_ASSERT(invariants_ok());\n   }\n\n   /**\n    * **Effects**: If `sz` is greater than the size of `*this`,\n    * additional value-initialized elements are inserted\n    * to the back. Invalidates iterators if reallocation is needed.\n    * If `sz` is smaller than than the size of `*this`,\n    * elements are popped from the back.\n    *\n    * **Requires**: T shall be [MoveInsertable] into *this and [DefaultConstructible].\n    *\n    * **Postcondition**: `sz == size()`.\n    *\n    * **Exceptions**: Strong exception guarantee.\n    *\n    * **Complexity**: Linear in the size of `*this` and `sz`.\n    *\n    * [MoveInsertable]: http://en.cppreference.com/w/cpp/concept/MoveInsertable\n    * [DefaultConstructible]: http://en.cppreference.com/w/cpp/concept/DefaultConstructible\n    */\n   BOOST_CONTAINER_FORCEINLINE void resize_back(size_type sz)\n   {\n      resize_back_impl(sz);\n      BOOST_ASSERT(invariants_ok());\n   }\n\n   /**\n    * **Effects**: If `sz` is greater than the size of `*this`,\n    * additional value-initialized elements are inserted\n    * to the back. Invalidates iterators if reallocation is needed.\n    * If `sz` is smaller than than the size of `*this`,\n    * elements are popped from the back.\n    *\n    * **Requires**: T shall be [MoveInsertable] into *this and default initializable.\n    *\n    * **Postcondition**: `sz == size()`.\n    *\n    * **Exceptions**: Strong exception guarantee.\n    *\n    * **Complexity**: Linear in the size of `*this` and `sz`.\n    *\n    * [MoveInsertable]: http://en.cppreference.com/w/cpp/concept/MoveInsertable\n    */\n   BOOST_CONTAINER_FORCEINLINE void resize_back(size_type sz, default_init_t)\n   {\n      resize_back_impl(sz, default_init);\n      BOOST_ASSERT(invariants_ok());\n   }\n\n   /**\n    * [CopyInsertable]: http://en.cppreference.com/w/cpp/concept/CopyInsertable\n    *\n    * **Effects**: If `sz` is greater than the size of `*this`,\n    * copies of `c` are inserted to the back.\n    * If `sz` is smaller than than the size of `*this`,\n    * elements are popped from the back.\n    *\n    * **Postcondition**: `sz == size()`.\n    *\n    * **Requires**: `T` shall be [CopyInsertable] into `*this`.\n    *\n    * **Exceptions**: Strong exception guarantee.\n    *\n    * **Complexity**: Linear in the size of `*this` and `sz`.\n    */\n   BOOST_CONTAINER_FORCEINLINE void resize_back(size_type sz, const T& c)\n   {\n      resize_back_impl(sz, c);\n      BOOST_ASSERT(invariants_ok());\n   }\n\n   /**\n    * [MoveInsertable]: http://en.cppreference.com/w/cpp/concept/MoveInsertable\n    *\n    * **Effects**: Ensures that at least `n` elements can be inserted\n    * without requiring reallocation, where `n` is `new_capacity - size()`,\n    * if `n` is positive. Otherwise, there are no effects.\n    * Invalidates iterators if reallocation is needed.\n    *\n    * **Requires**: `T` shall be [MoveInsertable] into `*this`.\n    *\n    * **Complexity**: Linear in the size of *this.\n    *\n    * **Exceptions**: Strong exception guarantee.\n    *\n    * **Throws**: length_error if `new_capacity > max_size()`.\n    */\n   BOOST_CONTAINER_FORCEINLINE void reserve(size_type new_capacity)\n   {\n      if (this->capacity() < new_capacity) {\n         const size_type rounder = devector_min_free_fraction - 2u;\n         const size_type divisor = devector_min_free_fraction - 1u;\n         size_type const nc = ((new_capacity + rounder)/divisor)*devector_min_free_fraction;\n         BOOST_ASSERT(new_capacity <= (nc - nc / devector_min_free_fraction));\n         size_type const sz = this->size();\n         reallocate_at(nc, (nc-sz)/2u);\n      }\n      BOOST_ASSERT(invariants_ok());\n   }\n\n   /**\n    * [MoveInsertable]: http://en.cppreference.com/w/cpp/concept/MoveInsertable\n    *\n    * **Effects**: Ensures that `n` elements can be pushed to the front\n    * without requiring reallocation, where `n` is `new_capacity - size()`,\n    * if `n` is positive. Otherwise, there are no effects.\n    * Invalidates iterators if reallocation is needed.\n    *\n    * **Requires**: `T` shall be [MoveInsertable] into `*this`.\n    *\n    * **Complexity**: Linear in the size of *this.\n    *\n    * **Exceptions**: Strong exception guarantee.\n    *\n    * **Throws**: `length_error` if `new_capacity > max_size()`.\n    */\n   BOOST_CONTAINER_FORCEINLINE void reserve_front(size_type new_capacity)\n   {\n      if (front_capacity() >= new_capacity) { return; }\n\n      reallocate_at(new_capacity + back_free_capacity(), new_capacity - size());\n\n      BOOST_ASSERT(invariants_ok());\n   }\n\n   /**\n    * [MoveInsertable]: http://en.cppreference.com/w/cpp/concept/MoveInsertable\n    *\n    * **Effects**: Ensures that `n` elements can be pushed to the back\n    * without requiring reallocation, where `n` is `new_capacity - size()`,\n    * if `n` is positive. Otherwise, there are no effects.\n    * Invalidates iterators if reallocation is needed.\n    *\n    * **Requires**: `T` shall be [MoveInsertable] into `*this`.\n    *\n    * **Complexity**: Linear in the size of *this.\n    *\n    * **Exceptions**: Strong exception guarantee.\n    *\n    * **Throws**: length_error if `new_capacity > max_size()`.\n    */\n   BOOST_CONTAINER_FORCEINLINE void reserve_back(size_type new_capacity)\n   {\n      if (back_capacity() >= new_capacity) { return; }\n\n      reallocate_at(new_capacity + front_free_capacity(), m_.front_idx);\n\n      BOOST_ASSERT(invariants_ok());\n   }\n\n\n   /**\n    * [MoveInsertable]: http://en.cppreference.com/w/cpp/concept/MoveInsertable\n    *\n    * **Effects**: Reduces `capacity()` to `size()`. Invalidates iterators.\n    *\n    * **Requires**: `T` shall be [MoveInsertable] into `*this`.\n    *\n    * **Exceptions**: Strong exception guarantee.\n    *\n    * **Complexity**: Linear in the size of *this.\n    */\n   BOOST_CONTAINER_FORCEINLINE void shrink_to_fit()\n   {\n      if(this->front_capacity() || this->back_capacity())\n            this->reallocate_at(size(), 0);\n   }\n\n   // element access:\n\n   /**\n    * **Returns**: A reference to the `n`th element in the devector.\n    *\n    * **Precondition**: `n < size()`.\n    *\n    * **Complexity**: Constant.\n    */\n   BOOST_CONTAINER_ATTRIBUTE_NODISCARD BOOST_CONTAINER_FORCEINLINE\n   reference operator[](size_type n) BOOST_NOEXCEPT\n   {\n      BOOST_ASSERT(n < size());\n      return m_.buffer[m_.front_idx + n];\n   }\n\n   /**\n    * **Returns**: A constant reference to the `n`th element in the devector.\n    *\n    * **Precondition**: `n < size()`.\n    *\n    * **Complexity**: Constant.\n    */\n   BOOST_CONTAINER_ATTRIBUTE_NODISCARD BOOST_CONTAINER_FORCEINLINE\n   const_reference operator[](size_type n) const BOOST_NOEXCEPT\n   {\n      BOOST_ASSERT(n < size());\n      return m_.buffer[m_.front_idx + n];\n   }\n\n   /**\n   * **Returns**: A reference to the `n`th element in the devector.\n   *\n   * **Throws**: `out_of_range`, if `n >= size()`.\n   *\n   * **Complexity**: Constant.\n   */\n   BOOST_CONTAINER_ATTRIBUTE_NODISCARD BOOST_CONTAINER_FORCEINLINE\n      reference at(size_type n)\n   {\n      if (size() <= n)\n            throw_out_of_range(\"devector::at out of range\");\n      return (*this)[n];\n   }\n\n   /**\n   * **Returns**: A constant reference to the `n`th element in the devector.\n   *\n   * **Throws**: `out_of_range`, if `n >= size()`.\n   *\n   * **Complexity**: Constant.\n   */\n   BOOST_CONTAINER_ATTRIBUTE_NODISCARD BOOST_CONTAINER_FORCEINLINE\n      const_reference at(size_type n) const\n   {\n      if (size() <= n)\n            throw_out_of_range(\"devector::at out of range\");\n      return (*this)[n];\n   }\n\n   /**\n   * **Returns**: A reference to the first element in the devector.\n   *\n   * **Precondition**: `!empty()`.\n   *\n   * **Complexity**: Constant.\n   */\n   BOOST_CONTAINER_ATTRIBUTE_NODISCARD BOOST_CONTAINER_FORCEINLINE\n      reference front() BOOST_NOEXCEPT\n   {\n      BOOST_ASSERT(!empty());\n\n      return m_.buffer[m_.front_idx];\n   }\n\n   /**\n   * **Returns**: A constant reference to the first element in the devector.\n   *\n   * **Precondition**: `!empty()`.\n   *\n   * **Complexity**: Constant.\n   */\n   BOOST_CONTAINER_ATTRIBUTE_NODISCARD BOOST_CONTAINER_FORCEINLINE\n      const_reference front() const BOOST_NOEXCEPT\n   {\n      BOOST_ASSERT(!empty());\n\n      return m_.buffer[m_.front_idx];\n   }\n\n   /**\n   * **Returns**: A reference to the last element in the devector.\n   *\n   * **Precondition**: `!empty()`.\n   *\n   * **Complexity**: Constant.\n   */\n   BOOST_CONTAINER_ATTRIBUTE_NODISCARD BOOST_CONTAINER_FORCEINLINE\n      reference back() BOOST_NOEXCEPT\n   {\n      BOOST_ASSERT(!empty());\n\n      return m_.buffer[m_.back_idx - 1u];\n   }\n\n   /**\n   * **Returns**: A constant reference to the last element in the devector.\n   *\n   * **Precondition**: `!empty()`.\n   *\n   * **Complexity**: Constant.\n   */\n   BOOST_CONTAINER_ATTRIBUTE_NODISCARD BOOST_CONTAINER_FORCEINLINE\n      const_reference back() const BOOST_NOEXCEPT\n   {\n      BOOST_ASSERT(!empty());\n\n      return m_.buffer[m_.back_idx - 1u];\n   }\n\n   /**\n   * **Returns**: A pointer to the underlying array serving as element storage.\n   * The range `[data(); data() + size())` is always valid. For a non-empty devector,\n   * `data() == &front()`.\n   *\n   * **Complexity**: Constant.\n   */\n   BOOST_CONTAINER_ATTRIBUTE_NODISCARD BOOST_CONTAINER_FORCEINLINE\n      T* data() BOOST_NOEXCEPT\n   {\n      return boost::movelib::to_raw_pointer(m_.buffer) + m_.front_idx;\n   }\n\n   /**\n   * **Returns**: A constant pointer to the underlying array serving as element storage.\n   * The range `[data(); data() + size())` is always valid. For a non-empty devector,\n   * `data() == &front()`.\n   *\n   * **Complexity**: Constant.\n   */\n   BOOST_CONTAINER_ATTRIBUTE_NODISCARD BOOST_CONTAINER_FORCEINLINE\n      const T* data() const BOOST_NOEXCEPT\n   {\n      return boost::movelib::to_raw_pointer(m_.buffer) + m_.front_idx;\n   }\n\n   // modifiers:\n\n   /**\n   * **Effects**: Pushes a new element to the front of the devector.\n   * The element is constructed in-place, using the perfect forwarded `args`\n   * as constructor arguments. Invalidates iterators if reallocation is needed.\n   * (`front_free_capacity() == 0`)\n   *\n   * **Requires**: `T` shall be [EmplaceConstructible] from `args` and [MoveInsertable] into `*this`.\n   *\n   * **Exceptions**: Strong exception guarantee.\n   *\n   * **Complexity**: Amortized constant in the size of `*this`.\n   * (Constant, if `front_free_capacity() > 0`)\n   *\n   * [EmplaceConstructible]: http://en.cppreference.com/w/cpp/concept/EmplaceConstructible\n   * [MoveInsertable]: http://en.cppreference.com/w/cpp/concept/MoveInsertable\n   */\n   #if !defined(BOOST_NO_CXX11_VARIADIC_TEMPLATES) || defined(BOOST_CONTAINER_DOXYGEN_INVOKED)\n   template <class... Args>\n   reference emplace_front(Args&&... args)\n   {\n      if (BOOST_LIKELY(front_free_capacity() != 0)) // fast path\n      {\n         pointer const p = m_.buffer + (m_.front_idx - 1u);\n         this->alloc_construct(p, boost::forward<Args>(args)...);\n         --m_.front_idx;\n         BOOST_ASSERT(invariants_ok());\n         return *p;\n      }\n      else\n      {\n         typedef dtl::insert_emplace_proxy<allocator_type, Args...> proxy_t;\n         return *this->insert_range_slow_path(this->begin(), 1, proxy_t(::boost::forward<Args>(args)...));\n      }\n   }\n\n   #else //!defined(BOOST_NO_CXX11_VARIADIC_TEMPLATES) || defined(BOOST_CONTAINER_DOXYGEN_INVOKED)\n\n   #define BOOST_CONTAINER_DEVECTOR_EMPLACE_FRONT(N) \\\n   BOOST_MOVE_TMPL_LT##N BOOST_MOVE_CLASS##N BOOST_MOVE_GT##N \\\n   BOOST_CONTAINER_FORCEINLINE reference emplace_front(BOOST_MOVE_UREF##N)\\\n   {\\\n      if (front_free_capacity())\\\n      {\\\n         pointer const p = m_.buffer + (m_.front_idx - 1u);\\\n         this->alloc_construct(p BOOST_MOVE_I##N BOOST_MOVE_FWD##N);\\\n         --m_.front_idx;\\\n         return *p;\\\n      }\\\n      else\\\n      {\\\n         typedef dtl::insert_emplace_proxy_arg##N<allocator_type BOOST_MOVE_I##N BOOST_MOVE_TARG##N> proxy_t;\\\n         return *this->insert_range_slow_path(this->begin(), 1, proxy_t(BOOST_MOVE_FWD##N));\\\n      }\\\n   }\\\n   //\n   BOOST_MOVE_ITERATE_0TO9(BOOST_CONTAINER_DEVECTOR_EMPLACE_FRONT)\n   #undef BOOST_CONTAINER_DEVECTOR_EMPLACE_FRONT\n\n   #endif\n\n   #if defined(BOOST_CONTAINER_DOXYGEN_INVOKED)\n   /**\n   * [CopyInsertable]: http://en.cppreference.com/w/cpp/concept/CopyInsertable\n   *\n   * **Effects**: Pushes the copy of `x` to the front of the devector.\n   * Invalidates iterators if reallocation is needed.\n   * (`front_free_capacity() == 0`)\n   *\n   * **Requires**: `T` shall be [CopyInsertable] into `*this`.\n   *\n   * **Exceptions**: Strong exception guarantee.\n   *\n   * **Complexity**: Amortized constant in the size of `*this`.\n   * (Constant, if `front_free_capacity() > 0`)\n   */\n   void push_front(const T& x);\n\n   /**\n   * [MoveInsertable]: http://en.cppreference.com/w/cpp/concept/MoveInsertable\n   *\n   * **Effects**: Move constructs a new element at the front of the devector using `x`.\n   * Invalidates iterators if reallocation is needed.\n   * (`front_free_capacity() == 0`)\n   *\n   * **Requires**: `T` shall be [MoveInsertable] into `*this`.\n   *\n   * **Exceptions**: Strong exception guarantee, not regarding the state of `x`.\n   *\n   * **Complexity**: Amortized constant in the size of `*this`.\n   * (Constant, if `front_free_capacity() > 0`)\n   */\n   void push_front(T&& x);\n\n   #else\n   BOOST_MOVE_CONVERSION_AWARE_CATCH(push_front, T, void, priv_push_front)\n   #endif\n\n   /**\n   * **Effects**: Removes the first element of `*this`.\n   *\n   * **Precondition**: `!empty()`.\n   *\n   * **Postcondition**: `front_free_capacity()` is incremented by 1.\n   *\n   * **Complexity**: Constant.\n   */\n   void pop_front() BOOST_NOEXCEPT\n   {\n      BOOST_ASSERT(!empty());\n      allocator_traits_type::destroy(get_allocator_ref(), boost::movelib::to_raw_pointer(m_.buffer + m_.front_idx));\n      ++m_.front_idx;\n      BOOST_ASSERT(invariants_ok());\n   }\n\n   /**\n   * **Effects**: Pushes a new element to the back of the devector.\n   * The element is constructed in-place, using the perfect forwarded `args`\n   * as constructor arguments. Invalidates iterators if reallocation is needed.\n   * (`back_free_capacity() == 0`)\n   *\n   * **Requires**: `T` shall be [EmplaceConstructible] from `args` and [MoveInsertable] into `*this`,\n   * and [MoveAssignable].\n   *\n   * **Exceptions**: Strong exception guarantee.\n   *\n   * **Complexity**: Amortized constant in the size of `*this`.\n   * (Constant, if `back_free_capacity() > 0`)\n   *\n   * [EmplaceConstructible]: http://en.cppreference.com/w/cpp/concept/EmplaceConstructible\n   * [MoveInsertable]: http://en.cppreference.com/w/cpp/concept/MoveInsertable\n   * [MoveAssignable]: http://en.cppreference.com/w/cpp/concept/MoveAssignable\n   */\n   #if !defined(BOOST_NO_CXX11_VARIADIC_TEMPLATES) || defined(BOOST_CONTAINER_DOXYGEN_INVOKED)\n   template <class... Args>\n   BOOST_CONTAINER_FORCEINLINE reference emplace_back(Args&&... args)\n   {\n      if (BOOST_LIKELY(this->back_free_capacity() != 0)){\n         pointer const p = m_.buffer + m_.back_idx;\n         this->alloc_construct(p, boost::forward<Args>(args)...);\n         ++m_.back_idx;\n         BOOST_ASSERT(invariants_ok());\n         return *p;\n      }\n      else {\n         typedef dtl::insert_emplace_proxy<allocator_type, Args...> proxy_t;\n         return *this->insert_range_slow_path(this->end(), 1, proxy_t(::boost::forward<Args>(args)...));\n      }\n   }\n\n   #else //!defined(BOOST_NO_CXX11_VARIADIC_TEMPLATES) || defined(BOOST_CONTAINER_DOXYGEN_INVOKED)\n\n   #define BOOST_CONTAINER_DEVECTOR_EMPLACE_BACK(N) \\\n   BOOST_MOVE_TMPL_LT##N BOOST_MOVE_CLASS##N BOOST_MOVE_GT##N \\\n   BOOST_CONTAINER_FORCEINLINE reference emplace_back(BOOST_MOVE_UREF##N)\\\n   {\\\n      if (this->back_free_capacity()){\\\n         pointer const p = m_.buffer + m_.back_idx;\\\n         this->alloc_construct(p BOOST_MOVE_I##N BOOST_MOVE_FWD##N);\\\n         ++m_.back_idx;\\\n         return *p;\\\n      }\\\n      else {\\\n         typedef dtl::insert_emplace_proxy_arg##N<allocator_type BOOST_MOVE_I##N BOOST_MOVE_TARG##N> proxy_t;\\\n         return *this->insert_range_slow_path(this->end(), 1, proxy_t(BOOST_MOVE_FWD##N));\\\n      }\\\n   }\\\n   //\n   BOOST_MOVE_ITERATE_0TO9(BOOST_CONTAINER_DEVECTOR_EMPLACE_BACK)\n   #undef BOOST_CONTAINER_DEVECTOR_EMPLACE_BACK\n\n   #endif    //!defined(BOOST_NO_CXX11_VARIADIC_TEMPLATES) || defined(BOOST_CONTAINER_DOXYGEN_INVOKED)\n\n\n   #if defined(BOOST_CONTAINER_DOXYGEN_INVOKED)\n   /**\n   * [CopyInsertable]: http://en.cppreference.com/w/cpp/concept/CopyInsertable\n   *\n   * **Effects**: Pushes the copy of `x` to the back of the devector.\n   * Invalidates iterators if reallocation is needed.\n   * (`back_free_capacity() == 0`)\n   *\n   * **Requires**: `T` shall be [CopyInsertable] into `*this`.\n   *\n   * **Exceptions**: Strong exception guarantee.\n   *\n   * **Complexity**: Amortized constant in the size of `*this`.\n   * (Constant, if `back_free_capacity() > 0`)\n   */\n   void push_back(const T& x);\n\n   /**\n   * [MoveInsertable]: http://en.cppreference.com/w/cpp/concept/MoveInsertable\n   *\n   * **Effects**: Move constructs a new element at the back of the devector using `x`.\n   * Invalidates iterators if reallocation is needed.\n   * (`back_free_capacity() == 0`)\n   *\n   * **Requires**: `T` shall be [MoveInsertable] into `*this`.\n   *\n   * **Exceptions**: Strong exception guarantee, not regarding the state of `x`.\n   *\n   * **Complexity**: Amortized constant in the size of `*this`.\n   * (Constant, if `back_free_capacity() > 0`)\n   */\n   void push_back(T&& x);\n\n   #else\n   BOOST_MOVE_CONVERSION_AWARE_CATCH(push_back, T, void, priv_push_back)\n   #endif\n\n   /**\n   * **Effects**: Removes the last element of `*this`.\n   *\n   * **Precondition**: `!empty()`.\n   *\n   * **Postcondition**: `back_free_capacity()` is incremented by 1.\n   *\n   * **Complexity**: Constant.\n   */\n   void pop_back() BOOST_NOEXCEPT\n   {\n      BOOST_ASSERT(! empty());\n      --m_.back_idx;\n      allocator_traits_type::destroy(get_allocator_ref(), boost::movelib::to_raw_pointer(m_.buffer + m_.back_idx));\n      BOOST_ASSERT(invariants_ok());\n   }\n\n   /**\n   * **Effects**: Constructs a new element before the element pointed by `position`.\n   * The element is constructed in-place, using the perfect forwarded `args`\n   * as constructor arguments. Invalidates iterators if reallocation is needed.\n   *\n   * **Requires**: `T` shall be [EmplaceConstructible], and [MoveInsertable] into `*this`,\n   * and [MoveAssignable].\n   *\n   * **Returns**: Iterator pointing to the newly constructed element.\n   *\n   * **Exceptions**: Strong exception guarantee if `T` is `NothrowConstructible`\n   * and `NothrowAssignable`, Basic exception guarantee otherwise.\n   *\n   * **Complexity**: Linear in the size of `*this`.\n   *\n   * [EmplaceConstructible]: http://en.cppreference.com/w/cpp/concept/EmplaceConstructible\n   * [MoveInsertable]: http://en.cppreference.com/w/cpp/concept/MoveInsertable\n   * [MoveAssignable]: http://en.cppreference.com/w/cpp/concept/MoveAssignable\n   */\n   #if !defined(BOOST_NO_CXX11_VARIADIC_TEMPLATES) || defined(BOOST_CONTAINER_DOXYGEN_INVOKED)\n   template <class... Args>\n   iterator emplace(const_iterator position, Args&&... args)\n   {\n      BOOST_ASSERT(position >= begin());\n      BOOST_ASSERT(position <= end());\n      typedef dtl::insert_emplace_proxy<allocator_type, Args...> proxy_t;\n      bool prefer_move_back;\n      if (position == end()){\n         if(back_free_capacity()) // fast path\n         {\n            pointer const p = m_.buffer + m_.back_idx;\n            this->alloc_construct(p, boost::forward<Args>(args)...);\n            ++m_.back_idx;\n            return iterator(p);\n         }\n         prefer_move_back = true;\n      }\n      else if (position == begin()){\n         if(front_free_capacity()) // secondary fast path\n         {\n            pointer const p = m_.buffer + (m_.front_idx - 1);\n            this->alloc_construct(p, boost::forward<Args>(args)...);\n            --m_.front_idx;\n            return iterator(p);\n         }\n         prefer_move_back = false;\n      }\n      else{\n         iterator nonconst_pos = unconst_iterator(position);\n         prefer_move_back = should_move_back(position);\n\n         if(prefer_move_back){\n            if(back_free_capacity()){\n               boost::container::expand_forward_and_insert_nonempty_middle_alloc\n                  ( get_allocator_ref()\n                  , boost::movelib::to_raw_pointer(nonconst_pos)\n                  , this->priv_raw_end()\n                  , 1, proxy_t(::boost::forward<Args>(args)...));\n               ++m_.back_idx;\n               return nonconst_pos;\n            }\n         }\n         else{\n            if (front_free_capacity()){\n               boost::container::expand_backward_and_insert_nonempty_middle_alloc\n               (get_allocator_ref()\n                  , this->priv_raw_begin()\n                  , boost::movelib::to_raw_pointer(nonconst_pos)\n                  , 1, proxy_t(::boost::forward<Args>(args)...));\n               --m_.front_idx;\n               return --nonconst_pos;\n            }\n         }\n      }\n      return this->insert_range_slow_path(position, 1, proxy_t(::boost::forward<Args>(args)...));\n   }\n\n   #else //!defined(BOOST_NO_CXX11_VARIADIC_TEMPLATES) || defined(BOOST_CONTAINER_DOXYGEN_INVOKED)\n\n   #define BOOST_CONTAINER_DEVECTOR_EMPLACE(N) \\\n   BOOST_MOVE_TMPL_LT##N BOOST_MOVE_CLASS##N BOOST_MOVE_GT##N \\\n   iterator emplace(const_iterator position BOOST_MOVE_I##N BOOST_MOVE_UREF##N)\\\n   {\\\n      BOOST_ASSERT(position >= begin());\\\n      BOOST_ASSERT(position <= end());\\\n      typedef dtl::insert_emplace_proxy_arg##N<allocator_type  BOOST_MOVE_I##N BOOST_MOVE_TARG##N> proxy_t;\\\n      bool prefer_move_back;\\\n      if (position == end()){\\\n         if(back_free_capacity())\\\n         {\\\n            pointer const p = m_.buffer + m_.back_idx;\\\n            this->alloc_construct(p BOOST_MOVE_I##N BOOST_MOVE_FWD##N);\\\n            ++m_.back_idx;\\\n            return iterator(p);\\\n         }\\\n         prefer_move_back = true;\\\n      }\\\n      else if (position == begin()){\\\n         if(front_free_capacity())\\\n         {\\\n            pointer const p = m_.buffer + (m_.front_idx - 1);\\\n            this->alloc_construct(p BOOST_MOVE_I##N BOOST_MOVE_FWD##N);\\\n            --m_.front_idx;\\\n            return iterator(p);\\\n         }\\\n         prefer_move_back = false;\\\n      }\\\n      else{\\\n         iterator nonconst_pos = unconst_iterator(position);\\\n         prefer_move_back = should_move_back(position);\\\n         \\\n         if(prefer_move_back){\\\n            if(back_free_capacity()){\\\n               boost::container::expand_forward_and_insert_nonempty_middle_alloc\\\n                  ( get_allocator_ref()\\\n                  , boost::movelib::to_raw_pointer(nonconst_pos)\\\n                  , this->priv_raw_end()\\\n                  , 1, proxy_t(BOOST_MOVE_FWD##N));\\\n               ++m_.back_idx;\\\n               return nonconst_pos;\\\n            }\\\n         }\\\n         else{\\\n            if (front_free_capacity()){\\\n               boost::container::expand_backward_and_insert_nonempty_middle_alloc\\\n               (get_allocator_ref()\\\n                  , this->priv_raw_begin()\\\n                  , boost::movelib::to_raw_pointer(nonconst_pos)\\\n                  , 1, proxy_t(BOOST_MOVE_FWD##N));\\\n               --m_.front_idx;\\\n               return --nonconst_pos;\\\n            }\\\n         }\\\n      }\\\n      return this->insert_range_slow_path(position, 1, proxy_t(BOOST_MOVE_FWD##N));\\\n   }\\\n   //\n   BOOST_MOVE_ITERATE_0TO9(BOOST_CONTAINER_DEVECTOR_EMPLACE)\n   #undef BOOST_CONTAINER_DEVECTOR_EMPLACE\n\n   #endif    //!defined(BOOST_NO_CXX11_VARIADIC_TEMPLATES) || defined(BOOST_CONTAINER_DOXYGEN_INVOKED)\n\n\n   #if defined(BOOST_CONTAINER_DOXYGEN_INVOKED)\n   /**\n   * **Effects**: Copy constructs a new element before the element pointed by `position`,\n   * using `x` as constructor argument. Invalidates iterators if reallocation is needed.\n   *\n   * **Requires**: `T` shall be [CopyInsertable] into `*this` and and [CopyAssignable].\n   *\n   * **Returns**: Iterator pointing to the newly constructed element.\n   *\n   * **Exceptions**: Strong exception guarantee if `T` is `NothrowConstructible`\n   * and `NothrowAssignable`, Basic exception guarantee otherwise.\n   *\n   * **Complexity**: Linear in the size of `*this`.\n   *\n   * [CopyInsertable]: http://en.cppreference.com/w/cpp/concept/CopyInsertable\n   * [CopyAssignable]: http://en.cppreference.com/w/cpp/concept/CopyAssignable\n   */\n   iterator insert(const_iterator position, const T &x);\n\n   /**\n   * **Effects**: Move constructs a new element before the element pointed by `position`,\n   * using `x` as constructor argument. Invalidates iterators if reallocation is needed.\n   *\n   * **Requires**: `T` shall be [MoveInsertable] into `*this` and and [CopyAssignable].\n   *\n   * **Returns**: Iterator pointing to the newly constructed element.\n   *\n   * **Exceptions**: Strong exception guarantee if `T` is `NothrowConstructible`\n   * and `NothrowAssignable` (not regarding the state of `x`),\n   * Basic exception guarantee otherwise.\n   *\n   * **Complexity**: Linear in the size of `*this`.\n   *\n   * [MoveInsertable]: http://en.cppreference.com/w/cpp/concept/MoveInsertable\n   * [CopyAssignable]: http://en.cppreference.com/w/cpp/concept/CopyAssignable\n   */\n   iterator insert(const_iterator position, T &&x);\n   #else\n   BOOST_MOVE_CONVERSION_AWARE_CATCH_1ARG(insert, T, iterator, priv_insert, const_iterator, const_iterator)\n   #endif\n\n   /**\n   * **Effects**: Copy constructs `n` elements before the element pointed by `position`,\n   * using `x` as constructor argument. Invalidates iterators if reallocation is needed.\n   *\n   * **Requires**: `T` shall be [CopyInsertable] into `*this` and and [CopyAssignable].\n   *\n   * **Returns**: Iterator pointing to the first inserted element, or `position`, if `n` is zero.\n   *\n   * **Exceptions**: Strong exception guarantee if `T` is `NothrowConstructible`\n   * and `NothrowAssignable`, Basic exception guarantee otherwise.\n   *\n   * **Complexity**: Linear in the size of `*this` and `n`.\n   *\n   * [CopyInsertable]: http://en.cppreference.com/w/cpp/concept/CopyInsertable\n   * [CopyAssignable]: http://en.cppreference.com/w/cpp/concept/CopyAssignable\n   */\n   BOOST_CONTAINER_FORCEINLINE iterator insert(const_iterator position, size_type n, const T& x)\n   {\n      cvalue_iterator first(x, n);\n      cvalue_iterator last = first + n;\n      return this->insert_range(position, first, last);\n   }\n\n   /**\n   * **Effects**: Copy constructs elements before the element pointed by position\n   * using each element in the range pointed by `first` and `last` as constructor arguments.\n   * Invalidates iterators if reallocation is needed.\n   *\n   * **Requires**: `T` shall be [EmplaceConstructible] into `*this` from `*first`. If the specified iterator\n   * does not meet the forward iterator requirements, `T` shall also be [MoveInsertable] into `*this`\n   * and [MoveAssignable].\n   *\n   * **Precondition**: `first` and `last` are not iterators into `*this`.\n   *\n   * **Returns**: Iterator pointing to the first inserted element, or `position`, if `first == last`.\n   *\n   * **Complexity**: Linear in the size of `*this` and `N` (where `N` is the distance between `first` and `last`).\n   * Makes only `N` calls to the constructor of `T` and no reallocations if iterators `first` and `last`\n   * are of forward, bidirectional, or random access categories. It makes 2N calls to the copy constructor of `T`\n   * and `O(log(N)) reallocations if they are just input iterators.\n   *\n   * **Exceptions**: Strong exception guarantee if `T` is `NothrowConstructible`\n   * and `NothrowAssignable`, Basic exception guarantee otherwise.\n   *\n   * **Remarks**: Each iterator in the range `[first,last)` shall be dereferenced exactly once,\n   * unless an exception is thrown.\n   *\n   * [EmplaceConstructible]: http://en.cppreference.com/w/cpp/concept/EmplaceConstructible\n   * [MoveInsertable]: http://en.cppreference.com/w/cpp/concept/MoveInsertable\n   * [MoveAssignable]: http://en.cppreference.com/w/cpp/concept/MoveAssignable\n   */\n   template <class InputIterator>\n   iterator insert(const_iterator position, InputIterator first, InputIterator last\n      //Input iterators\n      BOOST_CONTAINER_DOCIGN(BOOST_MOVE_I typename dtl::disable_if_or\n            < void\n            BOOST_MOVE_I dtl::is_convertible<InputIterator BOOST_MOVE_I size_type>\n            BOOST_MOVE_I dtl::is_not_input_iterator<InputIterator>\n            >::type * = 0)\n      )\n   {\n      if (position == end())\n      {\n         size_type insert_index = size();\n\n         for (; first != last; ++first)\n         {\n            this->emplace_back(*first);\n         }\n\n         return begin() + insert_index;\n      }\n      else\n      {\n         const size_type insert_index = static_cast<size_type>(position - this->cbegin());\n         const size_type old_size = static_cast<size_type>(this->size());\n\n         for (; first != last; ++first) {\n            this->emplace_back(*first);\n         }\n         iterator rit (this->begin() + insert_index);\n         boost::movelib::rotate_gcd(rit, this->begin() + old_size, this->begin() + this->size());\n         return rit;\n      }\n   }\n\n   #ifndef BOOST_CONTAINER_DOXYGEN_INVOKED\n\n   template <class ForwardIterator>\n   BOOST_CONTAINER_FORCEINLINE iterator insert(const_iterator position, ForwardIterator first, ForwardIterator last\n      //Other iterators\n      BOOST_CONTAINER_DOCIGN(BOOST_MOVE_I typename dtl::disable_if_or\n            < void\n            BOOST_MOVE_I dtl::is_convertible<ForwardIterator BOOST_MOVE_I size_type>\n            BOOST_MOVE_I dtl::is_input_iterator<ForwardIterator>\n            >::type * = 0)\n      )\n   {\n      return insert_range(position, first, last);\n   }\n\n   #endif // ifndef BOOST_CONTAINER_DOXYGEN_INVOKED\n\n   #if !defined(BOOST_NO_CXX11_HDR_INITIALIZER_LIST)\n   /** **Equivalent to**: `insert(position, il.begin(), il.end())` */\n   BOOST_CONTAINER_FORCEINLINE iterator insert(const_iterator position, std::initializer_list<T> il)\n   {\n      return this->insert(position, il.begin(), il.end());\n   }\n   #endif\n\n   /**\n   * [MoveAssignable]: http://en.cppreference.com/w/cpp/concept/MoveAssignable\n   *\n   * **Effects**: Destroys the element pointed by `position` and removes it from the devector.\n   * Invalidates iterators.\n   *\n   * **Requires**: `T` shall be [MoveAssignable].\n   *\n   * **Precondition**: `position` must be in the range of `[begin(), end())`.\n   *\n   * **Returns**: Iterator pointing to the element immediately following the erased element\n   * prior to its erasure. If no such element exists, `end()` is returned.\n   *\n   * **Exceptions**: Strong exception guarantee if `T` is `NothrowAssignable`,\n   * Basic exception guarantee otherwise.\n   *\n   * **Complexity**: Linear in half the size of `*this`.\n   */\n   iterator erase(const_iterator position)\n   {\n      return erase(position, position + 1);\n   }\n\n   /**\n   * [MoveAssignable]: http://en.cppreference.com/w/cpp/concept/MoveAssignable\n   *\n   * **Effects**: Destroys the range `[first,last)` and removes it from the devector.\n   * Invalidates iterators.\n   *\n   * **Requires**: `T` shall be [MoveAssignable].\n   *\n   * **Precondition**: `[first,last)` must be in the range of `[begin(), end())`.\n   *\n   * **Returns**: Iterator pointing to the element pointed to by `last` prior to any elements\n   * being erased. If no such element exists, `end()` is returned.\n   *\n   * **Exceptions**: Strong exception guarantee if `T` is `NothrowAssignable`,\n   * Basic exception guarantee otherwise.\n   *\n   * **Complexity**: Linear in half the size of `*this`\n   * plus the distance between `first` and `last`.\n   */\n   iterator erase(const_iterator first, const_iterator last)\n   {\n      iterator nc_first = unconst_iterator(first);\n      iterator nc_last  = unconst_iterator(last);\n      return erase(nc_first, nc_last);\n   }\n\n   /**\n   * [MoveAssignable]: http://en.cppreference.com/w/cpp/concept/MoveAssignable\n   *\n   * **Effects**: Destroys the range `[first,last)` and removes it from the devector.\n   * Invalidates iterators.\n   *\n   * **Requires**: `T` shall be [MoveAssignable].\n   *\n   * **Precondition**: `[first,last)` must be in the range of `[begin(), end())`.\n   *\n   * **Returns**: Iterator pointing to the element pointed to by `last` prior to any elements\n   * being erased. If no such element exists, `end()` is returned.\n   *\n   * **Exceptions**: Strong exception guarantee if `T` is `NothrowAssignable`,\n   * Basic exception guarantee otherwise.\n   *\n   * **Complexity**: Linear in half the size of `*this`.\n   */\n   iterator erase(iterator first, iterator last)\n   {\n      size_type front_distance = pos_to_index(last);\n      size_type back_distance  = size_type(end() - first);\n      size_type n = boost::container::iterator_udistance(first, last);\n\n      if (front_distance < back_distance)\n      {\n            // move n to the right\n            boost::container::move_backward(begin(), first, last);\n\n            for (iterator i = begin(); i != begin() + n; ++i)\n            {\n               allocator_traits_type::destroy(get_allocator_ref(), boost::movelib::to_raw_pointer(i));\n            }\n            //n is always less than max stored_size_type\n            m_.set_front_idx(m_.front_idx + n);\n\n            BOOST_ASSERT(invariants_ok());\n            return last;\n      }\n      else {\n            // move n to the left\n            boost::container::move(last, end(), first);\n\n            for (iterator i = end() - n; i != end(); ++i)\n            {\n               allocator_traits_type::destroy(get_allocator_ref(), boost::movelib::to_raw_pointer(i));\n            }\n            //n is always less than max stored_size_type\n            m_.set_back_idx(m_.back_idx - n);\n\n            BOOST_ASSERT(invariants_ok());\n            return first;\n      }\n   }\n\n   /**\n   * [MoveInsertable]: http://en.cppreference.com/w/cpp/concept/MoveInsertable\n   *\n   * **Effects**: exchanges the contents of `*this` and `b`.\n   *\n   * **Requires**: instances of `T` must be swappable by unqualified call of `swap`\n   * and `T` must be [MoveInsertable] into `*this`.\n   *\n   * **Precondition**: The allocators should allow propagation or should compare equal.\n   *\n   * **Exceptions**: Basic exceptions guarantee if not `noexcept`.\n   *\n   * **Complexity**: Constant.\n   */\n   void swap(devector& b)\n      BOOST_NOEXCEPT_IF( allocator_traits_type::propagate_on_container_swap::value\n                                 || allocator_traits_type::is_always_equal::value)\n   {\n      BOOST_CONSTEXPR_OR_CONST bool propagate_alloc = allocator_traits_type::propagate_on_container_swap::value;\n      BOOST_ASSERT(propagate_alloc || get_allocator_ref() == b.get_allocator_ref()); // else it's undefined behavior\n\n      swap_big_big(*this, b);\n\n      // swap indices\n      boost::adl_move_swap(m_.front_idx, b.m_.front_idx);\n      boost::adl_move_swap(m_.back_idx, b.m_.back_idx);\n\n      //And now swap the allocator\n      dtl::swap_alloc(this->get_allocator_ref(), b.get_allocator_ref(), dtl::bool_<propagate_alloc>());\n\n      BOOST_ASSERT(   invariants_ok());\n      BOOST_ASSERT(b.invariants_ok());\n   }\n\n   /**\n   * **Effects**: Destroys all elements in the devector.\n   * Invalidates all references, pointers and iterators to the\n   * elements of the devector.\n   *\n   * **Postcondition**: `empty() && front_free_capacity() == 0\n   * && back_free_capacity() == old capacity`.\n   *\n   * **Complexity**: Linear in the size of `*this`.\n   *\n   * **Remarks**: Does not free memory.\n   */\n   void clear() BOOST_NOEXCEPT\n   {\n      destroy_elements(begin(), end());\n      m_.front_idx = m_.back_idx = 0;\n   }\n\n   BOOST_CONTAINER_ATTRIBUTE_NODISCARD BOOST_CONTAINER_FORCEINLINE\n      friend bool operator==(const devector& x, const devector& y)\n   {   return x.size() == y.size() && ::boost::container::algo_equal(x.begin(), x.end(), y.begin());   }\n\n   BOOST_CONTAINER_ATTRIBUTE_NODISCARD BOOST_CONTAINER_FORCEINLINE\n      friend bool operator!=(const devector& x, const devector& y)\n   {   return !(x == y); }\n\n   BOOST_CONTAINER_ATTRIBUTE_NODISCARD BOOST_CONTAINER_FORCEINLINE\n      friend bool operator< (const devector& x, const devector& y)\n   {   return boost::container::algo_lexicographical_compare(x.begin(), x.end(), y.begin(), y.end());   }\n\n   BOOST_CONTAINER_ATTRIBUTE_NODISCARD BOOST_CONTAINER_FORCEINLINE\n      friend bool operator>(const devector& x, const devector& y)\n   {   return y < x;   }\n\n   BOOST_CONTAINER_ATTRIBUTE_NODISCARD BOOST_CONTAINER_FORCEINLINE\n      friend bool operator<=(const devector& x, const devector& y)\n   {   return !(y < x);   }\n\n   BOOST_CONTAINER_ATTRIBUTE_NODISCARD BOOST_CONTAINER_FORCEINLINE\n      friend bool operator>=(const devector& x, const devector& y)\n   {   return !(x < y);   }\n\n   BOOST_CONTAINER_FORCEINLINE friend void swap(devector& x, devector& y)\n      BOOST_NOEXCEPT_IF( allocator_traits_type::propagate_on_container_swap::value\n                                 || allocator_traits_type::is_always_equal::value)\n   {   x.swap(y);   }\n\n   private:\n\n   BOOST_CONTAINER_ATTRIBUTE_NODISCARD BOOST_CONTAINER_FORCEINLINE\n   size_type pos_to_index(const_iterator i) const \n   {\n      return static_cast<size_type>(i - cbegin());\n   }\n\n   BOOST_CONTAINER_ATTRIBUTE_NODISCARD BOOST_CONTAINER_FORCEINLINE\n   bool should_move_back(const_iterator i) const \n   {\n      return static_cast<size_type>(this->pos_to_index(i)) >= this->size()/2u;\n   }\n\n   BOOST_CONTAINER_FORCEINLINE static iterator unconst_iterator(const_iterator i)\n   {\n      return boost::intrusive::pointer_traits<pointer>::const_cast_from(i);\n   }\n\n   BOOST_CONTAINER_FORCEINLINE size_type front_capacity() const\n   {\n      return m_.back_idx;\n   }\n\n   BOOST_CONTAINER_FORCEINLINE size_type back_capacity() const\n   {\n      return size_type(m_.capacity - m_.front_idx);\n   }\n\n   #ifndef BOOST_CONTAINER_DOXYGEN_INVOKED\n\n   BOOST_CONTAINER_FORCEINLINE T* priv_raw_begin() BOOST_NOEXCEPT\n   {   return boost::movelib::to_raw_pointer(m_.buffer) + m_.front_idx;   }\n\n   BOOST_CONTAINER_FORCEINLINE T* priv_raw_end() BOOST_NOEXCEPT\n   {   return boost::movelib::to_raw_pointer(m_.buffer) + m_.back_idx;    }\n\n\n   template <class U>\n   BOOST_CONTAINER_FORCEINLINE void priv_push_front(BOOST_FWD_REF(U) u)\n   {\n      this->emplace_front(boost::forward<U>(u));\n   }\n\n   template <class U>\n   BOOST_CONTAINER_FORCEINLINE void priv_push_back(BOOST_FWD_REF(U) u)\n   {\n      this->emplace_back(boost::forward<U>(u));\n   }\n\n   template <class U>\n   BOOST_CONTAINER_FORCEINLINE iterator priv_insert(const_iterator pos, BOOST_FWD_REF(U) u)\n   {\n      return this->emplace(pos, boost::forward<U>(u));\n   }\n\n   // allocator_type wrappers\n\n   BOOST_CONTAINER_FORCEINLINE allocator_type& get_allocator_ref() BOOST_NOEXCEPT\n   {\n      return static_cast<allocator_type&>(m_);\n   }\n\n   BOOST_CONTAINER_FORCEINLINE const allocator_type& get_allocator_ref() const BOOST_NOEXCEPT\n   {\n      return static_cast<const allocator_type&>(m_);\n   }\n\n   pointer allocate(size_type capacity)\n   {\n      pointer const p = impl::do_allocate(get_allocator_ref(), capacity);\n      #ifdef BOOST_CONTAINER_DEVECTOR_ALLOC_STATS\n      ++m_.capacity_alloc_count;\n      #endif // BOOST_CONTAINER_DEVECTOR_ALLOC_STATS\n      return p;\n   }\n\n   void destroy_elements(pointer begin, pointer end)\n   {\n      for (; begin != end; ++begin)\n      {\n         allocator_traits_type::destroy(get_allocator_ref(), boost::movelib::to_raw_pointer(begin));\n      }\n   }\n\n   void deallocate_buffer()\n   {\n      if (m_.buffer)\n      {\n         allocator_traits_type::deallocate(get_allocator_ref(), m_.buffer, m_.capacity);\n      }\n   }\n\n   #if !defined(BOOST_NO_CXX11_VARIADIC_TEMPLATES) || defined(BOOST_CONTAINER_DOXYGEN_INVOKED)\n   template <typename... Args>\n   BOOST_CONTAINER_FORCEINLINE void alloc_construct(pointer dst, Args&&... args)\n   {\n      allocator_traits_type::construct(\n            get_allocator_ref(),\n            boost::movelib::to_raw_pointer(dst),\n            boost::forward<Args>(args)...\n      );\n   }\n\n   template <typename... Args>\n   void construct_n(pointer buffer, size_type n, Args&&... args)\n   {\n      detail::construction_guard<allocator_type> ctr_guard(buffer, get_allocator_ref());\n      guarded_construct_n(buffer, n, ctr_guard, boost::forward<Args>(args)...);\n      ctr_guard.release();\n   }\n\n   template <typename... Args>\n   void guarded_construct_n(pointer buffer, size_type n, detail::construction_guard<allocator_type>& ctr_guard, Args&&... args)\n   {\n      for (size_type i = 0; i < n; ++i) {\n         this->alloc_construct(buffer + i, boost::forward<Args>(args)...);\n         ctr_guard.extend();\n      }\n   }\n\n   #else //!defined(BOOST_NO_CXX11_VARIADIC_TEMPLATES) || defined(BOOST_CONTAINER_DOXYGEN_INVOKED)\n\n   #define BOOST_CONTAINER_DEVECTOR_ALLOC_CONSTRUCT(N) \\\n   BOOST_MOVE_TMPL_LT##N BOOST_MOVE_CLASS##N BOOST_MOVE_GT##N \\\n   BOOST_CONTAINER_FORCEINLINE void alloc_construct(pointer dst BOOST_MOVE_I##N BOOST_MOVE_UREF##N)\\\n   {\\\n      allocator_traits_type::construct(\\\n            get_allocator_ref(), boost::movelib::to_raw_pointer(dst) BOOST_MOVE_I##N BOOST_MOVE_FWD##N );\\\n   }\\\n   \\\n   BOOST_MOVE_TMPL_LT##N BOOST_MOVE_CLASS##N BOOST_MOVE_GT##N \\\n   void construct_n(pointer buffer, size_type n BOOST_MOVE_I##N BOOST_MOVE_UREF##N)\\\n   {\\\n      detail::construction_guard<allocator_type> ctr_guard(buffer, get_allocator_ref());\\\n      guarded_construct_n(buffer, n, ctr_guard BOOST_MOVE_I##N BOOST_MOVE_FWD##N);\\\n      ctr_guard.release();\\\n   }\\\n   \\\n   BOOST_MOVE_TMPL_LT##N BOOST_MOVE_CLASS##N BOOST_MOVE_GT##N \\\n   void guarded_construct_n(pointer buffer, size_type n, detail::construction_guard<allocator_type>& ctr_guard BOOST_MOVE_I##N BOOST_MOVE_UREF##N)\\\n   {\\\n      for (size_type i = 0; i < n; ++i) {\\\n            this->alloc_construct(buffer + i BOOST_MOVE_I##N BOOST_MOVE_FWD##N);\\\n            ctr_guard.extend();\\\n      }\\\n   }\n   //\n   BOOST_MOVE_ITERATE_0TO9(BOOST_CONTAINER_DEVECTOR_ALLOC_CONSTRUCT)\n   #undef BOOST_CONTAINER_DEVECTOR_ALLOC_CONSTRUCT\n\n   #endif    //!defined(BOOST_NO_CXX11_VARIADIC_TEMPLATES) || defined(BOOST_CONTAINER_DOXYGEN_INVOKED)\n\n   size_type calculate_new_capacity(size_type requested_capacity)\n   {\n      size_type max = allocator_traits_type::max_size(this->get_allocator_ref());\n      (clamp_by_stored_size_type)(max, stored_size_type());\n      const size_type remaining_additional_cap = max - size_type(m_.capacity);\n      const size_type min_additional_cap = requested_capacity - size_type(m_.capacity);\n      if ( remaining_additional_cap < min_additional_cap )\n            boost::container::throw_length_error(\"devector: get_next_capacity, max size exceeded\");\n\n      return growth_factor_type()( size_type(m_.capacity), min_additional_cap, max);\n   }\n\n   void buffer_move_or_copy(pointer dst)\n   {\n      detail::construction_guard<allocator_type> guard(dst, get_allocator_ref());\n\n      buffer_move_or_copy(dst, guard);\n\n      guard.release();\n   }\n\n   void buffer_move_or_copy(pointer dst, detail::construction_guard<allocator_type>& guard)\n   {\n      opt_move_or_copy(begin(), end(), dst, guard);\n\n      destroy_elements(data(), data() + size());\n      deallocate_buffer();\n   }\n\n   template <typename Guard>\n   void opt_move_or_copy(pointer begin, pointer end, pointer dst, Guard& guard)\n   {\n      // if trivial copy and default allocator, memcpy\n      boost::container::uninitialized_move_alloc(get_allocator_ref(), begin, end, dst);\n      guard.extend();\n   }\n\n   #if !defined(BOOST_NO_CXX11_VARIADIC_TEMPLATES) || defined(BOOST_CONTAINER_DOXYGEN_INVOKED)\n\n   template <typename... Args>\n   void resize_impl(size_type sz, Args&&... args)\n   {\n      const size_type old_sz = this->size();\n      if (sz > old_sz)\n      {\n         const size_type n = sz - old_sz;\n\n         if (sz <= m_.capacity)\n         {\n            //Construct at back\n            const size_type bfc = this->back_free_capacity();\n            const size_type b = n < bfc ? n : bfc;\n            construct_n(m_.buffer + m_.back_idx, b, boost::forward<Args>(args)...);\n            m_.set_back_idx(m_.back_idx + b);\n\n            //Construct remaining at front\n            const size_type f = n - b;\n            construct_n(m_.buffer + m_.front_idx - f, f, boost::forward<Args>(args)...);\n            m_.set_front_idx(m_.front_idx - f);\n         }\n         else\n         {\n            resize_back_slow_path(sz, n, boost::forward<Args>(args)...);\n         }\n      }\n      else\n      {\n         const size_type n = old_sz - sz;\n         const size_type new_bidx = m_.back_idx - n;\n         destroy_elements(m_.buffer + new_bidx, m_.buffer + m_.back_idx);\n         m_.set_back_idx(new_bidx);\n      }\n   }\n\n   template <typename... Args>\n   void resize_front_impl(size_type sz , Args&&... args)\n   {\n      const size_type old_sz = this->size();\n      if (sz > old_sz)\n      {\n         const size_type n = sz - old_sz;\n\n         if (sz <= this->front_capacity())\n         {\n            construct_n(m_.buffer + m_.front_idx - n, n, boost::forward<Args>(args)...);\n            m_.set_front_idx(m_.front_idx - n);\n         }\n         else\n         {\n            resize_front_slow_path(sz, n, boost::forward<Args>(args)...);\n         }\n      }\n      else {\n         const size_type n = old_sz - sz;\n         const size_type new_fidx = m_.front_idx + n;\n         destroy_elements(m_.buffer + m_.front_idx, m_.buffer + new_fidx);\n         m_.set_front_idx(new_fidx);\n      }\n   }\n\n   template <typename... Args>\n   void resize_front_slow_path(size_type sz, size_type n, Args&&... args)\n   {\n      const size_type new_capacity = calculate_new_capacity(sz + back_free_capacity());\n      pointer new_buffer = allocate(new_capacity);\n      allocation_guard new_buffer_guard(new_buffer, new_capacity, get_allocator_ref());\n\n      const size_type old_sz = this->size();\n      const size_type new_old_elem_index = new_capacity - old_sz;\n      const size_type new_elem_index = new_old_elem_index - n;\n\n      detail::construction_guard<allocator_type> guard(new_buffer + new_elem_index, get_allocator_ref());\n      guarded_construct_n(new_buffer + new_elem_index, n, guard, boost::forward<Args>(args)...);\n\n      buffer_move_or_copy(new_buffer + new_old_elem_index, guard);\n\n      guard.release();\n      new_buffer_guard.release();\n\n      m_.buffer = new_buffer;\n      m_.set_capacity(new_capacity);\n      m_.set_front_idx(new_elem_index);\n      m_.set_back_idx(new_elem_index + old_sz + n);\n   }\n\n   template <typename... Args>\n   void resize_back_impl(size_type sz, Args&&... args)\n   {\n      const size_type old_sz = this->size();\n      if (sz > old_sz)\n      {\n         const size_type n = sz - old_sz;\n\n         if (sz <= this->back_capacity())\n         {\n            construct_n(m_.buffer + m_.back_idx, n, boost::forward<Args>(args)...);\n            m_.set_back_idx(m_.back_idx + n);\n         }\n         else\n         {\n            resize_back_slow_path(sz, n, boost::forward<Args>(args)...);\n         }\n      }\n      else\n      {\n         const size_type n = old_sz - sz;\n         const size_type new_bidx = m_.back_idx - n;\n         destroy_elements(m_.buffer + new_bidx, m_.buffer + m_.back_idx);\n         m_.set_back_idx(new_bidx);\n      }\n   }\n\n   template <typename... Args>\n   void resize_back_slow_path(size_type sz, size_type n, Args&&... args)\n   {\n      const size_type new_capacity = calculate_new_capacity(sz + front_free_capacity());\n      pointer new_buffer = allocate(new_capacity);\n      allocation_guard new_buffer_guard(new_buffer, new_capacity, get_allocator_ref());\n\n      detail::construction_guard<allocator_type> guard(new_buffer + m_.back_idx, get_allocator_ref());\n      guarded_construct_n(new_buffer + m_.back_idx, n, guard, boost::forward<Args>(args)...);\n\n      buffer_move_or_copy(new_buffer + m_.front_idx);\n\n      guard.release();\n      new_buffer_guard.release();\n\n      m_.buffer = new_buffer;\n      m_.set_capacity(new_capacity);\n      m_.set_back_idx(m_.back_idx + n);\n   }\n\n   #else //!defined(BOOST_NO_CXX11_VARIADIC_TEMPLATES) || defined(BOOST_CONTAINER_DOXYGEN_INVOKED)\n\n   #define BOOST_CONTAINER_DEVECTOR_SLOW_PATH(N) \\\n   BOOST_MOVE_TMPL_LT##N BOOST_MOVE_CLASS##N BOOST_MOVE_GT##N \\\n   void resize_front_impl(size_type sz BOOST_MOVE_I##N BOOST_MOVE_UREF##N)\\\n   {\\\n      if (sz > size())\\\n      {\\\n         const size_type n = sz - size();\\\n         if (sz <= front_capacity()){\\\n            construct_n(m_.buffer + m_.front_idx - n, n BOOST_MOVE_I##N BOOST_MOVE_FWD##N);\\\n            m_.set_front_idx(m_.front_idx - n);\\\n         }\\\n         else\\\n         {\\\n            resize_front_slow_path(sz, n BOOST_MOVE_I##N BOOST_MOVE_FWD##N);\\\n         }\\\n      }\\\n      else {\\\n         while (this->size() > sz)\\\n         {\\\n            this->pop_front();\\\n         }\\\n      }\\\n   }\\\n   \\\n   BOOST_MOVE_TMPL_LT##N BOOST_MOVE_CLASS##N BOOST_MOVE_GT##N \\\n   void resize_front_slow_path(size_type sz, size_type n BOOST_MOVE_I##N BOOST_MOVE_UREF##N)\\\n   {\\\n      const size_type new_capacity = calculate_new_capacity(sz + back_free_capacity());\\\n      pointer new_buffer = allocate(new_capacity);\\\n      allocation_guard new_buffer_guard(new_buffer, new_capacity, get_allocator_ref());\\\n   \\\n      const size_type new_old_elem_index = new_capacity - size();\\\n      const size_type new_elem_index = new_old_elem_index - n;\\\n   \\\n      detail::construction_guard<allocator_type> guard(new_buffer + new_elem_index, get_allocator_ref());\\\n      guarded_construct_n(new_buffer + new_elem_index, n, guard BOOST_MOVE_I##N BOOST_MOVE_FWD##N);\\\n   \\\n      buffer_move_or_copy(new_buffer + new_old_elem_index, guard);\\\n   \\\n      guard.release();\\\n      new_buffer_guard.release();\\\n      m_.buffer = new_buffer;\\\n      m_.set_capacity(new_capacity);\\\n      m_.set_back_idx(new_old_elem_index + m_.back_idx - m_.front_idx);\\\n      m_.set_front_idx(new_elem_index);\\\n   }\\\n   \\\n   BOOST_MOVE_TMPL_LT##N BOOST_MOVE_CLASS##N BOOST_MOVE_GT##N \\\n   void resize_back_impl(size_type sz BOOST_MOVE_I##N BOOST_MOVE_UREF##N)\\\n   {\\\n      if (sz > size())\\\n      {\\\n         const size_type n = sz - size();\\\n      \\\n         if (sz <= back_capacity())\\\n         {\\\n            construct_n(m_.buffer + m_.back_idx, n BOOST_MOVE_I##N BOOST_MOVE_FWD##N);\\\n            m_.set_back_idx(m_.back_idx + n);\\\n         }\\\n         else\\\n         {\\\n            resize_back_slow_path(sz, n BOOST_MOVE_I##N BOOST_MOVE_FWD##N);\\\n         }\\\n      }\\\n      else\\\n      {\\\n         while (size() > sz)\\\n         {\\\n            pop_back();\\\n         }\\\n      }\\\n   }\\\n   \\\n   BOOST_MOVE_TMPL_LT##N BOOST_MOVE_CLASS##N BOOST_MOVE_GT##N \\\n   void resize_back_slow_path(size_type sz, size_type n BOOST_MOVE_I##N BOOST_MOVE_UREF##N)\\\n   {\\\n      const size_type new_capacity = calculate_new_capacity(sz + front_free_capacity());\\\n      pointer new_buffer = allocate(new_capacity);\\\n      allocation_guard new_buffer_guard(new_buffer, new_capacity, get_allocator_ref());\\\n   \\\n      detail::construction_guard<allocator_type> guard(new_buffer + m_.back_idx, get_allocator_ref());\\\n      guarded_construct_n(new_buffer + m_.back_idx, n, guard BOOST_MOVE_I##N BOOST_MOVE_FWD##N);\\\n   \\\n      buffer_move_or_copy(new_buffer + m_.front_idx);\\\n   \\\n      guard.release();\\\n      new_buffer_guard.release();\\\n   \\\n      m_.buffer = new_buffer;\\\n      m_.set_capacity(new_capacity);\\\n      m_.set_back_idx(m_.back_idx + n);\\\n   }\\\n   \\\n   //\n   BOOST_MOVE_ITERATE_0TO9(BOOST_CONTAINER_DEVECTOR_SLOW_PATH)\n   #undef BOOST_CONTAINER_DEVECTOR_SLOW_PATH\n\n   #endif    //!defined(BOOST_NO_CXX11_VARIADIC_TEMPLATES) || defined(BOOST_CONTAINER_DOXYGEN_INVOKED)\n\n   void reallocate_at(size_type new_capacity, size_type buffer_offset)\n   {\n      pointer new_buffer = allocate(new_capacity);\n      {\n         allocation_guard new_buffer_guard(new_buffer, new_capacity, get_allocator_ref());\n         boost::container::uninitialized_move_alloc(get_allocator_ref(), this->begin(), this->end(), new_buffer + buffer_offset);\n         new_buffer_guard.release();\n      }\n      destroy_elements(m_.buffer + m_.front_idx, m_.buffer + m_.back_idx);\n      deallocate_buffer();\n\n      m_.buffer = new_buffer;\n      //Safe cast, allocate() will handle stored_size_type overflow\n      m_.set_capacity(new_capacity);\n      m_.set_back_idx(size_type(m_.back_idx - m_.front_idx) + buffer_offset);\n      m_.set_front_idx(buffer_offset);\n\n      BOOST_ASSERT(invariants_ok());\n   }\n\n   template <typename ForwardIterator>\n   iterator insert_range(const_iterator position, ForwardIterator first, ForwardIterator last)\n   {\n      BOOST_ASSERT(position >= begin());\n      BOOST_ASSERT(position <= end());\n      typedef dtl::insert_range_proxy<allocator_type, ForwardIterator> proxy_t;\n\n      size_type const n = boost::container::iterator_udistance(first, last);\n      bool prefer_move_back;\n      if (BOOST_UNLIKELY(!n)) {\n         return begin() + size_type(position - cbegin());\n      }\n      else if (position == end()) {\n         if(back_free_capacity() >= n) // fast path\n         {\n            iterator r(this->end());\n            boost::container::uninitialized_copy_alloc(get_allocator_ref(), first, last, this->priv_raw_end());\n            m_.set_back_idx(m_.back_idx + n);\n            return r;\n         }\n         prefer_move_back = true;\n      }\n      else if (position == begin()) {\n         if(front_free_capacity() >= n) {// secondary fast path\n            boost::container::uninitialized_copy_alloc(get_allocator_ref(), first, last, this->priv_raw_begin() - n);\n            m_.set_front_idx(m_.front_idx - n);\n            return begin();\n         }\n         prefer_move_back = false;\n      }\n      else{\n         iterator nonconst_pos = unconst_iterator(position);\n         prefer_move_back = should_move_back(position);\n\n         if(prefer_move_back){\n            if(back_free_capacity() >= n){\n               boost::container::expand_forward_and_insert_nonempty_middle_alloc\n                  ( get_allocator_ref()\n                  , boost::movelib::to_raw_pointer(nonconst_pos)\n                  , this->priv_raw_end()\n                  , n, proxy_t(first));\n               m_.set_back_idx(m_.back_idx + n);\n               return nonconst_pos;\n            }\n         }\n         else{\n            if (front_free_capacity() >= n){\n               boost::container::expand_backward_and_insert_nonempty_middle_alloc\n                  ( get_allocator_ref()\n                  , this->priv_raw_begin()\n                  , boost::movelib::to_raw_pointer(nonconst_pos)\n                  , n, proxy_t(first));\n               m_.set_front_idx(m_.front_idx - n);\n               return (nonconst_pos -= n);\n            }\n         }\n      }\n      return this->insert_range_slow_path(position, n, proxy_t(first));\n   }\n\n   template <class InsertionProxy>\n   BOOST_CONTAINER_NOINLINE iterator insert_range_slow_path\n      (const_iterator p, const size_type n, const InsertionProxy proxy)\n   {\n      size_type const back_free_cap = back_free_capacity();\n      size_type const front_free_cap = front_free_capacity();\n      size_type const free_cap = front_free_cap + back_free_cap;\n      size_type const index = size_type(p - cbegin());\n\n      size_type const cap = m_.capacity;\n      //Test if enough free memory would be left\n      if (free_cap >= n && (free_cap - n) >= cap/devector_min_free_fraction) {\n         //Make sure relocation is happening because there was no enough space\n         size_type const old_size = this->size();\n         BOOST_ASSERT(should_move_back(p) ? (back_free_cap < n) : (front_free_cap < n));\n\n         T* const raw_pos = const_cast<T*>(boost::movelib::to_raw_pointer(p));\n         size_type const new_size = old_size + n;\n         size_type const new_front_idx = (cap - new_size) / 2u;\n\n         T* const raw_beg = this->priv_raw_begin();\n         T* const new_raw_beg = raw_beg - std::ptrdiff_t(m_.front_idx - new_front_idx);\n         m_.back_idx = 0u;\n         m_.front_idx = 0u;\n         boost::container::expand_backward_forward_and_insert_alloc\n            (raw_beg, old_size, new_raw_beg, raw_pos, n, proxy, get_allocator_ref());\n         m_.set_front_idx(new_front_idx);\n         m_.set_back_idx(new_front_idx + new_size);\n      }\n      else {\n         // reallocate\n         const size_type new_capacity = calculate_new_capacity(m_.capacity + n);\n         pointer new_buffer = allocate(new_capacity);\n\n         // guard allocation\n         allocation_guard new_buffer_guard(new_buffer, new_capacity, get_allocator_ref());\n\n         size_type const old_size = this->size();\n         const size_type new_front_index = (new_capacity - old_size - n) / 2u;\n\n         T* const raw_pos = const_cast<T*>(boost::movelib::to_raw_pointer(p));\n         T* const raw_new_start = const_cast<T*>(boost::movelib::to_raw_pointer(new_buffer)) + new_front_index;\n\n         boost::container::uninitialized_move_and_insert_alloc\n            (get_allocator_ref(), this->priv_raw_begin(), raw_pos, this->priv_raw_end(), raw_new_start, n, proxy);\n         new_buffer_guard.release();\n\n         // cleanup\n         destroy_elements(begin(), end());\n         deallocate_buffer();\n\n         // rebind members\n         m_.set_capacity(new_capacity);\n         m_.buffer = new_buffer;\n         m_.set_back_idx(new_front_index + old_size + n);\n         m_.set_front_idx(new_front_index);\n      }\n      return begin() + index;\n   }\n\n\n   template <typename Iterator>\n   void construct_from_range(Iterator begin, Iterator end)\n   {\n      allocation_guard buffer_guard(m_.buffer, m_.capacity, get_allocator_ref());\n      boost::container::uninitialized_copy_alloc(get_allocator_ref(), begin, end, m_.buffer);\n      buffer_guard.release();\n   }\n\n   template <typename ForwardIterator>\n   void allocate_and_copy_range(ForwardIterator first, ForwardIterator last)\n   {\n      size_type n = boost::container::iterator_udistance(first, last);\n\n      pointer new_buffer = n ? allocate(n) : pointer();\n      allocation_guard new_buffer_guard(new_buffer, n, get_allocator_ref());\n      boost::container::uninitialized_copy_alloc(get_allocator_ref(), first, last, new_buffer);\n      destroy_elements(begin(), end());\n      deallocate_buffer();\n\n      m_.set_capacity(n);\n      m_.buffer = new_buffer;\n      m_.front_idx = 0;\n      m_.set_back_idx(n);\n\n      new_buffer_guard.release();\n   }\n\n   static void swap_big_big(devector& a, devector& b) BOOST_NOEXCEPT\n   {\n      boost::adl_move_swap(a.m_.capacity, b.m_.capacity);\n      boost::adl_move_swap(a.m_.buffer, b.m_.buffer);\n   }\n\n   template <typename ForwardIterator>\n   void overwrite_buffer_impl(ForwardIterator first, ForwardIterator last, dtl::true_)\n   {\n      const size_type n = boost::container::iterator_udistance(first, last);\n\n      BOOST_ASSERT(m_.capacity >= n);\n      boost::container::uninitialized_copy_alloc_n\n            ( get_allocator_ref(), first\n            , n, boost::movelib::to_raw_pointer(m_.buffer));\n      m_.front_idx = 0;\n      m_.set_back_idx(n);\n   }\n\n   template <typename InputIterator>\n   InputIterator overwrite_buffer_impl(InputIterator first, InputIterator last, dtl::false_)\n   {\n      pointer pos = m_.buffer;\n      detail::construction_guard<allocator_type> front_guard(pos, get_allocator_ref());\n\n      while (first != last && pos != begin()) {\n         this->alloc_construct(pos++, *first++);\n         front_guard.extend();\n      }\n\n      while (first != last && pos != end()) {\n         *pos++ = *first++;\n      }\n\n      detail::construction_guard<allocator_type> back_guard(pos, get_allocator_ref());\n\n      iterator capacity_end = m_.buffer + m_.capacity;\n      while (first != last && pos != capacity_end) {\n         this->alloc_construct(pos++, *first++);\n         back_guard.extend();\n      }\n\n      pointer destroy_after = dtl::min_value(dtl::max_value(begin(), pos), end());\n      destroy_elements(destroy_after, end());\n\n      front_guard.release();\n      back_guard.release();\n\n      m_.front_idx = 0;\n      m_.set_back_idx(pos_to_index(pos));\n      return first;\n   }\n\n   template <typename ForwardIterator>\n   BOOST_CONTAINER_FORCEINLINE void overwrite_buffer(ForwardIterator first, ForwardIterator last)\n   {\n      this->overwrite_buffer_impl(first, last, \n            dtl::bool_<dtl::is_trivially_destructible<T>::value>());\n   }\n\n   bool invariants_ok()\n   {\n      return  (! m_.capacity || m_.buffer )\n              && m_.front_idx <= m_.back_idx\n              && m_.back_idx <= m_.capacity;\n   }\n\n   struct impl : allocator_type\n   {\n      BOOST_MOVABLE_BUT_NOT_COPYABLE(impl)\n\n      public:\n      allocator_type &get_al()\n      {   return *this;   }\n\n      static pointer do_allocate(allocator_type &a, size_type cap)\n      {\n         if (cap) {\n            //First detect overflow on smaller stored_size_types\n            if (cap > stored_size_type(-1)){\n                  boost::container::throw_length_error(\"get_next_capacity, allocator's max size reached\");\n            }\n            return allocator_traits_type::allocate(a, cap);\n         }\n         else {\n            return pointer();\n         }\n      }\n\n      impl()\n         : allocator_type(), buffer(), front_idx(), back_idx(), capacity()\n         #ifdef BOOST_CONTAINER_DEVECTOR_ALLOC_STATS\n         , capacity_alloc_count(0)\n         #endif\n      {}\n\n      explicit impl(const allocator_type &a)\n         : allocator_type(a), buffer(), front_idx(), back_idx(), capacity()\n         #ifdef BOOST_CONTAINER_DEVECTOR_ALLOC_STATS\n         , capacity_alloc_count(0)\n         #endif\n      {}\n\n      impl(reserve_uninitialized_t, const allocator_type& a, size_type c)\n         : allocator_type(a), buffer(do_allocate(get_al(), c) )\n         //static cast sizes, as the allocation function will take care of overflows\n         , front_idx(static_cast<stored_size_type>(0u))\n         , back_idx(static_cast<stored_size_type>(c))\n         , capacity(static_cast<stored_size_type>(c))\n         #ifdef BOOST_CONTAINER_DEVECTOR_ALLOC_STATS\n         , capacity_alloc_count(size_type(buffer != pointer()))\n         #endif\n      {}\n\n      impl(reserve_only_tag_t, const allocator_type &a, size_type const ffc, size_type const bfc)\n         : allocator_type(a), buffer(do_allocate(get_al(), ffc+bfc) )\n         //static cast sizes, as the allocation function will take care of overflows\n         , front_idx(static_cast<stored_size_type>(ffc))\n         , back_idx(static_cast<stored_size_type>(ffc))\n         , capacity(static_cast<stored_size_type>(ffc + bfc))\n         #ifdef BOOST_CONTAINER_DEVECTOR_ALLOC_STATS\n         , capacity_alloc_count(size_type(buffer != pointer()))\n         #endif\n      {}\n\n      impl(reserve_only_tag_t, const allocator_type &a, size_type const c)\n         : allocator_type(a), buffer(do_allocate(get_al(), c) )\n         //static cast sizes, as the allocation function will take care of overflows\n         , front_idx(static_cast<stored_size_type>(c/2u))\n         , back_idx(static_cast<stored_size_type>(c/2u))\n         , capacity(static_cast<stored_size_type>(c))\n         #ifdef BOOST_CONTAINER_DEVECTOR_ALLOC_STATS\n         , capacity_alloc_count(size_type(buffer != pointer()))\n         #endif\n      {}\n\n      impl(review_implementation_t, const allocator_type &a, pointer p, size_type fi, size_type bi, size_type c)\n         : allocator_type(a), buffer(p)\n         //static cast sizes, as the allocation function will take care of overflows\n         , front_idx(static_cast<stored_size_type>(fi))\n         , back_idx(static_cast<stored_size_type>(bi))\n         , capacity(static_cast<stored_size_type>(c))\n         #ifdef BOOST_CONTAINER_DEVECTOR_ALLOC_STATS\n         , capacity_alloc_count(0)\n         #endif\n      {}\n\n      impl(BOOST_RV_REF(impl) m)\n         : allocator_type(BOOST_MOVE_BASE(allocator_type, m))\n         , buffer(static_cast<impl&>(m).buffer)\n         , front_idx(static_cast<impl&>(m).front_idx)\n         , back_idx(static_cast<impl&>(m).back_idx)\n         , capacity(static_cast<impl&>(m).capacity)\n         #ifdef BOOST_CONTAINER_DEVECTOR_ALLOC_STATS\n         , capacity_alloc_count(0)\n         #endif\n      {\n         impl &i = static_cast<impl&>(m);\n         // buffer is already acquired, reset rhs\n         i.capacity = 0u;\n         i.buffer = pointer();\n         i.front_idx = 0;\n         i.back_idx = 0;\n      }\n\n      BOOST_CONTAINER_FORCEINLINE void set_back_idx(size_type bi)\n      {\n         back_idx = static_cast<stored_size_type>(bi);\n      }\n\n      BOOST_CONTAINER_FORCEINLINE void set_front_idx(size_type fi)\n      {\n         front_idx = static_cast<stored_size_type>(fi);\n      }\n\n      BOOST_CONTAINER_FORCEINLINE void set_capacity(size_type c)\n      {\n         capacity = static_cast<stored_size_type>(c);\n      }\n\n      pointer           buffer;\n      stored_size_type  front_idx;\n      stored_size_type  back_idx;\n      stored_size_type  capacity;\n      #ifdef BOOST_CONTAINER_DEVECTOR_ALLOC_STATS\n      size_type capacity_alloc_count;\n      #endif\n   } m_;\n\n   #ifdef BOOST_CONTAINER_DEVECTOR_ALLOC_STATS\n   public:\n   void reset_alloc_stats()\n   {\n      m_.capacity_alloc_count = 0;\n   }\n\n   size_type get_alloc_count() const\n   {\n      return m_.capacity_alloc_count;\n   }\n\n   #endif // ifdef BOOST_CONTAINER_DEVECTOR_ALLOC_STATS\n\n   #endif // ifndef BOOST_CONTAINER_DOXYGEN_INVOKED\n};\n\n}} // namespace boost::container\n\n#ifndef BOOST_CONTAINER_DOXYGEN_INVOKED\n\nnamespace boost {\n\n//!has_trivial_destructor_after_move<> == true_type\n//!specialization for optimizations\ntemplate <class T, class Allocator, class Options>\nstruct has_trivial_destructor_after_move<boost::container::devector<T, Allocator, Options> >\n{\n    typedef typename boost::container::devector<T, Allocator, Options>::allocator_type allocator_type;\n    typedef typename ::boost::container::allocator_traits<allocator_type>::pointer pointer;\n    static const bool value = ::boost::has_trivial_destructor_after_move<allocator_type>::value &&\n                                           ::boost::has_trivial_destructor_after_move<pointer>::value;\n};\n\n}\n\n#endif    //#ifndef BOOST_CONTAINER_DOXYGEN_INVOKED\n\n#include <boost/container/detail/config_end.hpp>\n\n#endif // BOOST_CONTAINER_DEVECTOR_HPP\n\n```\n\n3: **/usr/include/boost/json/basic_parser_impl.hpp**\n```\n//\n// Copyright (c) 2019 Vinnie Falco (vinnie.falco@gmail.com)\n// Copyright (c) 2020 Krystian Stasiowski (sdkrystian@gmail.com)\n//\n// Distributed under the Boost Software License, Version 1.0. (See accompanying\n// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n//\n// Official repository: https://github.com/boostorg/json\n//\n\n#ifndef BOOST_JSON_BASIC_PARSER_IMPL_HPP\n#define BOOST_JSON_BASIC_PARSER_IMPL_HPP\n\n#include <boost/json/detail/config.hpp>\n#include <boost/json/basic_parser.hpp>\n#include <boost/json/error.hpp>\n#include <boost/json/detail/buffer.hpp>\n#include <boost/json/detail/sse2.hpp>\n#include <cmath>\n#include <limits>\n#include <cstring>\n\n#ifdef _MSC_VER\n#pragma warning(push)\n#pragma warning(disable: 4702) // unreachable code\n#pragma warning(disable: 4127) // conditional expression is constant\n#endif\n\n/*  This file must be manually included to get the\n    function template definitions for basic_parser.\n*/\n\n/*  Reference:\n\n    https://www.json.org/\n\n    RFC 7159: The JavaScript Object Notation (JSON) Data Interchange Format\n    https://tools.ietf.org/html/rfc7159\n\n    https://ampl.com/netlib/fp/dtoa.c\n*/\n\n#ifndef BOOST_JSON_DOCS\n\nBOOST_JSON_NS_BEGIN\nnamespace detail {\n\ninline\ndouble\npow10(int exp) noexcept\n{\n    static double const tab[618] = {\n                        1e-308, 1e-307, 1e-306, 1e-305, 1e-304, 1e-303, 1e-302, 1e-301,\n\n        1e-300, 1e-299, 1e-298, 1e-297, 1e-296, 1e-295, 1e-294, 1e-293, 1e-292, 1e-291,\n        1e-290, 1e-289, 1e-288, 1e-287, 1e-286, 1e-285, 1e-284, 1e-283, 1e-282, 1e-281,\n        1e-280, 1e-279, 1e-278, 1e-277, 1e-276, 1e-275, 1e-274, 1e-273, 1e-272, 1e-271,\n        1e-270, 1e-269, 1e-268, 1e-267, 1e-266, 1e-265, 1e-264, 1e-263, 1e-262, 1e-261,\n        1e-260, 1e-259, 1e-258, 1e-257, 1e-256, 1e-255, 1e-254, 1e-253, 1e-252, 1e-251,\n        1e-250, 1e-249, 1e-248, 1e-247, 1e-246, 1e-245, 1e-244, 1e-243, 1e-242, 1e-241,\n        1e-240, 1e-239, 1e-238, 1e-237, 1e-236, 1e-235, 1e-234, 1e-233, 1e-232, 1e-231,\n        1e-230, 1e-229, 1e-228, 1e-227, 1e-226, 1e-225, 1e-224, 1e-223, 1e-222, 1e-221,\n        1e-220, 1e-219, 1e-218, 1e-217, 1e-216, 1e-215, 1e-214, 1e-213, 1e-212, 1e-211,\n        1e-210, 1e-209, 1e-208, 1e-207, 1e-206, 1e-205, 1e-204, 1e-203, 1e-202, 1e-201,\n\n        1e-200, 1e-199, 1e-198, 1e-197, 1e-196, 1e-195, 1e-194, 1e-193, 1e-192, 1e-191,\n        1e-190, 1e-189, 1e-188, 1e-187, 1e-186, 1e-185, 1e-184, 1e-183, 1e-182, 1e-181,\n        1e-180, 1e-179, 1e-178, 1e-177, 1e-176, 1e-175, 1e-174, 1e-173, 1e-172, 1e-171,\n        1e-170, 1e-169, 1e-168, 1e-167, 1e-166, 1e-165, 1e-164, 1e-163, 1e-162, 1e-161,\n        1e-160, 1e-159, 1e-158, 1e-157, 1e-156, 1e-155, 1e-154, 1e-153, 1e-152, 1e-151,\n        1e-150, 1e-149, 1e-148, 1e-147, 1e-146, 1e-145, 1e-144, 1e-143, 1e-142, 1e-141,\n        1e-140, 1e-139, 1e-138, 1e-137, 1e-136, 1e-135, 1e-134, 1e-133, 1e-132, 1e-131,\n        1e-130, 1e-129, 1e-128, 1e-127, 1e-126, 1e-125, 1e-124, 1e-123, 1e-122, 1e-121,\n        1e-120, 1e-119, 1e-118, 1e-117, 1e-116, 1e-115, 1e-114, 1e-113, 1e-112, 1e-111,\n        1e-110, 1e-109, 1e-108, 1e-107, 1e-106, 1e-105, 1e-104, 1e-103, 1e-102, 1e-101,\n\n        1e-100, 1e-099, 1e-098, 1e-097, 1e-096, 1e-095, 1e-094, 1e-093, 1e-092, 1e-091,\n        1e-090, 1e-089, 1e-088, 1e-087, 1e-086, 1e-085, 1e-084, 1e-083, 1e-082, 1e-081,\n        1e-080, 1e-079, 1e-078, 1e-077, 1e-076, 1e-075, 1e-074, 1e-073, 1e-072, 1e-071,\n        1e-070, 1e-069, 1e-068, 1e-067, 1e-066, 1e-065, 1e-064, 1e-063, 1e-062, 1e-061,\n        1e-060, 1e-059, 1e-058, 1e-057, 1e-056, 1e-055, 1e-054, 1e-053, 1e-052, 1e-051,\n        1e-050, 1e-049, 1e-048, 1e-047, 1e-046, 1e-045, 1e-044, 1e-043, 1e-042, 1e-041,\n        1e-040, 1e-039, 1e-038, 1e-037, 1e-036, 1e-035, 1e-034, 1e-033, 1e-032, 1e-031,\n        1e-030, 1e-029, 1e-028, 1e-027, 1e-026, 1e-025, 1e-024, 1e-023, 1e-022, 1e-021,\n        1e-020, 1e-019, 1e-018, 1e-017, 1e-016, 1e-015, 1e-014, 1e-013, 1e-012, 1e-011,\n        1e-010, 1e-009, 1e-008, 1e-007, 1e-006, 1e-005, 1e-004, 1e-003, 1e-002, 1e-001,\n\n        1e+000, 1e+001, 1e+002, 1e+003, 1e+004, 1e+005, 1e+006, 1e+007, 1e+008, 1e+009,\n        1e+010, 1e+011, 1e+012, 1e+013, 1e+014, 1e+015, 1e+016, 1e+017, 1e+018, 1e+019,\n        1e+020, 1e+021, 1e+022, 1e+023, 1e+024, 1e+025, 1e+026, 1e+027, 1e+028, 1e+029,\n        1e+030, 1e+031, 1e+032, 1e+033, 1e+034, 1e+035, 1e+036, 1e+037, 1e+038, 1e+039,\n        1e+040, 1e+041, 1e+042, 1e+043, 1e+044, 1e+045, 1e+046, 1e+047, 1e+048, 1e+049,\n        1e+050, 1e+051, 1e+052, 1e+053, 1e+054, 1e+055, 1e+056, 1e+057, 1e+058, 1e+059,\n        1e+060, 1e+061, 1e+062, 1e+063, 1e+064, 1e+065, 1e+066, 1e+067, 1e+068, 1e+069,\n        1e+070, 1e+071, 1e+072, 1e+073, 1e+074, 1e+075, 1e+076, 1e+077, 1e+078, 1e+079,\n        1e+080, 1e+081, 1e+082, 1e+083, 1e+084, 1e+085, 1e+086, 1e+087, 1e+088, 1e+089,\n        1e+090, 1e+091, 1e+092, 1e+093, 1e+094, 1e+095, 1e+096, 1e+097, 1e+098, 1e+099,\n\n        1e+100, 1e+101, 1e+102, 1e+103, 1e+104, 1e+105, 1e+106, 1e+107, 1e+108, 1e+109,\n        1e+110, 1e+111, 1e+112, 1e+113, 1e+114, 1e+115, 1e+116, 1e+117, 1e+118, 1e+119,\n        1e+120, 1e+121, 1e+122, 1e+123, 1e+124, 1e+125, 1e+126, 1e+127, 1e+128, 1e+129,\n        1e+130, 1e+131, 1e+132, 1e+133, 1e+134, 1e+135, 1e+136, 1e+137, 1e+138, 1e+139,\n        1e+140, 1e+141, 1e+142, 1e+143, 1e+144, 1e+145, 1e+146, 1e+147, 1e+148, 1e+149,\n        1e+150, 1e+151, 1e+152, 1e+153, 1e+154, 1e+155, 1e+156, 1e+157, 1e+158, 1e+159,\n        1e+160, 1e+161, 1e+162, 1e+163, 1e+164, 1e+165, 1e+166, 1e+167, 1e+168, 1e+169,\n        1e+170, 1e+171, 1e+172, 1e+173, 1e+174, 1e+175, 1e+176, 1e+177, 1e+178, 1e+179,\n        1e+180, 1e+181, 1e+182, 1e+183, 1e+184, 1e+185, 1e+186, 1e+187, 1e+188, 1e+189,\n        1e+190, 1e+191, 1e+192, 1e+193, 1e+194, 1e+195, 1e+196, 1e+197, 1e+198, 1e+199,\n\n        1e+200, 1e+201, 1e+202, 1e+203, 1e+204, 1e+205, 1e+206, 1e+207, 1e+208, 1e+209,\n        1e+210, 1e+211, 1e+212, 1e+213, 1e+214, 1e+215, 1e+216, 1e+217, 1e+218, 1e+219,\n        1e+220, 1e+221, 1e+222, 1e+223, 1e+224, 1e+225, 1e+226, 1e+227, 1e+228, 1e+229,\n        1e+230, 1e+231, 1e+232, 1e+233, 1e+234, 1e+235, 1e+236, 1e+237, 1e+238, 1e+239,\n        1e+240, 1e+241, 1e+242, 1e+243, 1e+244, 1e+245, 1e+246, 1e+247, 1e+248, 1e+249,\n        1e+250, 1e+251, 1e+252, 1e+253, 1e+254, 1e+255, 1e+256, 1e+257, 1e+258, 1e+259,\n        1e+260, 1e+261, 1e+262, 1e+263, 1e+264, 1e+265, 1e+266, 1e+267, 1e+268, 1e+269,\n        1e+270, 1e+271, 1e+272, 1e+273, 1e+274, 1e+275, 1e+276, 1e+277, 1e+278, 1e+279,\n        1e+280, 1e+281, 1e+282, 1e+283, 1e+284, 1e+285, 1e+286, 1e+287, 1e+288, 1e+289,\n        1e+290, 1e+291, 1e+292, 1e+293, 1e+294, 1e+295, 1e+296, 1e+297, 1e+298, 1e+299,\n\n        1e+300, 1e+301, 1e+302, 1e+303, 1e+304, 1e+305, 1e+306, 1e+307, 1e+308 };\n\n    if( exp > 308 )\n    {\n        return std::numeric_limits<double>::infinity();\n    }\n    else if( exp < -308 )\n    {\n        // due to the way pow10 is used by dec_to_float,\n        // we can afford to return 0.0 here\n        return 0.0;\n    }\n    else\n    {\n        exp += 308;\n        BOOST_ASSERT(exp >= 0 && exp < 618);\n        return tab[exp];\n    }\n}\n\ninline\ndouble\ndec_to_float(\n    std::uint64_t m,\n    std::int32_t e,\n    bool neg) noexcept\n{\n    // convert to double explicitly to silence warnings\n    double x = static_cast<double>(m);\n    if(neg)\n        x = -x;\n\n    if(e < -305)\n    {\n        x *= 1e-305 ;\n        e += 305;\n    }\n\n    if(e >= -22 && e < 0)\n        return x / pow10(-e);\n\n    return x * pow10(e);\n}\n\ninline\nbool\nis_control(char c) noexcept\n{\n    return static_cast<unsigned char>(c) < 32;\n}\n\ninline\nint\nhex_digit(unsigned char c) noexcept\n{\n    // by Peter Dimov\n    if( c >= '0' && c <= '9' )\n        return c - '0';\n    c &= ~0x20;\n    if( c >= 'A' && c <= 'F' )\n        return 10 + c - 'A';\n    return -1;\n}\n\n} // detail\n\n//----------------------------------------------------------\n\ntemplate<class Handler>\nvoid\nbasic_parser<Handler>::\nreserve()\n{\n    if(BOOST_JSON_LIKELY(\n        ! st_.empty()))\n        return;\n    // Reserve the largest stack we need,\n    // to avoid reallocation during suspend.\n    st_.reserve(\n        sizeof(state) + // document parsing state\n        (sizeof(state) +\n            sizeof(std::size_t)) * depth() + // array and object state + size\n        sizeof(state) + // value parsing state\n        sizeof(std::size_t) + // string size\n        sizeof(state)); // comment state\n}\n\n//----------------------------------------------------------\n//\n// The sentinel value is returned by parse functions\n// to indicate that the parser failed, or suspended.\n// this is used as it is distinct from all valid values\n// for data in write\n\ntemplate<class Handler>\nconst char*\nbasic_parser<Handler>::\nsentinel()\n{\n    return reinterpret_cast<\n        const char*>(this);\n}\n\ntemplate<class Handler>\nbool\nbasic_parser<Handler>::\nincomplete(\n    const detail::const_stream_wrapper& cs)\n{\n    return cs.begin() == sentinel();\n}\n\n//----------------------------------------------------------\n//\n// These functions are declared with the BOOST_NOINLINE\n// attribute to avoid polluting the parsers hot-path.\n// They return the canary value to indicate suspension\n// or failure.\n\ntemplate<class Handler>\nconst char*\nbasic_parser<Handler>::\nsuspend_or_fail(state st)\n{\n    if(BOOST_JSON_LIKELY(\n        ! ec_ && more_))\n    {\n        // suspend\n        reserve();\n        st_.push_unchecked(st);\n    }\n    return sentinel();\n}\n\ntemplate<class Handler>\nconst char*\nbasic_parser<Handler>::\nsuspend_or_fail(\n    state st,\n    std::size_t n)\n{\n    if(BOOST_JSON_LIKELY(\n        ! ec_ && more_))\n    {\n        // suspend\n        reserve();\n        st_.push_unchecked(n);\n        st_.push_unchecked(st);\n    }\n    return sentinel();\n}\n\n\ntemplate<class Handler>\nconst char*\nbasic_parser<Handler>::\nfail(const char* p) noexcept\n{\n    end_ = p;\n    return sentinel();\n}\n\ntemplate<class Handler>\nconst char*\nbasic_parser<Handler>::\nfail(\n    const char* p,\n    error ev,\n    source_location const* loc) noexcept\n{\n    end_ = p;\n    ec_.assign(ev, loc);\n    return sentinel();\n}\n\ntemplate<class Handler>\nconst char*\nbasic_parser<Handler>::\nmaybe_suspend(\n    const char* p,\n    state st)\n{\n    end_ = p;\n    if(BOOST_JSON_LIKELY(more_))\n    {\n        // suspend\n        reserve();\n        st_.push_unchecked(st);\n    }\n    return sentinel();\n}\n\ntemplate<class Handler>\nconst char*\nbasic_parser<Handler>::\nmaybe_suspend(\n    const char* p,\n    state st,\n    std::size_t n)\n{\n    end_ = p;\n    if(BOOST_JSON_LIKELY(more_))\n    {\n        // suspend\n        reserve();\n        st_.push_unchecked(n);\n        st_.push_unchecked(st);\n    }\n    return sentinel();\n}\n\ntemplate<class Handler>\nconst char*\nbasic_parser<Handler>::\nmaybe_suspend(\n    const char* p,\n    state st,\n    const number& num)\n{\n    end_ = p;\n    if(BOOST_JSON_LIKELY(more_))\n    {\n        // suspend\n        num_ = num;\n        reserve();\n        st_.push_unchecked(st);;\n    }\n    return sentinel();\n}\n\ntemplate<class Handler>\nconst char*\nbasic_parser<Handler>::\nsuspend(\n    const char* p,\n    state st)\n{\n    end_ = p;\n    // suspend\n    reserve();\n    st_.push_unchecked(st);\n    return sentinel();\n}\n\ntemplate<class Handler>\nconst char*\nbasic_parser<Handler>::\nsuspend(\n    const char* p,\n    state st,\n    const number& num)\n{\n    end_ = p;\n    // suspend\n    num_ = num;\n    reserve();\n    st_.push_unchecked(st);\n    return sentinel();\n}\n\ntemplate<class Handler>\ntemplate<\n    bool StackEmpty_/*,\n    bool Terminal_*/>\nconst char*\nbasic_parser<Handler>::\nparse_comment(const char* p,\n    std::integral_constant<bool, StackEmpty_> stack_empty,\n    /*std::integral_constant<bool, Terminal_>*/ bool terminal)\n{\n    detail::const_stream_wrapper cs(p, end_);\n    const char* start = cs.begin();\n    std::size_t remain;\n    if(! stack_empty && ! st_.empty())\n    {\n        state st;\n        st_.pop(st);\n        switch(st)\n        {\n            default: BOOST_JSON_UNREACHABLE();\n            case state::com1: goto do_com1;\n            case state::com2: goto do_com2;\n            case state::com3: goto do_com3;\n            case state::com4: goto do_com4;\n        }\n    }\n    BOOST_ASSERT(*cs == '/');\n    ++cs;\ndo_com1:\n    if(BOOST_JSON_UNLIKELY(! cs))\n        return maybe_suspend(cs.begin(), state::com1);\n    switch(*cs)\n    {\n    default:\n        {\n            BOOST_STATIC_CONSTEXPR source_location loc\n                = BOOST_CURRENT_LOCATION;\n            return fail(cs.begin(), error::syntax, &loc);\n        }\n    case '/':\n        ++cs;\ndo_com2:\n        // KRYSTIAN TODO: this is a mess, we have to fix this\n        remain = cs.remain();\n        cs = remain ? static_cast<const char*>(\n            std::memchr(cs.begin(), '\\n', remain)) : sentinel();\n        if(! cs.begin())\n            cs = sentinel();\n        if(BOOST_JSON_UNLIKELY(incomplete(cs)))\n        {\n            // if the doc does not terminate\n            // with a newline, treat it as the\n            // end of the comment\n            if(terminal && ! more_)\n            {\n                if(BOOST_JSON_UNLIKELY(! h_.on_comment(\n                    {start, cs.remain(start)}, ec_)))\n                    return fail(cs.end());\n                return cs.end();\n            }\n            if(BOOST_JSON_UNLIKELY(! h_.on_comment_part(\n                {start, cs.remain(start)}, ec_)))\n                return fail(cs.end());\n            if(terminal)\n                return suspend(cs.end(), state::com2);\n            return maybe_suspend(cs.end(), state::com2);\n        }\n        break;\n    case '*':\n        do\n        {\n            ++cs;\ndo_com3:\n            // KRYSTIAN TODO: this is a mess, we have to fix this\n            remain = cs.remain();\n            cs = remain ? static_cast<const char*>(\n                std::memchr(cs.begin(), '*', remain)) : sentinel();\n            if(! cs.begin())\n                cs = sentinel();\n            // stopped inside a c comment\n            if(BOOST_JSON_UNLIKELY(incomplete(cs)))\n            {\n                if(BOOST_JSON_UNLIKELY(! h_.on_comment_part(\n                    {start, cs.remain(start)}, ec_)))\n                    return fail(cs.end());\n                return maybe_suspend(cs.end(), state::com3);\n            }\n            // found a asterisk, check if the next char is a slash\n            ++cs;\ndo_com4:\n            if(BOOST_JSON_UNLIKELY(! cs))\n            {\n                if(BOOST_JSON_UNLIKELY(! h_.on_comment_part(\n                    {start, cs.used(start)}, ec_)))\n                    return fail(cs.begin());\n                return maybe_suspend(cs.begin(), state::com4);\n            }\n        }\n        while(*cs != '/');\n    }\n    ++cs;\n    if(BOOST_JSON_UNLIKELY(! h_.on_comment(\n        {start, cs.used(start)}, ec_)))\n        return fail(cs.begin());\n    return cs.begin();\n}\n\ntemplate<class Handler>\ntemplate<bool StackEmpty_>\nconst char*\nbasic_parser<Handler>::\nparse_document(const char* p,\n    std::integral_constant<bool, StackEmpty_> stack_empty)\n{\n    detail::const_stream_wrapper cs(p, end_);\n    if(! stack_empty && ! st_.empty())\n    {\n        state st;\n        st_.pop(st);\n        switch(st)\n        {\n        default: BOOST_JSON_UNREACHABLE();\n        case state::doc1: goto do_doc1;\n        case state::doc2: goto do_doc2;\n        case state::doc3: goto do_doc3;\n        case state::doc4: goto do_doc4;\n        }\n    }\ndo_doc1:\n    cs = detail::count_whitespace(cs.begin(), cs.end());\n    if(BOOST_JSON_UNLIKELY(! cs))\n        return maybe_suspend(cs.begin(), state::doc1);\ndo_doc2:\n    switch(+opt_.allow_comments |\n        (opt_.allow_trailing_commas << 1) |\n        (opt_.allow_invalid_utf8 << 2))\n    {\n    // no extensions\n    default:\n        cs = parse_value(cs.begin(), stack_empty, std::false_type(), std::false_type(), std::false_type());\n        break;\n    // comments\n    case 1:\n        cs = parse_value(cs.begin(), stack_empty, std::true_type(), std::false_type(), std::false_type());\n        break;\n    // trailing\n    case 2:\n        cs = parse_value(cs.begin(), stack_empty, std::false_type(), std::true_type(), std::false_type());\n        break;\n    // comments & trailing\n    case 3:\n        cs = parse_value(cs.begin(), stack_empty, std::true_type(), std::true_type(), std::false_type());\n        break;\n    // skip validation\n    case 4:\n        cs = parse_value(cs.begin(), stack_empty, std::false_type(), std::false_type(), std::true_type());\n        break;\n    // comments & skip validation\n    case 5:\n        cs = parse_value(cs.begin(), stack_empty, std::true_type(), std::false_type(), std::true_type());\n        break;\n    // trailing & skip validation\n    case 6:\n        cs = parse_value(cs.begin(), stack_empty, std::false_type(), std::true_type(), std::true_type());\n        break;\n    // comments & trailing & skip validation\n    case 7:\n        cs = parse_value(cs.begin(), stack_empty, std::true_type(), std::true_type(), std::true_type());\n        break;\n    }\n    if(BOOST_JSON_UNLIKELY(incomplete(cs)))\n        return suspend_or_fail(state::doc2);\ndo_doc3:\n    cs = detail::count_whitespace(cs.begin(), cs.end());\n    if(BOOST_JSON_UNLIKELY(! cs))\n    {\n        if(more_)\n            return suspend(cs.begin(), state::doc3);\n    }\n    else if(opt_.allow_comments && *cs == '/')\n    {\ndo_doc4:\n        cs = parse_comment(cs.begin(), stack_empty, std::true_type());\n        if(BOOST_JSON_UNLIKELY(incomplete(cs)))\n            return suspend_or_fail(state::doc4);\n        goto do_doc3;\n    }\n    return cs.begin();\n}\n\ntemplate<class Handler>\ntemplate<\n    bool StackEmpty_,\n    bool AllowComments_/*,\n    bool AllowTrailing_,\n    bool AllowBadUTF8_*/>\nconst char*\nbasic_parser<Handler>::\nparse_value(const char* p,\n    std::integral_constant<bool, StackEmpty_> stack_empty,\n    std::integral_constant<bool, AllowComments_> allow_comments,\n    /*std::integral_constant<bool, AllowTrailing_>*/ bool allow_trailing,\n    /*std::integral_constant<bool, AllowBadUTF8_>*/ bool allow_bad_utf8)\n{\n    if(stack_empty || st_.empty())\n    {\nloop:\n        switch(*p)\n        {\n        case '0':\n            return parse_number(p, std::true_type(), std::integral_constant<char, '0'>());\n        case '-':\n            return parse_number(p, std::true_type(), std::integral_constant<char, '-'>());\n        case '1': case '2': case '3':\n        case '4': case '5': case '6':\n        case '7': case '8': case '9':\n            return parse_number(p, std::true_type(), std::integral_constant<char, '+'>());\n        case 't':\n            return parse_true(p, std::true_type());\n        case 'f':\n            return parse_false(p, std::true_type());\n        case 'n':\n            return parse_null(p, std::true_type());\n        case '\"':\n            return parse_unescaped(p, std::true_type(), std::false_type(), allow_bad_utf8);\n        case '[':\n            return parse_array(p, std::true_type(), allow_comments, allow_trailing, allow_bad_utf8);\n        case '{':\n            return parse_object(p, std::true_type(), allow_comments, allow_trailing, allow_bad_utf8);\n        case '/':\n            if(! allow_comments)\n            {\n                BOOST_STATIC_CONSTEXPR source_location loc\n                    = BOOST_CURRENT_LOCATION;\n                return fail(p, error::syntax, &loc);\n            }\n            p = parse_comment(p, stack_empty, std::false_type());\n            // KRYSTIAN NOTE: incomplete takes const_stream, we either\n            // can add an overload, change the existing one to take a pointer,\n            // or just leave it as is\n            if(BOOST_JSON_UNLIKELY(p == sentinel()))\n                return maybe_suspend(p, state::val2);\n            // intentional fallthrough\n        case ' ':\n        case '\\t':\n        case '\\n':\n        case '\\r':\n            p = detail::count_whitespace(p, end_);\n            if(BOOST_JSON_UNLIKELY(p == end_))\n                return maybe_suspend(p, state::val1);\n            goto loop;\n        default:\n            {\n                BOOST_STATIC_CONSTEXPR source_location loc\n                    = BOOST_CURRENT_LOCATION;\n                return fail(p, error::syntax, &loc);\n            }\n        }\n    }\n    return resume_value(p, stack_empty, allow_comments, allow_trailing, allow_bad_utf8);\n}\n\ntemplate<class Handler>\ntemplate<\n    bool StackEmpty_,\n    bool AllowComments_/*,\n    bool AllowTrailing_,\n    bool AllowBadUTF8_*/>\nconst char*\nbasic_parser<Handler>::\nresume_value(const char* p,\n    std::integral_constant<bool, StackEmpty_> stack_empty,\n    std::integral_constant<bool, AllowComments_> allow_comments,\n    /*std::integral_constant<bool, AllowTrailing_>*/ bool allow_trailing,\n    /*std::integral_constant<bool, AllowBadUTF8_>*/ bool allow_bad_utf8)\n{\n    state st;\n    st_.peek(st);\n    switch(st)\n    {\n    default: BOOST_JSON_UNREACHABLE();\n    case state::nul1: case state::nul2:\n    case state::nul3:\n        return parse_null(p, stack_empty);\n\n    case state::tru1: case state::tru2:\n    case state::tru3:\n        return parse_true(p, stack_empty);\n\n    case state::fal1: case state::fal2:\n    case state::fal3: case state::fal4:\n        return parse_false(p, stack_empty);\n\n    case state::str1:\n        return parse_unescaped(p, stack_empty, std::false_type(), allow_bad_utf8);\n\n    case state::str2: case state::str3:\n    case state::str4: case state::str5:\n    case state::str6: case state::str7:\n    case state::str8:\n    case state::sur1: case state::sur2:\n    case state::sur3: case state::sur4:\n    case state::sur5: case state::sur6:\n        return parse_escaped(p, 0, stack_empty, std::false_type(), allow_bad_utf8);\n\n    case state::arr1: case state::arr2:\n    case state::arr3: case state::arr4:\n    case state::arr5: case state::arr6:\n        return parse_array(p, stack_empty, allow_comments, allow_trailing, allow_bad_utf8);\n\n    case state::obj1: case state::obj2:\n    case state::obj3: case state::obj4:\n    case state::obj5: case state::obj6:\n    case state::obj7: case state::obj8:\n    case state::obj9: case state::obj10:\n    case state::obj11:\n        return parse_object(p, stack_empty, allow_comments, allow_trailing, allow_bad_utf8);\n\n    case state::num1: case state::num2:\n    case state::num3: case state::num4:\n    case state::num5: case state::num6:\n    case state::num7: case state::num8:\n    case state::exp1: case state::exp2:\n    case state::exp3:\n        return parse_number(p, stack_empty, std::integral_constant<char, 0>());\n\n    case state::com1: case state::com2:\n    case state::com3: case state::com4:\n        return parse_comment(p, stack_empty, std::false_type());\n\n    // KRYSTIAN NOTE: these are special cases\n    case state::val1:\n    {\n        st_.pop(st);\n        BOOST_ASSERT(st_.empty());\n        p = detail::count_whitespace(p, end_);\n        if(BOOST_JSON_UNLIKELY(p == end_))\n            return maybe_suspend(p, state::val1);\n        return parse_value(p, std::true_type(), allow_comments, allow_trailing, allow_bad_utf8);\n    }\n\n    case state::val2:\n    {\n        st_.pop(st);\n        p = parse_comment(p, stack_empty, std::false_type());\n        if(BOOST_JSON_UNLIKELY(p == sentinel()))\n            return maybe_suspend(p, state::val2);\n        BOOST_ASSERT(st_.empty());\n        return parse_value(p, std::true_type(), std::true_type(), allow_trailing, allow_bad_utf8);\n    }\n    }\n}\n\ntemplate<class Handler>\ntemplate<bool StackEmpty_>\nconst char*\nbasic_parser<Handler>::\nparse_null(const char* p,\n    std::integral_constant<bool, StackEmpty_> stack_empty)\n{\n    detail::const_stream_wrapper cs(p, end_);\n    if(stack_empty || st_.empty())\n    {\n        if(BOOST_JSON_LIKELY(cs.remain() >= 4))\n        {\n            if(BOOST_JSON_UNLIKELY(\n                std::memcmp(cs.begin(), \"null\", 4) != 0))\n            {\n                BOOST_STATIC_CONSTEXPR source_location loc\n                    = BOOST_CURRENT_LOCATION;\n                return fail(cs.begin(), error::syntax, &loc);\n            }\n            if(BOOST_JSON_UNLIKELY(\n                ! h_.on_null(ec_)))\n                return fail(cs.begin());\n            cs += 4;\n            return cs.begin();\n        }\n    }\n    else\n    {\n        state st;\n        st_.pop(st);\n        switch(st)\n        {\n        default: BOOST_JSON_UNREACHABLE();\n        case state::nul1: goto do_nul1;\n        case state::nul2: goto do_nul2;\n        case state::nul3: goto do_nul3;\n        }\n    }\n    ++cs;\ndo_nul1:\n    if(BOOST_JSON_UNLIKELY(! cs))\n        return maybe_suspend(cs.begin(), state::nul1);\n    if(BOOST_JSON_UNLIKELY(*cs != 'u'))\n    {\n        BOOST_STATIC_CONSTEXPR source_location loc = BOOST_CURRENT_LOCATION;\n        return fail(cs.begin(), error::syntax, &loc);\n    }\n    ++cs;\ndo_nul2:\n    if(BOOST_JSON_UNLIKELY(! cs))\n        return maybe_suspend(cs.begin(), state::nul2);\n    if(BOOST_JSON_UNLIKELY(*cs != 'l'))\n    {\n        BOOST_STATIC_CONSTEXPR source_location loc = BOOST_CURRENT_LOCATION;\n        return fail(cs.begin(), error::syntax, &loc);\n    }\n    ++cs;\ndo_nul3:\n    if(BOOST_JSON_UNLIKELY(! cs))\n        return maybe_suspend(cs.begin(), state::nul3);\n    if(BOOST_JSON_UNLIKELY(*cs != 'l'))\n    {\n        BOOST_STATIC_CONSTEXPR source_location loc = BOOST_CURRENT_LOCATION;\n        return fail(cs.begin(), error::syntax, &loc);\n    }\n    if(BOOST_JSON_UNLIKELY(\n        ! h_.on_null(ec_)))\n        return fail(cs.begin());\n    ++cs;\n    return cs.begin();\n}\n\ntemplate<class Handler>\ntemplate<bool StackEmpty_>\nconst char*\nbasic_parser<Handler>::\nparse_true(const char* p,\n    std::integral_constant<bool, StackEmpty_> stack_empty)\n{\n    detail::const_stream_wrapper cs(p, end_);\n    if(stack_empty || st_.empty())\n    {\n        if(BOOST_JSON_LIKELY(cs.remain() >= 4))\n        {\n            if(BOOST_JSON_UNLIKELY(\n                std::memcmp(cs.begin(), \"true\", 4) != 0))\n            {\n                BOOST_STATIC_CONSTEXPR source_location loc\n                    = BOOST_CURRENT_LOCATION;\n                return fail(cs.begin(), error::syntax, &loc);\n            }\n            if(BOOST_JSON_UNLIKELY(\n                ! h_.on_bool(true, ec_)))\n                return fail(cs.begin());\n            cs += 4;\n            return cs.begin();\n        }\n    }\n    else\n    {\n        state st;\n        st_.pop(st);\n        switch(st)\n        {\n        default: BOOST_JSON_UNREACHABLE();\n        case state::tru1: goto do_tru1;\n        case state::tru2: goto do_tru2;\n        case state::tru3: goto do_tru3;\n        }\n    }\n    ++cs;\ndo_tru1:\n    if(BOOST_JSON_UNLIKELY(! cs))\n        return maybe_suspend(cs.begin(), state::tru1);\n    if(BOOST_JSON_UNLIKELY(*cs != 'r'))\n    {\n        BOOST_STATIC_CONSTEXPR source_location loc = BOOST_CURRENT_LOCATION;\n        return fail(cs.begin(), error::syntax, &loc);\n    }\n    ++cs;\ndo_tru2:\n    if(BOOST_JSON_UNLIKELY(! cs))\n        return maybe_suspend(cs.begin(), state::tru2);\n    if(BOOST_JSON_UNLIKELY(*cs != 'u'))\n    {\n        BOOST_STATIC_CONSTEXPR source_location loc = BOOST_CURRENT_LOCATION;\n        return fail(cs.begin(), error::syntax, &loc);\n    }\n    ++cs;\ndo_tru3:\n    if(BOOST_JSON_UNLIKELY(! cs))\n        return maybe_suspend(cs.begin(), state::tru3);\n    if(BOOST_JSON_UNLIKELY(*cs != 'e'))\n    {\n        BOOST_STATIC_CONSTEXPR source_location loc = BOOST_CURRENT_LOCATION;\n        return fail(cs.begin(), error::syntax, &loc);\n    }\n    if(BOOST_JSON_UNLIKELY(\n        ! h_.on_bool(true, ec_)))\n        return fail(cs.begin());\n    ++cs;\n    return cs.begin();\n}\n\ntemplate<class Handler>\ntemplate<bool StackEmpty_>\nconst char*\nbasic_parser<Handler>::\nparse_false(const char* p,\n    std::integral_constant<bool, StackEmpty_> stack_empty)\n{\n    detail::const_stream_wrapper cs(p, end_);\n    if(stack_empty || st_.empty())\n    {\n        if(BOOST_JSON_LIKELY(cs.remain() >= 5))\n        {\n            if(BOOST_JSON_UNLIKELY(\n                std::memcmp(cs.begin() + 1, \"alse\", 4) != 0))\n            {\n                BOOST_STATIC_CONSTEXPR source_location loc\n                    = BOOST_CURRENT_LOCATION;\n                return fail(cs.begin(), error::syntax, &loc);\n            }\n            if(BOOST_JSON_UNLIKELY(\n                ! h_.on_bool(false, ec_)))\n                return fail(cs.begin());\n            cs += 5;\n            return cs.begin();\n        }\n    }\n    else\n    {\n        state st;\n        st_.pop(st);\n        switch(st)\n        {\n        default: BOOST_JSON_UNREACHABLE();\n        case state::fal1: goto do_fal1;\n        case state::fal2: goto do_fal2;\n        case state::fal3: goto do_fal3;\n        case state::fal4: goto do_fal4;\n        }\n    }\n    ++cs;\ndo_fal1:\n    if(BOOST_JSON_UNLIKELY(! cs))\n        return maybe_suspend(cs.begin(), state::fal1);\n    if(BOOST_JSON_UNLIKELY(*cs != 'a'))\n    {\n        BOOST_STATIC_CONSTEXPR source_location loc = BOOST_CURRENT_LOCATION;\n        return fail(cs.begin(), error::syntax, &loc);\n    }\n    ++cs;\ndo_fal2:\n    if(BOOST_JSON_UNLIKELY(! cs))\n        return maybe_suspend(cs.begin(), state::fal2);\n    if(BOOST_JSON_UNLIKELY(*cs != 'l'))\n    {\n        BOOST_STATIC_CONSTEXPR source_location loc = BOOST_CURRENT_LOCATION;\n        return fail(cs.begin(), error::syntax, &loc);\n    }\n    ++cs;\ndo_fal3:\n    if(BOOST_JSON_UNLIKELY(! cs))\n        return maybe_suspend(cs.begin(), state::fal3);\n    if(BOOST_JSON_UNLIKELY(*cs != 's'))\n    {\n        BOOST_STATIC_CONSTEXPR source_location loc = BOOST_CURRENT_LOCATION;\n        return fail(cs.begin(), error::syntax, &loc);\n    }\n    ++cs;\ndo_fal4:\n    if(BOOST_JSON_UNLIKELY(! cs))\n        return maybe_suspend(cs.begin(), state::fal4);\n    if(BOOST_JSON_UNLIKELY(*cs != 'e'))\n    {\n        BOOST_STATIC_CONSTEXPR source_location loc = BOOST_CURRENT_LOCATION;\n        return fail(cs.begin(), error::syntax, &loc);\n    }\n    if(BOOST_JSON_UNLIKELY(\n        ! h_.on_bool(false, ec_)))\n        return fail(cs.begin());\n    ++cs;\n    return cs.begin();\n}\n\n//----------------------------------------------------------\n\ntemplate<class Handler>\ntemplate<\n    bool StackEmpty_,\n    bool IsKey_/*,\n    bool AllowBadUTF8_*/>\nconst char*\nbasic_parser<Handler>::\nparse_string(const char* p,\n    std::integral_constant<bool, StackEmpty_> stack_empty,\n    std::integral_constant<bool, IsKey_> is_key,\n    /*std::integral_constant<bool, AllowBadUTF8_>*/ bool allow_bad_utf8)\n{\n    if(! stack_empty && ! st_.empty())\n    {\n        state st;\n        st_.peek(st);\n        switch(st)\n        {\n        default: BOOST_JSON_UNREACHABLE();\n        case state::str1:\n            return parse_unescaped(p, stack_empty, is_key, allow_bad_utf8);\n\n        case state::str2: case state::str3:\n        case state::str4: case state::str5:\n        case state::str6: case state::str7:\n        case state::str8:\n        case state::sur1: case state::sur2:\n        case state::sur3: case state::sur4:\n        case state::sur5: case state::sur6:\n            return parse_escaped(p, 0, stack_empty, is_key, allow_bad_utf8);\n        }\n    }\n\n    return parse_unescaped(p, std::true_type(), is_key, allow_bad_utf8);\n}\n\ntemplate<class Handler>\ntemplate<\n    bool StackEmpty_,\n    bool IsKey_/*,\n    bool AllowBadUTF8_*/>\nconst char*\nbasic_parser<Handler>::\nparse_unescaped(const char* p,\n    std::integral_constant<bool, StackEmpty_> stack_empty,\n    std::integral_constant<bool, IsKey_> is_key,\n    /*std::integral_constant<bool, AllowBadUTF8_>*/ bool allow_bad_utf8)\n{\n    detail::const_stream_wrapper cs(p, end_);\n    std::size_t total;\n    if(stack_empty || st_.empty())\n    {\n        BOOST_ASSERT(*cs == '\\x22'); // '\"'\n        ++cs;\n        total = 0;\n    }\n    else\n    {\n        state st;\n        st_.pop(st);\n        st_.pop(total);\n    }\n    char const* start = cs.begin();\n    cs = allow_bad_utf8?\n        detail::count_valid<true>(cs.begin(), cs.end()):\n        detail::count_valid<false>(cs.begin(), cs.end());\n    std::size_t size = cs.used(start);\n    if(is_key)\n    {\n        BOOST_ASSERT(total <= Handler::max_key_size);\n        if(BOOST_JSON_UNLIKELY(size >\n            Handler::max_key_size - total))\n        {\n            BOOST_STATIC_CONSTEXPR source_location loc\n                = BOOST_CURRENT_LOCATION;\n            return fail(cs.begin(), error::key_too_large, &loc);\n        }\n    }\n    else\n    {\n        BOOST_ASSERT(total <= Handler::max_string_size);\n        if(BOOST_JSON_UNLIKELY(size >\n            Handler::max_string_size - total))\n        {\n            BOOST_STATIC_CONSTEXPR source_location loc\n                = BOOST_CURRENT_LOCATION;\n            return fail(cs.begin(), error::string_too_large, &loc);\n        }\n    }\n    total += size;\n    if(BOOST_JSON_UNLIKELY(! cs))\n    {\n        // call handler if the string isn't empty\n        if(BOOST_JSON_LIKELY(size))\n        {\n            {\n                bool r = is_key?\n                    h_.on_key_part( {start, size}, total, ec_ ):\n                    h_.on_string_part( {start, size}, total, ec_ );\n\n                if(BOOST_JSON_UNLIKELY(!r))\n                {\n                    return fail(cs.begin());\n                }\n            }\n        }\n        return maybe_suspend(cs.begin(), state::str1, total);\n    }\n    // at this point all valid characters have been skipped, so any remaining\n    // if there are any more characters, they are either escaped, or incomplete\n    // utf8, or invalid utf8\n    if(BOOST_JSON_UNLIKELY(*cs != '\\x22')) // '\"'\n    {\n        // sequence is invalid or incomplete\n        if((*cs & 0x80) && !allow_bad_utf8)\n        {\n            seq_.save(cs.begin(), cs.remain());\n            if(BOOST_JSON_UNLIKELY(seq_.complete()))\n            {\n                BOOST_STATIC_CONSTEXPR source_location loc\n                    = BOOST_CURRENT_LOCATION;\n                return fail(cs.begin(), error::syntax, &loc);\n            }\n            if(BOOST_JSON_LIKELY(size))\n            {\n                {\n                    bool r = is_key?\n                        h_.on_key_part( {start, size}, total, ec_ ):\n                        h_.on_string_part( {start, size}, total, ec_ );\n\n                    if(BOOST_JSON_UNLIKELY(!r))\n                    {\n                        return fail(cs.begin());\n                    }\n                }\n            }\n            return maybe_suspend(cs.end(), state::str8, total);\n        }\n        else if(BOOST_JSON_LIKELY(*cs == '\\\\'))\n        {\n            // flush unescaped run from input\n            if(BOOST_JSON_LIKELY(size))\n            {\n                {\n                    bool r = is_key?\n                        h_.on_key_part( {start, size}, total, ec_ ):\n                        h_.on_string_part( {start, size}, total, ec_ );\n\n                    if(BOOST_JSON_UNLIKELY(!r))\n                    {\n                        return fail(cs.begin());\n                    }\n                }\n            }\n            return parse_escaped(cs.begin(), total, stack_empty, is_key, allow_bad_utf8);\n        }\n        // illegal control\n        BOOST_STATIC_CONSTEXPR source_location loc = BOOST_CURRENT_LOCATION;\n        return fail(cs.begin(), error::syntax, &loc);\n    }\n\n    {\n        bool r = is_key?\n            h_.on_key( {start, size}, total, ec_ ):\n            h_.on_string( {start, size}, total, ec_ );\n\n        if(BOOST_JSON_UNLIKELY(!r))\n        {\n            return fail(cs.begin());\n        }\n    }\n\n    ++cs;\n    return cs.begin();\n}\n\ntemplate<class Handler>\ntemplate<\n    bool StackEmpty_/*,\n    bool IsKey_,\n    bool AllowBadUTF8_*/>\nconst char*\nbasic_parser<Handler>::\nparse_escaped(\n    const char* p,\n    std::size_t total,\n    std::integral_constant<bool, StackEmpty_> stack_empty,\n    /*std::integral_constant<bool, IsKey_>*/ bool is_key,\n    /*std::integral_constant<bool, AllowBadUTF8_>*/ bool allow_bad_utf8)\n{\n    //---------------------------------------------------------------\n    //\n    // To handle escapes, a local temporary buffer accumulates\n    // the unescaped result. The algorithm attempts to fill the\n    // buffer to capacity before invoking the handler.\n    // In some cases the temporary buffer needs to be flushed\n    // before it is full:\n    // * When the closing double quote is seen\n    // * When there in no more input (and more is expected later)\n    // A goal of the algorithm is to call the handler as few times\n    // as possible. Thus, when the first escape is encountered,\n    // the algorithm attempts to fill the temporary buffer first.\n    //\n    auto const ev_too_large = is_key?\n        error::key_too_large : error::string_too_large;\n    auto const max_size = is_key?\n        Handler::max_key_size : Handler::max_string_size;\n    detail::clipped_const_stream cs(p, end_);\n    detail::buffer<BOOST_JSON_STACK_BUFFER_SIZE> temp;\n    int digit;\n    char c;\n    cs.clip(temp.max_size());\n    if(! stack_empty && ! st_.empty())\n    {\n        state st;\n        st_.pop(st);\n        st_.pop(total);\n        switch(st)\n        {\n        default: BOOST_JSON_UNREACHABLE();\n        case state::str2: goto do_str2;\n        case state::str3: goto do_str3;\n        case state::str4: goto do_str4;\n        case state::str5: goto do_str5;\n        case state::str6: goto do_str6;\n        case state::str7: goto do_str7;\n        case state::str8: goto do_str8;\n        case state::sur1: goto do_sur1;\n        case state::sur2: goto do_sur2;\n        case state::sur3: goto do_sur3;\n        case state::sur4: goto do_sur4;\n        case state::sur5: goto do_sur5;\n        case state::sur6: goto do_sur6;\n        }\n    }\n    // Unescaped JSON is never larger than its escaped version.\n    // To efficiently process only what will fit in the temporary buffer,\n    // the size of the input stream is temporarily \"clipped\" to the size\n    // of the temporary buffer.\n    // handle escaped character\n    BOOST_ASSERT(*cs == '\\\\');\n    ++cs;\ndo_str3:\n    if(BOOST_JSON_UNLIKELY(! cs))\n    {\n        if(BOOST_JSON_LIKELY(! temp.empty()))\n        {\n            BOOST_ASSERT(total <= max_size);\n            if(BOOST_JSON_UNLIKELY(\n                temp.size() > max_size - total))\n            {\n                BOOST_STATIC_CONSTEXPR source_location loc\n                    = BOOST_CURRENT_LOCATION;\n                return fail(cs.begin(), ev_too_large, &loc);\n            }\n            total += temp.size();\n            {\n                bool r = is_key\n                    ? h_.on_key_part(temp.get(), total, ec_)\n                    : h_.on_string_part(temp.get(), total, ec_);\n\n                if(BOOST_JSON_UNLIKELY(!r))\n                {\n                    return fail(cs.begin());\n                }\n            }\n            temp.clear();\n        }\n        cs.clip(temp.max_size());\n        if(BOOST_JSON_UNLIKELY(! cs))\n            return maybe_suspend(cs.begin(), state::str3, total);\n    }\n    switch(*cs)\n    {\n    default:\n        {\n            BOOST_STATIC_CONSTEXPR source_location loc\n                = BOOST_CURRENT_LOCATION;\n            return fail(cs.begin(), error::syntax, &loc);\n        }\n    case '\\x22': // '\"'\n        temp.push_back('\\x22');\n        ++cs;\n        break;\n    case '\\\\':\n        temp.push_back('\\\\');\n        ++cs;\n        break;\n    case '/':\n        temp.push_back('/');\n        ++cs;\n        break;\n    case 'b':\n        temp.push_back('\\x08');\n        ++cs;\n        break;\n    case 'f':\n        temp.push_back('\\x0c');\n        ++cs;\n        break;\n    case 'n':\n        temp.push_back('\\x0a');\n        ++cs;\n        break;\n    case 'r':\n        temp.push_back('\\x0d');\n        ++cs;\n        break;\n    case 't':\n        temp.push_back('\\x09');\n        ++cs;\n        break;\n    case 'u':\n        // utf16 escape\n        //\n        // fast path only when the buffer\n        // is large enough for 2 surrogates\n        if(BOOST_JSON_LIKELY(cs.remain() > 10))\n        {\n            // KRYSTIAN TODO: this could be done\n            // with fewer instructions\n            digit = detail::load_little_endian<4>(\n                cs.begin() + 1);\n            int d4 = detail::hex_digit(static_cast<\n                unsigned char>(digit >> 24));\n            int d3 = detail::hex_digit(static_cast<\n                unsigned char>(digit >> 16));\n            int d2 = detail::hex_digit(static_cast<\n                unsigned char>(digit >> 8));\n            int d1 = detail::hex_digit(static_cast<\n                unsigned char>(digit));\n            if(BOOST_JSON_UNLIKELY(\n                (d1 | d2 | d3 | d4) == -1))\n            {\n                if(d1 != -1)\n                    ++cs;\n                if(d2 != -1)\n                    ++cs;\n                if(d3 != -1)\n                    ++cs;\n                BOOST_STATIC_CONSTEXPR source_location loc\n                    = BOOST_CURRENT_LOCATION;\n                return fail(cs.begin(), error::expected_hex_digit, &loc);\n            }\n            // 32 bit unicode scalar value\n            unsigned const u1 =\n                (d1 << 12) + (d2 << 8) +\n                (d3 << 4) + d4;\n            // valid unicode scalar values are\n            // [0, D7FF] and [E000, 10FFFF]\n            // values within this range are valid utf-8\n            // code points and invalid leading surrogates.\n            if(BOOST_JSON_LIKELY(\n                u1 < 0xd800 || u1 > 0xdfff))\n            {\n                cs += 5;\n                temp.append_utf8(u1);\n                break;\n            }\n            if(BOOST_JSON_UNLIKELY(u1 > 0xdbff))\n            {\n                BOOST_STATIC_CONSTEXPR source_location loc\n                    = BOOST_CURRENT_LOCATION;\n                return fail(cs.begin(), error::illegal_leading_surrogate,\n                    &loc);\n            }\n            cs += 5;\n            // KRYSTIAN TODO: this can be a two byte load\n            // and a single comparison. We lose error information,\n            // but it's faster.\n            if(BOOST_JSON_UNLIKELY(*cs != '\\\\'))\n            {\n                BOOST_STATIC_CONSTEXPR source_location loc\n                    = BOOST_CURRENT_LOCATION;\n                return fail(cs.begin(), error::syntax, &loc);\n            }\n            ++cs;\n            if(BOOST_JSON_UNLIKELY(*cs != 'u'))\n            {\n                BOOST_STATIC_CONSTEXPR source_location loc\n                    = BOOST_CURRENT_LOCATION;\n                return fail(cs.begin(), error::syntax, &loc);\n            }\n            ++cs;\n            digit = detail::load_little_endian<4>(cs.begin());\n            d4 = detail::hex_digit(static_cast<\n                unsigned char>(digit >> 24));\n            d3 = detail::hex_digit(static_cast<\n                unsigned char>(digit >> 16));\n            d2 = detail::hex_digit(static_cast<\n                unsigned char>(digit >> 8));\n            d1 = detail::hex_digit(static_cast<\n                unsigned char>(digit));\n            if(BOOST_JSON_UNLIKELY(\n                (d1 | d2 | d3 | d4) == -1))\n            {\n                if(d1 != -1)\n                    ++cs;\n                if(d2 != -1)\n                    ++cs;\n                if(d3 != -1)\n                    ++cs;\n                BOOST_STATIC_CONSTEXPR source_location loc\n                    = BOOST_CURRENT_LOCATION;\n                return fail(cs.begin(), error::expected_hex_digit, &loc);\n            }\n            unsigned const u2 =\n                (d1 << 12) + (d2 << 8) +\n                (d3 << 4) + d4;\n            // valid trailing surrogates are [DC00, DFFF]\n            if(BOOST_JSON_UNLIKELY(\n                u2 < 0xdc00 || u2 > 0xdfff))\n            {\n                BOOST_STATIC_CONSTEXPR source_location loc\n                    = BOOST_CURRENT_LOCATION;\n                return fail(cs.begin(), error::illegal_trailing_surrogate,\n                    &loc);\n            }\n            cs += 4;\n            unsigned cp =\n                ((u1 - 0xd800) << 10) +\n                ((u2 - 0xdc00)) +\n                    0x10000;\n            // utf-16 surrogate pair\n            temp.append_utf8(cp);\n            break;\n        }\n        // flush\n        if(BOOST_JSON_LIKELY(! temp.empty()))\n        {\n            BOOST_ASSERT(total <= max_size);\n            if(BOOST_JSON_UNLIKELY(\n                temp.size() > max_size - total))\n            {\n                BOOST_STATIC_CONSTEXPR source_location loc\n                    = BOOST_CURRENT_LOCATION;\n                return fail(cs.begin(), ev_too_large, &loc);\n            }\n            total += temp.size();\n            {\n                bool r = is_key\n                    ? h_.on_key_part(temp.get(), total, ec_)\n                    : h_.on_string_part(temp.get(), total, ec_);\n\n                if(BOOST_JSON_UNLIKELY(!r))\n                {\n                    return fail(cs.begin());\n                }\n            }\n            temp.clear();\n            cs.clip(temp.max_size());\n        }\n        ++cs;\n        // utf-16 escape\ndo_str4:\n        if(BOOST_JSON_UNLIKELY(! cs))\n            return maybe_suspend(cs.begin(), state::str4, total);\n        digit = detail::hex_digit(*cs);\n        if(BOOST_JSON_UNLIKELY(digit == -1))\n        {\n            BOOST_STATIC_CONSTEXPR source_location loc\n                = BOOST_CURRENT_LOCATION;\n            return fail(cs.begin(), error::expected_hex_digit, &loc);\n        }\n        ++cs;\n        u1_ = digit << 12;\ndo_str5:\n        if(BOOST_JSON_UNLIKELY(! cs))\n            return maybe_suspend(cs.begin(), state::str5, total);\n        digit = detail::hex_digit(*cs);\n        if(BOOST_JSON_UNLIKELY(digit == -1))\n        {\n            BOOST_STATIC_CONSTEXPR source_location loc\n                = BOOST_CURRENT_LOCATION;\n            return fail(cs.begin(), error::expected_hex_digit, &loc);\n        }\n        ++cs;\n        u1_ += digit << 8;\ndo_str6:\n        if(BOOST_JSON_UNLIKELY(! cs))\n            return maybe_suspend(cs.begin(), state::str6, total);\n        digit = detail::hex_digit(*cs);\n        if(BOOST_JSON_UNLIKELY(digit == -1))\n        {\n            BOOST_STATIC_CONSTEXPR source_location loc\n                = BOOST_CURRENT_LOCATION;\n            return fail(cs.begin(), error::expected_hex_digit, &loc);\n        }\n        ++cs;\n        u1_ += digit << 4;\ndo_str7:\n        if(BOOST_JSON_UNLIKELY(! cs))\n            return maybe_suspend(cs.begin(), state::str7, total);\n        digit = detail::hex_digit(*cs);\n        if(BOOST_JSON_UNLIKELY(digit == -1))\n        {\n            BOOST_STATIC_CONSTEXPR source_location loc\n                = BOOST_CURRENT_LOCATION;\n            return fail(cs.begin(), error::expected_hex_digit, &loc);\n        }\n        ++cs;\n        u1_ += digit;\n        if(BOOST_JSON_LIKELY(\n            u1_ < 0xd800 || u1_ > 0xdfff))\n        {\n            BOOST_ASSERT(temp.empty());\n            // utf-8 codepoint\n            temp.append_utf8(u1_);\n            break;\n        }\n        if(BOOST_JSON_UNLIKELY(u1_ > 0xdbff))\n        {\n            BOOST_STATIC_CONSTEXPR source_location loc\n                = BOOST_CURRENT_LOCATION;\n            return fail(cs.begin(), error::illegal_trailing_surrogate, &loc);\n        }\ndo_sur1:\n        if(BOOST_JSON_UNLIKELY(! cs))\n            return maybe_suspend(cs.begin(), state::sur1, total);\n        if(BOOST_JSON_UNLIKELY(*cs != '\\\\'))\n        {\n            BOOST_STATIC_CONSTEXPR source_location loc\n                = BOOST_CURRENT_LOCATION;\n            return fail(cs.begin(), error::syntax, &loc);\n        }\n        ++cs;\ndo_sur2:\n        if(BOOST_JSON_UNLIKELY(! cs))\n            return maybe_suspend(cs.begin(), state::sur2, total);\n        if(BOOST_JSON_UNLIKELY(*cs != 'u'))\n        {\n            BOOST_STATIC_CONSTEXPR source_location loc\n                = BOOST_CURRENT_LOCATION;\n            return fail(cs.begin(), error::syntax, &loc);\n        }\n        ++cs;\ndo_sur3:\n        if(BOOST_JSON_UNLIKELY(! cs))\n            return maybe_suspend(cs.begin(), state::sur3, total);\n        digit = detail::hex_digit(*cs);\n        if(BOOST_JSON_UNLIKELY(digit == -1))\n        {\n            BOOST_STATIC_CONSTEXPR source_location loc\n                = BOOST_CURRENT_LOCATION;\n            return fail(cs.begin(), error::expected_hex_digit, &loc);\n        }\n        ++cs;\n        u2_ = digit << 12;\ndo_sur4:\n        if(BOOST_JSON_UNLIKELY(! cs))\n            return maybe_suspend(cs.begin(), state::sur4, total);\n        digit = detail::hex_digit(*cs);\n        if(BOOST_JSON_UNLIKELY(digit == -1))\n        {\n            BOOST_STATIC_CONSTEXPR source_location loc\n                = BOOST_CURRENT_LOCATION;\n            return fail(cs.begin(), error::expected_hex_digit, &loc);\n        }\n        ++cs;\n        u2_ += digit << 8;\ndo_sur5:\n        if(BOOST_JSON_UNLIKELY(! cs))\n            return maybe_suspend(cs.begin(), state::sur5, total);\n        digit = detail::hex_digit(*cs);\n        if(BOOST_JSON_UNLIKELY(digit == -1))\n        {\n            BOOST_STATIC_CONSTEXPR source_location loc\n                = BOOST_CURRENT_LOCATION;\n            return fail(cs.begin(), error::expected_hex_digit, &loc);\n        }\n        ++cs;\n        u2_ += digit << 4;\ndo_sur6:\n        if(BOOST_JSON_UNLIKELY(! cs))\n            return maybe_suspend(cs.begin(), state::sur6, total);\n        digit = detail::hex_digit(*cs);\n        if(BOOST_JSON_UNLIKELY(digit == -1))\n        {\n            BOOST_STATIC_CONSTEXPR source_location loc\n                = BOOST_CURRENT_LOCATION;\n            return fail(cs.begin(), error::expected_hex_digit, &loc);\n        }\n        ++cs;\n        u2_ += digit;\n        if(BOOST_JSON_UNLIKELY(\n            u2_ < 0xdc00 || u2_ > 0xdfff))\n        {\n            BOOST_STATIC_CONSTEXPR source_location loc\n                = BOOST_CURRENT_LOCATION;\n            return fail(cs.begin(), error::expected_hex_digit, &loc);\n        }\n        unsigned cp =\n            ((u1_ - 0xd800) << 10) +\n            ((u2_ - 0xdc00)) +\n                0x10000;\n        BOOST_ASSERT(temp.empty());\n        // utf-16 surrogate pair\n        temp.append_utf8(cp);\n    }\ndo_str2:\n    // KRYSTIAN TODO: we can append the characters\n    // all at once instead of one at a time\n    for(;;)\n    {\n        if(BOOST_JSON_UNLIKELY(! cs))\n        {\n            // flush\n            if(BOOST_JSON_LIKELY(! temp.empty()))\n            {\n                BOOST_ASSERT(total <= max_size);\n                if(BOOST_JSON_UNLIKELY(\n                    temp.size() > max_size - total))\n                {\n                    BOOST_STATIC_CONSTEXPR source_location loc\n                        = BOOST_CURRENT_LOCATION;\n                    return fail(cs.begin(), ev_too_large, &loc);\n                }\n                total += temp.size();\n                {\n                    bool r = is_key\n                        ? h_.on_key_part(temp.get(), total, ec_)\n                        : h_.on_string_part(temp.get(), total, ec_);\n\n                    if(BOOST_JSON_UNLIKELY(!r))\n                    {\n                        return fail(cs.begin());\n                    }\n                }\n                temp.clear();\n            }\n            cs.clip(temp.max_size());\n            if(BOOST_JSON_UNLIKELY(! cs))\n                return maybe_suspend(cs.begin(), state::str2, total);\n        }\n        c = *cs;\n        if(BOOST_JSON_LIKELY(c == '\\x22')) // '\"'\n        {\n            BOOST_ASSERT(total <= max_size);\n            if(BOOST_JSON_UNLIKELY(\n                temp.size() > max_size - total))\n            {\n                BOOST_STATIC_CONSTEXPR source_location loc\n                    = BOOST_CURRENT_LOCATION;\n                return fail(cs.begin(), ev_too_large, &loc);\n            }\n            total += temp.size();\n            {\n                bool r = is_key\n                    ? h_.on_key(temp.get(), total, ec_)\n                    : h_.on_string(temp.get(), total, ec_);\n\n                if(BOOST_JSON_UNLIKELY(!r))\n                {\n                    return fail(cs.begin());\n                }\n            }\n            ++cs;\n            return cs.begin();\n        }\n        else if((c & 0x80) && !allow_bad_utf8)\n        {\n            seq_.save(cs.begin(), cs.remain());\n            if(BOOST_JSON_UNLIKELY(! seq_.complete()))\n            {\n                if(BOOST_JSON_LIKELY(! temp.empty()))\n                {\n                    BOOST_ASSERT(total <= max_size);\n                    if(BOOST_JSON_UNLIKELY(\n                        temp.size() > max_size - total))\n                    {\n                        BOOST_STATIC_CONSTEXPR source_location loc\n                            = BOOST_CURRENT_LOCATION;\n                        return fail(cs.begin(), ev_too_large, &loc);\n                    }\n                    total += temp.size();\n                    {\n                        bool r = is_key\n                            ? h_.on_key_part(temp.get(), total, ec_)\n                            : h_.on_string_part(temp.get(), total, ec_);\n\n                        if(BOOST_JSON_UNLIKELY(!r))\n                        {\n                            return fail(cs.begin());\n                        }\n                    }\n                    temp.clear();\n                }\n                cs = cs.end();\n                // ensure there is room for the saved byte sequence\n                cs.clip(temp.max_size() - seq_.length());\n                goto do_str8;\n            }\n            if(BOOST_JSON_UNLIKELY(! seq_.valid()))\n            {\n                BOOST_STATIC_CONSTEXPR source_location loc\n                    = BOOST_CURRENT_LOCATION;\n                return fail(cs.begin(), error::syntax, &loc);\n            }\n            temp.append(seq_.data(), seq_.length());\n            cs += seq_.length();\n            continue;\n        }\n        else if(BOOST_JSON_LIKELY(c == '\\\\'))\n        {\n            ++cs;\n            goto do_str3;\n        }\n        else if(BOOST_JSON_UNLIKELY(\n            detail::is_control(c)))\n        {\n            BOOST_STATIC_CONSTEXPR source_location loc\n                = BOOST_CURRENT_LOCATION;\n            return fail(cs.begin(), error::syntax, &loc);\n        }\n        temp.push_back(c);\n        ++cs;\n    }\ndo_str8:\n    uint8_t needed = seq_.needed();\n    if(BOOST_JSON_UNLIKELY(\n        ! seq_.append(cs.begin(), cs.remain())))\n        return maybe_suspend(cs.end(), state::str8, total);\n    if(BOOST_JSON_UNLIKELY(! seq_.valid()))\n    {\n        BOOST_STATIC_CONSTEXPR source_location loc = BOOST_CURRENT_LOCATION;\n        return fail(cs.begin(), error::syntax, &loc);\n    }\n    temp.append(seq_.data(), seq_.length());\n    cs += needed;\n    goto do_str2;\n}\n\n//----------------------------------------------------------\n\ntemplate<class Handler>\ntemplate<\n    bool StackEmpty_,\n    bool AllowComments_/*,\n    bool AllowTrailing_,\n    bool AllowBadUTF8_*/>\nconst char*\nbasic_parser<Handler>::\nparse_object(const char* p,\n    std::integral_constant<bool, StackEmpty_> stack_empty,\n    std::integral_constant<bool, AllowComments_> allow_comments,\n    /*std::integral_constant<bool, AllowTrailing_>*/ bool allow_trailing,\n    /*std::integral_constant<bool, AllowBadUTF8_>*/ bool allow_bad_utf8)\n{\n    detail::const_stream_wrapper cs(p, end_);\n    std::size_t size;\n    if(! stack_empty && ! st_.empty())\n    {\n        // resume\n        state st;\n        st_.pop(st);\n        st_.pop(size);\n        switch(st)\n        {\n        default: BOOST_JSON_UNREACHABLE();\n        case state::obj1: goto do_obj1;\n        case state::obj2: goto do_obj2;\n        case state::obj3: goto do_obj3;\n        case state::obj4: goto do_obj4;\n        case state::obj5: goto do_obj5;\n        case state::obj6: goto do_obj6;\n        case state::obj7: goto do_obj7;\n        case state::obj8: goto do_obj8;\n        case state::obj9: goto do_obj9;\n        case state::obj10: goto do_obj10;\n        case state::obj11: goto do_obj11;\n        }\n    }\n    BOOST_ASSERT(*cs == '{');\n    size = 0;\n    if(BOOST_JSON_UNLIKELY(! depth_))\n    {\n        BOOST_STATIC_CONSTEXPR source_location loc = BOOST_CURRENT_LOCATION;\n        return fail(cs.begin(), error::too_deep, &loc);\n    }\n    --depth_;\n    if(BOOST_JSON_UNLIKELY(\n        ! h_.on_object_begin(ec_)))\n        return fail(cs.begin());\n    ++cs;\n    // object:\n    //     '{' *ws '}'\n    //     '{' *ws string *ws ':' *ws value *ws *[ ',' *ws string *ws ':' *ws value *ws ] '}'\ndo_obj1:\n    cs = detail::count_whitespace(cs.begin(), cs.end());\n    if(BOOST_JSON_UNLIKELY(! cs))\n        return maybe_suspend(cs.begin(), state::obj1, size);\n    if(BOOST_JSON_LIKELY(*cs != '}'))\n    {\n        if(BOOST_JSON_UNLIKELY(*cs != '\\x22'))\n        {\n            if(allow_comments && *cs == '/')\n            {\ndo_obj2:\n                cs = parse_comment(cs.begin(), stack_empty, std::false_type());\n                if(BOOST_JSON_UNLIKELY(incomplete(cs)))\n                    return suspend_or_fail(state::obj2, size);\n                goto do_obj1;\n            }\n            BOOST_STATIC_CONSTEXPR source_location loc\n                = BOOST_CURRENT_LOCATION;\n            return fail(cs.begin(), error::syntax, &loc);\n        }\nloop:\n        if(BOOST_JSON_UNLIKELY(++size >\n            Handler::max_object_size))\n        {\n            BOOST_STATIC_CONSTEXPR source_location loc\n                = BOOST_CURRENT_LOCATION;\n            return fail(cs.begin(), error::object_too_large, &loc);\n        }\ndo_obj3:\n        cs = parse_string(cs.begin(), stack_empty, std::true_type(), allow_bad_utf8);\n        if(BOOST_JSON_UNLIKELY(incomplete(cs)))\n            return suspend_or_fail(state::obj3, size);\ndo_obj4:\n        cs = detail::count_whitespace(cs.begin(), cs.end());\n        if(BOOST_JSON_UNLIKELY(! cs))\n            return maybe_suspend(cs.begin(), state::obj4, size);\n        if(BOOST_JSON_UNLIKELY(*cs != ':'))\n        {\n            if(allow_comments && *cs == '/')\n            {\ndo_obj5:\n                cs = parse_comment(cs.begin(), stack_empty, std::false_type());\n                if(BOOST_JSON_UNLIKELY(incomplete(cs)))\n                    return suspend_or_fail(state::obj5, size);\n                goto do_obj4;\n            }\n            BOOST_STATIC_CONSTEXPR source_location loc\n                = BOOST_CURRENT_LOCATION;\n            return fail(cs.begin(), error::syntax, &loc);\n        }\n        ++cs;\ndo_obj6:\n        cs = detail::count_whitespace(cs.begin(), cs.end());\n        if(BOOST_JSON_UNLIKELY(! cs))\n            return maybe_suspend(cs.begin(), state::obj6, size);\ndo_obj7:\n        cs = parse_value(cs.begin(), stack_empty, allow_comments, allow_trailing, allow_bad_utf8);\n        if(BOOST_JSON_UNLIKELY(incomplete(cs)))\n            return suspend_or_fail(state::obj7, size);\ndo_obj8:\n        cs = detail::count_whitespace(cs.begin(), cs.end());\n        if(BOOST_JSON_UNLIKELY(! cs))\n            return maybe_suspend(cs.begin(), state::obj8, size);\n        if(BOOST_JSON_LIKELY(*cs == ','))\n        {\n            ++cs;\ndo_obj9:\n            cs = detail::count_whitespace(cs.begin(), cs.end());\n            if(BOOST_JSON_UNLIKELY(! cs))\n                return maybe_suspend(cs.begin(), state::obj9, size);\n\n            // loop for next element\n            if(BOOST_JSON_LIKELY(*cs == '\\x22'))\n                goto loop;\n            if(! allow_trailing || *cs != '}')\n            {\n                if(allow_comments && *cs == '/')\n                {\ndo_obj10:\n                    cs = parse_comment(cs.begin(), stack_empty, std::false_type());\n                    if(BOOST_JSON_UNLIKELY(incomplete(cs)))\n                        return suspend_or_fail(state::obj10, size);\n                    goto do_obj9;\n                }\n                BOOST_STATIC_CONSTEXPR source_location loc\n                    = BOOST_CURRENT_LOCATION;\n                return fail(cs.begin(), error::syntax, &loc);\n            }\n        }\n        else if(BOOST_JSON_UNLIKELY(*cs != '}'))\n        {\n            if(allow_comments && *cs == '/')\n            {\ndo_obj11:\n                cs = parse_comment(cs.begin(), stack_empty, std::false_type());\n                if(BOOST_JSON_UNLIKELY(incomplete(cs)))\n                    return suspend_or_fail(state::obj11, size);\n                goto do_obj8;\n            }\n            BOOST_STATIC_CONSTEXPR source_location loc\n                = BOOST_CURRENT_LOCATION;\n            return fail(cs.begin(), error::syntax, &loc);\n        }\n        // got closing brace, fall through\n    }\n    if(BOOST_JSON_UNLIKELY(\n        ! h_.on_object_end(size, ec_)))\n        return fail(cs.begin());\n    ++depth_;\n    ++cs;\n    return cs.begin();\n}\n\n//----------------------------------------------------------\n\ntemplate<class Handler>\ntemplate<\n    bool StackEmpty_,\n    bool AllowComments_/*,\n    bool AllowTrailing_,\n    bool AllowBadUTF8_*/>\nconst char*\nbasic_parser<Handler>::\nparse_array(const char* p,\n    std::integral_constant<bool, StackEmpty_> stack_empty,\n    std::integral_constant<bool, AllowComments_> allow_comments,\n    /*std::integral_constant<bool, AllowTrailing_>*/ bool allow_trailing,\n    /*std::integral_constant<bool, AllowBadUTF8_>*/ bool allow_bad_utf8)\n{\n    detail::const_stream_wrapper cs(p, end_);\n    std::size_t size;\n    if(! stack_empty && ! st_.empty())\n    {\n        // resume\n        state st;\n        st_.pop(st);\n        st_.pop(size);\n        switch(st)\n        {\n        default: BOOST_JSON_UNREACHABLE();\n        case state::arr1: goto do_arr1;\n        case state::arr2: goto do_arr2;\n        case state::arr3: goto do_arr3;\n        case state::arr4: goto do_arr4;\n        case state::arr5: goto do_arr5;\n        case state::arr6: goto do_arr6;\n        }\n    }\n    BOOST_ASSERT(*cs == '[');\n    size = 0;\n    if(BOOST_JSON_UNLIKELY(! depth_))\n    {\n        BOOST_STATIC_CONSTEXPR source_location loc = BOOST_CURRENT_LOCATION;\n        return fail(cs.begin(), error::too_deep, &loc);\n    }\n    --depth_;\n    if(BOOST_JSON_UNLIKELY(\n        ! h_.on_array_begin(ec_)))\n        return fail(cs.begin());\n    ++cs;\n    // array:\n    //     '[' *ws ']'\n    //     '[' *ws value *ws *[ ',' *ws value *ws ] ']'\ndo_arr1:\n    cs = detail::count_whitespace(cs.begin(), cs.end());\n    if(BOOST_JSON_UNLIKELY(! cs))\n        return maybe_suspend(cs.begin(), state::arr1, size);\n    if(BOOST_JSON_LIKELY(*cs != ']'))\n    {\nloop:\n        if(allow_comments && *cs == '/')\n        {\ndo_arr2:\n            cs = parse_comment(cs.begin(), stack_empty, std::false_type());\n            if(BOOST_JSON_UNLIKELY(incomplete(cs)))\n                return suspend_or_fail(state::arr2, size);\n            goto do_arr1;\n        }\n        if(BOOST_JSON_UNLIKELY(++size >\n            Handler::max_array_size))\n        {\n            BOOST_STATIC_CONSTEXPR source_location loc\n                = BOOST_CURRENT_LOCATION;\n            return fail(cs.begin(), error::array_too_large, &loc);\n        }\ndo_arr3:\n        // array is not empty, value required\n        cs = parse_value(cs.begin(), stack_empty, allow_comments, allow_trailing, allow_bad_utf8);\n        if(BOOST_JSON_UNLIKELY(incomplete(cs)))\n            return suspend_or_fail(state::arr3, size);\ndo_arr4:\n        cs = detail::count_whitespace(cs.begin(), cs.end());\n        if(BOOST_JSON_UNLIKELY(! cs))\n            return maybe_suspend(cs.begin(), state::arr4, size);\n        if(BOOST_JSON_LIKELY(*cs == ','))\n        {\n            ++cs;\ndo_arr5:\n            cs = detail::count_whitespace(cs.begin(), cs.end());\n            if(BOOST_JSON_UNLIKELY(! cs))\n                return maybe_suspend(cs.begin(), state::arr5, size);\n            // loop for next element\n            if(! allow_trailing || *cs != ']')\n                goto loop;\n        }\n        else if(BOOST_JSON_UNLIKELY(*cs != ']'))\n        {\n            if(allow_comments && *cs == '/')\n            {\ndo_arr6:\n                cs = parse_comment(cs.begin(), stack_empty, std::false_type());\n                if(BOOST_JSON_UNLIKELY(incomplete(cs)))\n                    return suspend_or_fail(state::arr6, size);\n                goto do_arr4;\n            }\n            BOOST_STATIC_CONSTEXPR source_location loc\n                = BOOST_CURRENT_LOCATION;\n            return fail(cs.begin(), error::syntax, &loc);\n        }\n        // got closing bracket; fall through\n    }\n    if(BOOST_JSON_UNLIKELY(\n        ! h_.on_array_end(size, ec_)))\n        return fail(cs.begin());\n    ++depth_;\n    ++cs;\n    return cs.begin();\n}\n\n//----------------------------------------------------------\n\ntemplate<class Handler>\ntemplate<bool StackEmpty_, char First_>\nconst char*\nbasic_parser<Handler>::\nparse_number(const char* p,\n    std::integral_constant<bool, StackEmpty_> stack_empty,\n    std::integral_constant<char, First_> first)\n{\n    // only one of these will be true if we are not resuming\n    // if negative then !zero_first && !nonzero_first\n    // if zero_first then !nonzero_first && !negative\n    // if nonzero_first then !zero_first && !negative\n    bool const negative = first == '-';\n    bool const zero_first = first == '0';\n    bool const nonzero_first = first == '+';\n    detail::const_stream_wrapper cs(p, end_);\n    number num;\n    const char* begin = cs.begin();\n    if(stack_empty || st_.empty())\n    {\n        num.bias = 0;\n        num.exp = 0;\n        num.frac = false;\n\n        //----------------------------------\n        //\n        // '-'\n        // leading minus sign\n        //\n        BOOST_ASSERT(cs);\n        if(negative)\n            ++cs;\n\n        num.neg = negative;\n        num.frac = false;\n        num.exp = 0;\n        num.bias = 0;\n\n        // fast path\n        if( cs.remain() >= 16 + 1 + 16 ) // digits . digits\n        {\n            int n1;\n\n            if( nonzero_first ||\n                (negative && *cs != '0') )\n            {\n                n1 = detail::count_digits( cs.begin() );\n                BOOST_ASSERT(n1 >= 0 && n1 <= 16);\n\n                if( ! nonzero_first && n1 == 0 )\n                {\n                    // digit required\n                    BOOST_STATIC_CONSTEXPR source_location loc\n                        = BOOST_CURRENT_LOCATION;\n                    return fail(cs.begin(), error::syntax, &loc);\n                }\n\n                num.mant = detail::parse_unsigned( 0, cs.begin(), n1 );\n\n                cs += n1;\n\n                // integer or floating-point with\n                // >= 16 leading digits\n                if( n1 == 16 )\n                {\n                    goto do_num2;\n                }\n            }\n            else\n            {\n                // 0. floating-point or 0e integer\n                num.mant = 0;\n                n1 = 0;\n                ++cs;\n            }\n\n            {\n                const char c = *cs;\n                if(c != '.')\n                {\n                    if((c | 32) == 'e')\n                    {\n                        ++cs;\n                        goto do_exp1;\n                    }\n                    if(negative)\n                        num.mant = ~num.mant + 1;\n                    goto finish_signed;\n                }\n            }\n\n            // floating-point number\n\n            ++cs;\n\n            int n2 = detail::count_digits( cs.begin() );\n            BOOST_ASSERT(n2 >= 0 && n2 <= 16);\n\n            if( n2 == 0 )\n            {\n                // digit required\n                BOOST_STATIC_CONSTEXPR source_location loc\n                    = BOOST_CURRENT_LOCATION;\n                return fail(cs.begin(), error::syntax, &loc);\n            }\n\n            // floating-point mantissa overflow\n            if( n1 + n2 >= 19 )\n            {\n                goto do_num7;\n            }\n\n            num.mant = detail::parse_unsigned( num.mant, cs.begin(), n2 );\n\n            BOOST_ASSERT(num.bias == 0);\n\n            num.bias -= n2;\n\n            cs += n2;\n\n            char ch = *cs;\n\n            if( (ch | 32) == 'e' )\n            {\n                ++cs;\n                goto do_exp1;\n            }\n            else if( ch >= '0' && ch <= '9' )\n            {\n                goto do_num8;\n            }\n\n            goto finish_dub;\n        }\n    }\n    else\n    {\n        num = num_;\n        state st;\n        st_.pop(st);\n        switch(st)\n        {\n        default: BOOST_JSON_UNREACHABLE();\n        case state::num1: goto do_num1;\n        case state::num2: goto do_num2;\n        case state::num3: goto do_num3;\n        case state::num4: goto do_num4;\n        case state::num5: goto do_num5;\n        case state::num6: goto do_num6;\n        case state::num7: goto do_num7;\n        case state::num8: goto do_num8;\n        case state::exp1: goto do_exp1;\n        case state::exp2: goto do_exp2;\n        case state::exp3: goto do_exp3;\n        }\n    }\n\n    //----------------------------------\n    //\n    // DIGIT\n    // first digit\n    //\ndo_num1:\n    if(zero_first || nonzero_first ||\n        BOOST_JSON_LIKELY(cs))\n    {\n        char const c = *cs;\n        if(zero_first)\n        {\n            ++cs;\n            num.mant = 0;\n            goto do_num6;\n        }\n        else if(nonzero_first || BOOST_JSON_LIKELY(\n            c >= '1' && c <= '9'))\n        {\n            ++cs;\n            num.mant = c - '0';\n        }\n        else if(BOOST_JSON_UNLIKELY(\n            c == '0'))\n        {\n            ++cs;\n            num.mant = 0;\n            goto do_num6;\n        }\n        else\n        {\n            BOOST_STATIC_CONSTEXPR source_location loc\n                = BOOST_CURRENT_LOCATION;\n            return fail(cs.begin(), error::syntax, &loc);\n        }\n    }\n    else\n    {\n        if(BOOST_JSON_UNLIKELY(\n            ! h_.on_number_part(\n                {begin, cs.used(begin)}, ec_)))\n            return fail(cs.begin());\n        return maybe_suspend(\n            cs.begin(), state::num1, num);\n    }\n\n    //----------------------------------\n    //\n    // 1*DIGIT\n    // significant digits left of decimal\n    //\ndo_num2:\n    if(negative || (!stack_empty && num.neg))\n    {\n        for(;;)\n        {\n            if(BOOST_JSON_UNLIKELY(! cs))\n            {\n                if(BOOST_JSON_UNLIKELY(more_))\n                {\n                    if(BOOST_JSON_UNLIKELY(\n                        ! h_.on_number_part(\n                            {begin, cs.used(begin)}, ec_)))\n                        return fail(cs.begin());\n                    return suspend(cs.begin(), state::num2, num);\n                }\n                goto finish_int;\n            }\n            char const c = *cs;\n            if(BOOST_JSON_LIKELY(\n                c >= '0' && c <= '9'))\n            {\n                ++cs;\n                //              9223372036854775808 INT64_MIN\n                if( num.mant  > 922337203685477580 || (\n                    num.mant == 922337203685477580 && c > '8'))\n                    break;\n                num.mant = 10 * num.mant + ( c - '0' );\n                continue;\n            }\n            goto do_num6; // [.eE]\n        }\n    }\n    else\n    {\n        for(;;)\n        {\n            if(BOOST_JSON_UNLIKELY(! cs))\n            {\n                if(BOOST_JSON_UNLIKELY(more_))\n                {\n                    if(BOOST_JSON_UNLIKELY(\n                        ! h_.on_number_part(\n                            {begin, cs.used(begin)}, ec_)))\n                        return fail(cs.begin());\n                    return suspend(cs.begin(), state::num2, num);\n                }\n                goto finish_int;\n            }\n            char const c = *cs;\n            if(BOOST_JSON_LIKELY(\n                c >= '0' && c <= '9'))\n            {\n                ++cs;\n                //              18446744073709551615 UINT64_MAX\n                if( num.mant  > 1844674407370955161 || (\n                    num.mant == 1844674407370955161 && c > '5'))\n                    break;\n                num.mant = 10 * num.mant + ( c - '0' );\n            }\n            else\n            {\n                goto do_num6; // [.eE]\n            }\n        }\n    }\n    ++num.bias;\n\n    //----------------------------------\n    //\n    // 1*DIGIT\n    // non-significant digits left of decimal\n    //\ndo_num3:\n    for(;;)\n    {\n        if(BOOST_JSON_UNLIKELY(! cs))\n        {\n            if(BOOST_JSON_UNLIKELY(more_))\n            {\n                if(BOOST_JSON_UNLIKELY(\n                    ! h_.on_number_part(\n                        {begin, cs.used(begin)}, ec_)))\n                    return fail(cs.begin());\n                return suspend(cs.begin(), state::num3, num);\n            }\n            goto finish_dub;\n        }\n        char const c = *cs;\n        if(BOOST_JSON_UNLIKELY(\n            c >= '0' && c <= '9'))\n        {\n            ++cs;\n            // VFALCO check overflow\n            ++num.bias;\n        }\n        else if(BOOST_JSON_LIKELY(\n            c == '.'))\n        {\n            ++cs;\n            break;\n        }\n        else if((c | 32) == 'e')\n        {\n            ++cs;\n            goto do_exp1;\n        }\n        else\n        {\n            goto finish_dub;\n        }\n    }\n\n    //----------------------------------\n    //\n    // DIGIT\n    // first non-significant digit\n    // to the right of decimal\n    //\ndo_num4:\n    {\n        if(BOOST_JSON_UNLIKELY(! cs))\n        {\n            if(BOOST_JSON_UNLIKELY(\n                ! h_.on_number_part(\n                    {begin, cs.used(begin)}, ec_)))\n                return fail(cs.begin());\n            return maybe_suspend(\n                cs.begin(), state::num4, num);\n        }\n        char const c = *cs;\n        if(BOOST_JSON_LIKELY(\n            //static_cast<unsigned char>(c - '0') < 10))\n            c >= '0' && c <= '9'))\n        {\n            ++cs;\n        }\n        else\n        {\n            // digit required\n            BOOST_STATIC_CONSTEXPR source_location loc\n                = BOOST_CURRENT_LOCATION;\n            return fail(cs.begin(), error::syntax, &loc);\n        }\n    }\n\n    //----------------------------------\n    //\n    // 1*DIGIT\n    // non-significant digits\n    // to the right of decimal\n    //\ndo_num5:\n    for(;;)\n    {\n        if(BOOST_JSON_UNLIKELY(! cs))\n        {\n            if(BOOST_JSON_UNLIKELY(more_))\n            {\n                if(BOOST_JSON_UNLIKELY(\n                    ! h_.on_number_part(\n                        {begin, cs.used(begin)}, ec_)))\n                    return fail(cs.begin());\n                return suspend(cs.begin(), state::num5, num);\n            }\n            goto finish_dub;\n        }\n        char const c = *cs;\n        if(BOOST_JSON_LIKELY(\n            c >= '0' && c <= '9'))\n        {\n            ++cs;\n        }\n        else if((c | 32) == 'e')\n        {\n            ++cs;\n            goto do_exp1;\n        }\n        else\n        {\n            goto finish_dub;\n        }\n    }\n\n    //----------------------------------\n    //\n    // [.eE]\n    //\ndo_num6:\n    {\n        if(BOOST_JSON_UNLIKELY(! cs))\n        {\n            if(BOOST_JSON_UNLIKELY(more_))\n            {\n                if(BOOST_JSON_UNLIKELY(\n                    ! h_.on_number_part(\n                        {begin, cs.used(begin)}, ec_)))\n                    return fail(cs.begin());\n                return suspend(cs.begin(), state::num6, num);\n            }\n            goto finish_int;\n        }\n        char const c = *cs;\n        if(BOOST_JSON_LIKELY(\n            c == '.'))\n        {\n            ++cs;\n        }\n        else if((c | 32) == 'e')\n        {\n            ++cs;\n            goto do_exp1;\n        }\n        else\n        {\n            goto finish_int;\n        }\n    }\n\n    //----------------------------------\n    //\n    // DIGIT\n    // first significant digit\n    // to the right of decimal\n    //\ndo_num7:\n    {\n        if(BOOST_JSON_UNLIKELY(! cs))\n        {\n            if(BOOST_JSON_UNLIKELY(more_))\n            {\n                if(BOOST_JSON_UNLIKELY(\n                    ! h_.on_number_part(\n                        {begin, cs.used(begin)}, ec_)))\n                    return fail(cs.begin());\n                return suspend(cs.begin(), state::num7, num);\n            }\n            // digit required\n            BOOST_STATIC_CONSTEXPR source_location loc\n                = BOOST_CURRENT_LOCATION;\n            return fail(cs.begin(), error::syntax, &loc);\n        }\n        char const c = *cs;\n        if(BOOST_JSON_UNLIKELY(\n            c < '0' || c > '9'))\n        {\n            // digit required\n            BOOST_STATIC_CONSTEXPR source_location loc\n                = BOOST_CURRENT_LOCATION;\n            return fail(cs.begin(), error::syntax, &loc);\n        }\n    }\n\n    //----------------------------------\n    //\n    // 1*DIGIT\n    // significant digits\n    // to the right of decimal\n    //\ndo_num8:\n    for(;;)\n    {\n        if(BOOST_JSON_UNLIKELY(! cs))\n        {\n            if(BOOST_JSON_UNLIKELY(more_))\n            {\n                if(BOOST_JSON_UNLIKELY(\n                    ! h_.on_number_part(\n                        {begin, cs.used(begin)}, ec_)))\n                    return fail(cs.begin());\n                return suspend(cs.begin(), state::num8, num);\n            }\n            goto finish_dub;\n        }\n        char const c = *cs;\n        if(BOOST_JSON_LIKELY(\n            c >= '0' && c <= '9'))\n        {\n            ++cs;\n            if(BOOST_JSON_LIKELY(\n                num.mant <= 9007199254740991)) // 2^53-1\n            {\n                --num.bias;\n                num.mant = 10 * num.mant + ( c - '0' );\n            }\n            else\n            {\n                goto do_num5;\n            }\n        }\n        else if((c | 32) == 'e')\n        {\n            ++cs;\n            goto do_exp1;\n        }\n        else\n        {\n            goto finish_dub;\n        }\n    }\n\n    //----------------------------------\n    //\n    // *[+-]\n    //\ndo_exp1:\n    if(BOOST_JSON_UNLIKELY(! cs))\n    {\n        if(BOOST_JSON_UNLIKELY(\n            ! h_.on_number_part(\n                {begin, cs.used(begin)}, ec_)))\n            return fail(cs.begin());\n        return maybe_suspend(\n            cs.begin(), state::exp1, num);\n    }\n    if(*cs == '+')\n    {\n        ++cs;\n    }\n    else if(*cs == '-')\n    {\n        ++cs;\n        num.frac = true;\n    }\n\n    //----------------------------------\n    //\n    // DIGIT\n    // first digit of the exponent\n    //\ndo_exp2:\n    {\n        if(BOOST_JSON_UNLIKELY(! cs))\n        {\n            if(BOOST_JSON_UNLIKELY(more_))\n            {\n                if(BOOST_JSON_UNLIKELY(\n                    ! h_.on_number_part(\n                        {begin, cs.used(begin)}, ec_)))\n                    return fail(cs.begin());\n                return suspend(cs.begin(), state::exp2, num);\n            }\n            // digit required\n            BOOST_STATIC_CONSTEXPR source_location loc\n                = BOOST_CURRENT_LOCATION;\n            return fail(cs.begin(), error::syntax, &loc);\n        }\n        char const c = *cs;\n        if(BOOST_JSON_UNLIKELY(\n            c < '0' || c > '9'))\n        {\n            // digit required\n            BOOST_STATIC_CONSTEXPR source_location loc\n                = BOOST_CURRENT_LOCATION;\n            return fail(cs.begin(), error::syntax, &loc);\n        }\n        ++cs;\n        num.exp = c - '0';\n    }\n\n    //----------------------------------\n    //\n    // 1*DIGIT\n    // subsequent digits in the exponent\n    //\ndo_exp3:\n    for(;;)\n    {\n        if(BOOST_JSON_UNLIKELY(! cs))\n        {\n            if(BOOST_JSON_UNLIKELY(more_))\n            {\n                if(BOOST_JSON_UNLIKELY(\n                    ! h_.on_number_part(\n                        {begin, cs.used(begin)}, ec_)))\n                    return fail(cs.begin());\n                return suspend(cs.begin(), state::exp3, num);\n            }\n        }\n        else\n        {\n            char const c = *cs;\n            if(BOOST_JSON_LIKELY(\n                c >= '0' && c <= '9'))\n            {\n                if(BOOST_JSON_UNLIKELY\n                //              2147483647 INT_MAX\n                    (num.exp  > 214748364 || (\n                        num.exp == 214748364 && c > '7')))\n                {\n                    BOOST_STATIC_CONSTEXPR source_location loc\n                        = BOOST_CURRENT_LOCATION;\n                    return fail(cs.begin(), error::exponent_overflow, &loc);\n                }\n                ++cs;\n                num.exp = 10 * num.exp + ( c - '0' );\n                continue;\n            }\n        }\n        BOOST_ASSERT(num.exp >= 0);\n        if ( num.frac )\n        {\n            if (BOOST_JSON_UNLIKELY( num.bias  < (INT_MIN + num.exp) ))\n            {\n                BOOST_STATIC_CONSTEXPR source_location loc\n                    = BOOST_CURRENT_LOCATION;\n                return fail(cs.begin(), error::exponent_overflow, &loc);\n            }\n        }\n        else\n        {\n            if (BOOST_JSON_UNLIKELY( num.bias > (INT_MAX - num.exp) ))\n            {\n                BOOST_STATIC_CONSTEXPR source_location loc\n                    = BOOST_CURRENT_LOCATION;\n                return fail(cs.begin(), error::exponent_overflow, &loc);\n            }\n        }\n        goto finish_dub;\n    }\n\nfinish_int:\n    if(negative || (!stack_empty && num.neg))\n    {\n        if(BOOST_JSON_UNLIKELY(\n            ! h_.on_int64(static_cast<\n                int64_t>(~num.mant + 1), {begin, cs.used(begin)}, ec_)))\n            return fail(cs.begin());\n        return cs.begin();\n    }\n    if(num.mant <= INT64_MAX)\n    {\nfinish_signed:\n        if(BOOST_JSON_UNLIKELY(\n            ! h_.on_int64(static_cast<\n                int64_t>(num.mant), {begin, cs.used(begin)}, ec_)))\n            return fail(cs.begin());\n        return cs.begin();\n    }\n    if(BOOST_JSON_UNLIKELY(\n        ! h_.on_uint64(num.mant, {begin, cs.used(begin)}, ec_)))\n        return fail(cs.begin());\n    return cs.begin();\nfinish_dub:\n    double const d = detail::dec_to_float(\n        num.mant,\n        num.bias + (num.frac ?\n            -num.exp : num.exp),\n        num.neg);\n    if(BOOST_JSON_UNLIKELY(\n        ! h_.on_double(d, {begin, cs.used(begin)}, ec_)))\n        return fail(cs.begin());\n    return cs.begin();\n}\n\n//----------------------------------------------------------\n\ntemplate<class Handler>\ntemplate<class... Args>\nbasic_parser<Handler>::\nbasic_parser(\n    parse_options const& opt,\n    Args&&... args)\n    : h_(std::forward<Args>(args)...)\n    , opt_(opt)\n{\n}\n\n//----------------------------------------------------------\n\ntemplate<class Handler>\nvoid\nbasic_parser<Handler>::\nreset() noexcept\n{\n    ec_ = {};\n    st_.clear();\n    more_ = true;\n    done_ = false;\n    clean_ = true;\n}\n\ntemplate<class Handler>\nvoid\nbasic_parser<Handler>::\nfail(error_code ec) noexcept\n{\n    if(! ec)\n    {\n        // assign an arbitrary\n        // error code to prevent UB\n        BOOST_JSON_FAIL(ec_, error::incomplete);\n    }\n    else\n    {\n        ec_ = ec;\n    }\n    done_ = false;\n}\n\n//----------------------------------------------------------\n\ntemplate<class Handler>\nstd::size_t\nbasic_parser<Handler>::\nwrite_some(\n    bool more,\n    char const* data,\n    std::size_t size,\n    error_code& ec)\n{\n    // see if we exited via exception\n    // on the last call to write_some\n    if(! clean_)\n    {\n        // prevent UB\n        if(! ec_)\n        {\n            BOOST_JSON_FAIL(ec_, error::exception);\n        }\n    }\n    if(ec_)\n    {\n        // error is sticky\n        ec = ec_;\n        return 0;\n    }\n    clean_ = false;\n    more_ = more;\n    end_ = data + size;\n    const char* p;\n    if(BOOST_JSON_LIKELY(st_.empty()))\n    {\n        // first time\n        depth_ = opt_.max_depth;\n        if(BOOST_JSON_UNLIKELY(\n            ! h_.on_document_begin(ec_)))\n        {\n            ec = ec_;\n            return 0;\n        }\n        p = parse_document(data, std::true_type());\n    }\n    else\n    {\n        p = parse_document(data, std::false_type());\n    }\n\n    if(BOOST_JSON_LIKELY(p != sentinel()))\n    {\n        BOOST_ASSERT(! ec_);\n        if(! done_)\n        {\n            done_ = true;\n            h_.on_document_end(ec_);\n        }\n    }\n    else\n    {\n        if(! ec_)\n        {\n            if(! more_)\n            {\n                BOOST_JSON_FAIL(ec_, error::incomplete);\n            }\n            else if(! st_.empty())\n            {\n                // consume as much trailing whitespace in\n                // the JSON document as possible, but still\n                // consider the parse complete\n                state st;\n                st_.peek(st);\n                if( st == state::doc3 &&\n                    ! done_)\n                {\n                    done_ = true;\n                    h_.on_document_end(ec_);\n                }\n            }\n        }\n        p = end_;\n    }\n    ec = ec_;\n    clean_ = true;\n    return p - data;\n}\n\ntemplate<class Handler>\nstd::size_t\nbasic_parser<Handler>::\nwrite_some(\n    bool more,\n    char const* data,\n    std::size_t size,\n    std::error_code& ec)\n{\n    error_code jec;\n    std::size_t const result = write_some(more, data, size, jec);\n    ec = jec;\n    return result;\n}\n\n#endif\n\nBOOST_JSON_NS_END\n\n#ifdef _MSC_VER\n#pragma warning(pop)\n#endif\n\n#endif\n\n```\n","ts":1.739157509438E9}
{"role":"assistant","content":"","ts":1.739157514741E9}
