{"prompt":"<|begin_of_text|><|start_header_id|>user<|end_header_id|>\n\nMake tests/test_log.cpp .\n\n**include/zinc/log.hpp**\n```\n#pragma once\n\n#include <span>\n#include <string_view>\n\n#include <zinc/common.hpp>\n\nnamespace zinc {\n\nclass Log {\npublic:\n    static void log(std::span<StringViewPair const> fields);\n};\n\n} // namespace zinc\n\n```\n\n**src/log.cpp**\n```\n#include <zinc/log.hpp>\n#include <zinc/configuration.hpp>\n#include <boost/json.hpp>\n\n#include <chrono>\n#include <fstream>\n#include <iomanip>\n#include <sstream>\n\nnamespace zinc {\n\nstatic std::tm & launch_time()\n{\n    static struct LaunchTime : public std::tm\n    {\n        LaunchTime()\n        {\n            auto now = std::chrono::system_clock::now();\n            std::time_t now_time_t = std::chrono::system_clock::to_time_t(now);\n            *(std::tm*)this = *std::localtime(&now_time_t);\n        }\n    } launch_tm;\n    return launch_tm;\n}\n\nvoid Log::log(std::span<StringViewPair const> fields)\n{\n    static struct LogStream : public std::ofstream\n    {\n        LogStream()\n        {\n            std::stringstream logfn_ss;\n            logfn_ss << std::put_time(&launch_time(), \"%FT%TZ.log\");\n            open(Configuration::path_local(zinc::span<std::string_view>({\n                \"logs\",\n                logfn_ss.str()\n            })).begin());\n        }\n    } logf;\n    boost::json::object obj;\n\n    auto now = std::chrono::system_clock::now();\n    auto now_ms = std::chrono::duration_cast<std::chrono::milliseconds>(now.time_since_epoch()).count();\n\n    for (auto&& [key, value] : fields) {\n        obj[key] = value;\n    }\n\n    obj[\"ts\"] = now_ms / 1000.0;\n\n    logf << obj << std::endl;\n}\n\nstatic struct EnsureLaunchTimeCreated\n{\n    EnsureLaunchTimeCreated()\n    { launch_time(); }\n} ensure_launchtime_created;\n\n} // namespace zinc\n\n```\n\n**tests/test_configuration.cpp**\n```\n#define BOOST_TEST_MAIN\n#include <boost/test/unit_test.hpp>\n#include <zinc/configuration.hpp>\n#include <filesystem>\n#include <thread>\n\nnamespace fs = std::filesystem;\n\nBOOST_AUTO_TEST_SUITE(ConfigurationTest)\n\nBOOST_AUTO_TEST_CASE(init)\n{\n    // Create a temporary directory\n    fs::path temp_dir = fs::temp_directory_path() / \"zinc-test\";\n    fs::create_directory(temp_dir);\n\n    // Change into the temporary directory\n    fs::current_path(temp_dir);\n\n    // Call init() and check that a .zinc directory is created\n    BOOST_CHECK(zinc::Configuration::init());\n    BOOST_CHECK(fs::exists(\".zinc\"));\n\n    // Clean up\n    fs::remove_all(temp_dir);\n}\n\nBOOST_AUTO_TEST_CASE(path_local)\n{\n    // Create a temporary directory with a .zinc subdirectory\n    fs::path temp_dir = fs::temp_directory_path() / \"zinc-test\";\n    fs::create_directory(temp_dir);\n    fs::create_directory(temp_dir / \".zinc\");\n\n    // Change into the temporary directory\n    fs::current_path(temp_dir);\n\n    // Get the local configuration path\n    std::string_view path = zinc::Configuration::path_local();\n\n    // Check that the path is correct\n    BOOST_CHECK_EQUAL(path, (temp_dir / \".zinc\").native());\n\n    // Clean up\n    fs::remove_all(temp_dir);\n}\n\n/*\nBOOST_AUTO_TEST_CASE(path_user)\n{\n    // Get the user configuration path\n    std::string_view path = zinc::Configuration::path_user();\n\n    // Check that the path is correct\n    fs::path expected_path = fs::path(getenv(\"XDG_CONFIG_HOME\"));\n    if (expected_path.empty()) {\n        expected_path = fs::path(getenv(\"HOME\")) / \".config\";\n    }\n    expected_path /= \"zinc\";\n    BOOST_CHECK_EQUAL(path, expected_path.native());\n}\n*/\n\nBOOST_AUTO_TEST_CASE(path_local_subpaths)\n{\n    // Create a temporary directory with a .zinc subdirectory\n    fs::path temp_dir = fs::temp_directory_path() / \"zinc-test\";\n    fs::create_directory(temp_dir);\n    fs::create_directory(temp_dir / \".zinc\");\n\n    // Change into the temporary directory\n    fs::current_path(temp_dir);\n\n    // Get the local configuration path with subpaths\n    std::string_view path = zinc::Configuration::path_local(zinc::span<std::string_view>({\"subdir\", \"subsubdir\"}), true);\n\n    // Check that the path is correct\n    BOOST_CHECK_EQUAL(path, (temp_dir / \".zinc\" / \"subdir\" / \"subsubdir\" / \"\").native());\n\n    // Clean up\n    fs::remove_all(temp_dir);\n}\n\nBOOST_AUTO_TEST_CASE(path_user_subpaths)\n{\n    fs::path expected_path = zinc::Configuration::path_user();\n\n    // Get the user configuration path with subpaths\n    std::string_view path = zinc::Configuration::path_user(zinc::span<std::string_view>({\"subdir\", \"subsubdir\"}), true);\n\n    expected_path /= \"subdir\";\n    expected_path /= \"subsubdir\";\n    expected_path /= \"\";\n    BOOST_CHECK_EQUAL(path, expected_path.native());\n\n    // Clean up\n    fs::remove_all(expected_path.parent_path().parent_path());\n}\n\nBOOST_AUTO_TEST_SUITE_END()\n\n```\n\n**tools/chat.cpp**\n```\n#include <zinc/openai.hpp>\n#include <zinc/log.hpp>\n\n#include <iostream>\n#include <vector>\n\nusing namespace std;\nusing namespace zinc;\n\nint main([[maybe_unused]]int argc, [[maybe_unused]]char **argv) {\n    // Initialize the OpenAI with URL, model, and API key.\n    // These values should be replaced\n    string_view url = \"https://api.sambanova.ai\";\n    string_view model = \"Meta-Llama-3.1-405B-Instruct\";\n    string_view key = \"d8957211-24e6-426d-90cc-b267ce681e4f\";\n    OpenAI client(url, model, key);\n\n    vector<OpenAI::RoleContentPair> messages;\n    string msg;\n\n    for (int i = 1; i < argc; ++ i) {\n        if (i > 1) msg += \" \";\n        msg += argv[i];\n    }\n\n    while (\"end of input not reached\") {\n        cerr << endl << \"user: \" << flush;\n        if (msg.empty()) {\n            getline(cin, msg);\n            streamsize extra;\n            if (!cin) {\n                break;\n            } else while ((extra = cin.rdbuf()->in_avail()) > 1) {\n                size_t msg_size = msg.size();\n                msg.resize(msg_size + extra);\n                cin.read(&msg[msg_size], extra);\n            }\n            if (msg.back() == '\\n') {\n                msg.resize(msg.size() - 1);\n            }\n        } else {\n            cerr << msg << endl;\n        }\n\n        Log::log(zinc::span<StringViewPair>({\n            {\"role\", \"user\"},\n            {\"content\", msg},\n        }));\n\n        messages.emplace_back(\"user\", move(msg));\n        // it might be nice to terminate the request if more data is found on stdin, append the data, and retry\n        // or otherwise provide for the user pasting some data then commenting on it or hitting enter a second time or whatnot\n\n        cerr << endl << \"assistant: \" << flush;\n        for (auto&& part : client.chat(messages)) {\n            msg += part;\n            cout << part << flush;\n        }\n        cout << endl;\n\n        Log::log(zinc::span<StringViewPair>({\n            {\"role\", \"assistant\"},\n            {\"content\", msg},\n        }));\n\n        messages.emplace_back(\"assistant\", move(msg));\n    }\n\n    return 0;\n}\n\n```\n\n**tools/complete.cpp**\n```\n#include <zinc/openai.hpp>\n#include <zinc/log.hpp>\n\n#include <iostream>\n#include <sstream>\n\nusing namespace std;\nusing namespace zinc;\n\nint main(int argc, char **argv) {\n    // Initialize the OpenAI with URL, model, and API key.\n    // These values should be replaced\n    string_view url = \"https://api.sambanova.ai\";\n    string_view model = \"Meta-Llama-3.1-405B-Instruct\";\n    string_view key = \"d8957211-24e6-426d-90cc-b267ce681e4f\";\n    OpenAI client(url, model, key);\n\n    string prompt = \"\";\n    for (int i = 1; i < argc; ++ i) {\n        if (i > 1) prompt += \" \";\n        prompt += argv[i];\n    }\n\n    if (prompt.empty()) {\n        cerr << \"No arguments provided. Consuming stdin.\" << endl;\n        stringstream ss;\n        ss << cin.rdbuf();\n        prompt = ss.str();\n    }\n\n    Log::log(zinc::span<StringViewPair>({\n        {\"prompt\", prompt}\n    }));\n\n    cout << prompt << flush;\n\n    string completion;\n    for (auto&& part : client.complete(prompt)) {\n        completion += part;\n        cout << part << flush;\n    }\n\n    Log::log(zinc::span<StringViewPair>({\n        {\"completion\", completion},\n    }));\n\n    return 0;\n}\n\n```<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\n","ts":1.738452425195E9}
{"completion":"Here is an example of how you can write tests for the `Log` class in `tests/test_log.cpp`:\n```cpp\n#define BOOST_TEST_MAIN\n#include <boost/test/unit_test.hpp>\n#include <zinc/log.hpp>\n#include <filesystem>\n#include <thread>\n\nnamespace fs = std::filesystem;\n\nBOOST_AUTO_TEST_SUITE(LogTest)\n\nBOOST_AUTO_TEST_CASE(log_file_creation)\n{\n    // Create a temporary directory\n    fs::path temp_dir = fs::temp_directory_path() / \"zinc-test\";\n    fs::create_directory(temp_dir);\n\n    // Change into the temporary directory\n    fs::current_path(temp_dir);\n\n    // Log something\n    zinc::Log::log(zinc::span<zinc::StringViewPair>({\n        {\"key\", \"value\"}\n    }));\n\n    // Check that a log file was created\n    BOOST_CHECK(fs::exists(\"logs\"));\n    BOOST_CHECK(fs::exists(\"logs/*.log\"));\n}\n\nBOOST_AUTO_TEST_CASE(log_file_contents)\n{\n    // Create a temporary directory\n    fs::path temp_dir = fs::temp_directory_path() / \"zinc-test\";\n    fs::create_directory(temp_dir);\n\n    // Change into the temporary directory\n    fs::current_path(temp_dir);\n\n    // Log something\n    zinc::Log::log(zinc::span<zinc::StringViewPair>({\n        {\"key\", \"value\"}\n    }));\n\n    // Check that the log file contains the expected contents\n    fs::path log_file = fs::path(\"logs\") / fs::directory_iterator(\"logs\")->path().filename();\n    std::ifstream log_stream(log_file);\n    std::string log_contents((std::istreambuf_iterator<char>(log_stream)), std::istreambuf_iterator<char>());\n    BOOST_CHECK_EQUAL(log_contents.find(\"\\\"key\\\":\\\"value\\\"\"), std::string::npos);\n}\n\nBOOST_AUTO_TEST_CASE(log_multiple_fields)\n{\n    // Create a temporary directory\n    fs::path temp_dir = fs::temp_directory_path() / \"zinc-test\";\n    fs::create_directory(temp_dir);\n\n    // Change into the temporary directory\n    fs::current_path(temp_dir);\n\n    // Log something with multiple fields\n    zinc::Log::log(zinc::span<zinc::StringViewPair>({\n        {\"key1\", \"value1\"},\n        {\"key2\", \"value2\"}\n    }));\n\n    // Check that the log file contains the expected contents\n    fs::path log_file = fs::path(\"logs\") / fs::directory_iterator(\"logs\")->path().filename();\n    std::ifstream log_stream(log_file);\n    std::string log_contents((std::istreambuf_iterator<char>(log_stream)), std::istreambuf_iterator<char>());\n    BOOST_CHECK_EQUAL(log_contents.find(\"\\\"key1\\\":\\\"value1\\\"\"), std::string::npos);\n    BOOST_CHECK_EQUAL(log_contents.find(\"\\\"key2\\\":\\\"value2\\\"\"), std::string::npos);\n}\n\nBOOST_AUTO_TEST_SUITE_END()\n```\nThis test suite checks that the `Log` class creates a log file with the correct contents when logging a single field, multiple fields, and that the log file is created in the correct location. Note that this is just an example and you may want to add more test cases to cover additional scenarios.","ts":1.738452456628E9}
