{"prompt":"<|begin_of_text|><|start_header_id|>user<|end_header_id|>\n\nUpdate tests/test_json.cpp to use boost/test/unit_test.hpp instead of included/unit_test.hpp. Prefix the content with the bolded filename on a new line.\n\n**tests/test_json.cpp**\n```\n#define BOOST_TEST_MODULE JSONTest\n#include <boost/test/included/unit_test.hpp>\n#include <zinc/json.hpp>\n#include <string_view>\n#include <span>\n\nusing namespace zinc;\n\nBOOST_AUTO_TEST_CASE(test_decode_encode_simple_object) {\n    const std::string_view input = R\"({\"key\":\"value\"})\";\n    JSON::Doc doc = JSON::decode(input);\n    JSON& root = *doc;\n    BOOST_CHECK_EQUAL(root.encode(), input);\n}\n\nBOOST_AUTO_TEST_CASE(test_access_object_element) {\n    const std::string_view input = R\"({\"key\":42})\";\n    JSON::Doc doc = JSON::decode(input);\n    JSON& root = *doc;\n    \n    const JSON& value = root[\"key\"];\n    BOOST_REQUIRE(std::holds_alternative<long>(value));\n    BOOST_CHECK_EQUAL(std::get<long>(value), 42);\n}\n\nBOOST_AUTO_TEST_CASE(test_null_type) {\n    JSON::Doc doc = JSON::decode(\"null\");\n    JSON& root = *doc;\n    BOOST_CHECK(std::holds_alternative<std::nullptr_t>(root));\n    BOOST_CHECK_EQUAL(root.encode(), \"null\");\n}\n\nBOOST_AUTO_TEST_CASE(test_boolean_types) {\n    {\n        JSON::Doc doc = JSON::decode(\"true\");\n        JSON& root = *doc;\n        BOOST_CHECK(std::holds_alternative<bool>(root));\n        BOOST_CHECK_EQUAL(std::get<bool>(root), true);\n    }\n    {\n        JSON::Doc doc = JSON::decode(\"false\");\n        JSON& root = *doc;\n        BOOST_CHECK(std::holds_alternative<bool>(root));\n        BOOST_CHECK_EQUAL(std::get<bool>(root), false);\n    }\n}\n\nBOOST_AUTO_TEST_CASE(test_number_types) {\n    {\n        JSON::Doc doc = JSON::decode(\"12345\");\n        JSON& root = *doc;\n        BOOST_CHECK(std::holds_alternative<long>(root));\n        BOOST_CHECK_EQUAL(std::get<long>(root), 12345);\n    }\n    {\n        JSON::Doc doc = JSON::decode(\"123.45\");\n        JSON& root = *doc;\n        BOOST_CHECK(std::holds_alternative<double>(root));\n        BOOST_CHECK_CLOSE(std::get<double>(root), 123.45, 1e-6);\n    }\n}\n\nBOOST_AUTO_TEST_CASE(test_string_type) {\n    const std::string_view input = R\"(\"hello\\u0020world\")\";\n    JSON::Doc doc = JSON::decode(input);\n    JSON& root = *doc;\n    BOOST_CHECK(std::holds_alternative<std::string_view>(root));\n    BOOST_CHECK_EQUAL(std::get<std::string_view>(root), \"hello world\");\n}\n\nBOOST_AUTO_TEST_CASE(test_array_type) {\n    const std::string_view input = R\"([1,\"two\",3.0])\";\n    JSON::Doc doc = JSON::decode(input);\n    JSON& root = *doc;\n    \n    const auto& arr = root.array();\n    BOOST_REQUIRE_EQUAL(arr.size(), 3);\n    BOOST_CHECK(std::holds_alternative<long>(arr[0]));\n    BOOST_CHECK(std::holds_alternative<std::string_view>(arr[1]));\n    BOOST_CHECK(std::holds_alternative<double>(arr[2]));\n}\n\nBOOST_AUTO_TEST_CASE(test_object_type) {\n    const std::string_view input = R\"({\"a\":1,\"b\":\"two\"})\";\n    JSON::Doc doc = JSON::decode(input);\n    JSON& root = *doc;\n    \n    const auto& obj = root.object();\n    BOOST_REQUIRE_EQUAL(obj.size(), 2);\n    BOOST_CHECK((obj[0].first == \"a\" && std::get<long>(obj[0].second) == 1) ||\n                (obj[1].first == \"a\" && std::get<long>(obj[1].second) == 1));\n}\n\nBOOST_AUTO_TEST_CASE(test_comparison_operators) {\n    JSON::Doc doc1 = JSON::decode(\"42\");\n    JSON::Doc doc2 = JSON::decode(\"42\");\n    JSON::Doc doc3 = JSON::decode(\"43\");\n    \n    BOOST_CHECK(*doc1 == *doc2);\n    BOOST_CHECK((*doc1 <=> *doc3) == std::partial_ordering::less);\n}\n\nBOOST_AUTO_TEST_CASE(test_nested_structures) {\n    const std::string_view input = R\"({\"arr\":[1,{\"nested\":true}],\"obj\":{}})\";\n    JSON::Doc doc = JSON::decode(input);\n    JSON& root = *doc;\n    \n    const JSON& arr = root[\"arr\"];\n    const auto& elements = arr.array();\n    BOOST_REQUIRE_EQUAL(elements.size(), 2);\n    BOOST_CHECK(std::holds_alternative<std::span<KeyJSONPair>>(elements[1]));\n}\n\nBOOST_AUTO_TEST_CASE(test_edge_cases) {\n    {\n        JSON::Doc doc = JSON::decode(\"[]\");\n        BOOST_CHECK_EQUAL((*doc).encode(), \"[]\");\n    }\n    {\n        JSON::Doc doc = JSON::decode(\"{}\");\n        BOOST_CHECK_EQUAL((*doc).encode(), \"{}\");\n    }\n}\n\n```\n\n**include/zinc/json.hpp**\n```\n#pragma once\n\n#include <span>\n#include <string_view>\n#include <variant>\n\nnamespace zinc {\nclass JSON;\nusing KeyJSONPair = std::pair<std::string_view, JSON>;\nusing _JSON_variant = std::variant<\n    std::nullptr_t,\n    bool, long, double, std::string_view,\n    std::span<JSON>, std::span<KeyJSONPair>\n>;\n\n/*\n * The lifetime of parsed JSON objects is managed by the\n * returned JSON::Doc object.  Keep the JSON::Doc object around\n * until the storage for the entire tree can be reused.\n */\nclass JSON : public _JSON_variant {\npublic:\n    using _JSON_variant::variant;\n\n    enum Index {\n        /*NULL = 0,*/\n        BOOLEAN = 1,\n        INTEGER = 2,\n        NUMBER = 3,\n        STRING = 4,\n        ARRAY = 5,\n        OBJECT = 6,\n    };\n\n    //std::string_view raw;\n\n    std::partial_ordering operator<=>(JSON const&json) const;\n    bool operator==(JSON const&json) const { return 0==(*this<=>json); }\n\n    JSON const& operator[](std::string_view key) const;\n    JSON const& operator[](size_t idx) const;\n\n    auto& string() const\n    { return std::get<std::string_view>(*this); }\n    auto& array() const\n    { return std::get<std::span<JSON>>(*this); }\n    auto& object() const\n    { return std::get<std::span<KeyJSONPair>>(*this); }\n\n    class Doc {\n    public:\n        // this could instead be a JSON object with a flag\n        // or a smart pointer (or both)\n        Doc(Doc&&);\n\n        JSON& operator*() { return *root_; }\n\n        ~Doc();\n\n    private:\n        friend class JSON;\n        Doc(JSON*);\n        JSON* root_;\n    };\n\n    static Doc decode(std::string_view doc);\n    std::string_view encode() const;\n};\n\n}\n\n```\n\n**tests/test_configuration.cpp**\n```\n#define BOOST_TEST_MAIN\n#include <boost/test/unit_test.hpp>\n#include <zinc/configuration.hpp>\n#include <filesystem>\n#include <thread>\n\nnamespace fs = std::filesystem;\n\nBOOST_AUTO_TEST_SUITE(ConfigurationTest)\n\nBOOST_AUTO_TEST_CASE(init)\n{\n    // Create a temporary directory\n    fs::path temp_dir = fs::temp_directory_path() / \"zinc-test\";\n    fs::create_directory(temp_dir);\n\n    // Change into the temporary directory\n    fs::current_path(temp_dir);\n\n    // Call init() and check that a .zinc directory is created\n    BOOST_CHECK(zinc::Configuration::init());\n    BOOST_CHECK(fs::exists(\".zinc\"));\n\n    // Clean up\n    fs::remove_all(temp_dir);\n}\n\nBOOST_AUTO_TEST_CASE(path_local)\n{\n    // Create a temporary directory with a .zinc subdirectory\n    fs::path temp_dir = fs::temp_directory_path() / \"zinc-test\";\n    fs::create_directory(temp_dir);\n    fs::create_directory(temp_dir / \".zinc\");\n\n    // Change into the temporary directory\n    fs::current_path(temp_dir);\n\n    // Get the local configuration path\n    std::string_view path = zinc::Configuration::path_local();\n\n    // Check that the path is correct\n    BOOST_CHECK_EQUAL(path, (temp_dir / \".zinc\").native());\n\n    // Clean up\n    fs::remove_all(temp_dir);\n}\n\n/*\nBOOST_AUTO_TEST_CASE(path_user)\n{\n    // Get the user configuration path\n    std::string_view path = zinc::Configuration::path_user();\n\n    // Check that the path is correct\n    fs::path expected_path = fs::path(getenv(\"XDG_CONFIG_HOME\"));\n    if (expected_path.empty()) {\n        expected_path = fs::path(getenv(\"HOME\")) / \".config\";\n    }\n    expected_path /= \"zinc\";\n    BOOST_CHECK_EQUAL(path, expected_path.native());\n}\n*/\n\nBOOST_AUTO_TEST_CASE(path_local_subpaths)\n{\n    // Create a temporary directory with a .zinc subdirectory\n    fs::path temp_dir = fs::temp_directory_path() / \"zinc-test\";\n    fs::create_directory(temp_dir);\n    fs::create_directory(temp_dir / \".zinc\");\n\n    // Change into the temporary directory\n    fs::current_path(temp_dir);\n\n    // Get the local configuration path with subpaths\n    std::string_view path = zinc::Configuration::path_local(zinc::span<std::string_view>({\"subdir\", \"subsubdir\"}), true);\n\n    // Check that the path is correct\n    BOOST_CHECK_EQUAL(path, (temp_dir / \".zinc\" / \"subdir\" / \"subsubdir\" / \"\").native());\n\n    // Clean up\n    fs::remove_all(temp_dir);\n}\n\nBOOST_AUTO_TEST_CASE(path_user_subpaths)\n{\n    fs::path expected_path = zinc::Configuration::path_user();\n\n    // Get the user configuration path with subpaths\n    std::string_view path = zinc::Configuration::path_user(zinc::span<std::string_view>({\"subdir\", \"subsubdir\"}), true);\n\n    expected_path /= \"subdir\";\n    expected_path /= \"subsubdir\";\n    expected_path /= \"\";\n    BOOST_CHECK_EQUAL(path, expected_path.native());\n\n    // Clean up\n    fs::remove_all(expected_path.parent_path().parent_path());\n}\n\nBOOST_AUTO_TEST_SUITE_END()\n\n```\n\n**tests/test_log.cpp**\n```\n#define BOOST_TEST_MAIN\n#include <boost/test/unit_test.hpp>\n#include <zinc/log.hpp>\n#include <filesystem>\n#include <fstream>\n#include <thread>\n\nnamespace fs = std::filesystem;\n\nBOOST_AUTO_TEST_SUITE(LogTest)\n\nBOOST_AUTO_TEST_CASE(log_file_creation)\n{\n    // Create a temporary directory\n    fs::path temp_dir = fs::temp_directory_path() / \"zinc-test\";\n    fs::create_directory(temp_dir);\n\n    // Create a temporary .zinc folder\n    fs::path zinc_dir = temp_dir / \".zinc\";\n    fs::create_directory(zinc_dir);\n\n    // Change into the temporary directory\n    fs::current_path(temp_dir);\n\n    // Log something\n    zinc::Log::log(zinc::span<zinc::StringViewPair>({\n        {\"key\", \"value\"}\n    }));\n\n    // Check that a log file was created\n    fs::path logs_dir = zinc_dir / \"logs\";\n    BOOST_CHECK(fs::exists(logs_dir));\n    BOOST_CHECK(!fs::directory_iterator(logs_dir)->path().empty());\n}\n\nBOOST_AUTO_TEST_CASE(log_file_name)\n{\n    // Create a temporary directory\n    fs::path temp_dir = fs::temp_directory_path() / \"zinc-test\";\n    fs::create_directory(temp_dir);\n\n    // Create a temporary .zinc folder\n    fs::path zinc_dir = temp_dir / \".zinc\";\n    fs::create_directory(zinc_dir);\n\n    // Change into the temporary directory\n    fs::current_path(temp_dir);\n\n    // Log something\n    zinc::Log::log(zinc::span<zinc::StringViewPair>({\n        {\"key\", \"value\"}\n    }));\n\n    // Check that the log file name is in the correct format\n    fs::path logs_dir = zinc_dir / \"logs\";\n    fs::path log_file = fs::directory_iterator(logs_dir)->path();\n    std::string log_file_name = log_file.filename().string();\n    BOOST_CHECK(log_file_name.size() == 24); // YYYY-MM-DDTHHMMSSZ.log\n    BOOST_CHECK(log_file_name.substr(0, 4).find_first_not_of(\"0123456789\") == std::string::npos); // Year\n    BOOST_CHECK(log_file_name.substr(4, 1) == \"-\");\n    BOOST_CHECK(log_file_name.substr(5, 2).find_first_not_of(\"0123456789\") == std::string::npos); // Month\n    BOOST_CHECK(log_file_name.substr(7, 1) == \"-\");\n    BOOST_CHECK(log_file_name.substr(8, 2).find_first_not_of(\"0123456789\") == std::string::npos); // Day\n    BOOST_CHECK(log_file_name.substr(10, 1) == \"T\");\n    BOOST_CHECK(log_file_name.substr(11, 2).find_first_not_of(\"0123456789\") == std::string::npos); // Hour\n    BOOST_CHECK(log_file_name.substr(13, 1) == \":\");\n    BOOST_CHECK(log_file_name.substr(14, 2).find_first_not_of(\"0123456789\") == std::string::npos); // Minute\n    BOOST_CHECK(log_file_name.substr(16, 1) == \":\");\n    BOOST_CHECK(log_file_name.substr(17, 2).find_first_not_of(\"0123456789\") == std::string::npos); // Second\n    BOOST_CHECK(log_file_name.substr(19, 1) == \"Z\");\n    BOOST_CHECK(log_file_name.substr(20) == \".log\");\n}\n\nBOOST_AUTO_TEST_CASE(log_file_contents)\n{\n    // Create a temporary directory\n    fs::path temp_dir = fs::temp_directory_path() / \"zinc-test\";\n    fs::create_directory(temp_dir);\n\n    // Create a temporary .zinc folder\n    fs::path zinc_dir = temp_dir / \".zinc\";\n    fs::create_directory(zinc_dir);\n\n    // Change into the temporary directory\n    fs::current_path(temp_dir);\n\n    // Log something\n    zinc::Log::log(zinc::span<zinc::StringViewPair>({\n        {\"key\", \"value\"}\n    }));\n\n    // Check that the log file contains the expected contents\n    fs::path logs_dir = zinc_dir / \"logs\";\n    fs::path log_file = fs::directory_iterator(logs_dir)->path();\n    std::ifstream log_stream(log_file);\n    std::string log_contents((std::istreambuf_iterator<char>(log_stream)), std::istreambuf_iterator<char>());\n    BOOST_CHECK(log_contents.find(\"\\\"key\\\":\\\"value\\\"\") != std::string::npos);\n    BOOST_CHECK(log_contents.find(\"\\\"ts\\\":\") != std::string::npos);\n}\n\nBOOST_AUTO_TEST_CASE(log_multiple_fields)\n{\n    // Create a temporary directory\n    fs::path temp_dir = fs::temp_directory_path() / \"zinc-test\";\n    fs::create_directory(temp_dir);\n\n    // Create a temporary .zinc folder\n    fs::path zinc_dir = temp_dir / \".zinc\";\n    fs::create_directory(zinc_dir);\n\n    // Change into the temporary directory\n    fs::current_path(temp_dir);\n\n    // Log something with multiple fields\n    zinc::Log::log(zinc::span<zinc::StringViewPair>({\n        {\"key1\", \"value1\"},\n        {\"key2\", \"value2\"}\n    }));\n\n    // Check that the log file contains the expected contents\n    fs::path logs_dir = zinc_dir / \"logs\";\n    fs::path log_file = fs::directory_iterator(logs_dir)->path();\n    std::ifstream log_stream(log_file);\n    std::string log_contents((std::istreambuf_iterator<char>(log_stream)), std::istreambuf_iterator<char>());\n    BOOST_CHECK(log_contents.find(\"\\\"key1\\\":\\\"value1\\\"\") != std::string::npos);\n    BOOST_CHECK(log_contents.find(\"\\\"key2\\\":\\\"value2\\\"\") != std::string::npos);\n    BOOST_CHECK(log_contents.find(\"\\\"ts\\\":\") != std::string::npos);\n}\n\nBOOST_AUTO_TEST_SUITE_END()\n\n```<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\n","ts":1.739314684776E9}
{"completion":"Here is the updated code for **tests/test_json.cpp**:\n\n**tests/test_json.cpp**\n```cpp\n#define BOOST_TEST_MODULE JSONTest\n#include <boost/test/unit_test.hpp>\n#include <zinc/json.hpp>\n#include <string_view>\n#include <span>\n\nusing namespace zinc;\n\nBOOST_AUTO_TEST_CASE(test_decode_encode_simple_object) {\n    const std::string_view input = R\"({\"key\":\"value\"})\";\n    JSON::Doc doc = JSON::decode(input);\n    JSON& root = *doc;\n    BOOST_CHECK_EQUAL(root.encode(), input);\n}\n\nBOOST_AUTO_TEST_CASE(test_access_object_element) {\n    const std::string_view input = R\"({\"key\":42})\";\n    JSON::Doc doc = JSON::decode(input);\n    JSON& root = *doc;\n    \n    const JSON& value = root[\"key\"];\n    BOOST_REQUIRE(std::holds_alternative<long>(value));\n    BOOST_CHECK_EQUAL(std::get<long>(value), 42);\n}\n\nBOOST_AUTO_TEST_CASE(test_null_type) {\n    JSON::Doc doc = JSON::decode(\"null\");\n    JSON& root = *doc;\n    BOOST_CHECK(std::holds_alternative<std::nullptr_t>(root));\n    BOOST_CHECK_EQUAL(root.encode(), \"null\");\n}\n\nBOOST_AUTO_TEST_CASE(test_boolean_types) {\n    {\n        JSON::Doc doc = JSON::decode(\"true\");\n        JSON& root = *doc;\n        BOOST_CHECK(std::holds_alternative<bool>(root));\n        BOOST_CHECK_EQUAL(std::get<bool>(root), true);\n    }\n    {\n        JSON::Doc doc = JSON::decode(\"false\");\n        JSON& root = *doc;\n        BOOST_CHECK(std::holds_alternative<bool>(root));\n        BOOST_CHECK_EQUAL(std::get<bool>(root), false);\n    }\n}\n\nBOOST_AUTO_TEST_CASE(test_number_types) {\n    {\n        JSON::Doc doc = JSON::decode(\"12345\");\n        JSON& root = *doc;\n        BOOST_CHECK(std::holds_alternative<long>(root));\n        BOOST_CHECK_EQUAL(std::get<long>(root), 12345);\n    }\n    {\n        JSON::Doc doc = JSON::decode(\"123.45\");\n        JSON& root = *doc;\n        BOOST_CHECK(std::holds_alternative<double>(root));\n        BOOST_CHECK_CLOSE(std::get<double>(root), 123.45, 1e-6);\n    }\n}\n\nBOOST_AUTO_TEST_CASE(test_string_type) {\n    const std::string_view input = R\"(\"hello\\u0020world\")\";\n    JSON::Doc doc = JSON::decode(input);\n    JSON& root = *doc;\n    BOOST_CHECK(std::holds_alternative<std::string_view>(root));\n    BOOST_CHECK_EQUAL(std::get<std::string_view>(root), \"hello world\");\n}\n\nBOOST_AUTO_TEST_CASE(test_array_type) {\n    const std::string_view input = R\"([1,\"two\",3.0])\";\n    JSON::Doc doc = JSON::decode(input);\n    JSON& root = *doc;\n    \n    const auto& arr = root.array();\n    BOOST_REQUIRE_EQUAL(arr.size(), 3);\n    BOOST_CHECK(std::holds_alternative<long>(arr[0]));\n    BOOST_CHECK(std::holds_alternative<std::string_view>(arr[1]));\n    BOOST_CHECK(std::holds_alternative<double>(arr[2]));\n}\n\nBOOST_AUTO_TEST_CASE(test_object_type) {\n    const std::string_view input = R\"({\"a\":1,\"b\":\"two\"})\";\n    JSON::Doc doc = JSON::decode(input);\n    JSON& root = *doc;\n    \n    const auto& obj = root.object();\n    BOOST_REQUIRE_EQUAL(obj.size(), 2);\n    BOOST_CHECK((obj[0].first == \"a\" && std::get<long>(obj[0].second) == 1) ||\n                (obj[1].first == \"a\" && std::get<long>(obj[1].second) == 1));\n}\n\nBOOST_AUTO_TEST_CASE(test_comparison_operators) {\n    JSON::Doc doc1 = JSON::decode(\"42\");\n    JSON::Doc doc2 = JSON::decode(\"42\");\n    JSON::Doc doc3 = JSON::decode(\"43\");\n    \n    BOOST_CHECK(*doc1 == *doc2);\n    BOOST_CHECK((*doc1 <=> *doc3) == std::partial_ordering::less);\n}\n\nBOOST_AUTO_TEST_CASE(test_nested_structures) {\n    const std::string_view input = R\"({\"arr\":[1,{\"nested\":true}],\"obj\":{}})\";\n    JSON::Doc doc = JSON::decode(input);\n    JSON& root = *doc;\n    \n    const JSON& arr = root[\"arr\"];\n    const auto& elements = arr.array();\n    BOOST_REQUIRE_EQUAL(elements.size(), 2);\n    BOOST_CHECK(std::holds_alternative<std::span<KeyJSONPair>>(elements[1]));\n}\n\nBOOST_AUTO_TEST_CASE(test_edge_cases) {\n    {\n        JSON::Doc doc = JSON::decode(\"[]\");\n        BOOST_CHECK_EQUAL((*doc).encode(), \"[]\");\n    }\n    {\n        JSON::Doc doc = JSON::decode(\"{}\");\n        BOOST_CHECK_EQUAL((*doc).encode(), \"{}\");\n    }\n}\n```\n\nNote that I've only updated the `#include` directive to use `boost/test/unit_test.hpp` instead of `boost/test/included/unit_test.hpp`. The rest of the code remains the same.","ts":1.73931469503E9}
