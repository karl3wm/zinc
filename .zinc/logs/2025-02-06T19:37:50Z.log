{"prompt":"<|begin_of_text|><|start_header_id|>user<|end_header_id|>\n\nUpdate doc.txt based on xutils.c xutils.h with any and all new or missing information on xdiff's public interface.\n\n**doc.txt**\n```\n`doc.txt`\n\nPublic Interface for xdiff\n==========================\n\n### Data Structures\n\n* `mmfile_t`: represents a memory-mapped file\n\t+ `char *ptr`: pointer to the file's contents\n\t+ `long size`: size of the file's contents\n* `mmbuffer_t`: represents a memory-mapped buffer\n\t+ `char *ptr`: pointer to the buffer's contents\n\t+ `long size`: size of the buffer's contents\n* `xpparam_t`: represents parameters for the xdiff algorithm\n\t+ `unsigned long flags`: flags controlling the algorithm's behavior\n\t+ `regex_t **ignore_regex`: array of regular expressions to ignore\n\t+ `size_t ignore_regex_nr`: number of regular expressions to ignore\n\t+ `char **anchors`: array of anchor strings\n\t+ `size_t anchors_nr`: number of anchor strings\n* `xdemitcb_t`: represents a callback function for emitting differences\n\t+ `void *priv`: private data for the callback function\n\t+ `int (*out_hunk)(void *, long, long, long, long, const char *, long)`: callback function for emitting a hunk\n\t+ `int (*out_line)(void *, mmbuffer_t *, int)`: callback function for emitting a line\n* `xdemitconf_t`: represents configuration for emitting differences\n\t+ `long ctxlen`: length of the context for emitting differences\n\t+ `long interhunkctxlen`: length of the inter-hunk context for emitting differences\n\t+ `unsigned long flags`: flags controlling the emission of differences\n\t+ `find_func_t find_func`: function for finding the next match\n\t+ `void *find_func_priv`: private data for the find function\n\t+ `xdl_emit_hunk_consume_func_t hunk_func`: function for consuming a hunk\n* `bdiffparam_t`: represents parameters for the bdiff algorithm\n\t+ `long bsize`: size of the buffer for the bdiff algorithm\n* `diffdata_t`: represents data for the xdiff algorithm\n\t+ `long nrec`: number of records\n\t+ `unsigned long const *ha`: array of hash values\n\t+ `long *rindex`: array of record indices\n\t+ `char *rchg`: array of record changes\n* `xdalgoenv_t`: represents environment for the xdiff algorithm\n\t+ `long mxcost`: maximum cost\n\t+ `long snake_cnt`: snake count\n\t+ `long heur_min`: heuristic minimum\n* `xdchange_t`: represents a change in the xdiff algorithm\n\t+ `struct s_xdchange *next`: next change\n\t+ `long i1`, `i2`: indices of the change\n\t+ `long chg1`, `chg2`: changes\n\t+ `int ignore`: ignore flag\n* `xmparam_t`: represents parameters for the merge algorithm\n\t+ `xpparam_t xpp`: parameters for the xdiff algorithm\n\t+ `int marker_size`: size of the conflict marker\n\t+ `int level`: merge level\n\t+ `int favor`: favor mode\n\t+ `int style`: merge style\n\t+ `const char *ancestor`: label for the original file\n\t+ `const char *file1`: label for the first file\n\t+ `const char *file2`: label for the second file\n* `chastore_t`: represents a store for changed records\n\t+ `chanode_t *head`, `*tail`: head and tail of the store\n\t+ `long isize`, `nsize`: size of the store\n\t+ `chanode_t *ancur`, `*sncur`: current nodes\n\t+ `long scurr`: current size\n* `chanode_t`: represents a node in the changed record store\n\t+ `struct s_chanode *next`: next node\n\t+ `long icurr`: current index\n* `xrecord_t`: represents a record in the xdiff algorithm\n\t+ `struct s_xrecord *next`: next record\n\t+ `char const *ptr`: pointer to the record's contents\n\t+ `long size`: size of the record's contents\n\t+ `unsigned long ha`: hash value of the record\n* `xdfile_t`: represents a file in the xdiff algorithm\n\t+ `chastore_t rcha`: store for changed records\n\t+ `long nrec`: number of records\n\t+ `unsigned int hbits`: number of hash bits\n\t+ `xrecord_t **rhash`: array of record hashes\n\t+ `long dstart`, `dend`: start and end indices of the file\n\t+ `xrecord_t **recs`: array of records\n\t+ `char *rchg`: array of record changes\n\t+ `long *rindex`: array of record indices\n\t+ `long nreff`: number of referenced records\n\t+ `unsigned long *ha`: array of hash values\n* `xdfenv_t`: represents an environment for the xdiff algorithm\n\t+ `xdfile_t xdf1`, `xdf2`: files in the xdiff algorithm\n\n### Functions\n\n* `xdl_diff(mmfile_t *mf1, mmfile_t *mf2, xpparam_t const *xpp, xdemitconf_t const *xecfg, xdemitcb_t *ecb)`: computes the differences between two files\n* `xdl_merge(mmfile_t *orig, mmfile_t *mf1, mmfile_t *mf2, xmparam_t const *xmp, mmbuffer_t *result)`: merges two files\n* `xdl_do_diff(mmfile_t *mf1, mmfile_t *mf2, xpparam_t const *xpp, xdfenv_t *xe)`: internal function for computing differences\n* `xdl_build_script(xdfenv_t *xe, xdchange_t **xscr)`: builds a script for emitting differences\n* `xdl_free_script(xdchange_t *xscr)`: frees a script for emitting differences\n* `xdl_call_hunk_func(xdfenv_t *xe, xdchange_t *xscr, xdemitcb_t *ecb, xdemitconf_t const *xecfg)`: internal function for emitting a hunk\n* `xdl_mark_ignorable_lines(xdchange_t *xscr, xdfenv_t *xe, long flags)`: marks ignorable lines in a script\n* `xdl_mark_ignorable_regex(xdchange_t *xscr, const xdfenv_t *xe, xpparam_t const *xpp)`: marks ignorable lines in a script using regular expressions\n* `xdl_recs_cmp(diffdata_t *dd1, long off1, long lim1, diffdata_t *dd2, long off2, long lim2, long *kvdf, long *kvdb, int need_min, xdalgoenv_t *xenv)`: compares records\n* `xdl_do_patience_diff(xpparam_t const *xpp, xdfenv_t *env)`: internal function for patience diff\n* `xdl_do_histogram_diff(xpparam_t const *xpp, xdfenv_t *env)`: internal function for histogram diff\n* `xdl_change_compact(xdfile_t *xdf, xdfile_t *xdfo, long flags)`: compacts changes\n* `xdl_emit_diff(xdfenv_t *xe, xdchange_t *xscr, xdemitcb_t *ecb, xdemitconf_t const *xecfg)`: emits differences\n* `xdl_get_hunk(xdchange_t **xscr, xdemitconf_t const *xecfg)`: gets the next hunk\n* `xdl_emit_record(xdfile_t *xdf, long ri, char const *pre, xdemitcb_t *ecb)`: emits a record\n* `xdl_get_rec(xdfile_t *xdf, long ri, char const **rec)`: gets a record\n* `xdl_mmfile_first(mmfile_t *mmf, long *size)`: gets the first memory-mapped file\n* `xdl_mmfile_size(mmfile_t *mmf)`: gets the size of a memory-mapped file\n* `xdl_do_histogram_diff(xpparam_t const *xpp, xdfenv_t *env)`: computes the differences between two files using the histogram diff algorithm\n\n### Flags\n\n* `XDF_NEED_MINIMAL`: flag for minimal diff\n* `XDF_IGNORE_WHITESPACE`: flag for ignoring whitespace\n* `XDF_IGNORE_WHITESPACE_CHANGE`: flag for ignoring whitespace changes\n* `XDF_IGNORE_WHITESPACE_AT_EOL`: flag for ignoring whitespace at end of line\n* `XDF_IGNORE_CR_AT_EOL`: flag for ignoring CR at end of line\n* `XDF_WHITESPACE_FLAGS`: flag for ignoring whitespace\n* `XDF_IGNORE_BLANK_LINES`: flag for ignoring blank lines\n* `XDF_PATIENCE_DIFF`: flag for patience diff\n* `XDF_HISTOGRAM_DIFF`: flag for histogram diff\n* `XDF_DIFF_ALGORITHM_MASK`: mask for diff algorithm\n* `XDF_DIFF_ALG(x)`: gets the diff algorithm\n* `XDF_INDENT_HEURISTIC`: flag for indent heuristic\n* `XDL_EMIT_FUNCNAMES`: flag for emitting function names\n* `XDL_EMIT_NO_HUNK_HDR`: flag for not emitting hunk headers\n* `XDL_EMIT_FUNCCONTEXT`: flag for emitting function context\n\n### Merge Simplification Levels\n\n* `XDL_MERGE_MINIMAL`: minimal merge level\n* `XDL_MERGE_EAGER`: eager merge level\n* `XDL_MERGE_ZEALOUS`: zealous merge level\n* `XDL_MERGE_ZEALOUS_ALNUM`: zealous alnum merge level\n\n### Merge Favor Modes\n\n* `XDL_MERGE_FAVOR_OURS`: favor our changes\n* `XDL_MERGE_FAVOR_THEIRS`: favor their changes\n* `XDL_MERGE_FAVOR_UNION`: favor union of changes\n\n### Merge Output Styles\n\n* `XDL_MERGE_DIFF3`: diff3 output style\n* `XDL_MERGE_ZEALOUS_DIFF3`: zealous diff3 output style\n\n### Macros\n\n* `XDL_MIN(a, b)`: returns the minimum of two values\n* `XDL_MAX(a, b)`: returns the maximum of two values\n* `XDL_ABS(v)`: returns the absolute value of a value\n* `XDL_ISDIGIT(c)`: checks if a character is a digit\n* `XDL_ISSPACE(c)`: checks if a character is a whitespace\n* `XDL_ADDBITS(v,b)`: adds bits to a value\n* `XDL_MASKBITS(b)`: masks bits of a value\n* `XDL_HASHLONG(v,b)`: hashes a long value\n* `XDL_LE32_PUT(p, v)`: puts a 32-bit little-endian value\n* `XDL_LE32_GET(p, v)`: gets a 32-bit little-endian value\n* `XDL_ALLOC_ARRAY(p, nr)`: allocates an array\n* `XDL_CALLOC_ARRAY(p, nr)`: allocates a zeroed-out array\n* `XDL_ALLOC_GROW(p, nr, alloc)`: grows an array\n\n### New Functions\n\n* `xdl_fill_merge_buffer(xdfenv_t *xe1, const char *name1, xdfenv_t *xe2, const char *name2, const char *ancestor_name, int favor, xdmerge_t *m, char *dest, int style, int marker_size)`: fills a merge buffer\n* `xdl_refine_zdiff3_conflicts(xdfenv_t *xe1, xdfenv_t *xe2, xdmerge_t *m, xpparam_t const *xpp)`: refines conflicts for zdiff3\n* `xdl_refine_conflicts(xdfenv_t *xe1, xdfenv_t *xe2, xdmerge_t *m, xpparam_t const *xpp)`: refines conflicts\n* `xdl_simplify_non_conflicts(xdfenv_t *xe1, xdmerge_t *m, int simplify_if_no_alnum)`: simplifies non-conflicts\n* `xdl_do_merge(xdfenv_t *xe1, xdchange_t *xscr1, xdfenv_t *xe2, xdchange_t *xscr2, xmparam_t const *xmp, mmbuffer_t *result)`: performs a merge\n\n### New Data Structures\n\n* `xdmerge_t`: represents a merge\n\t+ `struct s_xdmerge *next`: next merge\n\t+ `int mode`: merge mode\n\t+ `long i1`, `i2`: indices of the merge\n\t+ `long chg1`, `chg2`: changes\n\t+ `int ignore`: ignore flag\n\n```\n\n**ref/git/xdiff/xdiff.h**\n```\n/*\n *  LibXDiff by Davide Libenzi ( File Differential Library )\n *  Copyright (C) 2003  Davide Libenzi\n *\n *  This library is free software; you can redistribute it and/or\n *  modify it under the terms of the GNU Lesser General Public\n *  License as published by the Free Software Foundation; either\n *  version 2.1 of the License, or (at your option) any later version.\n *\n *  This library is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n *  Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; if not, see\n *  <http://www.gnu.org/licenses/>.\n *\n *  Davide Libenzi <davidel@xmailserver.org>\n *\n */\n\n#if !defined(XDIFF_H)\n#define XDIFF_H\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif /* #ifdef __cplusplus */\n\n/* xpparm_t.flags */\n#define XDF_NEED_MINIMAL (1 << 0)\n\n#define XDF_IGNORE_WHITESPACE (1 << 1)\n#define XDF_IGNORE_WHITESPACE_CHANGE (1 << 2)\n#define XDF_IGNORE_WHITESPACE_AT_EOL (1 << 3)\n#define XDF_IGNORE_CR_AT_EOL (1 << 4)\n#define XDF_WHITESPACE_FLAGS (XDF_IGNORE_WHITESPACE | \\\n\t\t\t      XDF_IGNORE_WHITESPACE_CHANGE | \\\n\t\t\t      XDF_IGNORE_WHITESPACE_AT_EOL | \\\n\t\t\t      XDF_IGNORE_CR_AT_EOL)\n\n#define XDF_IGNORE_BLANK_LINES (1 << 7)\n\n#define XDF_PATIENCE_DIFF (1 << 14)\n#define XDF_HISTOGRAM_DIFF (1 << 15)\n#define XDF_DIFF_ALGORITHM_MASK (XDF_PATIENCE_DIFF | XDF_HISTOGRAM_DIFF)\n#define XDF_DIFF_ALG(x) ((x) & XDF_DIFF_ALGORITHM_MASK)\n\n#define XDF_INDENT_HEURISTIC (1 << 23)\n\n/* xdemitconf_t.flags */\n#define XDL_EMIT_FUNCNAMES (1 << 0)\n#define XDL_EMIT_NO_HUNK_HDR (1 << 1)\n#define XDL_EMIT_FUNCCONTEXT (1 << 2)\n\n/* merge simplification levels */\n#define XDL_MERGE_MINIMAL 0\n#define XDL_MERGE_EAGER 1\n#define XDL_MERGE_ZEALOUS 2\n#define XDL_MERGE_ZEALOUS_ALNUM 3\n\n/* merge favor modes */\n#define XDL_MERGE_FAVOR_OURS 1\n#define XDL_MERGE_FAVOR_THEIRS 2\n#define XDL_MERGE_FAVOR_UNION 3\n\n/* merge output styles */\n#define XDL_MERGE_DIFF3 1\n#define XDL_MERGE_ZEALOUS_DIFF3 2\n\ntypedef struct s_mmfile {\n\tchar *ptr;\n\tlong size;\n} mmfile_t;\n\ntypedef struct s_mmbuffer {\n\tchar *ptr;\n\tlong size;\n} mmbuffer_t;\n\ntypedef struct s_xpparam {\n\tunsigned long flags;\n\n\t/* -I<regex> */\n\tregex_t **ignore_regex;\n\tsize_t ignore_regex_nr;\n\n\t/* See Documentation/diff-options.txt. */\n\tchar **anchors;\n\tsize_t anchors_nr;\n} xpparam_t;\n\ntypedef struct s_xdemitcb {\n\tvoid *priv;\n\tint (*out_hunk)(void *,\n\t\t\tlong old_begin, long old_nr,\n\t\t\tlong new_begin, long new_nr,\n\t\t\tconst char *func, long funclen);\n\tint (*out_line)(void *, mmbuffer_t *, int);\n} xdemitcb_t;\n\ntypedef long (*find_func_t)(const char *line, long line_len, char *buffer, long buffer_size, void *priv);\n\ntypedef int (*xdl_emit_hunk_consume_func_t)(long start_a, long count_a,\n\t\t\t\t\t    long start_b, long count_b,\n\t\t\t\t\t    void *cb_data);\n\ntypedef struct s_xdemitconf {\n\tlong ctxlen;\n\tlong interhunkctxlen;\n\tunsigned long flags;\n\tfind_func_t find_func;\n\tvoid *find_func_priv;\n\txdl_emit_hunk_consume_func_t hunk_func;\n} xdemitconf_t;\n\ntypedef struct s_bdiffparam {\n\tlong bsize;\n} bdiffparam_t;\n\n\n#define xdl_malloc(x) xmalloc(x)\n#define xdl_calloc(n, sz) xcalloc(n, sz)\n#define xdl_free(ptr) free(ptr)\n#define xdl_realloc(ptr,x) xrealloc(ptr,x)\n\nvoid *xdl_mmfile_first(mmfile_t *mmf, long *size);\nlong xdl_mmfile_size(mmfile_t *mmf);\n\nint xdl_diff(mmfile_t *mf1, mmfile_t *mf2, xpparam_t const *xpp,\n\t     xdemitconf_t const *xecfg, xdemitcb_t *ecb);\n\ntypedef struct s_xmparam {\n\txpparam_t xpp;\n\tint marker_size;\n\tint level;\n\tint favor;\n\tint style;\n\tconst char *ancestor;\t/* label for orig */\n\tconst char *file1;\t/* label for mf1 */\n\tconst char *file2;\t/* label for mf2 */\n} xmparam_t;\n\n#define DEFAULT_CONFLICT_MARKER_SIZE 7\n\nint xdl_merge(mmfile_t *orig, mmfile_t *mf1, mmfile_t *mf2,\n\t\txmparam_t const *xmp, mmbuffer_t *result);\n\n#ifdef __cplusplus\n}\n#endif /* #ifdef __cplusplus */\n\n#endif /* #if !defined(XDIFF_H) */\n\n```\n\n**ref/git/xdiff/xutils.c**\n```\n/*\n *  LibXDiff by Davide Libenzi ( File Differential Library )\n *  Copyright (C) 2003\tDavide Libenzi\n *\n *  This library is free software; you can redistribute it and/or\n *  modify it under the terms of the GNU Lesser General Public\n *  License as published by the Free Software Foundation; either\n *  version 2.1 of the License, or (at your option) any later version.\n *\n *  This library is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n *  Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; if not, see\n *  <http://www.gnu.org/licenses/>.\n *\n *  Davide Libenzi <davidel@xmailserver.org>\n *\n */\n\n#include \"xinclude.h\"\n\n\nlong xdl_bogosqrt(long n) {\n\tlong i;\n\n\t/*\n\t * Classical integer square root approximation using shifts.\n\t */\n\tfor (i = 1; n > 0; n >>= 2)\n\t\ti <<= 1;\n\n\treturn i;\n}\n\n\nint xdl_emit_diffrec(char const *rec, long size, char const *pre, long psize,\n\t\t     xdemitcb_t *ecb) {\n\tint i = 2;\n\tmmbuffer_t mb[3];\n\n\tmb[0].ptr = (char *) pre;\n\tmb[0].size = psize;\n\tmb[1].ptr = (char *) rec;\n\tmb[1].size = size;\n\tif (size > 0 && rec[size - 1] != '\\n') {\n\t\tmb[2].ptr = (char *) \"\\n\\\\ No newline at end of file\\n\";\n\t\tmb[2].size = strlen(mb[2].ptr);\n\t\ti++;\n\t}\n\tif (ecb->out_line(ecb->priv, mb, i) < 0) {\n\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nvoid *xdl_mmfile_first(mmfile_t *mmf, long *size)\n{\n\t*size = mmf->size;\n\treturn mmf->ptr;\n}\n\n\nlong xdl_mmfile_size(mmfile_t *mmf)\n{\n\treturn mmf->size;\n}\n\n\nint xdl_cha_init(chastore_t *cha, long isize, long icount) {\n\n\tcha->head = cha->tail = NULL;\n\tcha->isize = isize;\n\tcha->nsize = icount * isize;\n\tcha->ancur = cha->sncur = NULL;\n\tcha->scurr = 0;\n\n\treturn 0;\n}\n\n\nvoid xdl_cha_free(chastore_t *cha) {\n\tchanode_t *cur, *tmp;\n\n\tfor (cur = cha->head; (tmp = cur) != NULL;) {\n\t\tcur = cur->next;\n\t\txdl_free(tmp);\n\t}\n}\n\n\nvoid *xdl_cha_alloc(chastore_t *cha) {\n\tchanode_t *ancur;\n\tvoid *data;\n\n\tif (!(ancur = cha->ancur) || ancur->icurr == cha->nsize) {\n\t\tif (!(ancur = (chanode_t *) xdl_malloc(sizeof(chanode_t) + cha->nsize))) {\n\n\t\t\treturn NULL;\n\t\t}\n\t\tancur->icurr = 0;\n\t\tancur->next = NULL;\n\t\tif (cha->tail)\n\t\t\tcha->tail->next = ancur;\n\t\tif (!cha->head)\n\t\t\tcha->head = ancur;\n\t\tcha->tail = ancur;\n\t\tcha->ancur = ancur;\n\t}\n\n\tdata = (char *) ancur + sizeof(chanode_t) + ancur->icurr;\n\tancur->icurr += cha->isize;\n\n\treturn data;\n}\n\nlong xdl_guess_lines(mmfile_t *mf, long sample) {\n\tlong nl = 0, size, tsize = 0;\n\tchar const *data, *cur, *top;\n\n\tif ((cur = data = xdl_mmfile_first(mf, &size))) {\n\t\tfor (top = data + size; nl < sample && cur < top; ) {\n\t\t\tnl++;\n\t\t\tif (!(cur = memchr(cur, '\\n', top - cur)))\n\t\t\t\tcur = top;\n\t\t\telse\n\t\t\t\tcur++;\n\t\t}\n\t\ttsize += (long) (cur - data);\n\t}\n\n\tif (nl && tsize)\n\t\tnl = xdl_mmfile_size(mf) / (tsize / nl);\n\n\treturn nl + 1;\n}\n\nint xdl_blankline(const char *line, long size, long flags)\n{\n\tlong i;\n\n\tif (!(flags & XDF_WHITESPACE_FLAGS))\n\t\treturn (size <= 1);\n\n\tfor (i = 0; i < size && XDL_ISSPACE(line[i]); i++)\n\t\t;\n\n\treturn (i == size);\n}\n\n/*\n * Have we eaten everything on the line, except for an optional\n * CR at the very end?\n */\nstatic int ends_with_optional_cr(const char *l, long s, long i)\n{\n\tint complete = s && l[s-1] == '\\n';\n\n\tif (complete)\n\t\ts--;\n\tif (s == i)\n\t\treturn 1;\n\t/* do not ignore CR at the end of an incomplete line */\n\tif (complete && s == i + 1 && l[i] == '\\r')\n\t\treturn 1;\n\treturn 0;\n}\n\nint xdl_recmatch(const char *l1, long s1, const char *l2, long s2, long flags)\n{\n\tint i1, i2;\n\n\tif (s1 == s2 && !memcmp(l1, l2, s1))\n\t\treturn 1;\n\tif (!(flags & XDF_WHITESPACE_FLAGS))\n\t\treturn 0;\n\n\ti1 = 0;\n\ti2 = 0;\n\n\t/*\n\t * -w matches everything that matches with -b, and -b in turn\n\t * matches everything that matches with --ignore-space-at-eol,\n\t * which in turn matches everything that matches with --ignore-cr-at-eol.\n\t *\n\t * Each flavor of ignoring needs different logic to skip whitespaces\n\t * while we have both sides to compare.\n\t */\n\tif (flags & XDF_IGNORE_WHITESPACE) {\n\t\tgoto skip_ws;\n\t\twhile (i1 < s1 && i2 < s2) {\n\t\t\tif (l1[i1++] != l2[i2++])\n\t\t\t\treturn 0;\n\t\tskip_ws:\n\t\t\twhile (i1 < s1 && XDL_ISSPACE(l1[i1]))\n\t\t\t\ti1++;\n\t\t\twhile (i2 < s2 && XDL_ISSPACE(l2[i2]))\n\t\t\t\ti2++;\n\t\t}\n\t} else if (flags & XDF_IGNORE_WHITESPACE_CHANGE) {\n\t\twhile (i1 < s1 && i2 < s2) {\n\t\t\tif (XDL_ISSPACE(l1[i1]) && XDL_ISSPACE(l2[i2])) {\n\t\t\t\t/* Skip matching spaces and try again */\n\t\t\t\twhile (i1 < s1 && XDL_ISSPACE(l1[i1]))\n\t\t\t\t\ti1++;\n\t\t\t\twhile (i2 < s2 && XDL_ISSPACE(l2[i2]))\n\t\t\t\t\ti2++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (l1[i1++] != l2[i2++])\n\t\t\t\treturn 0;\n\t\t}\n\t} else if (flags & XDF_IGNORE_WHITESPACE_AT_EOL) {\n\t\twhile (i1 < s1 && i2 < s2 && l1[i1] == l2[i2]) {\n\t\t\ti1++;\n\t\t\ti2++;\n\t\t}\n\t} else if (flags & XDF_IGNORE_CR_AT_EOL) {\n\t\t/* Find the first difference and see how the line ends */\n\t\twhile (i1 < s1 && i2 < s2 && l1[i1] == l2[i2]) {\n\t\t\ti1++;\n\t\t\ti2++;\n\t\t}\n\t\treturn (ends_with_optional_cr(l1, s1, i1) &&\n\t\t\tends_with_optional_cr(l2, s2, i2));\n\t}\n\n\t/*\n\t * After running out of one side, the remaining side must have\n\t * nothing but whitespace for the lines to match.  Note that\n\t * ignore-whitespace-at-eol case may break out of the loop\n\t * while there still are characters remaining on both lines.\n\t */\n\tif (i1 < s1) {\n\t\twhile (i1 < s1 && XDL_ISSPACE(l1[i1]))\n\t\t\ti1++;\n\t\tif (s1 != i1)\n\t\t\treturn 0;\n\t}\n\tif (i2 < s2) {\n\t\twhile (i2 < s2 && XDL_ISSPACE(l2[i2]))\n\t\t\ti2++;\n\t\treturn (s2 == i2);\n\t}\n\treturn 1;\n}\n\nstatic unsigned long xdl_hash_record_with_whitespace(char const **data,\n\t\tchar const *top, long flags) {\n\tunsigned long ha = 5381;\n\tchar const *ptr = *data;\n\tint cr_at_eol_only = (flags & XDF_WHITESPACE_FLAGS) == XDF_IGNORE_CR_AT_EOL;\n\n\tfor (; ptr < top && *ptr != '\\n'; ptr++) {\n\t\tif (cr_at_eol_only) {\n\t\t\t/* do not ignore CR at the end of an incomplete line */\n\t\t\tif (*ptr == '\\r' &&\n\t\t\t    (ptr + 1 < top && ptr[1] == '\\n'))\n\t\t\t\tcontinue;\n\t\t}\n\t\telse if (XDL_ISSPACE(*ptr)) {\n\t\t\tconst char *ptr2 = ptr;\n\t\t\tint at_eol;\n\t\t\twhile (ptr + 1 < top && XDL_ISSPACE(ptr[1])\n\t\t\t\t\t&& ptr[1] != '\\n')\n\t\t\t\tptr++;\n\t\t\tat_eol = (top <= ptr + 1 || ptr[1] == '\\n');\n\t\t\tif (flags & XDF_IGNORE_WHITESPACE)\n\t\t\t\t; /* already handled */\n\t\t\telse if (flags & XDF_IGNORE_WHITESPACE_CHANGE\n\t\t\t\t && !at_eol) {\n\t\t\t\tha += (ha << 5);\n\t\t\t\tha ^= (unsigned long) ' ';\n\t\t\t}\n\t\t\telse if (flags & XDF_IGNORE_WHITESPACE_AT_EOL\n\t\t\t\t && !at_eol) {\n\t\t\t\twhile (ptr2 != ptr + 1) {\n\t\t\t\t\tha += (ha << 5);\n\t\t\t\t\tha ^= (unsigned long) *ptr2;\n\t\t\t\t\tptr2++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tha += (ha << 5);\n\t\tha ^= (unsigned long) *ptr;\n\t}\n\t*data = ptr < top ? ptr + 1: ptr;\n\n\treturn ha;\n}\n\nunsigned long xdl_hash_record(char const **data, char const *top, long flags) {\n\tunsigned long ha = 5381;\n\tchar const *ptr = *data;\n\n\tif (flags & XDF_WHITESPACE_FLAGS)\n\t\treturn xdl_hash_record_with_whitespace(data, top, flags);\n\n\tfor (; ptr < top && *ptr != '\\n'; ptr++) {\n\t\tha += (ha << 5);\n\t\tha ^= (unsigned long) *ptr;\n\t}\n\t*data = ptr < top ? ptr + 1: ptr;\n\n\treturn ha;\n}\n\nunsigned int xdl_hashbits(unsigned int size) {\n\tunsigned int val = 1, bits = 0;\n\n\tfor (; val < size && bits < CHAR_BIT * sizeof(unsigned int); val <<= 1, bits++);\n\treturn bits ? bits: 1;\n}\n\n\nint xdl_num_out(char *out, long val) {\n\tchar *ptr, *str = out;\n\tchar buf[32];\n\n\tptr = buf + sizeof(buf) - 1;\n\t*ptr = '\\0';\n\tif (val < 0) {\n\t\t*--ptr = '-';\n\t\tval = -val;\n\t}\n\tfor (; val && ptr > buf; val /= 10)\n\t\t*--ptr = \"0123456789\"[val % 10];\n\tif (*ptr)\n\t\tfor (; *ptr; ptr++, str++)\n\t\t\t*str = *ptr;\n\telse\n\t\t*str++ = '0';\n\t*str = '\\0';\n\n\treturn str - out;\n}\n\nstatic int xdl_format_hunk_hdr(long s1, long c1, long s2, long c2,\n\t\t\t       const char *func, long funclen,\n\t\t\t       xdemitcb_t *ecb) {\n\tint nb = 0;\n\tmmbuffer_t mb;\n\tchar buf[128];\n\n\tmemcpy(buf, \"@@ -\", 4);\n\tnb += 4;\n\n\tnb += xdl_num_out(buf + nb, c1 ? s1: s1 - 1);\n\n\tif (c1 != 1) {\n\t\tmemcpy(buf + nb, \",\", 1);\n\t\tnb += 1;\n\n\t\tnb += xdl_num_out(buf + nb, c1);\n\t}\n\n\tmemcpy(buf + nb, \" +\", 2);\n\tnb += 2;\n\n\tnb += xdl_num_out(buf + nb, c2 ? s2: s2 - 1);\n\n\tif (c2 != 1) {\n\t\tmemcpy(buf + nb, \",\", 1);\n\t\tnb += 1;\n\n\t\tnb += xdl_num_out(buf + nb, c2);\n\t}\n\n\tmemcpy(buf + nb, \" @@\", 3);\n\tnb += 3;\n\tif (func && funclen) {\n\t\tbuf[nb++] = ' ';\n\t\tif (funclen > sizeof(buf) - nb - 1)\n\t\t\tfunclen = sizeof(buf) - nb - 1;\n\t\tmemcpy(buf + nb, func, funclen);\n\t\tnb += funclen;\n\t}\n\tbuf[nb++] = '\\n';\n\n\tmb.ptr = buf;\n\tmb.size = nb;\n\tif (ecb->out_line(ecb->priv, &mb, 1) < 0)\n\t\treturn -1;\n\treturn 0;\n}\n\nint xdl_emit_hunk_hdr(long s1, long c1, long s2, long c2,\n\t\t      const char *func, long funclen,\n\t\t      xdemitcb_t *ecb) {\n\tif (!ecb->out_hunk)\n\t\treturn xdl_format_hunk_hdr(s1, c1, s2, c2, func, funclen, ecb);\n\tif (ecb->out_hunk(ecb->priv,\n\t\t\t  c1 ? s1 : s1 - 1, c1,\n\t\t\t  c2 ? s2 : s2 - 1, c2,\n\t\t\t  func, funclen) < 0)\n\t\treturn -1;\n\treturn 0;\n}\n\nint xdl_fall_back_diff(xdfenv_t *diff_env, xpparam_t const *xpp,\n\t\tint line1, int count1, int line2, int count2)\n{\n\t/*\n\t * This probably does not work outside Git, since\n\t * we have a very simple mmfile structure.\n\t *\n\t * Note: ideally, we would reuse the prepared environment, but\n\t * the libxdiff interface does not (yet) allow for diffing only\n\t * ranges of lines instead of the whole files.\n\t */\n\tmmfile_t subfile1, subfile2;\n\txdfenv_t env;\n\n\tsubfile1.ptr = (char *)diff_env->xdf1.recs[line1 - 1]->ptr;\n\tsubfile1.size = diff_env->xdf1.recs[line1 + count1 - 2]->ptr +\n\t\tdiff_env->xdf1.recs[line1 + count1 - 2]->size - subfile1.ptr;\n\tsubfile2.ptr = (char *)diff_env->xdf2.recs[line2 - 1]->ptr;\n\tsubfile2.size = diff_env->xdf2.recs[line2 + count2 - 2]->ptr +\n\t\tdiff_env->xdf2.recs[line2 + count2 - 2]->size - subfile2.ptr;\n\tif (xdl_do_diff(&subfile1, &subfile2, xpp, &env) < 0)\n\t\treturn -1;\n\n\tmemcpy(diff_env->xdf1.rchg + line1 - 1, env.xdf1.rchg, count1);\n\tmemcpy(diff_env->xdf2.rchg + line2 - 1, env.xdf2.rchg, count2);\n\n\txdl_free_env(&env);\n\n\treturn 0;\n}\n\nvoid* xdl_alloc_grow_helper(void *p, long nr, long *alloc, size_t size)\n{\n\tvoid *tmp = NULL;\n\tsize_t n = ((LONG_MAX - 16) / 2 >= *alloc) ? 2 * *alloc + 16 : LONG_MAX;\n\tif (nr > n)\n\t\tn = nr;\n\tif (SIZE_MAX / size >= n)\n\t\ttmp = xdl_realloc(p, n * size);\n\tif (tmp) {\n\t\t*alloc = n;\n\t} else {\n\t\txdl_free(p);\n\t\t*alloc = 0;\n\t}\n\treturn tmp;\n}\n\n```\n\n**ref/git/xdiff/xutils.h**\n```\n/*\n *  LibXDiff by Davide Libenzi ( File Differential Library )\n *  Copyright (C) 2003  Davide Libenzi\n *\n *  This library is free software; you can redistribute it and/or\n *  modify it under the terms of the GNU Lesser General Public\n *  License as published by the Free Software Foundation; either\n *  version 2.1 of the License, or (at your option) any later version.\n *\n *  This library is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n *  Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; if not, see\n *  <http://www.gnu.org/licenses/>.\n *\n *  Davide Libenzi <davidel@xmailserver.org>\n *\n */\n\n#if !defined(XUTILS_H)\n#define XUTILS_H\n\n\n\nlong xdl_bogosqrt(long n);\nint xdl_emit_diffrec(char const *rec, long size, char const *pre, long psize,\n\t\t     xdemitcb_t *ecb);\nint xdl_cha_init(chastore_t *cha, long isize, long icount);\nvoid xdl_cha_free(chastore_t *cha);\nvoid *xdl_cha_alloc(chastore_t *cha);\nlong xdl_guess_lines(mmfile_t *mf, long sample);\nint xdl_blankline(const char *line, long size, long flags);\nint xdl_recmatch(const char *l1, long s1, const char *l2, long s2, long flags);\nunsigned long xdl_hash_record(char const **data, char const *top, long flags);\nunsigned int xdl_hashbits(unsigned int size);\nint xdl_num_out(char *out, long val);\nint xdl_emit_hunk_hdr(long s1, long c1, long s2, long c2,\n\t\t      const char *func, long funclen, xdemitcb_t *ecb);\nint xdl_fall_back_diff(xdfenv_t *diff_env, xpparam_t const *xpp,\n\t\t       int line1, int count1, int line2, int count2);\n\n/* Do not call this function, use XDL_ALLOC_GROW instead */\nvoid* xdl_alloc_grow_helper(void* p, long nr, long* alloc, size_t size);\n\n#endif /* #if !defined(XUTILS_H) */\n\n```<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\n","ts":1.738870670863E9}
{"completion":"Based on the provided code, I've updated the `doc.txt` file to include the new or missing information on xdiff's public interface.\n\n**Updated doc.txt**\n```\n`doc.txt`\n\nPublic Interface for xdiff\n==========================\n\n### Data Structures\n\n* `mmfile_t`: represents a memory-mapped file\n\t+ `char *ptr`: pointer to the file's contents\n\t+ `long size`: size of the file's contents\n* `mmbuffer_t`: represents a memory-mapped buffer\n\t+ `char *ptr`: pointer to the buffer's contents\n\t+ `long size`: size of the buffer's contents\n* `xpparam_t`: represents parameters for the xdiff algorithm\n\t+ `unsigned long flags`: flags controlling the algorithm's behavior\n\t+ `regex_t **ignore_regex`: array of regular expressions to ignore\n\t+ `size_t ignore_regex_nr`: number of regular expressions to ignore\n\t+ `char **anchors`: array of anchor strings\n\t+ `size_t anchors_nr`: number of anchor strings\n* `xdemitcb_t`: represents a callback function for emitting differences\n\t+ `void *priv`: private data for the callback function\n\t+ `int (*out_hunk)(void *, long, long, long, long, const char *, long)`: callback function for emitting a hunk\n\t+ `int (*out_line)(void *, mmbuffer_t *, int)`: callback function for emitting a line\n* `xdemitconf_t`: represents configuration for emitting differences\n\t+ `long ctxlen`: length of the context for emitting differences\n\t+ `long interhunkctxlen`: length of the inter-hunk context for emitting differences\n\t+ `unsigned long flags`: flags controlling the emission of differences\n\t+ `find_func_t find_func`: function for finding the next match\n\t+ `void *find_func_priv`: private data for the find function\n\t+ `xdl_emit_hunk_consume_func_t hunk_func`: function for consuming a hunk\n* `bdiffparam_t`: represents parameters for the bdiff algorithm\n\t+ `long bsize`: size of the buffer for the bdiff algorithm\n* `diffdata_t`: represents data for the xdiff algorithm\n\t+ `long nrec`: number of records\n\t+ `unsigned long const *ha`: array of hash values\n\t+ `long *rindex`: array of record indices\n\t+ `char *rchg`: array of record changes\n* `xdalgoenv_t`: represents environment for the xdiff algorithm\n\t+ `long mxcost`: maximum cost\n\t+ `long snake_cnt`: snake count\n\t+ `long heur_min`: heuristic minimum\n* `xdchange_t`: represents a change in the xdiff algorithm\n\t+ `struct s_xdchange *next`: next change\n\t+ `long i1`, `i2`: indices of the change\n\t+ `long chg1`, `chg2`: changes\n\t+ `int ignore`: ignore flag\n* `xmparam_t`: represents parameters for the merge algorithm\n\t+ `xpparam_t xpp`: parameters for the xdiff algorithm\n\t+ `int marker_size`: size of the conflict marker\n\t+ `int level`: merge level\n\t+ `int favor`: favor mode\n\t+ `int style`: merge style\n\t+ `const char *ancestor`: label for the original file\n\t+ `const char *file1`: label for the first file\n\t+ `const char *file2`: label for the second file\n* `chastore_t`: represents a store for changed records\n\t+ `chanode_t *head`, `*tail`: head and tail of the store\n\t+ `long isize`, `nsize`: size of the store\n\t+ `chanode_t *ancur`, `*sncur`: current nodes\n\t+ `long scurr`: current size\n* `chanode_t`: represents a node in the changed record store\n\t+ `struct s_chanode *next`: next node\n\t+ `long icurr`: current index\n* `xrecord_t`: represents a record in the xdiff algorithm\n\t+ `struct s_xrecord *next`: next record\n\t+ `char const *ptr`: pointer to the record's contents\n\t+ `long size`: size of the record's contents\n\t+ `unsigned long ha`: hash value of the record\n* `xdfile_t`: represents a file in the xdiff algorithm\n\t+ `chastore_t rcha`: store for changed records\n\t+ `long nrec`: number of records\n\t+ `unsigned int hbits`: number of hash bits\n\t+ `xrecord_t **rhash`: array of record hashes\n\t+ `long dstart`, `dend`: start and end indices of the file\n\t+ `xrecord_t **recs`: array of records\n\t+ `char *rchg`: array of record changes\n\t+ `long *rindex`: array of record indices\n\t+ `long nreff`: number of referenced records\n\t+ `unsigned long *ha`: array of hash values\n* `xdfenv_t`: represents an environment for the xdiff algorithm\n\t+ `xdfile_t xdf1`, `xdf2`: files in the xdiff algorithm\n* `xdmerge_t`: represents a merge\n\t+ `struct s_xdmerge *next`: next merge\n\t+ `int mode`: merge mode\n\t+ `long i1`, `i2`: indices of the merge\n\t+ `long chg1`, `chg2`: changes\n\t+ `int ignore`: ignore flag\n\n### Functions\n\n* `xdl_diff(mmfile_t *mf1, mmfile_t *mf2, xpparam_t const *xpp, xdemitconf_t const *xecfg, xdemitcb_t *ecb)`: computes the differences between two files\n* `xdl_merge(mmfile_t *orig, mmfile_t *mf1, mmfile_t *mf2, xmparam_t const *xmp, mmbuffer_t *result)`: merges two files\n* `xdl_do_diff(mmfile_t *mf1, mmfile_t *mf2, xpparam_t const *xpp, xdfenv_t *xe)`: internal function for computing differences\n* `xdl_build_script(xdfenv_t *xe, xdchange_t **xscr)`: builds a script for emitting differences\n* `xdl_free_script(xdchange_t *xscr)`: frees a script for emitting differences\n* `xdl_call_hunk_func(xdfenv_t *xe, xdchange_t *xscr, xdemitcb_t *ecb, xdemitconf_t const *xecfg)`: internal function for emitting a hunk\n* `xdl_mark_ignorable_lines(xdchange_t *xscr, xdfenv_t *xe, long flags)`: marks ignorable lines in a script\n* `xdl_mark_ignorable_regex(xdchange_t *xscr, const xdfenv_t *xe, xpparam_t const *xpp)`: marks ignorable lines in a script using regular expressions\n* `xdl_recs_cmp(diffdata_t *dd1, long off1, long lim1, diffdata_t *dd2, long off2, long lim2, long *kvdf, long *kvdb, int need_min, xdalgoenv_t *xenv)`: compares records\n* `xdl_do_patience_diff(xpparam_t const *xpp, xdfenv_t *env)`: internal function for patience diff\n* `xdl_do_histogram_diff(xpparam_t const *xpp, xdfenv_t *env)`: internal function for histogram diff\n* `xdl_change_compact(xdfile_t *xdf, xdfile_t *xdfo, long flags)`: compacts changes\n* `xdl_emit_diff(xdfenv_t *xe, xdchange_t *xscr, xdemitcb_t *ecb, xdemitconf_t const *xecfg)`: emits differences\n* `xdl_get_hunk(xdchange_t **xscr, xdemitconf_t const *xecfg)`: gets the next hunk\n* `xdl_emit_record(xdfile_t *xdf, long ri, char const *pre, xdemitcb_t *ecb)`: emits a record\n* `xdl_get_rec(xdfile_t *xdf, long ri, char const **rec)`: gets a record\n* `xdl_mmfile_first(mmfile_t *mmf, long *size)`: gets the first memory-mapped file\n* `xdl_mmfile_size(mmfile_t *mmf)`: gets the size of a memory-mapped file\n* `xdl_do_histogram_diff(xpparam_t const *xpp, xdfenv_t *env)`: computes the differences between two files using the histogram diff algorithm\n* `xdl_fill_merge_buffer(xdfenv_t *xe1, const char *name1, xdfenv_t *xe2, const char *name2, const char *ancestor_name, int favor, xdmerge_t *m, char *dest, int style, int marker_size)`: fills a merge buffer\n* `xdl_refine_zdiff3_conflicts(xdfenv_t *xe1, xdfenv_t *xe2, xdmerge_t *m, xpparam_t const *xpp)`: refines conflicts for zdiff3\n* `xdl_refine_conflicts(xdfenv_t *xe1, xdfenv_t *xe2, xdmerge_t *m, xpparam_t const *xpp)`: refines conflicts\n* `xdl_simplify_non_conflicts(xdfenv_t *xe1, xdmerge_t *m, int simplify_if_no_alnum)`: simplifies non-conflicts\n* `xdl_do_merge(xdfenv_t *xe1, xdchange_t *xscr1, xdfenv_t *xe2, xdchange_t *xscr2, xmparam_t const *xmp, mmbuffer_t *result)`: performs a merge\n* `xdl_bogosqrt(long n)`: computes the square root of a number\n* `xdl_emit_diffrec(char const *rec, long size, char const *pre, long psize, xdemitcb_t *ecb)`: emits a difference record\n* `xdl_cha_init(chastore_t *cha, long isize, long icount)`: initializes a changed record store\n* `xdl_cha_free(chastore_t *cha)`: frees a changed record store\n* `xdl_cha_alloc(chastore_t *cha)`: allocates a changed record\n* `xdl_guess_lines(mmfile_t *mf, long sample)`: guesses the number of lines in a file\n* `xdl_blankline(const char *line, long size, long flags)`: checks if a line is blank\n* `xdl_recmatch(const char *l1, long s1, const char *l2, long s2, long flags)`: checks if two records match\n* `xdl_hash_record(char const **data, char const *top, long flags)`: computes the hash value of a record\n* `xdl_hashbits(unsigned int size)`: computes the number of hash bits\n* `xdl_num_out(char *out, long val)`: converts a number to a string\n* `xdl_emit_hunk_hdr(long s1, long c1, long s2, long c2, const char *func, long funclen, xdemitcb_t *ecb)`: emits a hunk header\n* `xdl_fall_back_diff(xdfenv_t *diff_env, xpparam_t const *xpp, int line1, int count1, int line2, int count2)`: falls back to a different diff algorithm\n* `xdl_alloc_grow_helper(void *p, long nr, long *alloc, size_t size)`: grows an array\n\n### Flags\n\n* `XDF_NEED_MINIMAL`: flag for minimal diff\n* `XDF_IGNORE_WHITESPACE`: flag for ignoring whitespace\n* `XDF_IGNORE_WHITESPACE_CHANGE`: flag for ignoring whitespace changes\n* `XDF_IGNORE_WHITESPACE_AT_EOL`: flag for ignoring whitespace at end of line\n* `XDF_IGNORE_CR_AT_EOL`: flag for ignoring CR at end of line\n* `XDF_WHITESPACE_FLAGS`: flag for ignoring whitespace\n* `XDF_IGNORE_BLANK_LINES`: flag for ignoring blank lines\n* `XDF_PATIENCE_DIFF`: flag for patience diff\n* `XDF_HISTOGRAM_DIFF`: flag for histogram diff\n* `XDF_DIFF_ALGORITHM_MASK`: mask for diff algorithm\n* `XDF_DIFF_ALG(x)`: gets the diff algorithm\n* `XDF_INDENT_HEURISTIC`: flag for indent heuristic\n* `XDL_EMIT_FUNCNAMES`: flag for emitting function names\n* `XDL_EMIT_NO_HUNK_HDR`: flag for not emitting hunk headers\n* `XDL_EMIT_FUNCCONTEXT`: flag for emitting function context\n\n### Merge Simplification Levels\n\n* `XDL_MERGE_MINIMAL`: minimal merge level\n* `XDL_MERGE_EAGER`: eager merge level\n* `XDL_MERGE_ZEALOUS`: zealous merge level\n* `XDL_MERGE_ZEALOUS_ALNUM`: zealous alnum merge level\n\n### Merge Favor Modes\n\n* `XDL_MERGE_FAVOR_OURS`: favor our changes\n* `XDL_MERGE_FAVOR_THEIRS`: favor their changes\n* `XDL_MERGE_FAVOR_UNION`: favor union of changes\n\n### Merge Output Styles\n\n* `XDL_MERGE_DIFF3`: diff3 output style\n* `XDL_MERGE_ZEALOUS_DIFF3`: zealous diff3 output style\n\n### Macros\n\n* `XDL_MIN(a, b)`: returns the minimum of two values\n* `XDL_MAX(a, b)`: returns the maximum of two values\n* `XDL_ABS(v)`: returns the absolute value of a value\n* `XDL_ISDIGIT(c)`: checks if a character is a digit\n* `XDL_ISSPACE(c)`: checks if a character is a whitespace\n* `XDL_ADDBITS(v,b)`: adds bits to a value\n* `XDL_MASKBITS(b)`: masks bits of a value\n* `XDL_HASHLONG(v,b)`: hashes a long value\n* `XDL_LE32_PUT(p, v)`: puts a 32-bit little-endian value\n* `XDL_LE32_GET(p, v)`: gets a 32-bit little-endian value\n* `XDL_ALLOC_ARRAY(p, nr)`: allocates an array\n* `XDL_CALLOC_ARRAY(p, nr)`: allocates a zeroed-out array\n* `XDL_ALLOC_GROW(p, nr, alloc)`: grows an array\n```","ts":1.738870721768E9}
